/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faleksandar%2FDesktop%2FRaboten%2Fmd%20to%20docx%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*******************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faleksandar%2FDesktop%2FRaboten%2Fmd%20to%20docx%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*******************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.js */ \"(app-pages-browser)/./app/page.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZhbGVrc2FuZGFyJTJGRGVza3RvcCUyRlJhYm90ZW4lMkZtZCUyMHRvJTIwZG9jeCUyRmFwcCUyRnBhZ2UuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvSkFBNkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9iNTg3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL2FsZWtzYW5kYXIvRGVza3RvcC9SYWJvdGVuL21kIHRvIGRvY3gvYXBwL3BhZ2UuanNcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faleksandar%2FDesktop%2FRaboten%2Fmd%20to%20docx%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlLXNhdmVyL2Rpc3QvRmlsZVNhdmVyLm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrR0FBZSxHQUFHLElBQXFDLENBQUMsaUNBQU8sRUFBRSxvQ0FBQyxDQUFDO0FBQUE7QUFBQTtBQUFBLGtHQUFDLENBQUMsS0FBSyxFQUE2RSxDQUFDLGtCQUFrQixhQUFhLGdCQUFnQiwrQkFBK0IsV0FBVyw0RkFBNEYsV0FBVyxrRUFBa0UsNERBQTRELFlBQVksSUFBSSxrQkFBa0IseUJBQXlCLDBEQUEwRCxrQkFBa0Isc0JBQXNCLHlDQUF5QyxVQUFVLGNBQWMseUJBQXlCLG9CQUFvQixJQUFJLFNBQVMsVUFBVSxvQ0FBb0MsY0FBYyxJQUFJLHlDQUF5QyxTQUFTLDBDQUEwQywwRkFBMEYsMkhBQTJILHFCQUFNLEVBQUUscUJBQU0sVUFBVSxxQkFBTSxDQUFDLHFCQUFNLHdNQUF3TSw4REFBOEQsdURBQXVELGlOQUFpTiwwQkFBMEIsNEJBQTRCLEtBQUssS0FBSyxnREFBZ0QsbUZBQW1GLHNCQUFzQixLQUFLLGtDQUFrQyxpREFBaUQsS0FBSyxHQUFHLG1CQUFtQiw4SEFBOEgsb0lBQW9JLGlEQUFpRCxxQkFBcUIsdUJBQXVCLGVBQWUsMEJBQTBCLEdBQUcsd0JBQXdCLHlDQUF5QyxvQkFBb0IsS0FBSyxnREFBZ0QsNERBQTRELHFCQUFxQixPQUFPLEVBQUUsb0JBQW9CLEtBQTBCLHFCQUFxQjs7QUFFaHBGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9maWxlLXNhdmVyL2Rpc3QvRmlsZVNhdmVyLm1pbi5qcz8xZjNjIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihhLGIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sYik7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cyliKCk7ZWxzZXtiKCksYS5GaWxlU2F2ZXI9e2V4cG9ydHM6e319LmV4cG9ydHN9fSkodGhpcyxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYSxiKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgYj9iPXthdXRvQm9tOiExfTpcIm9iamVjdFwiIT10eXBlb2YgYiYmKGNvbnNvbGUud2FybihcIkRlcHJlY2F0ZWQ6IEV4cGVjdGVkIHRoaXJkIGFyZ3VtZW50IHRvIGJlIGEgb2JqZWN0XCIpLGI9e2F1dG9Cb206IWJ9KSxiLmF1dG9Cb20mJi9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGEudHlwZSk/bmV3IEJsb2IoW1wiXFx1RkVGRlwiLGFdLHt0eXBlOmEudHlwZX0pOmF9ZnVuY3Rpb24gYyhhLGIsYyl7dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbihcIkdFVFwiLGEpLGQucmVzcG9uc2VUeXBlPVwiYmxvYlwiLGQub25sb2FkPWZ1bmN0aW9uKCl7ZyhkLnJlc3BvbnNlLGIsYyl9LGQub25lcnJvcj1mdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJjb3VsZCBub3QgZG93bmxvYWQgZmlsZVwiKX0sZC5zZW5kKCl9ZnVuY3Rpb24gZChhKXt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiSEVBRFwiLGEsITEpO3RyeXtiLnNlbmQoKX1jYXRjaChhKXt9cmV0dXJuIDIwMDw9Yi5zdGF0dXMmJjI5OT49Yi5zdGF0dXN9ZnVuY3Rpb24gZShhKXt0cnl7YS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIikpfWNhdGNoKGMpe3ZhciBiPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7Yi5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsd2luZG93LDAsMCwwLDgwLDIwLCExLCExLCExLCExLDAsbnVsbCksYS5kaXNwYXRjaEV2ZW50KGIpfX12YXIgZj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiZ3aW5kb3cud2luZG93PT09d2luZG93P3dpbmRvdzpcIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZi5zZWxmPT09c2VsZj9zZWxmOlwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWwmJmdsb2JhbC5nbG9iYWw9PT1nbG9iYWw/Z2xvYmFsOnZvaWQgMCxhPWYubmF2aWdhdG9yJiYvTWFjaW50b3NoLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYvQXBwbGVXZWJLaXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLGc9Zi5zYXZlQXN8fChcIm9iamVjdFwiIT10eXBlb2Ygd2luZG93fHx3aW5kb3chPT1mP2Z1bmN0aW9uKCl7fTpcImRvd25sb2FkXCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGUmJiFhP2Z1bmN0aW9uKGIsZyxoKXt2YXIgaT1mLlVSTHx8Zi53ZWJraXRVUkwsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtnPWd8fGIubmFtZXx8XCJkb3dubG9hZFwiLGouZG93bmxvYWQ9ZyxqLnJlbD1cIm5vb3BlbmVyXCIsXCJzdHJpbmdcIj09dHlwZW9mIGI/KGouaHJlZj1iLGoub3JpZ2luPT09bG9jYXRpb24ub3JpZ2luP2Uoaik6ZChqLmhyZWYpP2MoYixnLGgpOmUoaixqLnRhcmdldD1cIl9ibGFua1wiKSk6KGouaHJlZj1pLmNyZWF0ZU9iamVjdFVSTChiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS5yZXZva2VPYmplY3RVUkwoai5ocmVmKX0sNEU0KSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShqKX0sMCkpfTpcIm1zU2F2ZU9yT3BlbkJsb2JcImluIG5hdmlnYXRvcj9mdW5jdGlvbihmLGcsaCl7aWYoZz1nfHxmLm5hbWV8fFwiZG93bmxvYWRcIixcInN0cmluZ1wiIT10eXBlb2YgZiluYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihiKGYsaCksZyk7ZWxzZSBpZihkKGYpKWMoZixnLGgpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7aS5ocmVmPWYsaS50YXJnZXQ9XCJfYmxhbmtcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShpKX0pfX06ZnVuY3Rpb24oYixkLGUsZyl7aWYoZz1nfHxvcGVuKFwiXCIsXCJfYmxhbmtcIiksZyYmKGcuZG9jdW1lbnQudGl0bGU9Zy5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD1cImRvd25sb2FkaW5nLi4uXCIpLFwic3RyaW5nXCI9PXR5cGVvZiBiKXJldHVybiBjKGIsZCxlKTt2YXIgaD1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiPT09Yi50eXBlLGk9L2NvbnN0cnVjdG9yL2kudGVzdChmLkhUTUxFbGVtZW50KXx8Zi5zYWZhcmksaj0vQ3JpT1NcXC9bXFxkXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoKGp8fGgmJml8fGEpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgRmlsZVJlYWRlcil7dmFyIGs9bmV3IEZpbGVSZWFkZXI7ay5vbmxvYWRlbmQ9ZnVuY3Rpb24oKXt2YXIgYT1rLnJlc3VsdDthPWo/YTphLnJlcGxhY2UoL15kYXRhOlteO10qOy8sXCJkYXRhOmF0dGFjaG1lbnQvZmlsZTtcIiksZz9nLmxvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbj1hLGc9bnVsbH0say5yZWFkQXNEYXRhVVJMKGIpfWVsc2V7dmFyIGw9Zi5VUkx8fGYud2Via2l0VVJMLG09bC5jcmVhdGVPYmplY3RVUkwoYik7Zz9nLmxvY2F0aW9uPW06bG9jYXRpb24uaHJlZj1tLGc9bnVsbCxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bC5yZXZva2VPYmplY3RVUkwobSl9LDRFNCl9fSk7Zi5zYXZlQXM9Zy5zYXZlQXM9ZyxcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9Zyl9KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVNhdmVyLm1pbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMsdUJBQXVCLHdCQUF3Qix3QkFBd0IsMEZBQTBGLHNCQUFzQixtQkFBbUIscUJBQXFCLHFCQUFxQix3QkFBd0IsdUJBQXVCLDBCQUEwQix3QkFBd0IsWUFBWSxtSkFBbUosbUVBQW1FLDhCQUE4Qix5SEFBeUgsOEJBQThCLHdCQUF3Qiw2RkFBNkYsNkJBQTZCLG1CQUFtQiwwQkFBMEIsb0JBQW9CLGNBQWMscUdBQXFHLHdEQUF3RCxtSkFBbUosNEJBQTRCLG9CQUFvQiw2REFBNkQseUNBQXlDLHVCQUF1Qix3QkFBd0IsOERBQThELGFBQWEsd0VBQXdFLHNCQUFzQixjQUFjLFNBQVMsdUJBQXVCLGtCQUFrQiw2RUFBNkUsdUJBQXVCLDZCQUE2QixxQkFBcUIsd0JBQXdCLGNBQWMsd0NBQXdDLCtCQUErQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix5QkFBeUIsZ0NBQWdDLFNBQVMsMEJBQTBCLDRDQUE0Qyx3QkFBd0Isc0JBQXNCLG1CQUFtQixVQUFVLGVBQWUsU0FBUywwQkFBMEIsdUNBQXVDLHNCQUFzQixZQUFZLElBQUksTUFBTSxjQUFjLFNBQVMsZ0NBQWdDLHdCQUF3Qiw2REFBNkQsMEJBQTBCLDZEQUE2RCxNQUFNLGlDQUFpQyxvQkFBb0IsdUJBQXVCLHNCQUFzQixLQUFLLHdCQUF3QiwwQ0FBMEMsU0FBUyx1QkFBdUIsdUJBQXVCLDBCQUEwQixzQkFBc0IsaUJBQWlCLFNBQVMsZ0JBQWdCLFNBQVMseUJBQXlCLHNEQUFzRCx1QkFBdUIsd0JBQXdCLDZDQUE2Qyw4QkFBOEIsb0JBQW9CLFNBQVMsMkdBQTJHLFdBQVcsdUJBQXVCLFVBQVUsSUFBSSx3QkFBd0IscUNBQXFDLDBEQUEwRCxxQ0FBcUMsbUVBQW1FLG1FQUFtRSw2Q0FBNkMsNkZBQTZGLGtCQUFrQixlQUFlLGVBQWUsNEJBQTRCLElBQUksS0FBSyxnQkFBZ0IsT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLGdCQUFnQixVQUFVLHlDQUF5QyxnQ0FBZ0Msb0pBQW9KLHVCQUF1QixtQ0FBbUMsc0JBQXNCLG1FQUFtRSxpQkFBaUIsdUJBQXVCLE1BQU0sa0JBQWtCLElBQUksUUFBUSxXQUFXLEtBQUssZ0JBQWdCLDRCQUE0QixRQUFRLFFBQVEsV0FBVyxLQUFLLFdBQVcsNkJBQTZCLGlCQUFpQix3QkFBd0IsbUVBQW1FLFlBQVksWUFBWSxVQUFVLHlCQUF5Qix1QkFBdUIsZ0JBQWdCLHFEQUFxRCxvQkFBb0Isd0JBQXdCLDRIQUE0SCxlQUFlLDhDQUE4QyxzQkFBc0IsWUFBWSxNQUFNLEVBQUUsVUFBVSwrQ0FBK0Msb0RBQW9ELCtEQUErRCx1QkFBdUIsNENBQTRDLGNBQWMsa0NBQWtDLHVCQUF1QixTQUFTLDZCQUE2Qiw2QkFBNkIsWUFBWSx1QkFBdUIsSUFBSSxrQkFBa0IsU0FBUyxpQ0FBaUMsY0FBYyxTQUFTLFNBQVMsT0FBTyxPQUFPLFNBQVMsU0FBUyxlQUFlLFlBQVksVUFBVSxvQ0FBb0Msa0RBQWtELHdDQUF3Qyx1REFBdUQsMENBQTBDLGtGQUFrRix5REFBeUQsdUJBQXVCLFNBQVMsZ0NBQWdDLHFCQUFxQixXQUFXLFVBQVUsT0FBTywwQ0FBMEMsa0JBQWtCLFlBQVksa0VBQWtFLFlBQVksSUFBSSxNQUFNLGlCQUFpQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixhQUFhLDBDQUEwQyxrQkFBa0IsWUFBWSxrRUFBa0UsWUFBWSxJQUFJLE1BQU0saUJBQWlCLG1CQUFtQixtQkFBbUIsbUJBQW1CLGFBQWEsOENBQThDLGtCQUFrQixrQkFBa0IsbURBQW1ELDJDQUEyQywwREFBMEQsMkNBQTJDLHdFQUF3RSx3QkFBd0IsbUNBQW1DLDRDQUE0QyxTQUFTLDBCQUEwQix1Q0FBdUMsRUFBRSxrQkFBa0IsNEJBQTRCLHdCQUF3QixNQUFNLDZDQUE2QyxxREFBcUQsNkJBQTZCLHVDQUF1Qyx3QkFBd0Isa0hBQWtILGtCQUFrQixJQUFJLGtCQUFrQixlQUFlLGtCQUFrQixJQUFJLGtCQUFrQixjQUFjLHdDQUF3QywyQ0FBMkMsZUFBZSxTQUFTLFNBQVMsU0FBUyxTQUFTLFNBQVMsT0FBTyxPQUFPLE9BQU8sT0FBTyxxQkFBcUIsVUFBVSxVQUFVLG9CQUFvQixzQkFBc0IsbUJBQW1CLFlBQVksSUFBSSxLQUFLLGdCQUFnQixPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsZ0JBQWdCLFVBQVUseUNBQXlDLHlCQUF5Qix3QkFBd0IsSUFBSSxJQUFJLHNCQUFzQixhQUFhLHVCQUF1QixjQUFjLEtBQUssbUJBQW1CLGlCQUFpQixvQkFBb0IsZ0JBQWdCLGNBQWMsa0JBQWtCLGFBQWEsU0FBUyxjQUFjLHdCQUF3QixtQkFBbUIsdUJBQXVCLGlCQUFpQixTQUFTLCtCQUErQiw2QkFBNkIsUUFBUSxxREFBcUQsTUFBTSxnREFBZ0QsS0FBSyxxREFBcUQsaUNBQWlDLDREQUE0RCxpQ0FBaUMsUUFBUSxlQUFlLGVBQWUsa0JBQWtCLDBCQUEwQiwyREFBMkQsMkJBQTJCLFNBQVMsSUFBSSxLQUFLLEtBQUssTUFBTSxtQkFBbUIsVUFBVSxZQUFZLEtBQUssNEJBQTRCLE1BQU0sTUFBTSxTQUFTLFFBQVEsSUFBSSxLQUFLLHFDQUFxQyxjQUFjLHdCQUF3QixLQUFLLGlCQUFpQixPQUFPLEtBQUssZUFBZSxRQUFRLEtBQUssS0FBSyxXQUFXLFlBQVksSUFBSSxLQUFLLDRCQUE0QixRQUFRLE9BQU8sZUFBZSxTQUFTLG1EQUFtRCxpQ0FBaUMsaURBQWlELDhDQUE4Qyx5REFBeUQsK0NBQStDLDJCQUEyQixlQUFlLGlCQUFpQixPQUFPLElBQUksS0FBSyxZQUFZLFFBQVEsS0FBSyxlQUFlLFVBQVUsTUFBTSxZQUFZLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLFNBQVMsU0FBUyw0QkFBNEIsbURBQW1ELDZCQUE2Qix5Q0FBeUMsOEJBQThCLDJCQUEyQiw4QkFBOEIsMENBQTBDLDRCQUE0QixzREFBc0QsK0NBQStDLGtCQUFrQixTQUFTLGNBQWMsSUFBSSw0Q0FBNEMsSUFBSSxjQUFjLElBQUkscUJBQXFCLFFBQVEsZ0JBQWdCLFFBQVEsMEJBQTBCLEtBQUssSUFBSSxhQUFhLEtBQUssMkZBQTJGLG9CQUFvQiwwQkFBMEIsMENBQTBDLCtEQUErRCxlQUFlLFlBQVksTUFBTSxFQUFFLFVBQVUsc0NBQXNDLG9EQUFvRCwwQ0FBMEMseURBQXlELDRDQUE0QyxpRkFBaUYseURBQXlELHVCQUF1QixVQUFVLDBDQUEwQyxPQUFPLG1FQUFtRSw0QkFBNEIsd0JBQXdCLDBCQUEwQixLQUFLLHNDQUFzQywwQkFBMEIsdUJBQXVCLFNBQVMsUUFBUSxXQUFXLFdBQVcsV0FBVyxnQ0FBZ0MsV0FBVyxZQUFZLFVBQVUsaUJBQWlCLElBQUksTUFBTSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixVQUFVLEtBQUssTUFBTSxnQkFBZ0IsU0FBUyxpQ0FBaUMsNEJBQTRCLCtCQUErQixLQUFLLE1BQU0sZ0JBQWdCLFNBQVMsU0FBUyxnREFBZ0QsdUNBQXVDLHVCQUF1QixPQUFPLGFBQWEsUUFBUSxJQUFJLGlCQUFpQixTQUFTLDBCQUEwQixlQUFlLFVBQVUsS0FBSyxnQ0FBZ0MsV0FBVyxrQ0FBa0MsZUFBZSxTQUFTLDJDQUEyQyxTQUFTLFFBQVEsV0FBVyxxREFBcUQsU0FBUywyQkFBMkIsU0FBUyx1QkFBdUIsWUFBWSxJQUFJLEtBQUssaUNBQWlDLFNBQVMsNEJBQTRCLFNBQVMsdUJBQXVCLFlBQVksSUFBSSxLQUFLLDZCQUE2QixTQUFTLHlCQUF5QixlQUFlLGVBQWUsb0JBQW9CLFNBQVMsWUFBWSxJQUFJLEtBQUssV0FBVyxTQUFTLDZCQUE2QixtQkFBbUIsU0FBUyxZQUFZLFdBQVcsTUFBTSx3Q0FBd0MsU0FBUywyQ0FBMkMsa0JBQWtCLE1BQU0sc0JBQXNCLFFBQVEsS0FBSyxXQUFXLGFBQWEsSUFBSSxRQUFRLEtBQUssV0FBVyxhQUFhLElBQUksV0FBVyx5QkFBeUIsMENBQTBDLFVBQVUsNEJBQTRCLDJEQUEyRCx1RUFBdUUsdURBQXVELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsVUFBVSx1REFBdUQsUUFBUSxRQUFRLE9BQU8sNkJBQTZCLGtCQUFrQixRQUFRLHFCQUFxQixpQkFBaUIsVUFBVSxtREFBbUQsUUFBUSxtQ0FBbUMsZ0JBQWdCLHlEQUF5RCxRQUFRLG1DQUFtQyw2QkFBNkIseURBQXlELFFBQVEsbUNBQW1DLDZCQUE2Qix5REFBeUQsUUFBUSxtQ0FBbUMsK0RBQStELHlEQUF5RCxRQUFRLG1DQUFtQyxnRUFBZ0UscURBQXFELFFBQVEsUUFBUSxtQ0FBbUMsY0FBYyxRQUFRLFFBQVEsdUJBQXVCLGVBQWUsT0FBTywyQkFBMkIsVUFBVSxxREFBcUQsUUFBUSxRQUFRLG1DQUFtQyxRQUFRLFFBQVEsa0JBQWtCLHFCQUFxQixpQkFBaUIsT0FBTywyQkFBMkIsVUFBVSxpREFBaUQsUUFBUSxtQ0FBbUMsaUNBQWlDLDBCQUEwQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMsMkJBQTJCLCtCQUErQix1REFBdUQsUUFBUSxtQ0FBbUMseURBQXlELHVEQUF1RCxRQUFRLG1DQUFtQyx5REFBeUQsdURBQXVELFFBQVEsbUNBQW1DLGlDQUFpQyx1REFBdUQsUUFBUSxtQ0FBbUMsa0NBQWtDLHlEQUF5RCxRQUFRLG1DQUFtQyxpQ0FBaUMseURBQXlELFFBQVEsbUNBQW1DLGtDQUFrQywrQkFBK0IsMEZBQTBGLHNFQUFzRSwyREFBMkQsMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixRQUFRLFFBQVEsY0FBYyx1QkFBdUIsa0JBQWtCLFlBQVksMkRBQTJELEtBQUssUUFBUSxRQUFRLE9BQU8sd0JBQXdCLHlCQUF5QixVQUFVLFFBQVEsZ0JBQWdCLHdCQUF3QixrQkFBa0IsWUFBWSx1REFBdUQsS0FBSyxRQUFRLGlDQUFpQyxjQUFjLFlBQVksNkRBQTZELEtBQUssUUFBUSxtQ0FBbUMsY0FBYyxnQkFBZ0IsWUFBWSw2REFBNkQsS0FBSyxRQUFRLG1DQUFtQyxjQUFjLGdCQUFnQixZQUFZLDZEQUE2RCxLQUFLLFFBQVEsd0NBQXdDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGNBQWMsWUFBWSw2REFBNkQsS0FBSyxRQUFRLHdDQUF3QyxlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsUUFBUSxRQUFRLFFBQVEsY0FBYyx1QkFBdUIsZ0NBQWdDLElBQUkseUJBQXlCLFlBQVkseURBQXlELEtBQUssUUFBUSxPQUFPLHdCQUF3Qiw0QkFBNEIsVUFBVSxRQUFRLFFBQVEsZ0JBQWdCLHdCQUF3QixnQ0FBZ0MsSUFBSSx5QkFBeUIsWUFBWSxxREFBcUQsS0FBSyxRQUFRLG9DQUFvQyxpQkFBaUIsY0FBYyxZQUFZLDJEQUEyRCxLQUFLLFFBQVEsd0NBQXdDLGNBQWMsZ0JBQWdCLFlBQVksMkRBQTJELEtBQUssUUFBUSx3Q0FBd0MsY0FBYyxnQkFBZ0IsWUFBWSwyREFBMkQsS0FBSyxRQUFRLGtEQUFrRCxjQUFjLGdCQUFnQixpQkFBaUIsaUJBQWlCLFlBQVksMkRBQTJELEtBQUssUUFBUSxrREFBa0Qsd0JBQXdCLGVBQWUsaUJBQWlCLGdCQUFnQixnQkFBZ0IsWUFBWSxtQ0FBbUMsMkRBQTJELGtEQUFrRCwrQkFBK0IsS0FBSyxRQUFRLE9BQU8saUVBQWlFLHNCQUFzQixXQUFXLDJEQUEyRCxvQ0FBb0MsMkRBQTJELHFDQUFxQyxnQ0FBZ0MsS0FBSyxRQUFRLE9BQU8sbUVBQW1FLHNCQUFzQixXQUFXLDZEQUE2RCxxQ0FBcUMsNkRBQTZELHNDQUFzQyw2Q0FBNkMsMEVBQTBFLFVBQVUsMkJBQTJCLDBCQUEwQixVQUFVLGdCQUFnQixrQkFBa0IsMENBQTBDLFFBQVEsa0RBQWtELGtFQUFrRSx1REFBdUQsK0JBQStCLG1CQUFtQixlQUFlLFVBQVUsa0VBQWtFLHVCQUF1Qiw0QkFBNEIsY0FBYyxLQUFLLEtBQUssa0JBQWtCLEtBQUssc0RBQXNELFVBQVUsNkNBQTZDLHdCQUF3Qix3QkFBd0IsSUFBSSxJQUFJLGNBQWMsNkJBQTZCLElBQUksY0FBYyx1Q0FBdUMsaURBQWlELCtDQUErQyw0Q0FBNEMsaUJBQWlCLHNCQUFzQixvQ0FBb0MsTUFBTSw2QkFBNkIsUUFBUSw4QkFBOEIsWUFBWSxzQ0FBc0MsMkNBQTJDLFNBQVMsWUFBWSxRQUFRLGtDQUFrQyxVQUFVLE1BQU0sd0JBQXdCLFFBQVEsSUFBSSxLQUFLLFdBQVcsS0FBSyw0Q0FBNEMsZUFBZSxVQUFVLHlFQUF5RSxRQUFRLE1BQU0sS0FBSyxrQkFBa0IsYUFBYSwwQkFBMEIsd0JBQXdCLGtCQUFrQix5QkFBeUIsdUJBQXVCLHNCQUFzQixRQUFRLFNBQVMsMEJBQTBCLGNBQWMsTUFBTSxlQUFlLFdBQVcsU0FBUyxZQUFZLElBQUksS0FBSyxrQkFBa0IscUJBQXFCLE9BQU8sWUFBWSxpQ0FBaUMsU0FBUyxpQkFBaUIsaUNBQWlDLFNBQVMsSUFBSSxTQUFTLFlBQVksaUNBQWlDLElBQUksU0FBUyw4QkFBOEIsV0FBVyxpQ0FBaUMsT0FBTyxVQUFVLGtCQUFrQixVQUFVLGdCQUFnQixrQkFBa0IsMEJBQTBCLGlCQUFpQixrQkFBa0IsdUNBQXVDLG1CQUFtQixrQkFBa0Isb0RBQW9ELEtBQUssdUNBQXVDLFNBQVMseUJBQXlCLFNBQVMsWUFBWSxXQUFXLEtBQUssNEJBQTRCLFNBQVMsNkJBQTZCLFVBQVUsU0FBUyxZQUFZLFdBQVcsS0FBSyxrQkFBa0Isa0JBQWtCLE9BQU8sUUFBUSxVQUFVLFVBQVUsU0FBUywwQkFBMEIscUNBQXFDLDZCQUE2QixZQUFZLElBQUksS0FBSyxvQ0FBb0MsWUFBWSxTQUFTLHlCQUF5QiwyR0FBMkcsd0JBQXdCLGFBQWEsaUJBQWlCLHlCQUF5QixxQkFBcUIsWUFBWSxLQUFLLEtBQUssV0FBVyxZQUFZLEtBQUssS0FBSyxrQkFBa0IsU0FBUyxHQUFHO0FBQ3p4dkI7QUFDQSwyQkFBMkIsUUFBUSxjQUFjLGVBQWUsV0FBVyxTQUFTLGNBQWMsYUFBYSxhQUFhLEtBQUssY0FBYyxPQUFPLEtBQUssS0FBSyxJQUFJLDJCQUEyQixjQUFjLE9BQU8sS0FBSyxLQUFLLElBQUksMkJBQTJCLFVBQVUsTUFBTSxlQUFlLCtCQUErQixLQUFLLGtCQUFrQixNQUFNLGtDQUFrQyw4QkFBOEIsVUFBVSxjQUFjLGVBQWUsV0FBVywrQ0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcz8zOGYxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXs2NzU6ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtyLnRvQnl0ZUFycmF5PXRvQnl0ZUFycmF5O3IuZnJvbUJ5dGVBcnJheT1mcm9tQnl0ZUFycmF5O3ZhciB0PVtdO3ZhciBmPVtdO3ZhciBuPXR5cGVvZiBVaW50OEFycmF5IT09XCJ1bmRlZmluZWRcIj9VaW50OEFycmF5OkFycmF5O3ZhciBpPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO2Zvcih2YXIgbz0wLHU9aS5sZW5ndGg7bzx1Oysrbyl7dFtvXT1pW29dO2ZbaS5jaGFyQ29kZUF0KG8pXT1vfWZbXCItXCIuY2hhckNvZGVBdCgwKV09NjI7ZltcIl9cIi5jaGFyQ29kZUF0KDApXT02MztmdW5jdGlvbiBnZXRMZW5zKGUpe3ZhciByPWUubGVuZ3RoO2lmKHIlND4wKXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpfXZhciB0PWUuaW5kZXhPZihcIj1cIik7aWYodD09PS0xKXQ9cjt2YXIgZj10PT09cj8wOjQtdCU0O3JldHVyblt0LGZdfWZ1bmN0aW9uIGJ5dGVMZW5ndGgoZSl7dmFyIHI9Z2V0TGVucyhlKTt2YXIgdD1yWzBdO3ZhciBmPXJbMV07cmV0dXJuKHQrZikqMy80LWZ9ZnVuY3Rpb24gX2J5dGVMZW5ndGgoZSxyLHQpe3JldHVybihyK3QpKjMvNC10fWZ1bmN0aW9uIHRvQnl0ZUFycmF5KGUpe3ZhciByO3ZhciB0PWdldExlbnMoZSk7dmFyIGk9dFswXTt2YXIgbz10WzFdO3ZhciB1PW5ldyBuKF9ieXRlTGVuZ3RoKGUsaSxvKSk7dmFyIGE9MDt2YXIgcz1vPjA/aS00Omk7dmFyIGg7Zm9yKGg9MDtoPHM7aCs9NCl7cj1mW2UuY2hhckNvZGVBdChoKV08PDE4fGZbZS5jaGFyQ29kZUF0KGgrMSldPDwxMnxmW2UuY2hhckNvZGVBdChoKzIpXTw8NnxmW2UuY2hhckNvZGVBdChoKzMpXTt1W2ErK109cj4+MTYmMjU1O3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9aWYobz09PTIpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwyfGZbZS5jaGFyQ29kZUF0KGgrMSldPj40O3VbYSsrXT1yJjI1NX1pZihvPT09MSl7cj1mW2UuY2hhckNvZGVBdChoKV08PDEwfGZbZS5jaGFyQ29kZUF0KGgrMSldPDw0fGZbZS5jaGFyQ29kZUF0KGgrMildPj4yO3VbYSsrXT1yPj44JjI1NTt1W2ErK109ciYyNTV9cmV0dXJuIHV9ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KGUpe3JldHVybiB0W2U+PjE4JjYzXSt0W2U+PjEyJjYzXSt0W2U+PjYmNjNdK3RbZSY2M119ZnVuY3Rpb24gZW5jb2RlQ2h1bmsoZSxyLHQpe3ZhciBmO3ZhciBuPVtdO2Zvcih2YXIgaT1yO2k8dDtpKz0zKXtmPShlW2ldPDwxNiYxNjcxMTY4MCkrKGVbaSsxXTw8OCY2NTI4MCkrKGVbaSsyXSYyNTUpO24ucHVzaCh0cmlwbGV0VG9CYXNlNjQoZikpfXJldHVybiBuLmpvaW4oXCJcIil9ZnVuY3Rpb24gZnJvbUJ5dGVBcnJheShlKXt2YXIgcjt2YXIgZj1lLmxlbmd0aDt2YXIgbj1mJTM7dmFyIGk9W107dmFyIG89MTYzODM7Zm9yKHZhciB1PTAsYT1mLW47dTxhO3UrPW8pe2kucHVzaChlbmNvZGVDaHVuayhlLHUsdStvPmE/YTp1K28pKX1pZihuPT09MSl7cj1lW2YtMV07aS5wdXNoKHRbcj4+Ml0rdFtyPDw0JjYzXStcIj09XCIpfWVsc2UgaWYobj09PTIpe3I9KGVbZi0yXTw8OCkrZVtmLTFdO2kucHVzaCh0W3I+PjEwXSt0W3I+PjQmNjNdK3Rbcjw8MiY2M10rXCI9XCIpfXJldHVybiBpLmpvaW4oXCJcIil9fSw3MjpmdW5jdGlvbihlLHIsdCl7XCJ1c2Ugc3RyaWN0XCI7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi92YXIgZj10KDY3NSk7dmFyIG49dCg3ODMpO3ZhciBpPXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJnR5cGVvZiBTeW1ib2wuZm9yPT09XCJmdW5jdGlvblwiP1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKTpudWxsO3IuQnVmZmVyPUJ1ZmZlcjtyLlNsb3dCdWZmZXI9U2xvd0J1ZmZlcjtyLklOU1BFQ1RfTUFYX0JZVEVTPTUwO3ZhciBvPTIxNDc0ODM2NDc7ci5rTWF4TGVuZ3RoPW87QnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dHlwZWRBcnJheVN1cHBvcnQoKTtpZighQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQmJnR5cGVvZiBjb25zb2xlIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PT1cImZ1bmN0aW9uXCIpe2NvbnNvbGUuZXJyb3IoXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgXCIrXCJgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKX1mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTt2YXIgcj17Zm9vOmZ1bmN0aW9uKCl7cmV0dXJuIDQyfX07T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihlLHIpO3JldHVybiBlLmZvbygpPT09NDJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX1PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcInBhcmVudFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ1ZmZlcn19KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSxcIm9mZnNldFwiLHtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7aWYoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSlyZXR1cm4gdW5kZWZpbmVkO3JldHVybiB0aGlzLmJ5dGVPZmZzZXR9fSk7ZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGUpe2lmKGU+byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9dmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKHIsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQnVmZmVyKGUscix0KXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX1yZXR1cm4gYWxsb2NVbnNhZmUoZSl9cmV0dXJuIGZyb20oZSxyLHQpfUJ1ZmZlci5wb29sU2l6ZT04MTkyO2Z1bmN0aW9uIGZyb20oZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7cmV0dXJuIGZyb21TdHJpbmcoZSxyKX1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGU9PW51bGwpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLEFycmF5QnVmZmVyKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmKGlzSW5zdGFuY2UoZSxTaGFyZWRBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsU2hhcmVkQXJyYXlCdWZmZXIpKSl7cmV0dXJuIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl9aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXZhciBmPWUudmFsdWVPZiYmZS52YWx1ZU9mKCk7aWYoZiE9bnVsbCYmZiE9PWUpe3JldHVybiBCdWZmZXIuZnJvbShmLHIsdCl9dmFyIG49ZnJvbU9iamVjdChlKTtpZihuKXJldHVybiBuO2lmKHR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2wudG9QcmltaXRpdmUhPW51bGwmJnR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV09PT1cImZ1bmN0aW9uXCIpe3JldHVybiBCdWZmZXIuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIikscix0KX10aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9QnVmZmVyLmZyb209ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBmcm9tKGUscix0KX07T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsVWludDhBcnJheS5wcm90b3R5cGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsVWludDhBcnJheSk7ZnVuY3Rpb24gYXNzZXJ0U2l6ZShlKXtpZih0eXBlb2YgZSE9PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKX1lbHNlIGlmKGU8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyl9fWZ1bmN0aW9uIGFsbG9jKGUscix0KXthc3NlcnRTaXplKGUpO2lmKGU8PTApe3JldHVybiBjcmVhdGVCdWZmZXIoZSl9aWYociE9PXVuZGVmaW5lZCl7cmV0dXJuIHR5cGVvZiB0PT09XCJzdHJpbmdcIj9jcmVhdGVCdWZmZXIoZSkuZmlsbChyLHQpOmNyZWF0ZUJ1ZmZlcihlKS5maWxsKHIpfXJldHVybiBjcmVhdGVCdWZmZXIoZSl9QnVmZmVyLmFsbG9jPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gYWxsb2MoZSxyLHQpfTtmdW5jdGlvbiBhbGxvY1Vuc2FmZShlKXthc3NlcnRTaXplKGUpO3JldHVybiBjcmVhdGVCdWZmZXIoZTwwPzA6Y2hlY2tlZChlKXwwKX1CdWZmZXIuYWxsb2NVbnNhZmU9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtCdWZmZXIuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07ZnVuY3Rpb24gZnJvbVN0cmluZyhlLHIpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8cj09PVwiXCIpe3I9XCJ1dGY4XCJ9aWYoIUJ1ZmZlci5pc0VuY29kaW5nKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcil9dmFyIHQ9Ynl0ZUxlbmd0aChlLHIpfDA7dmFyIGY9Y3JlYXRlQnVmZmVyKHQpO3ZhciBuPWYud3JpdGUoZSxyKTtpZihuIT09dCl7Zj1mLnNsaWNlKDAsbil9cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbUFycmF5TGlrZShlKXt2YXIgcj1lLmxlbmd0aDwwPzA6Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7Zm9yKHZhciBmPTA7ZjxyO2YrPTEpe3RbZl09ZVtmXSYyNTV9cmV0dXJuIHR9ZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGUscix0KXtpZihyPDB8fGUuYnl0ZUxlbmd0aDxyKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX1pZihlLmJ5dGVMZW5ndGg8cisodHx8MCkpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfXZhciBmO2lmKHI9PT11bmRlZmluZWQmJnQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSl9ZWxzZSBpZih0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUscil9ZWxzZXtmPW5ldyBVaW50OEFycmF5KGUscix0KX1PYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn1mdW5jdGlvbiBmcm9tT2JqZWN0KGUpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7dmFyIHI9Y2hlY2tlZChlLmxlbmd0aCl8MDt2YXIgdD1jcmVhdGVCdWZmZXIocik7aWYodC5sZW5ndGg9PT0wKXtyZXR1cm4gdH1lLmNvcHkodCwwLDAscik7cmV0dXJuIHR9aWYoZS5sZW5ndGghPT11bmRlZmluZWQpe2lmKHR5cGVvZiBlLmxlbmd0aCE9PVwibnVtYmVyXCJ8fG51bWJlcklzTmFOKGUubGVuZ3RoKSl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKX1yZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlLnR5cGU9PT1cIkJ1ZmZlclwiJiZBcnJheS5pc0FycmF5KGUuZGF0YSkpe3JldHVybiBmcm9tQXJyYXlMaWtlKGUuZGF0YSl9fWZ1bmN0aW9uIGNoZWNrZWQoZSl7aWYoZT49byl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIFwiK1wic2l6ZTogMHhcIitvLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKX1yZXR1cm4gZXwwfWZ1bmN0aW9uIFNsb3dCdWZmZXIoZSl7aWYoK2UhPWUpe2U9MH1yZXR1cm4gQnVmZmVyLmFsbG9jKCtlKX1CdWZmZXIuaXNCdWZmZXI9ZnVuY3Rpb24gaXNCdWZmZXIoZSl7cmV0dXJuIGUhPW51bGwmJmUuX2lzQnVmZmVyPT09dHJ1ZSYmZSE9PUJ1ZmZlci5wcm90b3R5cGV9O0J1ZmZlci5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCk7aWYoaXNJbnN0YW5jZShyLFVpbnQ4QXJyYXkpKXI9QnVmZmVyLmZyb20ocixyLm9mZnNldCxyLmJ5dGVMZW5ndGgpO2lmKCFCdWZmZXIuaXNCdWZmZXIoZSl8fCFCdWZmZXIuaXNCdWZmZXIocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknKX1pZihlPT09cilyZXR1cm4gMDt2YXIgdD1lLmxlbmd0aDt2YXIgZj1yLmxlbmd0aDtmb3IodmFyIG49MCxpPU1hdGgubWluKHQsZik7bjxpOysrbil7aWYoZVtuXSE9PXJbbl0pe3Q9ZVtuXTtmPXJbbl07YnJlYWt9fWlmKHQ8ZilyZXR1cm4tMTtpZihmPHQpcmV0dXJuIDE7cmV0dXJuIDB9O0J1ZmZlci5pc0VuY29kaW5nPWZ1bmN0aW9uIGlzRW5jb2RpbmcoZSl7c3dpdGNoKFN0cmluZyhlKS50b0xvd2VyQ2FzZSgpKXtjYXNlXCJoZXhcIjpjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0cnVlO2RlZmF1bHQ6cmV0dXJuIGZhbHNlfX07QnVmZmVyLmNvbmNhdD1mdW5jdGlvbiBjb25jYXQoZSxyKXtpZighQXJyYXkuaXNBcnJheShlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aWYoZS5sZW5ndGg9PT0wKXtyZXR1cm4gQnVmZmVyLmFsbG9jKDApfXZhciB0O2lmKHI9PT11bmRlZmluZWQpe3I9MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyKz1lW3RdLmxlbmd0aH19dmFyIGY9QnVmZmVyLmFsbG9jVW5zYWZlKHIpO3ZhciBuPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7dmFyIGk9ZVt0XTtpZihpc0luc3RhbmNlKGksVWludDhBcnJheSkpe2k9QnVmZmVyLmZyb20oaSl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihpKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyl9aS5jb3B5KGYsbik7bis9aS5sZW5ndGh9cmV0dXJuIGZ9O2Z1bmN0aW9uIGJ5dGVMZW5ndGgoZSxyKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3JldHVybiBlLmxlbmd0aH1pZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcikpe3JldHVybiBlLmJ5dGVMZW5ndGh9aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfXZhciB0PWUubGVuZ3RoO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdPT09dHJ1ZTtpZighZiYmdD09PTApcmV0dXJuIDA7dmFyIG49ZmFsc2U7Zm9yKDs7KXtzd2l0Y2gocil7Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gdDtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFRvQnl0ZXMoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB0KjI7Y2FzZVwiaGV4XCI6cmV0dXJuIHQ+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRUb0J5dGVzKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pe3JldHVybiBmPy0xOnV0ZjhUb0J5dGVzKGUpLmxlbmd0aH1yPShcIlwiK3IpLnRvTG93ZXJDYXNlKCk7bj10cnVlfX19QnVmZmVyLmJ5dGVMZW5ndGg9Ynl0ZUxlbmd0aDtmdW5jdGlvbiBzbG93VG9TdHJpbmcoZSxyLHQpe3ZhciBmPWZhbHNlO2lmKHI9PT11bmRlZmluZWR8fHI8MCl7cj0wfWlmKHI+dGhpcy5sZW5ndGgpe3JldHVyblwiXCJ9aWYodD09PXVuZGVmaW5lZHx8dD50aGlzLmxlbmd0aCl7dD10aGlzLmxlbmd0aH1pZih0PD0wKXtyZXR1cm5cIlwifXQ+Pj49MDtyPj4+PTA7aWYodDw9cil7cmV0dXJuXCJcIn1pZighZSllPVwidXRmOFwiO3doaWxlKHRydWUpe3N3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4U2xpY2UodGhpcyxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4U2xpY2UodGhpcyxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpU2xpY2UodGhpcyxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMscix0KTtkZWZhdWx0OmlmKGYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2UpO2U9KGUrXCJcIikudG9Mb3dlckNhc2UoKTtmPXRydWV9fX1CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlcj10cnVlO2Z1bmN0aW9uIHN3YXAoZSxyLHQpe3ZhciBmPWVbcl07ZVtyXT1lW3RdO2VbdF09Zn1CdWZmZXIucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbiBzd2FwMTYoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz0yKXtzd2FwKHRoaXMscixyKzEpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbiBzd2FwMzIoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz00KXtzd2FwKHRoaXMscixyKzMpO3N3YXAodGhpcyxyKzEscisyKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24gc3dhcDY0KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9OCl7c3dhcCh0aGlzLHIscis3KTtzd2FwKHRoaXMscisxLHIrNik7c3dhcCh0aGlzLHIrMixyKzUpO3N3YXAodGhpcyxyKzMscis0KX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGU9PT0wKXJldHVyblwiXCI7aWYoYXJndW1lbnRzLmxlbmd0aD09PTApcmV0dXJuIHV0ZjhTbGljZSh0aGlzLDAsZSk7cmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O0J1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmc9QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZztCdWZmZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbiBlcXVhbHMoZSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih0aGlzPT09ZSlyZXR1cm4gdHJ1ZTtyZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcyxlKT09PTB9O0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbiBpbnNwZWN0KCl7dmFyIGU9XCJcIjt2YXIgdD1yLklOU1BFQ1RfTUFYX0JZVEVTO2U9dGhpcy50b1N0cmluZyhcImhleFwiLDAsdCkucmVwbGFjZSgvKC57Mn0pL2csXCIkMSBcIikudHJpbSgpO2lmKHRoaXMubGVuZ3RoPnQpZSs9XCIgLi4uIFwiO3JldHVyblwiPEJ1ZmZlciBcIitlK1wiPlwifTtpZihpKXtCdWZmZXIucHJvdG90eXBlW2ldPUJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdH1CdWZmZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIsdCxmLG4pe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSl7ZT1CdWZmZXIuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCl9aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJytcIlJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKHI9PT11bmRlZmluZWQpe3I9MH1pZih0PT09dW5kZWZpbmVkKXt0PWU/ZS5sZW5ndGg6MH1pZihmPT09dW5kZWZpbmVkKXtmPTB9aWYobj09PXVuZGVmaW5lZCl7bj10aGlzLmxlbmd0aH1pZihyPDB8fHQ+ZS5sZW5ndGh8fGY8MHx8bj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYoZj49biYmcj49dCl7cmV0dXJuIDB9aWYoZj49bil7cmV0dXJuLTF9aWYocj49dCl7cmV0dXJuIDF9cj4+Pj0wO3Q+Pj49MDtmPj4+PTA7bj4+Pj0wO2lmKHRoaXM9PT1lKXJldHVybiAwO3ZhciBpPW4tZjt2YXIgbz10LXI7dmFyIHU9TWF0aC5taW4oaSxvKTt2YXIgYT10aGlzLnNsaWNlKGYsbik7dmFyIHM9ZS5zbGljZShyLHQpO2Zvcih2YXIgaD0wO2g8dTsrK2gpe2lmKGFbaF0hPT1zW2hdKXtpPWFbaF07bz1zW2hdO2JyZWFrfX1pZihpPG8pcmV0dXJuLTE7aWYobzxpKXJldHVybiAxO3JldHVybiAwfTtmdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZihlLHIsdCxmLG4pe2lmKGUubGVuZ3RoPT09MClyZXR1cm4tMTtpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PTB9ZWxzZSBpZih0PjIxNDc0ODM2NDcpe3Q9MjE0NzQ4MzY0N31lbHNlIGlmKHQ8LTIxNDc0ODM2NDgpe3Q9LTIxNDc0ODM2NDh9dD0rdDtpZihudW1iZXJJc05hTih0KSl7dD1uPzA6ZS5sZW5ndGgtMX1pZih0PDApdD1lLmxlbmd0aCt0O2lmKHQ+PWUubGVuZ3RoKXtpZihuKXJldHVybi0xO2Vsc2UgdD1lLmxlbmd0aC0xfWVsc2UgaWYodDwwKXtpZihuKXQ9MDtlbHNlIHJldHVybi0xfWlmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7cj1CdWZmZXIuZnJvbShyLGYpfWlmKEJ1ZmZlci5pc0J1ZmZlcihyKSl7aWYoci5sZW5ndGg9PT0wKXtyZXR1cm4tMX1yZXR1cm4gYXJyYXlJbmRleE9mKGUscix0LGYsbil9ZWxzZSBpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe3I9ciYyNTU7aWYodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2Y9PT1cImZ1bmN0aW9uXCIpe2lmKG4pe3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoZSxyLHQpfWVsc2V7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoZSxyLHQpfX1yZXR1cm4gYXJyYXlJbmRleE9mKGUsW3JdLHQsZixuKX10aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pe3ZhciBpPTE7dmFyIG89ZS5sZW5ndGg7dmFyIHU9ci5sZW5ndGg7aWYoZiE9PXVuZGVmaW5lZCl7Zj1TdHJpbmcoZikudG9Mb3dlckNhc2UoKTtpZihmPT09XCJ1Y3MyXCJ8fGY9PT1cInVjcy0yXCJ8fGY9PT1cInV0ZjE2bGVcInx8Zj09PVwidXRmLTE2bGVcIil7aWYoZS5sZW5ndGg8Mnx8ci5sZW5ndGg8Mil7cmV0dXJuLTF9aT0yO28vPTI7dS89Mjt0Lz0yfX1mdW5jdGlvbiByZWFkKGUscil7aWYoaT09PTEpe3JldHVybiBlW3JdfWVsc2V7cmV0dXJuIGUucmVhZFVJbnQxNkJFKHIqaSl9fXZhciBhO2lmKG4pe3ZhciBzPS0xO2ZvcihhPXQ7YTxvO2ErKyl7aWYocmVhZChlLGEpPT09cmVhZChyLHM9PT0tMT8wOmEtcykpe2lmKHM9PT0tMSlzPWE7aWYoYS1zKzE9PT11KXJldHVybiBzKml9ZWxzZXtpZihzIT09LTEpYS09YS1zO3M9LTF9fX1lbHNle2lmKHQrdT5vKXQ9by11O2ZvcihhPXQ7YT49MDthLS0pe3ZhciBoPXRydWU7Zm9yKHZhciBjPTA7Yzx1O2MrKyl7aWYocmVhZChlLGErYykhPT1yZWFkKHIsYykpe2g9ZmFsc2U7YnJlYWt9fWlmKGgpcmV0dXJuIGF9fXJldHVybi0xfUJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXM9ZnVuY3Rpb24gaW5jbHVkZXMoZSxyLHQpe3JldHVybiB0aGlzLmluZGV4T2YoZSxyLHQpIT09LTF9O0J1ZmZlci5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbiBpbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCx0cnVlKX07QnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbiBsYXN0SW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsZmFsc2UpfTtmdW5jdGlvbiBoZXhXcml0ZShlLHIsdCxmKXt0PU51bWJlcih0KXx8MDt2YXIgbj1lLmxlbmd0aC10O2lmKCFmKXtmPW59ZWxzZXtmPU51bWJlcihmKTtpZihmPm4pe2Y9bn19dmFyIGk9ci5sZW5ndGg7aWYoZj5pLzIpe2Y9aS8yfWZvcih2YXIgbz0wO288ZjsrK28pe3ZhciB1PXBhcnNlSW50KHIuc3Vic3RyKG8qMiwyKSwxNik7aWYobnVtYmVySXNOYU4odSkpcmV0dXJuIG87ZVt0K29dPXV9cmV0dXJuIG99ZnVuY3Rpb24gdXRmOFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfWZ1bmN0aW9uIGFzY2lpV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiBsYXRpbjFXcml0ZShlLHIsdCxmKXtyZXR1cm4gYXNjaWlXcml0ZShlLHIsdCxmKX1mdW5jdGlvbiBiYXNlNjRXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHIpLGUsdCxmKX1mdW5jdGlvbiB1Y3MyV3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9QnVmZmVyLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbiB3cml0ZShlLHIsdCxmKXtpZihyPT09dW5kZWZpbmVkKXtmPVwidXRmOFwiO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYodD09PXVuZGVmaW5lZCYmdHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZihpc0Zpbml0ZShyKSl7cj1yPj4+MDtpZihpc0Zpbml0ZSh0KSl7dD10Pj4+MDtpZihmPT09dW5kZWZpbmVkKWY9XCJ1dGY4XCJ9ZWxzZXtmPXQ7dD11bmRlZmluZWR9fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIil9dmFyIG49dGhpcy5sZW5ndGgtcjtpZih0PT09dW5kZWZpbmVkfHx0Pm4pdD1uO2lmKGUubGVuZ3RoPjAmJih0PDB8fHI8MCl8fHI+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIil9aWYoIWYpZj1cInV0ZjhcIjt2YXIgaT1mYWxzZTtmb3IoOzspe3N3aXRjaChmKXtjYXNlXCJoZXhcIjpyZXR1cm4gaGV4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBsYXRpbjFXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHVjczJXcml0ZSh0aGlzLGUscix0KTtkZWZhdWx0OmlmKGkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpO2Y9KFwiXCIrZikudG9Mb3dlckNhc2UoKTtpPXRydWV9fX07QnVmZmVyLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24gdG9KU09OKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O2Z1bmN0aW9uIGJhc2U2NFNsaWNlKGUscix0KXtpZihyPT09MCYmdD09PWUubGVuZ3RoKXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUpfWVsc2V7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHIsdCkpfX1mdW5jdGlvbiB1dGY4U2xpY2UoZSxyLHQpe3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7dmFyIGY9W107dmFyIG49cjt3aGlsZShuPHQpe3ZhciBpPWVbbl07dmFyIG89bnVsbDt2YXIgdT1pPjIzOT80Omk+MjIzPzM6aT4xOTE/MjoxO2lmKG4rdTw9dCl7dmFyIGEscyxoLGM7c3dpdGNoKHUpe2Nhc2UgMTppZihpPDEyOCl7bz1pfWJyZWFrO2Nhc2UgMjphPWVbbisxXTtpZigoYSYxOTIpPT09MTI4KXtjPShpJjMxKTw8NnxhJjYzO2lmKGM+MTI3KXtvPWN9fWJyZWFrO2Nhc2UgMzphPWVbbisxXTtzPWVbbisyXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTJ8KGEmNjMpPDw2fHMmNjM7aWYoYz4yMDQ3JiYoYzw1NTI5Nnx8Yz41NzM0Mykpe289Y319YnJlYWs7Y2FzZSA0OmE9ZVtuKzFdO3M9ZVtuKzJdO2g9ZVtuKzNdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgmJihoJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxOHwoYSY2Myk8PDEyfChzJjYzKTw8NnxoJjYzO2lmKGM+NjU1MzUmJmM8MTExNDExMil7bz1jfX19fWlmKG89PT1udWxsKXtvPTY1NTMzO3U9MX1lbHNlIGlmKG8+NjU1MzUpe28tPTY1NTM2O2YucHVzaChvPj4+MTAmMTAyM3w1NTI5Nik7bz01NjMyMHxvJjEwMjN9Zi5wdXNoKG8pO24rPXV9cmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShmKX12YXIgdT00MDk2O2Z1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShlKXt2YXIgcj1lLmxlbmd0aDtpZihyPD11KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZSl9dmFyIHQ9XCJcIjt2YXIgZj0wO3doaWxlKGY8cil7dCs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShmLGYrPXUpKX1yZXR1cm4gdH1mdW5jdGlvbiBhc2NpaVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dJjEyNyl9cmV0dXJuIGZ9ZnVuY3Rpb24gbGF0aW4xU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0pfXJldHVybiBmfWZ1bmN0aW9uIGhleFNsaWNlKGUscix0KXt2YXIgZj1lLmxlbmd0aDtpZighcnx8cjwwKXI9MDtpZighdHx8dDwwfHx0PmYpdD1mO3ZhciBuPVwiXCI7Zm9yKHZhciBpPXI7aTx0OysraSl7bis9c1tlW2ldXX1yZXR1cm4gbn1mdW5jdGlvbiB1dGYxNmxlU2xpY2UoZSxyLHQpe3ZhciBmPWUuc2xpY2Uocix0KTt2YXIgbj1cIlwiO2Zvcih2YXIgaT0wO2k8Zi5sZW5ndGg7aSs9Mil7bis9U3RyaW5nLmZyb21DaGFyQ29kZShmW2ldK2ZbaSsxXSoyNTYpfXJldHVybiBufUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24gc2xpY2UoZSxyKXt2YXIgdD10aGlzLmxlbmd0aDtlPX5+ZTtyPXI9PT11bmRlZmluZWQ/dDp+fnI7aWYoZTwwKXtlKz10O2lmKGU8MCllPTB9ZWxzZSBpZihlPnQpe2U9dH1pZihyPDApe3IrPXQ7aWYocjwwKXI9MH1lbHNlIGlmKHI+dCl7cj10fWlmKHI8ZSlyPWU7dmFyIGY9dGhpcy5zdWJhcnJheShlLHIpO09iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfTtmdW5jdGlvbiBjaGVja09mZnNldChlLHIsdCl7aWYoZSUxIT09MHx8ZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrcj50KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24gcmVhZFVJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uIHJlYWRVSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCl7Y2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKX12YXIgZj10aGlzW2UrLS1yXTt2YXIgbj0xO3doaWxlKHI+MCYmKG4qPTI1Nikpe2YrPXRoaXNbZSstLXJdKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uIHJlYWRVSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24gcmVhZFVJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OH07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24gcmVhZFVJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDw4fHRoaXNbZSsxXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24gcmVhZFVJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybih0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2KSt0aGlzW2UrM10qMTY3NzcyMTZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uIHJlYWRVSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXSoxNjc3NzIxNisodGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdKX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24gcmVhZEludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufW4qPTEyODtpZihmPj1uKWYtPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24gcmVhZEludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj1yO3ZhciBuPTE7dmFyIGk9dGhpc1tlKy0tZl07d2hpbGUoZj4wJiYobio9MjU2KSl7aSs9dGhpc1tlKy0tZl0qbn1uKj0xMjg7aWYoaT49bilpLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24gcmVhZEludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7aWYoISh0aGlzW2VdJjEyOCkpcmV0dXJuIHRoaXNbZV07cmV0dXJuKDI1NS10aGlzW2VdKzEpKi0xfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uIHJlYWRJbnQxNkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uIHJlYWRJbnQxNkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDIsdGhpcy5sZW5ndGgpO3ZhciB0PXRoaXNbZSsxXXx0aGlzW2VdPDw4O3JldHVybiB0JjMyNzY4P3R8NDI5NDkwMTc2MDp0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uIHJlYWRJbnQzMkxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24gcmVhZEludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbiByZWFkRmxvYXRMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uIHJlYWRGbG9hdEJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDIzLDQpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRT1mdW5jdGlvbiByZWFkRG91YmxlTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSw1Miw4KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24gcmVhZERvdWJsZUJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLGZhbHNlLDUyLDgpfTtmdW5jdGlvbiBjaGVja0ludChlLHIsdCxmLG4saSl7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtpZihyPm58fHI8aSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKTtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRT1mdW5jdGlvbiB3cml0ZVVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPTE7dmFyIG89MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsrbzx0JiYoaSo9MjU2KSl7dGhpc1tyK29dPWUvaSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbiB3cml0ZVVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7dD10Pj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQpLTE7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLDApfXZhciBpPXQtMTt2YXIgbz0xO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXt0aGlzW3IraV09ZS9vJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24gd3JpdGVVSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMjU1LDApO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlVUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU9ZnVuY3Rpb24gd3JpdGVVSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3IrM109ZT4+PjI0O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlVUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbiB3cml0ZUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPTA7dmFyIG89MTt2YXIgdT0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytpPHQmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraS0xXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uIHdyaXRlSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9dC0xO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2krMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uIHdyaXRlSW50OChlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDEsMTI3LC0xMjgpO2lmKGU8MCllPTI1NStlKzE7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbiB3cml0ZUludDE2TEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24gd3JpdGVJbnQxNkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlSW50MzJMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrM109ZT4+PjI0O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uIHdyaXRlSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCk7aWYoZTwwKWU9NDI5NDk2NzI5NStlKzE7dGhpc1tyXT1lPj4+MjQ7dGhpc1tyKzFdPWU+Pj4xNjt0aGlzW3IrMl09ZT4+Pjg7dGhpc1tyKzNdPWUmMjU1O3JldHVybiByKzR9O2Z1bmN0aW9uIGNoZWNrSUVFRTc1NChlLHIsdCxmLG4saSl7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiB3cml0ZUZsb2F0KGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsNCwzNDAyODIzNDY2Mzg1Mjg4NmUyMiwtMzQwMjgyMzQ2NjM4NTI4ODZlMjIpfW4ud3JpdGUoZSxyLHQsZiwyMyw0KTtyZXR1cm4gdCs0fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uIHdyaXRlRmxvYXRMRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24gd3JpdGVGbG9hdEJFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscixmYWxzZSx0KX07ZnVuY3Rpb24gd3JpdGVEb3VibGUoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw4LDE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiwtMTc5NzY5MzEzNDg2MjMxNTdlMjkyKX1uLndyaXRlKGUscix0LGYsNTIsOCk7cmV0dXJuIHQrOH1CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24gd3JpdGVEb3VibGVMRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbiB3cml0ZURvdWJsZUJFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsZmFsc2UsdCl9O0J1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbiBjb3B5KGUscix0LGYpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtpZighdCl0PTA7aWYoIWYmJmYhPT0wKWY9dGhpcy5sZW5ndGg7aWYocj49ZS5sZW5ndGgpcj1lLmxlbmd0aDtpZighcilyPTA7aWYoZj4wJiZmPHQpZj10O2lmKGY9PT10KXJldHVybiAwO2lmKGUubGVuZ3RoPT09MHx8dGhpcy5sZW5ndGg9PT0wKXJldHVybiAwO2lmKHI8MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpfWlmKHQ8MHx8dD49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoZjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7aWYoZj50aGlzLmxlbmd0aClmPXRoaXMubGVuZ3RoO2lmKGUubGVuZ3RoLXI8Zi10KXtmPWUubGVuZ3RoLXIrdH12YXIgbj1mLXQ7aWYodGhpcz09PWUmJnR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluPT09XCJmdW5jdGlvblwiKXt0aGlzLmNvcHlXaXRoaW4ocix0LGYpfWVsc2UgaWYodGhpcz09PWUmJnQ8ciYmcjxmKXtmb3IodmFyIGk9bi0xO2k+PTA7LS1pKXtlW2krcl09dGhpc1tpK3RdfX1lbHNle1VpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheSh0LGYpLHIpfXJldHVybiBufTtCdWZmZXIucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24gZmlsbChlLHIsdCxmKXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2lmKHR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3I9MDt0PXRoaXMubGVuZ3RofWVsc2UgaWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD10aGlzLmxlbmd0aH1pZihmIT09dW5kZWZpbmVkJiZ0eXBlb2YgZiE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpfWlmKHR5cGVvZiBmPT09XCJzdHJpbmdcIiYmIUJ1ZmZlci5pc0VuY29kaW5nKGYpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZil9aWYoZS5sZW5ndGg9PT0xKXt2YXIgbj1lLmNoYXJDb2RlQXQoMCk7aWYoZj09PVwidXRmOFwiJiZuPDEyOHx8Zj09PVwibGF0aW4xXCIpe2U9bn19fWVsc2UgaWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtlPWUmMjU1fWVsc2UgaWYodHlwZW9mIGU9PT1cImJvb2xlYW5cIil7ZT1OdW1iZXIoZSl9aWYocjwwfHx0aGlzLmxlbmd0aDxyfHx0aGlzLmxlbmd0aDx0KXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKX1pZih0PD1yKXtyZXR1cm4gdGhpc31yPXI+Pj4wO3Q9dD09PXVuZGVmaW5lZD90aGlzLmxlbmd0aDp0Pj4+MDtpZighZSllPTA7dmFyIGk7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtmb3IoaT1yO2k8dDsrK2kpe3RoaXNbaV09ZX19ZWxzZXt2YXIgbz1CdWZmZXIuaXNCdWZmZXIoZSk/ZTpCdWZmZXIuZnJvbShlLGYpO3ZhciB1PW8ubGVuZ3RoO2lmKHU9PT0wKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpfWZvcihpPTA7aTx0LXI7KytpKXt0aGlzW2krcl09b1tpJXVdfX1yZXR1cm4gdGhpc307dmFyIGE9L1teKy8wLTlBLVphLXotX10vZztmdW5jdGlvbiBiYXNlNjRjbGVhbihlKXtlPWUuc3BsaXQoXCI9XCIpWzBdO2U9ZS50cmltKCkucmVwbGFjZShhLFwiXCIpO2lmKGUubGVuZ3RoPDIpcmV0dXJuXCJcIjt3aGlsZShlLmxlbmd0aCU0IT09MCl7ZT1lK1wiPVwifXJldHVybiBlfWZ1bmN0aW9uIHV0ZjhUb0J5dGVzKGUscil7cj1yfHxJbmZpbml0eTt2YXIgdDt2YXIgZj1lLmxlbmd0aDt2YXIgbj1udWxsO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZjsrK28pe3Q9ZS5jaGFyQ29kZUF0KG8pO2lmKHQ+NTUyOTUmJnQ8NTczNDQpe2lmKCFuKXtpZih0PjU2MzE5KXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1lbHNlIGlmKG8rMT09PWYpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfW49dDtjb250aW51ZX1pZih0PDU2MzIwKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtuPXQ7Y29udGludWV9dD0obi01NTI5Njw8MTB8dC01NjMyMCkrNjU1MzZ9ZWxzZSBpZihuKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KX1uPW51bGw7aWYodDwxMjgpe2lmKChyLT0xKTwwKWJyZWFrO2kucHVzaCh0KX1lbHNlIGlmKHQ8MjA0OCl7aWYoKHItPTIpPDApYnJlYWs7aS5wdXNoKHQ+PjZ8MTkyLHQmNjN8MTI4KX1lbHNlIGlmKHQ8NjU1MzYpe2lmKChyLT0zKTwwKWJyZWFrO2kucHVzaCh0Pj4xMnwyMjQsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2UgaWYodDwxMTE0MTEyKXtpZigoci09NCk8MClicmVhaztpLnB1c2godD4+MTh8MjQwLHQ+PjEyJjYzfDEyOCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIil9fXJldHVybiBpfWZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhlKXt2YXIgcj1bXTtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCl7ci5wdXNoKGUuY2hhckNvZGVBdCh0KSYyNTUpfXJldHVybiByfWZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKGUscil7dmFyIHQsZixuO3ZhciBpPVtdO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXtpZigoci09Mik8MClicmVhazt0PWUuY2hhckNvZGVBdChvKTtmPXQ+Pjg7bj10JTI1NjtpLnB1c2gobik7aS5wdXNoKGYpfXJldHVybiBpfWZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoZSl7cmV0dXJuIGYudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oZSkpfWZ1bmN0aW9uIGJsaXRCdWZmZXIoZSxyLHQsZil7Zm9yKHZhciBuPTA7bjxmOysrbil7aWYobit0Pj1yLmxlbmd0aHx8bj49ZS5sZW5ndGgpYnJlYWs7cltuK3RdPWVbbl19cmV0dXJuIG59ZnVuY3Rpb24gaXNJbnN0YW5jZShlLHIpe3JldHVybiBlIGluc3RhbmNlb2Ygcnx8ZSE9bnVsbCYmZS5jb25zdHJ1Y3RvciE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWU9PT1yLm5hbWV9ZnVuY3Rpb24gbnVtYmVySXNOYU4oZSl7cmV0dXJuIGUhPT1lfXZhciBzPWZ1bmN0aW9uKCl7dmFyIGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCI7dmFyIHI9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciB0PTA7dDwxNjsrK3Qpe3ZhciBmPXQqMTY7Zm9yKHZhciBuPTA7bjwxNjsrK24pe3JbZituXT1lW3RdK2Vbbl19fXJldHVybiByfSgpfSw3ODM6ZnVuY3Rpb24oZSxyKXtcbi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5yLnJlYWQ9ZnVuY3Rpb24oZSxyLHQsZixuKXt2YXIgaSxvO3ZhciB1PW4qOC1mLTE7dmFyIGE9KDE8PHUpLTE7dmFyIHM9YT4+MTt2YXIgaD0tNzt2YXIgYz10P24tMTowO3ZhciBsPXQ/LTE6MTt2YXIgcD1lW3IrY107Yys9bDtpPXAmKDE8PC1oKS0xO3A+Pj0taDtoKz11O2Zvcig7aD4wO2k9aSoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fW89aSYoMTw8LWgpLTE7aT4+PS1oO2grPWY7Zm9yKDtoPjA7bz1vKjI1NitlW3IrY10sYys9bCxoLT04KXt9aWYoaT09PTApe2k9MS1zfWVsc2UgaWYoaT09PWEpe3JldHVybiBvP05hTjoocD8tMToxKSpJbmZpbml0eX1lbHNle289bytNYXRoLnBvdygyLGYpO2k9aS1zfXJldHVybihwPy0xOjEpKm8qTWF0aC5wb3coMixpLWYpfTtyLndyaXRlPWZ1bmN0aW9uKGUscix0LGYsbixpKXt2YXIgbyx1LGE7dmFyIHM9aSo4LW4tMTt2YXIgaD0oMTw8cyktMTt2YXIgYz1oPj4xO3ZhciBsPW49PT0yMz9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjA7dmFyIHA9Zj8wOmktMTt2YXIgeT1mPzE6LTE7dmFyIGc9cjwwfHxyPT09MCYmMS9yPDA/MTowO3I9TWF0aC5hYnMocik7aWYoaXNOYU4ocil8fHI9PT1JbmZpbml0eSl7dT1pc05hTihyKT8xOjA7bz1ofWVsc2V7bz1NYXRoLmZsb29yKE1hdGgubG9nKHIpL01hdGguTE4yKTtpZihyKihhPU1hdGgucG93KDIsLW8pKTwxKXtvLS07YSo9Mn1pZihvK2M+PTEpe3IrPWwvYX1lbHNle3IrPWwqTWF0aC5wb3coMiwxLWMpfWlmKHIqYT49Mil7bysrO2EvPTJ9aWYobytjPj1oKXt1PTA7bz1ofWVsc2UgaWYobytjPj0xKXt1PShyKmEtMSkqTWF0aC5wb3coMixuKTtvPW8rY31lbHNle3U9cipNYXRoLnBvdygyLGMtMSkqTWF0aC5wb3coMixuKTtvPTB9fWZvcig7bj49ODtlW3QrcF09dSYyNTUscCs9eSx1Lz0yNTYsbi09OCl7fW89bzw8bnx1O3MrPW47Zm9yKDtzPjA7ZVt0K3BdPW8mMjU1LHArPXksby89MjU2LHMtPTgpe31lW3QrcC15XXw9ZyoxMjh9fX07dmFyIHI9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgZj1yW3RdO2lmKGYhPT11bmRlZmluZWQpe3JldHVybiBmLmV4cG9ydHN9dmFyIG49clt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7ZVt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgclt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDcyKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/punycode.js/punycode.es6.js":
/*!**************************************************!*\
  !*** ./node_modules/punycode.js/punycode.es6.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   toASCII: function() { return /* binding */ toASCII; },\n/* harmony export */   toUnicode: function() { return /* binding */ toUnicode; },\n/* harmony export */   ucs2decode: function() { return /* binding */ ucs2decode; },\n/* harmony export */   ucs2encode: function() { return /* binding */ ucs2encode; }\n/* harmony export */ });\n\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7F]/; // Note: U+007F DEL is excluded too.\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, callback) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = callback(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {String} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(domain, callback) {\n\tconst parts = domain.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tdomain = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tdomain = domain.replace(regexSeparators, '\\x2E');\n\tconst labels = domain.split('.');\n\tconst encoded = map(labels, callback).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = codePoints => String.fromCodePoint(...codePoints);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint >= 0x30 && codePoint < 0x3A) {\n\t\treturn 26 + (codePoint - 0x30);\n\t}\n\tif (codePoint >= 0x41 && codePoint < 0x5B) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint >= 0x61 && codePoint < 0x7B) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tconst oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\t\t\tif (digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tconst inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tconst basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue === n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.3.1',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (punycode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS5qcy9wdW55Y29kZS5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxxREFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLEtBQUs7QUFDTCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1DQUFtQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qiw2Q0FBNkMscUJBQXFCOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0U7QUFDdEUsK0RBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wdW55Y29kZS5qcy9wdW55Y29kZS5lczYuanM/MDRhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cbmNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgdE1pbiA9IDE7XG5jb25zdCB0TWF4ID0gMjY7XG5jb25zdCBza2V3ID0gMzg7XG5jb25zdCBkYW1wID0gNzAwO1xuY29uc3QgaW5pdGlhbEJpYXMgPSA3MjtcbmNvbnN0IGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG5jb25zdCBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbmNvbnN0IHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xuY29uc3QgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHg3Rl0vOyAvLyBOb3RlOiBVKzAwN0YgREVMIGlzIGV4Y2x1ZGVkIHRvby5cbmNvbnN0IHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5jb25zdCBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5jb25zdCBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgY2FsbGJhY2spIHtcblx0Y29uc3QgcmVzdWx0ID0gW107XG5cdGxldCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gY2FsbGJhY2soYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oZG9tYWluLCBjYWxsYmFjaykge1xuXHRjb25zdCBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnQCcpO1xuXHRsZXQgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0ZG9tYWluID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRkb21haW4gPSBkb21haW4ucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRjb25zdCBsYWJlbHMgPSBkb21haW4uc3BsaXQoJy4nKTtcblx0Y29uc3QgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGNhbGxiYWNrKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0bGV0IGNvdW50ZXIgPSAwO1xuXHRjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdGNvbnN0IHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0Y29uc3QgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbmNvbnN0IHVjczJlbmNvZGUgPSBjb2RlUG9pbnRzID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmNvZGVQb2ludHMpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50ID49IDB4MzAgJiYgY29kZVBvaW50IDwgMHgzQSkge1xuXHRcdHJldHVybiAyNiArIChjb2RlUG9pbnQgLSAweDMwKTtcblx0fVxuXHRpZiAoY29kZVBvaW50ID49IDB4NDEgJiYgY29kZVBvaW50IDwgMHg1Qikge1xuXHRcdHJldHVybiBjb2RlUG9pbnQgLSAweDQxO1xuXHR9XG5cdGlmIChjb2RlUG9pbnQgPj0gMHg2MSAmJiBjb2RlUG9pbnQgPCAweDdCKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbmNvbnN0IGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uKGRpZ2l0LCBmbGFnKSB7XG5cdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGFkYXB0ID0gZnVuY3Rpb24oZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdGxldCBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xuY29uc3QgZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0Ly8gRG9uJ3QgdXNlIFVDUy0yLlxuXHRjb25zdCBvdXRwdXQgPSBbXTtcblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdGxldCBpID0gMDtcblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0bGV0IGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAobGV0IGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yIChsZXQgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdGNvbnN0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSkge1xuXHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdH1cblxuXHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0aSAlPSBvdXQ7XG5cblx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0LlxuXHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLm91dHB1dCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbmNvbnN0IGVuY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXG5cdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIGFuIGFycmF5IG9mIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0Ly8gQ2FjaGUgdGhlIGxlbmd0aC5cblx0Y29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdGxldCBuID0gaW5pdGlhbE47XG5cdGxldCBkZWx0YSA9IDA7XG5cdGxldCBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PT0gbikge1xuXHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0bGV0IHEgPSBkZWx0YTtcblx0XHRcdFx0Zm9yIChsZXQgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0Y29uc3QgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgcU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdGNvbnN0IGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cblx0fVxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cbiAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG4gKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAqIHN0cmluZy5cbiAqL1xuY29uc3QgdG9Vbmljb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbmNvbnN0IHRvQVNDSUkgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5jb25zdCBwdW55Y29kZSA9IHtcblx0LyoqXG5cdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKi9cblx0J3ZlcnNpb24nOiAnMi4zLjEnLFxuXHQvKipcblx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdCd1Y3MyJzoge1xuXHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdH0sXG5cdCdkZWNvZGUnOiBkZWNvZGUsXG5cdCdlbmNvZGUnOiBlbmNvZGUsXG5cdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxufTtcblxuZXhwb3J0IHsgdWNzMmRlY29kZSwgdWNzMmVuY29kZSwgZGVjb2RlLCBlbmNvZGUsIHRvQVNDSUksIHRvVW5pY29kZSB9O1xuZXhwb3J0IGRlZmF1bHQgcHVueWNvZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/punycode.js/punycode.es6.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.js":
/*!*********************!*\
  !*** ./app/page.js ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_MarkdownConverter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/MarkdownConverter */ \"(app-pages-browser)/./components/MarkdownConverter.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                style: {\n                    textAlign: \"center\",\n                    marginBottom: \"20px\"\n                },\n                children: \"MD to DOCX Converter\"\n            }, void 0, false, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/app/page.js\",\n                lineNumber: 9,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MarkdownConverter__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/app/page.js\",\n                lineNumber: 10,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/app/page.js\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, this);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVnQztBQUMrQjtBQUVoRCxTQUFTRTtJQUNwQixxQkFDSSw4REFBQ0M7UUFBS0MsV0FBVTs7MEJBQ1osOERBQUNDO2dCQUFHQyxPQUFPO29CQUFFQyxXQUFXO29CQUFVQyxjQUFjO2dCQUFPOzBCQUFHOzs7Ozs7MEJBQzFELDhEQUFDUCxxRUFBaUJBOzs7Ozs7Ozs7OztBQUc5QjtLQVB3QkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BhZ2UuanM/YmU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBNYXJrZG93bkNvbnZlcnRlciBmcm9tICcuLi9jb21wb25lbnRzL01hcmtkb3duQ29udmVydGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxtYWluIGNsYXNzTmFtZT1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGgxIHN0eWxlPXt7IHRleHRBbGlnbjogJ2NlbnRlcicsIG1hcmdpbkJvdHRvbTogJzIwcHgnIH19Pk1EIHRvIERPQ1ggQ29udmVydGVyPC9oMT5cbiAgICAgICAgICAgIDxNYXJrZG93bkNvbnZlcnRlciAvPlxuICAgICAgICA8L21haW4+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsIk1hcmtkb3duQ29udmVydGVyIiwiSG9tZSIsIm1haW4iLCJjbGFzc05hbWUiLCJoMSIsInN0eWxlIiwidGV4dEFsaWduIiwibWFyZ2luQm90dG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/MarkdownConverter.js":
/*!*****************************************!*\
  !*** ./components/MarkdownConverter.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MarkdownConverter; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mohtasham_md_to_docx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mohtasham/md-to-docx */ \"(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/index.js\");\n/* harmony import */ var markdown_it__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! markdown-it */ \"(app-pages-browser)/./node_modules/markdown-it/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst md = new markdown_it__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n    html: true,\n    linkify: true,\n    typographer: true\n});\nconsole.log(\"MarkdownConverter component loaded\");\nconsole.log(\"convertMarkdownToDocx function:\", typeof _mohtasham_md_to_docx__WEBPACK_IMPORTED_MODULE_2__.convertMarkdownToDocx);\nconsole.log(\"MarkdownIt instance:\", md);\nfunction MarkdownConverter() {\n    _s();\n    console.log(\"MarkdownConverter component rendered\");\n    const [markdownContent, setMarkdownContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [statusType, setStatusType] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        console.log(\"Component mounted, markdownContent:\", markdownContent);\n    }, [\n        markdownContent\n    ]);\n    const handleFileChange = async (e)=>{\n        console.log(\"File input changed:\", e.target.files);\n        const file = e.target.files[0];\n        console.log(\"Selected file:\", file);\n        if (!file) {\n            console.log(\"No file selected\");\n            return;\n        }\n        console.log(\"File type:\", file.type);\n        console.log(\"File name:\", file.name);\n        if (file.type === \"text/markdown\" || file.type === \"text/x-markdown\" || file.name.toLowerCase().endsWith(\".md\") || file.name.toLowerCase().endsWith(\".markdown\")) {\n            console.log(\"Valid markdown file detected, reading content...\");\n            setStatus(\"Reading file...\");\n            setStatusType(\"\");\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                console.log(\"File read successfully, content length:\", e.target.result.length);\n                const content = e.target.result;\n                setMarkdownContent(content);\n                setStatus(\"File loaded successfully\");\n                setStatusType(\"success\");\n                console.log(\"Markdown content set, preview should appear\");\n            };\n            reader.onerror = ()=>{\n                console.error(\"FileReader error\");\n                setStatus(\"Error reading file\");\n                setStatusType(\"error\");\n            };\n            reader.readAsText(file);\n        } else {\n            console.log(\"Invalid file type\");\n            setStatus(\"Please select a valid markdown file (.md or .markdown)\");\n            setStatusType(\"error\");\n        }\n    };\n    const handleConvert = async ()=>{\n        console.log(\"Convert button clicked\");\n        console.log(\"Markdown content length:\", markdownContent === null || markdownContent === void 0 ? void 0 : markdownContent.length);\n        if (!markdownContent) {\n            console.log(\"No markdown content available\");\n            setStatus(\"No markdown content to convert\");\n            setStatusType(\"error\");\n            return;\n        }\n        try {\n            var _fileInputRef_current;\n            console.log(\"Starting conversion...\");\n            setStatus(\"Converting...\");\n            setStatusType(\"\");\n            console.log(\"Calling convertMarkdownToDocx...\");\n            const docxBlob = await (0,_mohtasham_md_to_docx__WEBPACK_IMPORTED_MODULE_2__.convertMarkdownToDocx)(markdownContent);\n            console.log(\"Conversion completed, blob size:\", docxBlob.size);\n            // Create download link\n            const downloadUrl = URL.createObjectURL(docxBlob);\n            console.log(\"Created download URL:\", downloadUrl);\n            const fileName = ((_fileInputRef_current = fileInputRef.current) === null || _fileInputRef_current === void 0 ? void 0 : _fileInputRef_current.files[0]) ? fileInputRef.current.files[0].name.replace(/\\.[^/.]+$/, \"\") + \".docx\" : \"converted.docx\";\n            console.log(\"Download filename:\", fileName);\n            const link = document.createElement(\"a\");\n            link.href = downloadUrl;\n            link.download = fileName;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            URL.revokeObjectURL(downloadUrl);\n            console.log(\"Download initiated successfully\");\n            setStatus(\"Conversion successful! Download started.\");\n            setStatusType(\"success\");\n        } catch (error) {\n            console.error(\"Conversion error:\", error);\n            console.error(\"Error details:\", error.stack);\n            setStatus(\"Conversion failed: \" + error.message);\n            setStatusType(\"error\");\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"preview-section\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"preview-content\",\n                    dangerouslySetInnerHTML: {\n                        __html: markdownContent ? md.render(markdownContent) : '<p style=\"color: #b0b0b0; font-style: italic;\">Select a markdown file to see the preview here...</p>'\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                    lineNumber: 124,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                lineNumber: 122,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"action-section\",\n                style: {\n                    display: \"flex\",\n                    gap: \"10px\",\n                    justifyContent: \"space-between\",\n                    alignItems: \"center\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"file-input-wrapper\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"file\",\n                                id: \"mdFile\",\n                                accept: \".md,.markdown\",\n                                onChange: handleFileChange,\n                                ref: fileInputRef,\n                                style: {\n                                    display: \"none\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                                lineNumber: 134,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                htmlFor: \"mdFile\",\n                                className: \"file-input-label\",\n                                children: \"Choose Markdown File\"\n                            }, void 0, false, {\n                                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                                lineNumber: 142,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                        lineNumber: 133,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        id: \"convertBtn\",\n                        className: \"convert-btn\",\n                        onClick: handleConvert,\n                        disabled: !markdownContent,\n                        children: \"Convert to DOCX\"\n                    }, void 0, false, {\n                        fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                        lineNumber: 147,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                lineNumber: 132,\n                columnNumber: 13\n            }, this),\n            !markdownContent && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"file-hint\",\n                style: {\n                    textAlign: \"center\",\n                    marginTop: \"10px\"\n                },\n                children: \"Select a .md or .markdown file to convert\"\n            }, void 0, false, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                lineNumber: 158,\n                columnNumber: 17\n            }, this),\n            status && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"status-message \".concat(statusType),\n                children: status\n            }, void 0, false, {\n                fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n                lineNumber: 164,\n                columnNumber: 17\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/aleksandar/Desktop/Raboten/md to docx/components/MarkdownConverter.js\",\n        lineNumber: 121,\n        columnNumber: 9\n    }, this);\n}\n_s(MarkdownConverter, \"FDT+HLziD4ZAvyvzwmtWtPXRYOE=\");\n_c = MarkdownConverter;\nvar _c;\n$RefreshReg$(_c, \"MarkdownConverter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFya2Rvd25Db252ZXJ0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFbUQ7QUFDVTtBQUN6QjtBQUVwQyxNQUFNSyxLQUFLLElBQUlELG1EQUFVQSxDQUFDO0lBQ3RCRSxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsYUFBYTtBQUNqQjtBQUVBQyxRQUFRQyxHQUFHLENBQUM7QUFDWkQsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQyxPQUFPUCx3RUFBcUJBO0FBQzNFTSxRQUFRQyxHQUFHLENBQUMsd0JBQXdCTDtBQUVyQixTQUFTTTs7SUFDcEJGLFFBQVFDLEdBQUcsQ0FBQztJQUVaLE1BQU0sQ0FBQ0UsaUJBQWlCQyxtQkFBbUIsR0FBR2IsK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDYyxRQUFRQyxVQUFVLEdBQUdmLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ2dCLFlBQVlDLGNBQWMsR0FBR2pCLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU1rQixlQUFlakIsNkNBQU1BLENBQUM7SUFFNUJDLGdEQUFTQSxDQUFDO1FBQ05PLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUNFO0lBQ3ZELEdBQUc7UUFBQ0E7S0FBZ0I7SUFFcEIsTUFBTU8sbUJBQW1CLE9BQU9DO1FBQzVCWCxRQUFRQyxHQUFHLENBQUMsdUJBQXVCVSxFQUFFQyxNQUFNLENBQUNDLEtBQUs7UUFDakQsTUFBTUMsT0FBT0gsRUFBRUMsTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRTtRQUM5QmIsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQmE7UUFFOUIsSUFBSSxDQUFDQSxNQUFNO1lBQ1BkLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0o7UUFFQUQsUUFBUUMsR0FBRyxDQUFDLGNBQWNhLEtBQUtDLElBQUk7UUFDbkNmLFFBQVFDLEdBQUcsQ0FBQyxjQUFjYSxLQUFLRSxJQUFJO1FBRW5DLElBQUlGLEtBQUtDLElBQUksS0FBSyxtQkFBbUJELEtBQUtDLElBQUksS0FBSyxxQkFDL0NELEtBQUtFLElBQUksQ0FBQ0MsV0FBVyxHQUFHQyxRQUFRLENBQUMsVUFBVUosS0FBS0UsSUFBSSxDQUFDQyxXQUFXLEdBQUdDLFFBQVEsQ0FBQyxjQUFjO1lBRTFGbEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1pLLFVBQVU7WUFDVkUsY0FBYztZQUVkLE1BQU1XLFNBQVMsSUFBSUM7WUFDbkJELE9BQU9FLE1BQU0sR0FBRyxDQUFDVjtnQkFDYlgsUUFBUUMsR0FBRyxDQUFDLDJDQUEyQ1UsRUFBRUMsTUFBTSxDQUFDVSxNQUFNLENBQUNDLE1BQU07Z0JBQzdFLE1BQU1DLFVBQVViLEVBQUVDLE1BQU0sQ0FBQ1UsTUFBTTtnQkFDL0JsQixtQkFBbUJvQjtnQkFDbkJsQixVQUFVO2dCQUNWRSxjQUFjO2dCQUNkUixRQUFRQyxHQUFHLENBQUM7WUFDaEI7WUFDQWtCLE9BQU9NLE9BQU8sR0FBRztnQkFDYnpCLFFBQVEwQixLQUFLLENBQUM7Z0JBQ2RwQixVQUFVO2dCQUNWRSxjQUFjO1lBQ2xCO1lBQ0FXLE9BQU9RLFVBQVUsQ0FBQ2I7UUFDdEIsT0FBTztZQUNIZCxRQUFRQyxHQUFHLENBQUM7WUFDWkssVUFBVTtZQUNWRSxjQUFjO1FBQ2xCO0lBQ0o7SUFFQSxNQUFNb0IsZ0JBQWdCO1FBQ2xCNUIsUUFBUUMsR0FBRyxDQUFDO1FBQ1pELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJFLDRCQUFBQSxzQ0FBQUEsZ0JBQWlCb0IsTUFBTTtRQUUvRCxJQUFJLENBQUNwQixpQkFBaUI7WUFDbEJILFFBQVFDLEdBQUcsQ0FBQztZQUNaSyxVQUFVO1lBQ1ZFLGNBQWM7WUFDZDtRQUNKO1FBRUEsSUFBSTtnQkFhaUJDO1lBWmpCVCxRQUFRQyxHQUFHLENBQUM7WUFDWkssVUFBVTtZQUNWRSxjQUFjO1lBRWRSLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE1BQU00QixXQUFXLE1BQU1uQyw0RUFBcUJBLENBQUNTO1lBQzdDSCxRQUFRQyxHQUFHLENBQUMsb0NBQW9DNEIsU0FBU0MsSUFBSTtZQUU3RCx1QkFBdUI7WUFDdkIsTUFBTUMsY0FBY0MsSUFBSUMsZUFBZSxDQUFDSjtZQUN4QzdCLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUI4QjtZQUVyQyxNQUFNRyxXQUFXekIsRUFBQUEsd0JBQUFBLGFBQWEwQixPQUFPLGNBQXBCMUIsNENBQUFBLHNCQUFzQkksS0FBSyxDQUFDLEVBQUUsSUFDekNKLGFBQWEwQixPQUFPLENBQUN0QixLQUFLLENBQUMsRUFBRSxDQUFDRyxJQUFJLENBQUNvQixPQUFPLENBQUMsYUFBYSxNQUFNLFVBQzlEO1lBQ05wQyxRQUFRQyxHQUFHLENBQUMsc0JBQXNCaUM7WUFFbEMsTUFBTUcsT0FBT0MsU0FBU0MsYUFBYSxDQUFDO1lBQ3BDRixLQUFLRyxJQUFJLEdBQUdUO1lBQ1pNLEtBQUtJLFFBQVEsR0FBR1A7WUFDaEJJLFNBQVNJLElBQUksQ0FBQ0MsV0FBVyxDQUFDTjtZQUMxQkEsS0FBS08sS0FBSztZQUVWTixTQUFTSSxJQUFJLENBQUNHLFdBQVcsQ0FBQ1I7WUFDMUJMLElBQUljLGVBQWUsQ0FBQ2Y7WUFFcEIvQixRQUFRQyxHQUFHLENBQUM7WUFDWkssVUFBVTtZQUNWRSxjQUFjO1FBQ2xCLEVBQUUsT0FBT2tCLE9BQU87WUFDWjFCLFFBQVEwQixLQUFLLENBQUMscUJBQXFCQTtZQUNuQzFCLFFBQVEwQixLQUFLLENBQUMsa0JBQWtCQSxNQUFNcUIsS0FBSztZQUMzQ3pDLFVBQVUsd0JBQXdCb0IsTUFBTXNCLE9BQU87WUFDL0N4QyxjQUFjO1FBQ2xCO0lBRUo7SUFDQSxxQkFDSSw4REFBQ3lDOzswQkFDRyw4REFBQ0E7Z0JBQUlDLFdBQVU7MEJBRVgsNEVBQUNEO29CQUNHQyxXQUFVO29CQUNWQyx5QkFBeUI7d0JBQ3JCQyxRQUFRakQsa0JBQWtCUCxHQUFHeUQsTUFBTSxDQUFDbEQsbUJBQW1CO29CQUMzRDs7Ozs7Ozs7Ozs7MEJBSVIsOERBQUM4QztnQkFBSUMsV0FBVTtnQkFBaUJJLE9BQU87b0JBQUVDLFNBQVM7b0JBQVFDLEtBQUs7b0JBQVFDLGdCQUFnQjtvQkFBaUJDLFlBQVk7Z0JBQVM7O2tDQUN6SCw4REFBQ1Q7d0JBQUlDLFdBQVU7OzBDQUNYLDhEQUFDUztnQ0FDRzVDLE1BQUs7Z0NBQ0w2QyxJQUFHO2dDQUNIQyxRQUFPO2dDQUNQQyxVQUFVcEQ7Z0NBQ1ZxRCxLQUFLdEQ7Z0NBQ0w2QyxPQUFPO29DQUFFQyxTQUFTO2dDQUFPOzs7Ozs7MENBRTdCLDhEQUFDUztnQ0FBTUMsU0FBUTtnQ0FBU2YsV0FBVTswQ0FBbUI7Ozs7Ozs7Ozs7OztrQ0FLekQsOERBQUNnQjt3QkFDR04sSUFBRzt3QkFDSFYsV0FBVTt3QkFDVmlCLFNBQVN2Qzt3QkFDVHdDLFVBQVUsQ0FBQ2pFO2tDQUNkOzs7Ozs7Ozs7Ozs7WUFLSixDQUFDQSxpQ0FDRSw4REFBQ2tFO2dCQUFFbkIsV0FBVTtnQkFBWUksT0FBTztvQkFBRWdCLFdBQVc7b0JBQVVDLFdBQVc7Z0JBQU87MEJBQUc7Ozs7OztZQUsvRWxFLHdCQUNHLDhEQUFDNEM7Z0JBQUlDLFdBQVcsa0JBQTZCLE9BQVgzQzswQkFDN0JGOzs7Ozs7Ozs7Ozs7QUFLckI7R0F6SndCSDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL01hcmtkb3duQ29udmVydGVyLmpzPzU5MzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY29udmVydE1hcmtkb3duVG9Eb2N4IH0gZnJvbSAnQG1vaHRhc2hhbS9tZC10by1kb2N4J1xuaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnXG5cbmNvbnN0IG1kID0gbmV3IE1hcmtkb3duSXQoe1xuICAgIGh0bWw6IHRydWUsXG4gICAgbGlua2lmeTogdHJ1ZSxcbiAgICB0eXBvZ3JhcGhlcjogdHJ1ZVxufSlcblxuY29uc29sZS5sb2coJ01hcmtkb3duQ29udmVydGVyIGNvbXBvbmVudCBsb2FkZWQnKVxuY29uc29sZS5sb2coJ2NvbnZlcnRNYXJrZG93blRvRG9jeCBmdW5jdGlvbjonLCB0eXBlb2YgY29udmVydE1hcmtkb3duVG9Eb2N4KVxuY29uc29sZS5sb2coJ01hcmtkb3duSXQgaW5zdGFuY2U6JywgbWQpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcmtkb3duQ29udmVydGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdNYXJrZG93bkNvbnZlcnRlciBjb21wb25lbnQgcmVuZGVyZWQnKVxuXG4gICAgY29uc3QgW21hcmtkb3duQ29udGVudCwgc2V0TWFya2Rvd25Db250ZW50XSA9IHVzZVN0YXRlKCcnKVxuICAgIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZSgnJylcbiAgICBjb25zdCBbc3RhdHVzVHlwZSwgc2V0U3RhdHVzVHlwZV0gPSB1c2VTdGF0ZSgnJylcbiAgICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWYobnVsbClcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb21wb25lbnQgbW91bnRlZCwgbWFya2Rvd25Db250ZW50OicsIG1hcmtkb3duQ29udGVudClcbiAgICB9LCBbbWFya2Rvd25Db250ZW50XSlcblxuICAgIGNvbnN0IGhhbmRsZUZpbGVDaGFuZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnRmlsZSBpbnB1dCBjaGFuZ2VkOicsIGUudGFyZ2V0LmZpbGVzKVxuICAgICAgICBjb25zdCBmaWxlID0gZS50YXJnZXQuZmlsZXNbMF1cbiAgICAgICAgY29uc29sZS5sb2coJ1NlbGVjdGVkIGZpbGU6JywgZmlsZSlcblxuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdObyBmaWxlIHNlbGVjdGVkJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgdHlwZTonLCBmaWxlLnR5cGUpXG4gICAgICAgIGNvbnNvbGUubG9nKCdGaWxlIG5hbWU6JywgZmlsZS5uYW1lKVxuXG4gICAgICAgIGlmIChmaWxlLnR5cGUgPT09ICd0ZXh0L21hcmtkb3duJyB8fCBmaWxlLnR5cGUgPT09ICd0ZXh0L3gtbWFya2Rvd24nIHx8XG4gICAgICAgICAgICBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLm1kJykgfHwgZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5tYXJrZG93bicpKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdWYWxpZCBtYXJrZG93biBmaWxlIGRldGVjdGVkLCByZWFkaW5nIGNvbnRlbnQuLi4nKVxuICAgICAgICAgICAgc2V0U3RhdHVzKCdSZWFkaW5nIGZpbGUuLi4nKVxuICAgICAgICAgICAgc2V0U3RhdHVzVHlwZSgnJylcblxuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgcmVhZCBzdWNjZXNzZnVsbHksIGNvbnRlbnQgbGVuZ3RoOicsIGUudGFyZ2V0LnJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGUudGFyZ2V0LnJlc3VsdFxuICAgICAgICAgICAgICAgIHNldE1hcmtkb3duQ29udGVudChjb250ZW50KVxuICAgICAgICAgICAgICAgIHNldFN0YXR1cygnRmlsZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXNUeXBlKCdzdWNjZXNzJylcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWFya2Rvd24gY29udGVudCBzZXQsIHByZXZpZXcgc2hvdWxkIGFwcGVhcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGaWxlUmVhZGVyIGVycm9yJylcbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoJ0Vycm9yIHJlYWRpbmcgZmlsZScpXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzVHlwZSgnZXJyb3InKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIGZpbGUgdHlwZScpXG4gICAgICAgICAgICBzZXRTdGF0dXMoJ1BsZWFzZSBzZWxlY3QgYSB2YWxpZCBtYXJrZG93biBmaWxlICgubWQgb3IgLm1hcmtkb3duKScpXG4gICAgICAgICAgICBzZXRTdGF0dXNUeXBlKCdlcnJvcicpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVDb252ZXJ0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnQ29udmVydCBidXR0b24gY2xpY2tlZCcpXG4gICAgICAgIGNvbnNvbGUubG9nKCdNYXJrZG93biBjb250ZW50IGxlbmd0aDonLCBtYXJrZG93bkNvbnRlbnQ/Lmxlbmd0aClcblxuICAgICAgICBpZiAoIW1hcmtkb3duQ29udGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIG1hcmtkb3duIGNvbnRlbnQgYXZhaWxhYmxlJylcbiAgICAgICAgICAgIHNldFN0YXR1cygnTm8gbWFya2Rvd24gY29udGVudCB0byBjb252ZXJ0JylcbiAgICAgICAgICAgIHNldFN0YXR1c1R5cGUoJ2Vycm9yJylcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBjb252ZXJzaW9uLi4uJylcbiAgICAgICAgICAgIHNldFN0YXR1cygnQ29udmVydGluZy4uLicpXG4gICAgICAgICAgICBzZXRTdGF0dXNUeXBlKCcnKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FsbGluZyBjb252ZXJ0TWFya2Rvd25Ub0RvY3guLi4nKVxuICAgICAgICAgICAgY29uc3QgZG9jeEJsb2IgPSBhd2FpdCBjb252ZXJ0TWFya2Rvd25Ub0RvY3gobWFya2Rvd25Db250ZW50KVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnZlcnNpb24gY29tcGxldGVkLCBibG9iIHNpemU6JywgZG9jeEJsb2Iuc2l6ZSlcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGRvd25sb2FkIGxpbmtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkb2N4QmxvYilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIGRvd25sb2FkIFVSTDonLCBkb3dubG9hZFVybClcblxuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlSW5wdXRSZWYuY3VycmVudD8uZmlsZXNbMF1cbiAgICAgICAgICAgICAgICA/IGZpbGVJbnB1dFJlZi5jdXJyZW50LmZpbGVzWzBdLm5hbWUucmVwbGFjZSgvXFwuW14vLl0rJC8sIFwiXCIpICsgJy5kb2N4J1xuICAgICAgICAgICAgICAgIDogJ2NvbnZlcnRlZC5kb2N4J1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIGZpbGVuYW1lOicsIGZpbGVOYW1lKVxuXG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgICAgICBsaW5rLmhyZWYgPSBkb3dubG9hZFVybFxuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspXG4gICAgICAgICAgICBsaW5rLmNsaWNrKClcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKVxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChkb3dubG9hZFVybClcblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Rvd25sb2FkIGluaXRpYXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAgICAgICAgc2V0U3RhdHVzKCdDb252ZXJzaW9uIHN1Y2Nlc3NmdWwhIERvd25sb2FkIHN0YXJ0ZWQuJylcbiAgICAgICAgICAgIHNldFN0YXR1c1R5cGUoJ3N1Y2Nlc3MnKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ29udmVyc2lvbiBlcnJvcjonLCBlcnJvcilcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3Iuc3RhY2spXG4gICAgICAgICAgICBzZXRTdGF0dXMoJ0NvbnZlcnNpb24gZmFpbGVkOiAnICsgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIHNldFN0YXR1c1R5cGUoJ2Vycm9yJylcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByZXZpZXctc2VjdGlvblwiPlxuXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwcmV2aWV3LWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xuICAgICAgICAgICAgICAgICAgICAgICAgX19odG1sOiBtYXJrZG93bkNvbnRlbnQgPyBtZC5yZW5kZXIobWFya2Rvd25Db250ZW50KSA6ICc8cCBzdHlsZT1cImNvbG9yOiAjYjBiMGIwOyBmb250LXN0eWxlOiBpdGFsaWM7XCI+U2VsZWN0IGEgbWFya2Rvd24gZmlsZSB0byBzZWUgdGhlIHByZXZpZXcgaGVyZS4uLjwvcD4nXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjdGlvbi1zZWN0aW9uXCIgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnLCBnYXA6ICcxMHB4JywganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJywgYWxpZ25JdGVtczogJ2NlbnRlcicgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWxlLWlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBpZD1cIm1kRmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9XCIubWQsLm1hcmtkb3duXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtmaWxlSW5wdXRSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBkaXNwbGF5OiAnbm9uZScgfX1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJtZEZpbGVcIiBjbGFzc05hbWU9XCJmaWxlLWlucHV0LWxhYmVsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBDaG9vc2UgTWFya2Rvd24gRmlsZVxuICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBpZD1cImNvbnZlcnRCdG5cIlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb252ZXJ0LWJ0blwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNvbnZlcnR9XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXshbWFya2Rvd25Db250ZW50fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgQ29udmVydCB0byBET0NYXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgeyFtYXJrZG93bkNvbnRlbnQgJiYgKFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZpbGUtaGludFwiIHN0eWxlPXt7IHRleHRBbGlnbjogJ2NlbnRlcicsIG1hcmdpblRvcDogJzEwcHgnIH19PlxuICAgICAgICAgICAgICAgICAgICBTZWxlY3QgYSAubWQgb3IgLm1hcmtkb3duIGZpbGUgdG8gY29udmVydFxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHtzdGF0dXMgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgc3RhdHVzLW1lc3NhZ2UgJHtzdGF0dXNUeXBlfWB9PlxuICAgICAgICAgICAgICAgICAgICB7c3RhdHVzfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUVmZmVjdCIsImNvbnZlcnRNYXJrZG93blRvRG9jeCIsIk1hcmtkb3duSXQiLCJtZCIsImh0bWwiLCJsaW5raWZ5IiwidHlwb2dyYXBoZXIiLCJjb25zb2xlIiwibG9nIiwiTWFya2Rvd25Db252ZXJ0ZXIiLCJtYXJrZG93bkNvbnRlbnQiLCJzZXRNYXJrZG93bkNvbnRlbnQiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJzdGF0dXNUeXBlIiwic2V0U3RhdHVzVHlwZSIsImZpbGVJbnB1dFJlZiIsImhhbmRsZUZpbGVDaGFuZ2UiLCJlIiwidGFyZ2V0IiwiZmlsZXMiLCJmaWxlIiwidHlwZSIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlc3VsdCIsImxlbmd0aCIsImNvbnRlbnQiLCJvbmVycm9yIiwiZXJyb3IiLCJyZWFkQXNUZXh0IiwiaGFuZGxlQ29udmVydCIsImRvY3hCbG9iIiwic2l6ZSIsImRvd25sb2FkVXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiZmlsZU5hbWUiLCJjdXJyZW50IiwicmVwbGFjZSIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJocmVmIiwiZG93bmxvYWQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJjbGljayIsInJlbW92ZUNoaWxkIiwicmV2b2tlT2JqZWN0VVJMIiwic3RhY2siLCJtZXNzYWdlIiwiZGl2IiwiY2xhc3NOYW1lIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJyZW5kZXIiLCJzdHlsZSIsImRpc3BsYXkiLCJnYXAiLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJpbnB1dCIsImlkIiwiYWNjZXB0Iiwib25DaGFuZ2UiLCJyZWYiLCJsYWJlbCIsImh0bWxGb3IiLCJidXR0b24iLCJvbkNsaWNrIiwiZGlzYWJsZWQiLCJwIiwidGV4dEFsaWduIiwibWFyZ2luVG9wIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MarkdownConverter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz82ZGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/ZGY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/helpers.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   collectTables: function() { return /* binding */ collectTables; },\n/* harmony export */   computeImageDimensions: function() { return /* binding */ computeImageDimensions; },\n/* harmony export */   createLinkParagraph: function() { return /* binding */ createLinkParagraph; },\n/* harmony export */   processBlockquote: function() { return /* binding */ processBlockquote; },\n/* harmony export */   processCodeBlock: function() { return /* binding */ processCodeBlock; },\n/* harmony export */   processComment: function() { return /* binding */ processComment; },\n/* harmony export */   processFormattedText: function() { return /* binding */ processFormattedText; },\n/* harmony export */   processHeading: function() { return /* binding */ processHeading; },\n/* harmony export */   processImage: function() { return /* binding */ processImage; },\n/* harmony export */   processInlineCode: function() { return /* binding */ processInlineCode; },\n/* harmony export */   processLink: function() { return /* binding */ processLink; },\n/* harmony export */   processLinkParagraph: function() { return /* binding */ processLinkParagraph; },\n/* harmony export */   processListItem: function() { return /* binding */ processListItem; },\n/* harmony export */   processParagraph: function() { return /* binding */ processParagraph; },\n/* harmony export */   processTable: function() { return /* binding */ processTable; }\n/* harmony export */ });\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docx */ \"(app-pages-browser)/./node_modules/docx/dist/index.mjs\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n// Helper function to sanitize text for use in bookmark IDs\nfunction sanitizeForBookmarkId(text) {\n    // Remove non-alphanumeric characters (except underscores), replace spaces with underscores\n    // Ensure it starts with a letter or underscore\n    let sanitized = text.replace(/[^a-zA-Z0-9_\\s]/g, \"\").replace(/\\s+/g, \"_\");\n    if (!/^[a-zA-Z_]/.test(sanitized)) {\n        sanitized = \"_\" + sanitized;\n    }\n    // Truncate if necessary (Word has limits, though usually generous)\n    return sanitized.substring(0, 40);\n}\n/**\n * Processes a heading line and returns appropriate paragraph formatting and a bookmark ID\n * @param line - The heading line to process\n * @param config - The heading configuration\n * @param style - The style configuration\n * @param documentType - The document type\n * @returns An object containing the processed paragraph and its bookmark ID\n */\nfunction processHeading(line, config, style, documentType) {\n    const headingText = line.replace(new RegExp(`^#{${config.level}} `), \"\");\n    const headingLevel = config.level;\n    // Generate a unique bookmark ID using the clean text (without markdown)\n    const cleanTextForBookmark = headingText\n        .replace(/\\*\\*/g, \"\")\n        .replace(/\\*/g, \"\");\n    const bookmarkId = `_Toc_${sanitizeForBookmarkId(cleanTextForBookmark)}_${Date.now()}`;\n    // Get the appropriate font size based on heading level and custom style\n    let headingSize = style.titleSize;\n    // Use specific heading size if provided, otherwise calculate based on level\n    if (headingLevel === 1 && style.heading1Size) {\n        headingSize = style.heading1Size;\n    }\n    else if (headingLevel === 2 && style.heading2Size) {\n        headingSize = style.heading2Size;\n    }\n    else if (headingLevel === 3 && style.heading3Size) {\n        headingSize = style.heading3Size;\n    }\n    else if (headingLevel === 4 && style.heading4Size) {\n        headingSize = style.heading4Size;\n    }\n    else if (headingLevel === 5 && style.heading5Size) {\n        headingSize = style.heading5Size;\n    }\n    else if (headingLevel > 1) {\n        // Fallback calculation if specific size not provided\n        headingSize = style.titleSize - (headingLevel - 1) * 4;\n    }\n    // Determine alignment based on heading level\n    let alignment;\n    // Check for level-specific alignment first\n    if (headingLevel === 1 && style.heading1Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading1Alignment];\n    }\n    else if (headingLevel === 2 && style.heading2Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading2Alignment];\n    }\n    else if (headingLevel === 3 && style.heading3Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading3Alignment];\n    }\n    else if (headingLevel === 4 && style.heading4Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading4Alignment];\n    }\n    else if (headingLevel === 5 && style.heading5Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading5Alignment];\n    }\n    else if (style.headingAlignment) {\n        // Fallback to general heading alignment if no level-specific alignment\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.headingAlignment];\n    }\n    // Process the heading text to handle markdown formatting (bold/italic)\n    const processedTextRuns = processFormattedTextForHeading(headingText, headingSize, style);\n    // Create the paragraph with bookmark\n    const paragraph = new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Bookmark({\n                id: bookmarkId,\n                children: processedTextRuns,\n            }),\n        ],\n        heading: headingLevel,\n        spacing: {\n            before: config.level === 1 ? style.headingSpacing * 2 : style.headingSpacing,\n            after: style.headingSpacing / 2,\n        },\n        alignment: alignment,\n        style: `Heading${headingLevel}`, // This is crucial for TOC recognition\n        bidirectional: style.direction === \"RTL\",\n    });\n    return { paragraph, bookmarkId };\n}\n/**\n * Processes formatted text specifically for headings (bold/italic) and returns an array of TextRun objects\n * @param text - The text to process\n * @param fontSize - The font size to apply\n * @returns An array of TextRun objects\n */\nfunction processFormattedTextForHeading(text, fontSize, style) {\n    const textRuns = [];\n    let currentText = \"\";\n    let isBold = false;\n    let isItalic = false;\n    // Track unclosed markers to reset at end if needed\n    let boldStart = -1;\n    let italicStart = -1;\n    for (let j = 0; j < text.length; j++) {\n        // Handle escaped characters\n        if (text[j] === \"\\\\\" && j + 1 < text.length) {\n            const nextChar = text[j + 1];\n            if (nextChar === \"*\" || nextChar === \"\\\\\") {\n                currentText += nextChar;\n                j++; // Skip the escaped character\n                continue;\n            }\n            // If not a recognized escape sequence, treat normally\n            currentText += text[j];\n            continue;\n        }\n        // Handle bold with ** markers\n        if (j + 1 < text.length && text[j] === \"*\" && text[j + 1] === \"*\") {\n            // Flush current text before toggling bold\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: fontSize,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle bold state\n            if (!isBold) {\n                boldStart = j;\n            }\n            else {\n                boldStart = -1;\n            }\n            isBold = !isBold;\n            j++; // Skip the second *\n            continue;\n        }\n        // Handle italic with single * marker (but not if it's part of **)\n        if (text[j] === \"*\" &&\n            (j === 0 || text[j - 1] !== \"*\") &&\n            (j === text.length - 1 || text[j + 1] !== \"*\")) {\n            // Flush current text before toggling italic\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: fontSize,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle italic state\n            if (!isItalic) {\n                italicStart = j;\n            }\n            else {\n                italicStart = -1;\n            }\n            isItalic = !isItalic;\n            continue;\n        }\n        // Add to current text\n        currentText += text[j];\n    }\n    // Handle any remaining text\n    if (currentText) {\n        // If we have unclosed markers, treat them as literal text\n        if (isBold && boldStart >= 0) {\n            // Insert the ** back into the text and turn off bold\n            const beforeBold = currentText;\n            currentText = \"**\" + beforeBold;\n            isBold = false;\n        }\n        if (isItalic && italicStart >= 0) {\n            // Insert the * back into the text and turn off italic\n            const beforeItalic = currentText;\n            currentText = \"*\" + beforeItalic;\n            isItalic = false;\n        }\n        // Only add non-empty text runs\n        if (currentText.trim()) {\n            textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: currentText,\n                bold: isBold,\n                italics: isItalic,\n                color: \"000000\",\n                size: fontSize,\n                rightToLeft: style?.direction === \"RTL\",\n            }));\n        }\n    }\n    // If no text runs were created, return a single empty run to avoid empty paragraphs\n    if (textRuns.length === 0) {\n        textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\",\n            color: \"000000\",\n            size: fontSize,\n            bold: true, // Headings are bold by default\n        }));\n    }\n    return textRuns;\n}\n/**\n * Processes a table and returns table formatting\n * @param tableData - The table data\n * @param documentType - The document type\n * @returns The processed table\n */\nfunction processTable(tableData, documentType) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Table({\n        width: { size: 100, type: docx__WEBPACK_IMPORTED_MODULE_0__.WidthType.PERCENTAGE },\n        rows: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TableRow({\n                tableHeader: true,\n                children: tableData.headers.map((header) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableCell({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                            style: \"Strong\",\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: header,\n                                    bold: true,\n                                    color: \"000000\",\n                                }),\n                            ],\n                        }),\n                    ],\n                    shading: {\n                        fill: documentType === \"report\" ? \"DDDDDD\" : \"F2F2F2\",\n                    },\n                })),\n            }),\n            ...tableData.rows.map((row) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableRow({\n                children: row.map((cell) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableCell({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: cell,\n                                    color: \"000000\",\n                                    rightToLeft: false,\n                                }),\n                            ],\n                        }),\n                    ],\n                })),\n            })),\n        ],\n        layout: docx__WEBPACK_IMPORTED_MODULE_0__.TableLayoutType.FIXED,\n        margins: {\n            top: 100,\n            bottom: 100,\n            left: 100,\n            right: 100,\n        },\n    });\n}\n/**\n * Processes a list item and returns appropriate paragraph formatting\n * @param config - The list item configuration\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processListItem(config, style) {\n    let textContent = config.text;\n    // Process the main text with formatting\n    const children = processFormattedText(textContent, style);\n    // If there's bold text on the next line, add it with a line break\n    if (config.boldText) {\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\\n\",\n            size: style.listItemSize || 24,\n        }), new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: config.boldText,\n            bold: true,\n            color: \"000000\",\n            size: style.listItemSize || 24,\n        }));\n    }\n    // Use different formatting for numbered vs bullet lists\n    if (config.isNumbered) {\n        // Use numbering for numbered lists with unique reference per sequence\n        const numberingReference = `numbered-list-${config.sequenceId || 1}`;\n        return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n            children,\n            numbering: {\n                reference: numberingReference,\n                level: 0,\n            },\n            spacing: {\n                before: style.paragraphSpacing / 2,\n                after: style.paragraphSpacing / 2,\n            },\n            bidirectional: style.direction === \"RTL\",\n        });\n    }\n    else {\n        // Use bullet formatting for bullet lists\n        return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n            children,\n            bullet: {\n                level: 0,\n            },\n            spacing: {\n                before: style.paragraphSpacing / 2,\n                after: style.paragraphSpacing / 2,\n            },\n            bidirectional: style.direction === \"RTL\",\n        });\n    }\n}\n/**\n * Processes a blockquote and returns appropriate paragraph formatting\n * @param text - The blockquote text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processBlockquote(text, style) {\n    // Determine alignment for blockquote - only if explicitly set\n    let alignment = undefined;\n    if (style.blockquoteAlignment) {\n        switch (style.blockquoteAlignment) {\n            case \"LEFT\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT;\n                break;\n            case \"CENTER\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER;\n                break;\n            case \"RIGHT\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.RIGHT;\n                break;\n            case \"JUSTIFIED\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.JUSTIFIED;\n                break;\n            default:\n                // Don't set alignment if not explicitly defined\n                alignment = undefined;\n        }\n    }\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: text,\n                italics: true,\n                color: \"000000\",\n                size: style.blockquoteSize || 24, // Use custom blockquote size if provided\n                rightToLeft: style.direction === \"RTL\",\n            }),\n        ],\n        indent: {\n            left: 720, // 0.5 inch indent\n        },\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n        border: {\n            left: {\n                style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE,\n                size: 3,\n                color: \"AAAAAA\",\n            },\n        },\n        alignment: alignment,\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n/**\n * Processes a comment and returns appropriate paragraph formatting\n * @param text - The comment text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processComment(text, style) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: \"Comment: \" + text,\n                italics: true,\n                color: \"666666\",\n            }),\n        ],\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n    });\n}\n/**\n * Processes formatted text (bold/italic/inline-code/links) and returns an array of TextRun or ExternalHyperlink objects\n * @param line - The line to process\n * @param style - The style configuration\n * @returns An array of TextRun or ExternalHyperlink objects\n */\nfunction processFormattedText(line, style) {\n    const textRuns = [];\n    let currentText = \"\";\n    let isBold = false;\n    let isItalic = false;\n    let isInlineCode = false;\n    // Track unclosed markers to reset at end if needed\n    let boldStart = -1;\n    let italicStart = -1;\n    for (let j = 0; j < line.length; j++) {\n        // Handle escaped characters\n        if (line[j] === \"\\\\\" && j + 1 < line.length) {\n            const nextChar = line[j + 1];\n            if (nextChar === \"*\" || nextChar === \"`\" || nextChar === \"\\\\\" || nextChar === \"[\" || nextChar === \"]\") {\n                currentText += nextChar;\n                j++; // Skip the escaped character\n                continue;\n            }\n            // If not a recognized escape sequence, treat normally\n            currentText += line[j];\n            continue;\n        }\n        // Handle inline links [text](url) - only when not in inline code\n        if (!isInlineCode && line[j] === \"[\") {\n            // Look for closing ] and then (url)\n            let closeBracket = -1;\n            let openParen = -1;\n            let closeParen = -1;\n            // Find closing bracket\n            for (let k = j + 1; k < line.length; k++) {\n                if (line[k] === \"\\\\\" && k + 1 < line.length) {\n                    k++; // Skip escaped character\n                    continue;\n                }\n                if (line[k] === \"]\") {\n                    closeBracket = k;\n                    break;\n                }\n            }\n            // If we found closing bracket, look for (url)\n            if (closeBracket > j && closeBracket + 1 < line.length && line[closeBracket + 1] === \"(\") {\n                openParen = closeBracket + 1;\n                // Find closing paren\n                for (let k = openParen + 1; k < line.length; k++) {\n                    if (line[k] === \")\") {\n                        closeParen = k;\n                        break;\n                    }\n                }\n            }\n            // If we found a complete link pattern\n            if (closeBracket > j && openParen > closeBracket && closeParen > openParen) {\n                // Flush current text first\n                if (currentText) {\n                    textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: currentText,\n                        bold: isBold,\n                        italics: isItalic,\n                        color: \"000000\",\n                        size: style?.paragraphSize || 24,\n                        rightToLeft: style?.direction === \"RTL\",\n                    }));\n                    currentText = \"\";\n                }\n                // Extract link text and URL\n                const linkText = line.substring(j + 1, closeBracket);\n                const linkUrl = line.substring(openParen + 1, closeParen);\n                // Create hyperlink\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                            text: linkText,\n                            color: \"0000FF\",\n                            underline: { type: \"single\" },\n                            bold: isBold,\n                            italics: isItalic,\n                            size: style?.paragraphSize || 24,\n                            rightToLeft: style?.direction === \"RTL\",\n                        }),\n                    ],\n                    link: linkUrl,\n                }));\n                // Skip to after the link\n                j = closeParen;\n                continue;\n            }\n        }\n        // Handle inline code with backtick\n        if (line[j] === \"`\" && !isInlineCode) {\n            // Starting inline code - flush current text first\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            isInlineCode = true;\n            continue;\n        }\n        if (line[j] === \"`\" && isInlineCode) {\n            // Ending inline code\n            if (currentText) {\n                textRuns.push(processInlineCode(currentText, style));\n                currentText = \"\";\n            }\n            isInlineCode = false;\n            continue;\n        }\n        // If we're inside inline code, just accumulate text (no formatting)\n        if (isInlineCode) {\n            currentText += line[j];\n            continue;\n        }\n        // Handle bold with ** markers\n        if (j + 1 < line.length && line[j] === \"*\" && line[j + 1] === \"*\") {\n            // Flush current text before toggling bold\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle bold state\n            if (!isBold) {\n                boldStart = j;\n            }\n            else {\n                boldStart = -1;\n            }\n            isBold = !isBold;\n            j++; // Skip the second *\n            continue;\n        }\n        // Handle italic with single * marker (but not if it's part of **)\n        if (line[j] === \"*\" &&\n            (j === 0 || line[j - 1] !== \"*\") &&\n            (j === line.length - 1 || line[j + 1] !== \"*\")) {\n            // Flush current text before toggling italic\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                }));\n                currentText = \"\";\n            }\n            // Toggle italic state\n            if (!isItalic) {\n                italicStart = j;\n            }\n            else {\n                italicStart = -1;\n            }\n            isItalic = !isItalic;\n            continue;\n        }\n        // Add to current text\n        currentText += line[j];\n    }\n    // Handle any remaining text\n    if (currentText) {\n        // If we have unclosed markers, treat them as literal text\n        if (isBold && boldStart >= 0) {\n            // Insert the ** back into the text and turn off bold\n            const beforeBold = currentText;\n            currentText = \"**\" + beforeBold;\n            isBold = false;\n        }\n        if (isItalic && italicStart >= 0) {\n            // Insert the * back into the text and turn off italic\n            const beforeItalic = currentText;\n            currentText = \"*\" + beforeItalic;\n            isItalic = false;\n        }\n        if (isInlineCode) {\n            // Unclosed inline code - treat as literal text\n            currentText = \"`\" + currentText;\n        }\n        // Only add non-empty text runs\n        if (currentText.trim()) {\n            textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: currentText,\n                bold: isBold,\n                italics: isItalic,\n                color: \"000000\",\n                size: style?.paragraphSize || 24,\n                rightToLeft: style?.direction === \"RTL\",\n            }));\n        }\n    }\n    // If no text runs were created, return a single empty run to avoid empty paragraphs\n    if (textRuns.length === 0) {\n        textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\",\n            color: \"000000\",\n            size: style?.paragraphSize || 24,\n        }));\n    }\n    return textRuns;\n}\n/**\n * Collects tables from markdown lines\n * @param lines - The markdown lines\n * @returns An array of table data\n */\nfunction collectTables(lines) {\n    const tables = [];\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (line.trim().startsWith(\"|\")) {\n            // Check for separator row with proper regex\n            if (i + 1 < lines.length &&\n                /^\\s*\\|(?:\\s*:?-+:?\\s*\\|)+\\s*$/.test(lines[i + 1])) {\n                // Preserve empty cells by slicing off leading/trailing pipe and splitting\n                const headers = line\n                    .trim()\n                    .replace(/^\\|/, \"\")\n                    .replace(/\\|$/, \"\")\n                    .split(\"|\")\n                    .map((h) => h.trim());\n                const rows = [];\n                let j = i + 2;\n                while (j < lines.length && lines[j].trim().startsWith(\"|\")) {\n                    const row = lines[j]\n                        .trim()\n                        .replace(/^\\|/, \"\")\n                        .replace(/\\|$/, \"\")\n                        .split(\"|\")\n                        .map((cell) => cell.trim());\n                    rows.push(row);\n                    j++;\n                }\n                tables.push({ headers, rows });\n            }\n        }\n    }\n    return tables;\n}\n/**\n * Processes inline code and returns a TextRun object\n * @param code - The inline code text\n * @param style - The style configuration\n * @returns A TextRun object\n */\nfunction processInlineCode(code, style) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n        text: code,\n        font: \"Courier New\",\n        size: style?.paragraphSize ? style.paragraphSize - 2 : 20,\n        color: \"444444\",\n        shading: {\n            fill: \"F5F5F5\",\n        },\n        rightToLeft: style?.direction === \"RTL\",\n    });\n}\n/**\n * Processes a code block and returns appropriate paragraph formatting\n * @param code - The code block text\n * @param language - The programming language (optional)\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processCodeBlock(code, language, style) {\n    // Split the code into lines and process each line\n    const lines = code.split(\"\\n\");\n    // Create text runs for each line\n    const codeRuns = [];\n    // Add language indicator if present\n    if (language) {\n        codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: language,\n            font: \"Courier New\",\n            size: style.codeBlockSize || 18,\n            color: \"666666\",\n            bold: true,\n            rightToLeft: style.direction === \"RTL\",\n        }), new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\\n\",\n            font: \"Courier New\",\n            size: style.codeBlockSize || 18,\n            break: 1,\n            rightToLeft: style.direction === \"RTL\",\n        }));\n    }\n    // Process each line\n    lines.forEach((line, index) => {\n        // Preserve leading spaces by converting them to non-breaking spaces\n        const leadingSpaces = line.match(/^\\s*/)?.[0].length || 0;\n        const leadingNbsp = \"\\u00A0\".repeat(leadingSpaces);\n        const processedLine = leadingNbsp + line.slice(leadingSpaces);\n        // Add the line\n        codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: processedLine,\n            font: \"Courier New\",\n            size: style.codeBlockSize || 20,\n            color: \"444444\",\n            rightToLeft: style.direction === \"RTL\",\n        }));\n        // Add line break if not the last line\n        if (index < lines.length - 1) {\n            codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: \"\\n\",\n                font: \"Courier New\",\n                size: style.codeBlockSize || 20,\n                break: 1,\n                rightToLeft: style.direction === \"RTL\",\n            }));\n        }\n    });\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: codeRuns,\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n            // Preserve line spacing exactly\n            line: 360,\n            lineRule: \"exact\",\n        },\n        shading: {\n            fill: \"F5F5F5\",\n        },\n        border: {\n            top: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            bottom: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            left: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            right: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n        },\n        // Preserve indentation\n        indent: {\n            left: 360, // 0.25 inch indent for the entire code block\n        },\n    });\n}\n/**\n * Processes a link and returns appropriate text run\n */\nfunction processLink(text, url) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n        text: text,\n        color: \"0000FF\",\n        underline: { type: \"single\" },\n    });\n}\n/**\n * Processes a link and returns a paragraph with hyperlink\n * @param text - The link text\n * @param url - The link URL\n * @param style - The style configuration\n * @returns The processed paragraph with hyperlink\n */\nfunction processLinkParagraph(text, url, style) {\n    const hyperlink = new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: text,\n                color: \"0000FF\",\n                underline: { type: \"single\" },\n                rightToLeft: style.direction === \"RTL\",\n            }),\n        ],\n        link: url,\n    });\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [hyperlink],\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n/**\n * Computes output image dimensions preserving aspect ratio.\n * - If both hints provided, uses them directly.\n * - If one hint provided and intrinsic aspect known, computes the other.\n * - Falls back to intrinsic width capped to 400, or default width 200.\n */\nfunction computeImageDimensions(widthHint, heightHint, intrinsicWidth, intrinsicHeight) {\n    let outWidth;\n    let outHeight;\n    const aspect = intrinsicWidth && intrinsicHeight\n        ? intrinsicWidth / intrinsicHeight\n        : undefined;\n    if (widthHint && heightHint) {\n        outWidth = widthHint;\n        outHeight = heightHint;\n    }\n    else if (widthHint && aspect) {\n        outWidth = widthHint;\n        outHeight = Math.max(1, Math.round(widthHint / aspect));\n    }\n    else if (heightHint && aspect) {\n        outHeight = heightHint;\n        outWidth = Math.max(1, Math.round(heightHint * aspect));\n    }\n    else if (intrinsicWidth) {\n        outWidth = Math.min(intrinsicWidth, 400);\n        if (aspect)\n            outHeight = Math.max(1, Math.round(outWidth / aspect));\n    }\n    else {\n        outWidth = 200;\n    }\n    return { width: outWidth, height: outHeight };\n}\n/**\n * Creates a simple link paragraph\n * @param text - The link text\n * @param url - The URL to link to\n * @returns A paragraph with a hyperlink\n */\nfunction createLinkParagraph(text, url) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: text,\n                        color: \"0000FF\",\n                        underline: { type: \"single\" },\n                    }),\n                ],\n                link: url,\n            }),\n        ],\n    });\n}\n/**\n * Processes an image and returns appropriate paragraph\n * @param altText - The alt text\n * @param imageUrl - The image URL\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nasync function processImage(altText, imageUrl, style) {\n    try {\n        // Support data URLs without fetch and extract raw data/content-type\n        let data;\n        let contentType = \"\";\n        if (/^data:/i.test(imageUrl)) {\n            // data:[<mediatype>][;base64],<data>\n            const match = imageUrl.match(/^data:([^;,]*)(;base64)?,(.*)$/i);\n            if (!match) {\n                throw new Error(\"Invalid data URL for image\");\n            }\n            contentType = match[1] || \"\";\n            const isBase64 = !!match[2];\n            const dataPart = match[3];\n            const binary = isBase64\n                ? typeof Buffer !== \"undefined\"\n                    ? Buffer.from(dataPart, \"base64\")\n                    : Uint8Array.from(atob(dataPart), (c) => c.charCodeAt(0))\n                : typeof Buffer !== \"undefined\"\n                    ? Buffer.from(decodeURIComponent(dataPart))\n                    : new TextEncoder().encode(decodeURIComponent(dataPart));\n            data = binary;\n        }\n        else {\n            const response = await fetch(imageUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);\n            }\n            const arrayBuffer = await response.arrayBuffer();\n            // Use Buffer in Node environments, Uint8Array in browsers\n            data =\n                typeof Buffer !== \"undefined\"\n                    ? Buffer.from(arrayBuffer)\n                    : new Uint8Array(arrayBuffer);\n            // Infer image type from content-type header or URL extension\n            contentType = response.headers.get(\"content-type\") || \"\";\n        }\n        let imageType = \"png\";\n        if (/jpeg|jpg/i.test(contentType) || /\\.(jpe?g)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"jpg\";\n        }\n        else if (/png/i.test(contentType) || /\\.(png)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"png\";\n        }\n        else if (/gif/i.test(contentType) || /\\.(gif)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"gif\";\n        }\n        // Parse optional width/height hints from URL fragment\n        let widthHint;\n        let heightHint;\n        const hashIndex = imageUrl.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            const fragment = imageUrl.substring(hashIndex + 1);\n            // Pattern #<width>x<height>\n            const wxh = fragment.match(/^(\\d+)x(\\d+)$/);\n            if (wxh) {\n                widthHint = parseInt(wxh[1], 10);\n                heightHint = parseInt(wxh[2], 10);\n            }\n            else {\n                // Pattern #w=123&h=45 or #width=..&height=..\n                const params = new URLSearchParams(fragment.replace(/&amp;/g, \"&\"));\n                const w = params.get(\"w\") || params.get(\"width\");\n                const h = params.get(\"h\") || params.get(\"height\");\n                if (w && /^\\d+$/.test(w))\n                    widthHint = parseInt(w, 10);\n                if (h && /^\\d+$/.test(h))\n                    heightHint = parseInt(h, 10);\n            }\n        }\n        // Extract intrinsic dimensions and compute output to preserve aspect ratio\n        function readUint16BE(buf, offset) {\n            return (buf[offset] << 8) | buf[offset + 1];\n        }\n        function readUint32BE(buf, offset) {\n            return (((buf[offset] << 24) |\n                (buf[offset + 1] << 16) |\n                (buf[offset + 2] << 8) |\n                buf[offset + 3]) >>>\n                0);\n        }\n        let intrinsicWidth;\n        let intrinsicHeight;\n        const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n        if (imageType === \"png\" && bytes.length >= 24) {\n            const isPng = bytes[0] === 0x89 &&\n                bytes[1] === 0x50 &&\n                bytes[2] === 0x4e &&\n                bytes[3] === 0x47;\n            if (isPng) {\n                intrinsicWidth = readUint32BE(bytes, 16);\n                intrinsicHeight = readUint32BE(bytes, 20);\n            }\n        }\n        else if (imageType === \"jpg\") {\n            let offset = 2; // skip SOI\n            while (offset + 9 < bytes.length) {\n                if (bytes[offset] !== 0xff)\n                    break;\n                const marker = bytes[offset + 1];\n                const length = readUint16BE(bytes, offset + 2);\n                if (marker === 0xc0 || marker === 0xc2) {\n                    intrinsicHeight = readUint16BE(bytes, offset + 5);\n                    intrinsicWidth = readUint16BE(bytes, offset + 7);\n                    break;\n                }\n                offset += 2 + length;\n            }\n        }\n        else if (imageType === \"gif\" && bytes.length >= 10) {\n            intrinsicWidth = bytes[6] | (bytes[7] << 8);\n            intrinsicHeight = bytes[8] | (bytes[9] << 8);\n        }\n        let outWidth;\n        let outHeight;\n        const aspect = intrinsicWidth && intrinsicHeight\n            ? intrinsicWidth / intrinsicHeight\n            : undefined;\n        if (widthHint && heightHint) {\n            outWidth = widthHint;\n            outHeight = heightHint;\n        }\n        else if (widthHint && aspect) {\n            outWidth = widthHint;\n            outHeight = Math.max(1, Math.round(widthHint / aspect));\n        }\n        else if (heightHint && aspect) {\n            outHeight = heightHint;\n            outWidth = Math.max(1, Math.round(heightHint * aspect));\n        }\n        else if (intrinsicWidth) {\n            outWidth = Math.min(intrinsicWidth, 400);\n            if (aspect)\n                outHeight = Math.max(1, Math.round(outWidth / aspect));\n        }\n        else {\n            outWidth = 200;\n        }\n        // Create a paragraph with just the image, no hyperlink\n        return [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.ImageRun({\n                        data,\n                        transformation: outHeight\n                            ? { width: outWidth, height: outHeight }\n                            : { width: outWidth, height: 1 },\n                        type: imageType,\n                    }),\n                ],\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                spacing: {\n                    before: style.paragraphSpacing,\n                    after: style.paragraphSpacing,\n                },\n            }),\n        ];\n    }\n    catch (error) {\n        console.error(\"Error in processImage:\", error);\n        console.error(\"Error stack:\", error instanceof Error ? error.stack : \"No stack available\");\n        return [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: `[Image could not be displayed: ${altText}]`,\n                        italics: true,\n                        color: \"FF0000\",\n                    }),\n                ],\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n            }),\n        ];\n    }\n}\n/**\n * Processes a paragraph and returns appropriate paragraph formatting\n * @param text - The paragraph text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processParagraph(text, style) {\n    // Use processFormattedText to handle all inline formatting\n    const textRuns = processFormattedText(text, style);\n    // Default alignment uses direct enum value\n    const alignment = style.paragraphAlignment\n        ? style.paragraphAlignment === \"CENTER\"\n            ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER\n            : style.paragraphAlignment === \"RIGHT\"\n                ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.RIGHT\n                : style.paragraphAlignment === \"JUSTIFIED\"\n                    ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.JUSTIFIED\n                    : docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT\n        : docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT;\n    // Only apply indent for justified text\n    const indent = style.paragraphAlignment === \"JUSTIFIED\"\n        ? { left: 0, right: 0 }\n        : undefined;\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: textRuns,\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n            line: style.lineSpacing * 240,\n        },\n        alignment,\n        indent,\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbW9odGFzaGFtL21kLXRvLWRvY3gvZGlzdC9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNLO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvREFBb0QsRUFBRSxlQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDLEdBQUcsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQWE7QUFDakM7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBYTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUFTO0FBQ25DO0FBQ0EsZ0JBQWdCLDBDQUFRO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUNBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseUNBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSx1Q0FBSztBQUNwQixpQkFBaUIsaUJBQWlCLDJDQUFTLGFBQWE7QUFDeEQ7QUFDQSxnQkFBZ0IsMENBQVE7QUFDeEI7QUFDQSxnRUFBZ0UsMkNBQVM7QUFDekU7QUFDQSw0QkFBNEIsMkNBQVM7QUFDckMsdUNBQXVDLCtDQUFhO0FBQ3BEO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLCtDQUErQywwQ0FBUTtBQUN2RCxnREFBZ0QsMkNBQVM7QUFDekQ7QUFDQSw0QkFBNEIsMkNBQVM7QUFDckM7QUFDQSxvQ0FBb0MseUNBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixpREFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBTztBQUNqQztBQUNBO0FBQ0EsU0FBUyxPQUFPLHlDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHVCQUF1QjtBQUMzRSxtQkFBbUIsMkNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQ0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQWE7QUFDekM7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBYTtBQUN6QztBQUNBO0FBQ0EsNEJBQTRCLCtDQUFhO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBUztBQUN4QjtBQUNBLGdCQUFnQix5Q0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1Qiw2Q0FBVztBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLDJDQUFTO0FBQ3hCO0FBQ0EsZ0JBQWdCLHlDQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlDQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQWlCO0FBQ25EO0FBQ0EsNEJBQTRCLHlDQUFPO0FBQ25DO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlDQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUseUNBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU8seUNBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGVBQWUsMkNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixPQUFPLDZDQUFXLG1DQUFtQztBQUN4RSxzQkFBc0IsT0FBTyw2Q0FBVyxtQ0FBbUM7QUFDM0Usb0JBQW9CLE9BQU8sNkNBQVcsbUNBQW1DO0FBQ3pFLHFCQUFxQixPQUFPLDZDQUFXLG1DQUFtQztBQUMxRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSx5Q0FBTztBQUN0QjtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMEJBQTBCLG1EQUFpQjtBQUMzQztBQUNBLGdCQUFnQix5Q0FBTztBQUN2QjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsMkNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLDJDQUFTO0FBQ3hCO0FBQ0EsZ0JBQWdCLG1EQUFpQjtBQUNqQztBQUNBLHdCQUF3Qix5Q0FBTztBQUMvQjtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0Isc0JBQXNCLE1BQU07QUFDNUI7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQixzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCLEVBQUUsb0JBQW9CO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0Isc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQVM7QUFDekI7QUFDQSx3QkFBd0IsMENBQVE7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMkJBQTJCLCtDQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUFTO0FBQ3pCO0FBQ0Esd0JBQXdCLHlDQUFPO0FBQy9CLGdFQUFnRSxRQUFRO0FBQ3hFO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwyQkFBMkIsK0NBQWE7QUFDeEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQWE7QUFDM0I7QUFDQSxrQkFBa0IsK0NBQWE7QUFDL0I7QUFDQSxzQkFBc0IsK0NBQWE7QUFDbkMsc0JBQXNCLCtDQUFhO0FBQ25DLFVBQVUsK0NBQWE7QUFDdkI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGVBQWUsMkNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Btb2h0YXNoYW0vbWQtdG8tZG9jeC9kaXN0L2hlbHBlcnMuanM/ODFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJhZ3JhcGgsIFRleHRSdW4sIFRhYmxlLCBUYWJsZVJvdywgVGFibGVDZWxsLCBBbGlnbm1lbnRUeXBlLCBCb3JkZXJTdHlsZSwgVGFibGVMYXlvdXRUeXBlLCBXaWR0aFR5cGUsIEV4dGVybmFsSHlwZXJsaW5rLCBJbWFnZVJ1biwgQm9va21hcmssIH0gZnJvbSBcImRvY3hcIjtcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzYW5pdGl6ZSB0ZXh0IGZvciB1c2UgaW4gYm9va21hcmsgSURzXG5mdW5jdGlvbiBzYW5pdGl6ZUZvckJvb2ttYXJrSWQodGV4dCkge1xuICAgIC8vIFJlbW92ZSBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgKGV4Y2VwdCB1bmRlcnNjb3JlcyksIHJlcGxhY2Ugc3BhY2VzIHdpdGggdW5kZXJzY29yZXNcbiAgICAvLyBFbnN1cmUgaXQgc3RhcnRzIHdpdGggYSBsZXR0ZXIgb3IgdW5kZXJzY29yZVxuICAgIGxldCBzYW5pdGl6ZWQgPSB0ZXh0LnJlcGxhY2UoL1teYS16QS1aMC05X1xcc10vZywgXCJcIikucmVwbGFjZSgvXFxzKy9nLCBcIl9cIik7XG4gICAgaWYgKCEvXlthLXpBLVpfXS8udGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICAgIHNhbml0aXplZCA9IFwiX1wiICsgc2FuaXRpemVkO1xuICAgIH1cbiAgICAvLyBUcnVuY2F0ZSBpZiBuZWNlc3NhcnkgKFdvcmQgaGFzIGxpbWl0cywgdGhvdWdoIHVzdWFsbHkgZ2VuZXJvdXMpXG4gICAgcmV0dXJuIHNhbml0aXplZC5zdWJzdHJpbmcoMCwgNDApO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBoZWFkaW5nIGxpbmUgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmcgYW5kIGEgYm9va21hcmsgSURcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGhlYWRpbmcgbGluZSB0byBwcm9jZXNzXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGhlYWRpbmcgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBkb2N1bWVudFR5cGUgLSBUaGUgZG9jdW1lbnQgdHlwZVxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGggYW5kIGl0cyBib29rbWFyayBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0hlYWRpbmcobGluZSwgY29uZmlnLCBzdHlsZSwgZG9jdW1lbnRUeXBlKSB7XG4gICAgY29uc3QgaGVhZGluZ1RleHQgPSBsaW5lLnJlcGxhY2UobmV3IFJlZ0V4cChgXiN7JHtjb25maWcubGV2ZWx9fSBgKSwgXCJcIik7XG4gICAgY29uc3QgaGVhZGluZ0xldmVsID0gY29uZmlnLmxldmVsO1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGJvb2ttYXJrIElEIHVzaW5nIHRoZSBjbGVhbiB0ZXh0ICh3aXRob3V0IG1hcmtkb3duKVxuICAgIGNvbnN0IGNsZWFuVGV4dEZvckJvb2ttYXJrID0gaGVhZGluZ1RleHRcbiAgICAgICAgLnJlcGxhY2UoL1xcKlxcKi9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiXCIpO1xuICAgIGNvbnN0IGJvb2ttYXJrSWQgPSBgX1RvY18ke3Nhbml0aXplRm9yQm9va21hcmtJZChjbGVhblRleHRGb3JCb29rbWFyayl9XyR7RGF0ZS5ub3coKX1gO1xuICAgIC8vIEdldCB0aGUgYXBwcm9wcmlhdGUgZm9udCBzaXplIGJhc2VkIG9uIGhlYWRpbmcgbGV2ZWwgYW5kIGN1c3RvbSBzdHlsZVxuICAgIGxldCBoZWFkaW5nU2l6ZSA9IHN0eWxlLnRpdGxlU2l6ZTtcbiAgICAvLyBVc2Ugc3BlY2lmaWMgaGVhZGluZyBzaXplIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY2FsY3VsYXRlIGJhc2VkIG9uIGxldmVsXG4gICAgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMSAmJiBzdHlsZS5oZWFkaW5nMVNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nMVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMiAmJiBzdHlsZS5oZWFkaW5nMlNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nMlNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMyAmJiBzdHlsZS5oZWFkaW5nM1NpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nM1NpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gNCAmJiBzdHlsZS5oZWFkaW5nNFNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nNFNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gNSAmJiBzdHlsZS5oZWFkaW5nNVNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nNVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA+IDEpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgY2FsY3VsYXRpb24gaWYgc3BlY2lmaWMgc2l6ZSBub3QgcHJvdmlkZWRcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS50aXRsZVNpemUgLSAoaGVhZGluZ0xldmVsIC0gMSkgKiA0O1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgYWxpZ25tZW50IGJhc2VkIG9uIGhlYWRpbmcgbGV2ZWxcbiAgICBsZXQgYWxpZ25tZW50O1xuICAgIC8vIENoZWNrIGZvciBsZXZlbC1zcGVjaWZpYyBhbGlnbm1lbnQgZmlyc3RcbiAgICBpZiAoaGVhZGluZ0xldmVsID09PSAxICYmIHN0eWxlLmhlYWRpbmcxQWxpZ25tZW50KSB7XG4gICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGVbc3R5bGUuaGVhZGluZzFBbGlnbm1lbnRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWFkaW5nTGV2ZWwgPT09IDIgJiYgc3R5bGUuaGVhZGluZzJBbGlnbm1lbnQpIHtcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nMkFsaWdubWVudF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMyAmJiBzdHlsZS5oZWFkaW5nM0FsaWdubWVudCkge1xuICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlW3N0eWxlLmhlYWRpbmczQWxpZ25tZW50XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGVhZGluZ0xldmVsID09PSA0ICYmIHN0eWxlLmhlYWRpbmc0QWxpZ25tZW50KSB7XG4gICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGVbc3R5bGUuaGVhZGluZzRBbGlnbm1lbnRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWFkaW5nTGV2ZWwgPT09IDUgJiYgc3R5bGUuaGVhZGluZzVBbGlnbm1lbnQpIHtcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nNUFsaWdubWVudF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0eWxlLmhlYWRpbmdBbGlnbm1lbnQpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZ2VuZXJhbCBoZWFkaW5nIGFsaWdubWVudCBpZiBubyBsZXZlbC1zcGVjaWZpYyBhbGlnbm1lbnRcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nQWxpZ25tZW50XTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyB0aGUgaGVhZGluZyB0ZXh0IHRvIGhhbmRsZSBtYXJrZG93biBmb3JtYXR0aW5nIChib2xkL2l0YWxpYylcbiAgICBjb25zdCBwcm9jZXNzZWRUZXh0UnVucyA9IHByb2Nlc3NGb3JtYXR0ZWRUZXh0Rm9ySGVhZGluZyhoZWFkaW5nVGV4dCwgaGVhZGluZ1NpemUsIHN0eWxlKTtcbiAgICAvLyBDcmVhdGUgdGhlIHBhcmFncmFwaCB3aXRoIGJvb2ttYXJrXG4gICAgY29uc3QgcGFyYWdyYXBoID0gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgQm9va21hcmsoe1xuICAgICAgICAgICAgICAgIGlkOiBib29rbWFya0lkLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBwcm9jZXNzZWRUZXh0UnVucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nTGV2ZWwsXG4gICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgIGJlZm9yZTogY29uZmlnLmxldmVsID09PSAxID8gc3R5bGUuaGVhZGluZ1NwYWNpbmcgKiAyIDogc3R5bGUuaGVhZGluZ1NwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUuaGVhZGluZ1NwYWNpbmcgLyAyLFxuICAgICAgICB9LFxuICAgICAgICBhbGlnbm1lbnQ6IGFsaWdubWVudCxcbiAgICAgICAgc3R5bGU6IGBIZWFkaW5nJHtoZWFkaW5nTGV2ZWx9YCwgLy8gVGhpcyBpcyBjcnVjaWFsIGZvciBUT0MgcmVjb2duaXRpb25cbiAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgIH0pO1xuICAgIHJldHVybiB7IHBhcmFncmFwaCwgYm9va21hcmtJZCB9O1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgZm9ybWF0dGVkIHRleHQgc3BlY2lmaWNhbGx5IGZvciBoZWFkaW5ncyAoYm9sZC9pdGFsaWMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFRleHRSdW4gb2JqZWN0c1xuICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBwcm9jZXNzXG4gKiBAcGFyYW0gZm9udFNpemUgLSBUaGUgZm9udCBzaXplIHRvIGFwcGx5XG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBUZXh0UnVuIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0Zvcm1hdHRlZFRleHRGb3JIZWFkaW5nKHRleHQsIGZvbnRTaXplLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHRSdW5zID0gW107XG4gICAgbGV0IGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICBsZXQgaXNCb2xkID0gZmFsc2U7XG4gICAgbGV0IGlzSXRhbGljID0gZmFsc2U7XG4gICAgLy8gVHJhY2sgdW5jbG9zZWQgbWFya2VycyB0byByZXNldCBhdCBlbmQgaWYgbmVlZGVkXG4gICAgbGV0IGJvbGRTdGFydCA9IC0xO1xuICAgIGxldCBpdGFsaWNTdGFydCA9IC0xO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBIYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICh0ZXh0W2pdID09PSBcIlxcXFxcIiAmJiBqICsgMSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRleHRbaiArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSBcIipcIiB8fCBuZXh0Q2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCArPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgICBqKys7IC8vIFNraXAgdGhlIGVzY2FwZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBub3QgYSByZWNvZ25pemVkIGVzY2FwZSBzZXF1ZW5jZSwgdHJlYXQgbm9ybWFsbHlcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IHRleHRbal07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYm9sZCB3aXRoICoqIG1hcmtlcnNcbiAgICAgICAgaWYgKGogKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dFtqXSA9PT0gXCIqXCIgJiYgdGV4dFtqICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCBjdXJyZW50IHRleHQgYmVmb3JlIHRvZ2dsaW5nIGJvbGRcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGJvbGQgc3RhdGVcbiAgICAgICAgICAgIGlmICghaXNCb2xkKSB7XG4gICAgICAgICAgICAgICAgYm9sZFN0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvbGRTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNCb2xkID0gIWlzQm9sZDtcbiAgICAgICAgICAgIGorKzsgLy8gU2tpcCB0aGUgc2Vjb25kICpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpdGFsaWMgd2l0aCBzaW5nbGUgKiBtYXJrZXIgKGJ1dCBub3QgaWYgaXQncyBwYXJ0IG9mICoqKVxuICAgICAgICBpZiAodGV4dFtqXSA9PT0gXCIqXCIgJiZcbiAgICAgICAgICAgIChqID09PSAwIHx8IHRleHRbaiAtIDFdICE9PSBcIipcIikgJiZcbiAgICAgICAgICAgIChqID09PSB0ZXh0Lmxlbmd0aCAtIDEgfHwgdGV4dFtqICsgMV0gIT09IFwiKlwiKSkge1xuICAgICAgICAgICAgLy8gRmx1c2ggY3VycmVudCB0ZXh0IGJlZm9yZSB0b2dnbGluZyBpdGFsaWNcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGl0YWxpYyBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc0l0YWxpYykge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0l0YWxpYyA9ICFpc0l0YWxpYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IHRleHRcbiAgICAgICAgY3VycmVudFRleHQgKz0gdGV4dFtqXTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFueSByZW1haW5pbmcgdGV4dFxuICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHVuY2xvc2VkIG1hcmtlcnMsIHRyZWF0IHRoZW0gYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgIGlmIChpc0JvbGQgJiYgYm9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgKiogYmFjayBpbnRvIHRoZSB0ZXh0IGFuZCB0dXJuIG9mZiBib2xkXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVCb2xkID0gY3VycmVudFRleHQ7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiKipcIiArIGJlZm9yZUJvbGQ7XG4gICAgICAgICAgICBpc0JvbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGFsaWMgJiYgaXRhbGljU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSAqIGJhY2sgaW50byB0aGUgdGV4dCBhbmQgdHVybiBvZmYgaXRhbGljXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVJdGFsaWMgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCIqXCIgKyBiZWZvcmVJdGFsaWM7XG4gICAgICAgICAgICBpc0l0YWxpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgYWRkIG5vbi1lbXB0eSB0ZXh0IHJ1bnNcbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgdGV4dFJ1bnMucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgIGl0YWxpY3M6IGlzSXRhbGljLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBzdHlsZT8uZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIG5vIHRleHQgcnVucyB3ZXJlIGNyZWF0ZWQsIHJldHVybiBhIHNpbmdsZSBlbXB0eSBydW4gdG8gYXZvaWQgZW1wdHkgcGFyYWdyYXBoc1xuICAgIGlmICh0ZXh0UnVucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGV4dFJ1bnMucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICBzaXplOiBmb250U2l6ZSxcbiAgICAgICAgICAgIGJvbGQ6IHRydWUsIC8vIEhlYWRpbmdzIGFyZSBib2xkIGJ5IGRlZmF1bHRcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dFJ1bnM7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIHRhYmxlIGFuZCByZXR1cm5zIHRhYmxlIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0YWJsZURhdGEgLSBUaGUgdGFibGUgZGF0YVxuICogQHBhcmFtIGRvY3VtZW50VHlwZSAtIFRoZSBkb2N1bWVudCB0eXBlXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHRhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVGFibGUodGFibGVEYXRhLCBkb2N1bWVudFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlKHtcbiAgICAgICAgd2lkdGg6IHsgc2l6ZTogMTAwLCB0eXBlOiBXaWR0aFR5cGUuUEVSQ0VOVEFHRSB9LFxuICAgICAgICByb3dzOiBbXG4gICAgICAgICAgICBuZXcgVGFibGVSb3coe1xuICAgICAgICAgICAgICAgIHRhYmxlSGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0YWJsZURhdGEuaGVhZGVycy5tYXAoKGhlYWRlcikgPT4gbmV3IFRhYmxlQ2VsbCh7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcIlN0cm9uZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBkb2N1bWVudFR5cGUgPT09IFwicmVwb3J0XCIgPyBcIkRERERERFwiIDogXCJGMkYyRjJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC4uLnRhYmxlRGF0YS5yb3dzLm1hcCgocm93KSA9PiBuZXcgVGFibGVSb3coe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByb3cubWFwKChjZWxsKSA9PiBuZXcgVGFibGVDZWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSxcbiAgICAgICAgbGF5b3V0OiBUYWJsZUxheW91dFR5cGUuRklYRUQsXG4gICAgICAgIG1hcmdpbnM6IHtcbiAgICAgICAgICAgIHRvcDogMTAwLFxuICAgICAgICAgICAgYm90dG9tOiAxMDAsXG4gICAgICAgICAgICBsZWZ0OiAxMDAsXG4gICAgICAgICAgICByaWdodDogMTAwLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsaXN0IGl0ZW0gYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgbGlzdCBpdGVtIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xpc3RJdGVtKGNvbmZpZywgc3R5bGUpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSBjb25maWcudGV4dDtcbiAgICAvLyBQcm9jZXNzIHRoZSBtYWluIHRleHQgd2l0aCBmb3JtYXR0aW5nXG4gICAgY29uc3QgY2hpbGRyZW4gPSBwcm9jZXNzRm9ybWF0dGVkVGV4dCh0ZXh0Q29udGVudCwgc3R5bGUpO1xuICAgIC8vIElmIHRoZXJlJ3MgYm9sZCB0ZXh0IG9uIHRoZSBuZXh0IGxpbmUsIGFkZCBpdCB3aXRoIGEgbGluZSBicmVha1xuICAgIGlmIChjb25maWcuYm9sZFRleHQpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBcIlxcblwiLFxuICAgICAgICAgICAgc2l6ZTogc3R5bGUubGlzdEl0ZW1TaXplIHx8IDI0LFxuICAgICAgICB9KSwgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgdGV4dDogY29uZmlnLmJvbGRUZXh0LFxuICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgc2l6ZTogc3R5bGUubGlzdEl0ZW1TaXplIHx8IDI0LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFVzZSBkaWZmZXJlbnQgZm9ybWF0dGluZyBmb3IgbnVtYmVyZWQgdnMgYnVsbGV0IGxpc3RzXG4gICAgaWYgKGNvbmZpZy5pc051bWJlcmVkKSB7XG4gICAgICAgIC8vIFVzZSBudW1iZXJpbmcgZm9yIG51bWJlcmVkIGxpc3RzIHdpdGggdW5pcXVlIHJlZmVyZW5jZSBwZXIgc2VxdWVuY2VcbiAgICAgICAgY29uc3QgbnVtYmVyaW5nUmVmZXJlbmNlID0gYG51bWJlcmVkLWxpc3QtJHtjb25maWcuc2VxdWVuY2VJZCB8fCAxfWA7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgbnVtYmVyaW5nOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBudW1iZXJpbmdSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogc3R5bGUucGFyYWdyYXBoU3BhY2luZyAvIDIsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcgLyAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVc2UgYnVsbGV0IGZvcm1hdHRpbmcgZm9yIGJ1bGxldCBsaXN0c1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGJ1bGxldDoge1xuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcgLyAyLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nIC8gMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgYmxvY2txdW90ZSBhbmQgcmV0dXJucyBhcHByb3ByaWF0ZSBwYXJhZ3JhcGggZm9ybWF0dGluZ1xuICogQHBhcmFtIHRleHQgLSBUaGUgYmxvY2txdW90ZSB0ZXh0XG4gKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgVGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NCbG9ja3F1b3RlKHRleHQsIHN0eWxlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGFsaWdubWVudCBmb3IgYmxvY2txdW90ZSAtIG9ubHkgaWYgZXhwbGljaXRseSBzZXRcbiAgICBsZXQgYWxpZ25tZW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChzdHlsZS5ibG9ja3F1b3RlQWxpZ25tZW50KSB7XG4gICAgICAgIHN3aXRjaCAoc3R5bGUuYmxvY2txdW90ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSBcIkxFRlRcIjpcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLkxFRlQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ0VOVEVSXCI6XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZS5DRU5URVI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUklHSFRcIjpcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLlJJR0hUO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkpVU1RJRklFRFwiOlxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGUuSlVTVElGSUVEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzZXQgYWxpZ25tZW50IGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgaXRhbGljczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS5ibG9ja3F1b3RlU2l6ZSB8fCAyNCwgLy8gVXNlIGN1c3RvbSBibG9ja3F1b3RlIHNpemUgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgbGVmdDogNzIwLCAvLyAwLjUgaW5jaCBpbmRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsXG4gICAgICAgICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJBQUFBQUFcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFsaWdubWVudDogYWxpZ25tZW50LFxuICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgfSk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIGNvbW1lbnQgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIGNvbW1lbnQgdGV4dFxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIFRoZSBwcm9jZXNzZWQgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzQ29tbWVudCh0ZXh0LCBzdHlsZSkge1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIkNvbW1lbnQ6IFwiICsgdGV4dCxcbiAgICAgICAgICAgICAgICBpdGFsaWNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIjY2NjY2NlwiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgIGJlZm9yZTogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgIGFmdGVyOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgZm9ybWF0dGVkIHRleHQgKGJvbGQvaXRhbGljL2lubGluZS1jb2RlL2xpbmtzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBUZXh0UnVuIG9yIEV4dGVybmFsSHlwZXJsaW5rIG9iamVjdHNcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGxpbmUgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFRleHRSdW4gb3IgRXh0ZXJuYWxIeXBlcmxpbmsgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0Zvcm1hdHRlZFRleHQobGluZSwgc3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UnVucyA9IFtdO1xuICAgIGxldCBjdXJyZW50VGV4dCA9IFwiXCI7XG4gICAgbGV0IGlzQm9sZCA9IGZhbHNlO1xuICAgIGxldCBpc0l0YWxpYyA9IGZhbHNlO1xuICAgIGxldCBpc0lubGluZUNvZGUgPSBmYWxzZTtcbiAgICAvLyBUcmFjayB1bmNsb3NlZCBtYXJrZXJzIHRvIHJlc2V0IGF0IGVuZCBpZiBuZWVkZWRcbiAgICBsZXQgYm9sZFN0YXJ0ID0gLTE7XG4gICAgbGV0IGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiXFxcXFwiICYmIGogKyAxIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gbGluZVtqICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IFwiKlwiIHx8IG5leHRDaGFyID09PSBcImBcIiB8fCBuZXh0Q2hhciA9PT0gXCJcXFxcXCIgfHwgbmV4dENoYXIgPT09IFwiW1wiIHx8IG5leHRDaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICAgIGorKzsgLy8gU2tpcCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vdCBhIHJlY29nbml6ZWQgZXNjYXBlIHNlcXVlbmNlLCB0cmVhdCBub3JtYWxseVxuICAgICAgICAgICAgY3VycmVudFRleHQgKz0gbGluZVtqXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpbmxpbmUgbGlua3MgW3RleHRdKHVybCkgLSBvbmx5IHdoZW4gbm90IGluIGlubGluZSBjb2RlXG4gICAgICAgIGlmICghaXNJbmxpbmVDb2RlICYmIGxpbmVbal0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBjbG9zaW5nIF0gYW5kIHRoZW4gKHVybClcbiAgICAgICAgICAgIGxldCBjbG9zZUJyYWNrZXQgPSAtMTtcbiAgICAgICAgICAgIGxldCBvcGVuUGFyZW4gPSAtMTtcbiAgICAgICAgICAgIGxldCBjbG9zZVBhcmVuID0gLTE7XG4gICAgICAgICAgICAvLyBGaW5kIGNsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgZm9yIChsZXQgayA9IGogKyAxOyBrIDwgbGluZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lW2tdID09PSBcIlxcXFxcIiAmJiBrICsgMSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKzsgLy8gU2tpcCBlc2NhcGVkIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVba10gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnJhY2tldCA9IGs7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGNsb3NpbmcgYnJhY2tldCwgbG9vayBmb3IgKHVybClcbiAgICAgICAgICAgIGlmIChjbG9zZUJyYWNrZXQgPiBqICYmIGNsb3NlQnJhY2tldCArIDEgPCBsaW5lLmxlbmd0aCAmJiBsaW5lW2Nsb3NlQnJhY2tldCArIDFdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIG9wZW5QYXJlbiA9IGNsb3NlQnJhY2tldCArIDE7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBjbG9zaW5nIHBhcmVuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IG9wZW5QYXJlbiArIDE7IGsgPCBsaW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lW2tdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VQYXJlbiA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgY29tcGxldGUgbGluayBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoY2xvc2VCcmFja2V0ID4gaiAmJiBvcGVuUGFyZW4gPiBjbG9zZUJyYWNrZXQgJiYgY2xvc2VQYXJlbiA+IG9wZW5QYXJlbikge1xuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGN1cnJlbnQgdGV4dCBmaXJzdFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGN1cnJlbnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlPy5wYXJhZ3JhcGhTaXplIHx8IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGxpbmsgdGV4dCBhbmQgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgbGlua1RleHQgPSBsaW5lLnN1YnN0cmluZyhqICsgMSwgY2xvc2VCcmFja2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rVXJsID0gbGluZS5zdWJzdHJpbmcob3BlblBhcmVuICsgMSwgY2xvc2VQYXJlbik7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGh5cGVybGlua1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IEV4dGVybmFsSHlwZXJsaW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5rVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwRkZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5rOiBsaW5rVXJsLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRvIGFmdGVyIHRoZSBsaW5rXG4gICAgICAgICAgICAgICAgaiA9IGNsb3NlUGFyZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlubGluZSBjb2RlIHdpdGggYmFja3RpY2tcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiYFwiICYmICFpc0lubGluZUNvZGUpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGlubGluZSBjb2RlIC0gZmx1c2ggY3VycmVudCB0ZXh0IGZpcnN0XG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzSW5saW5lQ29kZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVtqXSA9PT0gXCJgXCIgJiYgaXNJbmxpbmVDb2RlKSB7XG4gICAgICAgICAgICAvLyBFbmRpbmcgaW5saW5lIGNvZGVcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gocHJvY2Vzc0lubGluZUNvZGUoY3VycmVudFRleHQsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNJbmxpbmVDb2RlID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgaW5saW5lIGNvZGUsIGp1c3QgYWNjdW11bGF0ZSB0ZXh0IChubyBmb3JtYXR0aW5nKVxuICAgICAgICBpZiAoaXNJbmxpbmVDb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCArPSBsaW5lW2pdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGJvbGQgd2l0aCAqKiBtYXJrZXJzXG4gICAgICAgIGlmIChqICsgMSA8IGxpbmUubGVuZ3RoICYmIGxpbmVbal0gPT09IFwiKlwiICYmIGxpbmVbaiArIDFdID09PSBcIipcIikge1xuICAgICAgICAgICAgLy8gRmx1c2ggY3VycmVudCB0ZXh0IGJlZm9yZSB0b2dnbGluZyBib2xkXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvZ2dsZSBib2xkIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWlzQm9sZCkge1xuICAgICAgICAgICAgICAgIGJvbGRTdGFydCA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2xkU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQm9sZCA9ICFpc0JvbGQ7XG4gICAgICAgICAgICBqKys7IC8vIFNraXAgdGhlIHNlY29uZCAqXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaXRhbGljIHdpdGggc2luZ2xlICogbWFya2VyIChidXQgbm90IGlmIGl0J3MgcGFydCBvZiAqKilcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiKlwiICYmXG4gICAgICAgICAgICAoaiA9PT0gMCB8fCBsaW5lW2ogLSAxXSAhPT0gXCIqXCIpICYmXG4gICAgICAgICAgICAoaiA9PT0gbGluZS5sZW5ndGggLSAxIHx8IGxpbmVbaiArIDFdICE9PSBcIipcIikpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIGN1cnJlbnQgdGV4dCBiZWZvcmUgdG9nZ2xpbmcgaXRhbGljXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGl0YWxpYyBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc0l0YWxpYykge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0l0YWxpYyA9ICFpc0l0YWxpYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IHRleHRcbiAgICAgICAgY3VycmVudFRleHQgKz0gbGluZVtqXTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFueSByZW1haW5pbmcgdGV4dFxuICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHVuY2xvc2VkIG1hcmtlcnMsIHRyZWF0IHRoZW0gYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgIGlmIChpc0JvbGQgJiYgYm9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgKiogYmFjayBpbnRvIHRoZSB0ZXh0IGFuZCB0dXJuIG9mZiBib2xkXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVCb2xkID0gY3VycmVudFRleHQ7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiKipcIiArIGJlZm9yZUJvbGQ7XG4gICAgICAgICAgICBpc0JvbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGFsaWMgJiYgaXRhbGljU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSAqIGJhY2sgaW50byB0aGUgdGV4dCBhbmQgdHVybiBvZmYgaXRhbGljXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVJdGFsaWMgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCIqXCIgKyBiZWZvcmVJdGFsaWM7XG4gICAgICAgICAgICBpc0l0YWxpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lubGluZUNvZGUpIHtcbiAgICAgICAgICAgIC8vIFVuY2xvc2VkIGlubGluZSBjb2RlIC0gdHJlYXQgYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiYFwiICsgY3VycmVudFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhZGQgbm9uLWVtcHR5IHRleHQgcnVuc1xuICAgICAgICBpZiAoY3VycmVudFRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICBib2xkOiBpc0JvbGQsXG4gICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgc2l6ZTogc3R5bGU/LnBhcmFncmFwaFNpemUgfHwgMjQsXG4gICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbm8gdGV4dCBydW5zIHdlcmUgY3JlYXRlZCwgcmV0dXJuIGEgc2luZ2xlIGVtcHR5IHJ1biB0byBhdm9pZCBlbXB0eSBwYXJhZ3JhcGhzXG4gICAgaWYgKHRleHRSdW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgIHNpemU6IHN0eWxlPy5wYXJhZ3JhcGhTaXplIHx8IDI0LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0UnVucztcbn1cbi8qKlxuICogQ29sbGVjdHMgdGFibGVzIGZyb20gbWFya2Rvd24gbGluZXNcbiAqIEBwYXJhbSBsaW5lcyAtIFRoZSBtYXJrZG93biBsaW5lc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGFibGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdFRhYmxlcyhsaW5lcykge1xuICAgIGNvbnN0IHRhYmxlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aChcInxcIikpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBzZXBhcmF0b3Igcm93IHdpdGggcHJvcGVyIHJlZ2V4XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBsaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAvXlxccypcXHwoPzpcXHMqOj8tKzo/XFxzKlxcfCkrXFxzKiQvLnRlc3QobGluZXNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGVtcHR5IGNlbGxzIGJ5IHNsaWNpbmcgb2ZmIGxlYWRpbmcvdHJhaWxpbmcgcGlwZSBhbmQgc3BsaXR0aW5nXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcfC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHwkLywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwifFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChoKSA9PiBoLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSArIDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lcy5sZW5ndGggJiYgbGluZXNbal0udHJpbSgpLnN0YXJ0c1dpdGgoXCJ8XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGxpbmVzW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcfC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx8JC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjZWxsKSA9PiBjZWxsLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlcy5wdXNoKHsgaGVhZGVycywgcm93cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGVzO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgaW5saW5lIGNvZGUgYW5kIHJldHVybnMgYSBUZXh0UnVuIG9iamVjdFxuICogQHBhcmFtIGNvZGUgLSBUaGUgaW5saW5lIGNvZGUgdGV4dFxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEEgVGV4dFJ1biBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbmxpbmVDb2RlKGNvZGUsIHN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgdGV4dDogY29kZSxcbiAgICAgICAgZm9udDogXCJDb3VyaWVyIE5ld1wiLFxuICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSA/IHN0eWxlLnBhcmFncmFwaFNpemUgLSAyIDogMjAsXG4gICAgICAgIGNvbG9yOiBcIjQ0NDQ0NFwiLFxuICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICBmaWxsOiBcIkY1RjVGNVwiLFxuICAgICAgICB9LFxuICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICB9KTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgY29kZSBibG9jayBhbmQgcmV0dXJucyBhcHByb3ByaWF0ZSBwYXJhZ3JhcGggZm9ybWF0dGluZ1xuICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSBibG9jayB0ZXh0XG4gKiBAcGFyYW0gbGFuZ3VhZ2UgLSBUaGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgKG9wdGlvbmFsKVxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIFRoZSBwcm9jZXNzZWQgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzQ29kZUJsb2NrKGNvZGUsIGxhbmd1YWdlLCBzdHlsZSkge1xuICAgIC8vIFNwbGl0IHRoZSBjb2RlIGludG8gbGluZXMgYW5kIHByb2Nlc3MgZWFjaCBsaW5lXG4gICAgY29uc3QgbGluZXMgPSBjb2RlLnNwbGl0KFwiXFxuXCIpO1xuICAgIC8vIENyZWF0ZSB0ZXh0IHJ1bnMgZm9yIGVhY2ggbGluZVxuICAgIGNvbnN0IGNvZGVSdW5zID0gW107XG4gICAgLy8gQWRkIGxhbmd1YWdlIGluZGljYXRvciBpZiBwcmVzZW50XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIGNvZGVSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgdGV4dDogbGFuZ3VhZ2UsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDE4LFxuICAgICAgICAgICAgY29sb3I6IFwiNjY2NjY2XCIsXG4gICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgfSksIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDE4LFxuICAgICAgICAgICAgYnJlYWs6IDEsXG4gICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZWFjaCBsaW5lXG4gICAgbGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gUHJlc2VydmUgbGVhZGluZyBzcGFjZXMgYnkgY29udmVydGluZyB0aGVtIHRvIG5vbi1icmVha2luZyBzcGFjZXNcbiAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlcyA9IGxpbmUubWF0Y2goL15cXHMqLyk/LlswXS5sZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgbGVhZGluZ05ic3AgPSBcIlxcdTAwQTBcIi5yZXBlYXQobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZExpbmUgPSBsZWFkaW5nTmJzcCArIGxpbmUuc2xpY2UobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgIC8vIEFkZCB0aGUgbGluZVxuICAgICAgICBjb2RlUnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IHByb2Nlc3NlZExpbmUsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDIwLFxuICAgICAgICAgICAgY29sb3I6IFwiNDQ0NDQ0XCIsXG4gICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEFkZCBsaW5lIGJyZWFrIGlmIG5vdCB0aGUgbGFzdCBsaW5lXG4gICAgICAgIGlmIChpbmRleCA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvZGVSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgZm9udDogXCJDb3VyaWVyIE5ld1wiLFxuICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLmNvZGVCbG9ja1NpemUgfHwgMjAsXG4gICAgICAgICAgICAgICAgYnJlYWs6IDEsXG4gICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IGNvZGVSdW5zLFxuICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxpbmUgc3BhY2luZyBleGFjdGx5XG4gICAgICAgICAgICBsaW5lOiAzNjAsXG4gICAgICAgICAgICBsaW5lUnVsZTogXCJleGFjdFwiLFxuICAgICAgICB9LFxuICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICBmaWxsOiBcIkY1RjVGNVwiLFxuICAgICAgICB9LFxuICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgIHRvcDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCJERERERERcIiB9LFxuICAgICAgICAgICAgYm90dG9tOiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIkRERERERFwiIH0sXG4gICAgICAgICAgICBsZWZ0OiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIkRERERERFwiIH0sXG4gICAgICAgICAgICByaWdodDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCJERERERERcIiB9LFxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSBpbmRlbnRhdGlvblxuICAgICAgICBpbmRlbnQ6IHtcbiAgICAgICAgICAgIGxlZnQ6IDM2MCwgLy8gMC4yNSBpbmNoIGluZGVudCBmb3IgdGhlIGVudGlyZSBjb2RlIGJsb2NrXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIGxpbmsgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgdGV4dCBydW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NMaW5rKHRleHQsIHVybCkge1xuICAgIHJldHVybiBuZXcgVGV4dFJ1bih7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGNvbG9yOiBcIjAwMDBGRlwiLFxuICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsaW5rIGFuZCByZXR1cm5zIGEgcGFyYWdyYXBoIHdpdGggaHlwZXJsaW5rXG4gKiBAcGFyYW0gdGV4dCAtIFRoZSBsaW5rIHRleHRcbiAqIEBwYXJhbSB1cmwgLSBUaGUgbGluayBVUkxcbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaCB3aXRoIGh5cGVybGlua1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xpbmtQYXJhZ3JhcGgodGV4dCwgdXJsLCBzdHlsZSkge1xuICAgIGNvbnN0IGh5cGVybGluayA9IG5ldyBFeHRlcm5hbEh5cGVybGluayh7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwRkZcIixcbiAgICAgICAgICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICAgICAgbGluazogdXJsLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtoeXBlcmxpbmtdLFxuICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgfSxcbiAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyBvdXRwdXQgaW1hZ2UgZGltZW5zaW9ucyBwcmVzZXJ2aW5nIGFzcGVjdCByYXRpby5cbiAqIC0gSWYgYm90aCBoaW50cyBwcm92aWRlZCwgdXNlcyB0aGVtIGRpcmVjdGx5LlxuICogLSBJZiBvbmUgaGludCBwcm92aWRlZCBhbmQgaW50cmluc2ljIGFzcGVjdCBrbm93biwgY29tcHV0ZXMgdGhlIG90aGVyLlxuICogLSBGYWxscyBiYWNrIHRvIGludHJpbnNpYyB3aWR0aCBjYXBwZWQgdG8gNDAwLCBvciBkZWZhdWx0IHdpZHRoIDIwMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZURpbWVuc2lvbnMod2lkdGhIaW50LCBoZWlnaHRIaW50LCBpbnRyaW5zaWNXaWR0aCwgaW50cmluc2ljSGVpZ2h0KSB7XG4gICAgbGV0IG91dFdpZHRoO1xuICAgIGxldCBvdXRIZWlnaHQ7XG4gICAgY29uc3QgYXNwZWN0ID0gaW50cmluc2ljV2lkdGggJiYgaW50cmluc2ljSGVpZ2h0XG4gICAgICAgID8gaW50cmluc2ljV2lkdGggLyBpbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHdpZHRoSGludCAmJiBoZWlnaHRIaW50KSB7XG4gICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgIH1cbiAgICBlbHNlIGlmICh3aWR0aEhpbnQgJiYgYXNwZWN0KSB7XG4gICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHdpZHRoSGludCAvIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWlnaHRIaW50ICYmIGFzcGVjdCkge1xuICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaGVpZ2h0SGludCAqIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNXaWR0aCkge1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGgubWluKGludHJpbnNpY1dpZHRoLCA0MDApO1xuICAgICAgICBpZiAoYXNwZWN0KVxuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChvdXRXaWR0aCAvIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0V2lkdGggPSAyMDA7XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoOiBvdXRXaWR0aCwgaGVpZ2h0OiBvdXRIZWlnaHQgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNpbXBsZSBsaW5rIHBhcmFncmFwaFxuICogQHBhcmFtIHRleHQgLSBUaGUgbGluayB0ZXh0XG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBsaW5rIHRvXG4gKiBAcmV0dXJucyBBIHBhcmFncmFwaCB3aXRoIGEgaHlwZXJsaW5rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rUGFyYWdyYXBoKHRleHQsIHVybCkge1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEh5cGVybGluayh7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDBGRlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lOiB7IHR5cGU6IFwic2luZ2xlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBsaW5rOiB1cmwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIGFuIGltYWdlIGFuZCByZXR1cm5zIGFwcHJvcHJpYXRlIHBhcmFncmFwaFxuICogQHBhcmFtIGFsdFRleHQgLSBUaGUgYWx0IHRleHRcbiAqIEBwYXJhbSBpbWFnZVVybCAtIFRoZSBpbWFnZSBVUkxcbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlKGFsdFRleHQsIGltYWdlVXJsLCBzdHlsZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZGF0YSBVUkxzIHdpdGhvdXQgZmV0Y2ggYW5kIGV4dHJhY3QgcmF3IGRhdGEvY29udGVudC10eXBlXG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAoL15kYXRhOi9pLnRlc3QoaW1hZ2VVcmwpKSB7XG4gICAgICAgICAgICAvLyBkYXRhOls8bWVkaWF0eXBlPl1bO2Jhc2U2NF0sPGRhdGE+XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGltYWdlVXJsLm1hdGNoKC9eZGF0YTooW147LF0qKSg7YmFzZTY0KT8sKC4qKSQvaSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3IgaW1hZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IG1hdGNoWzFdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBpc0Jhc2U2NCA9ICEhbWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCBkYXRhUGFydCA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gaXNCYXNlNjRcbiAgICAgICAgICAgICAgICA/IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgPyBCdWZmZXIuZnJvbShkYXRhUGFydCwgXCJiYXNlNjRcIilcbiAgICAgICAgICAgICAgICAgICAgOiBVaW50OEFycmF5LmZyb20oYXRvYihkYXRhUGFydCksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgID8gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFQYXJ0KSlcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFQYXJ0KSk7XG4gICAgICAgICAgICBkYXRhID0gYmluYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZVVybCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBVc2UgQnVmZmVyIGluIE5vZGUgZW52aXJvbm1lbnRzLCBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICAgICAgICBkYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgLy8gSW5mZXIgaW1hZ2UgdHlwZSBmcm9tIGNvbnRlbnQtdHlwZSBoZWFkZXIgb3IgVVJMIGV4dGVuc2lvblxuICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbWFnZVR5cGUgPSBcInBuZ1wiO1xuICAgICAgICBpZiAoL2pwZWd8anBnL2kudGVzdChjb250ZW50VHlwZSkgfHwgL1xcLihqcGU/ZykoXFw/fCQpL2kudGVzdChpbWFnZVVybCkpIHtcbiAgICAgICAgICAgIGltYWdlVHlwZSA9IFwianBnXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL3BuZy9pLnRlc3QoY29udGVudFR5cGUpIHx8IC9cXC4ocG5nKShcXD98JCkvaS50ZXN0KGltYWdlVXJsKSkge1xuICAgICAgICAgICAgaW1hZ2VUeXBlID0gXCJwbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvZ2lmL2kudGVzdChjb250ZW50VHlwZSkgfHwgL1xcLihnaWYpKFxcP3wkKS9pLnRlc3QoaW1hZ2VVcmwpKSB7XG4gICAgICAgICAgICBpbWFnZVR5cGUgPSBcImdpZlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIG9wdGlvbmFsIHdpZHRoL2hlaWdodCBoaW50cyBmcm9tIFVSTCBmcmFnbWVudFxuICAgICAgICBsZXQgd2lkdGhIaW50O1xuICAgICAgICBsZXQgaGVpZ2h0SGludDtcbiAgICAgICAgY29uc3QgaGFzaEluZGV4ID0gaW1hZ2VVcmwuaW5kZXhPZihcIiNcIik7XG4gICAgICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpbWFnZVVybC5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuICM8d2lkdGg+eDxoZWlnaHQ+XG4gICAgICAgICAgICBjb25zdCB3eGggPSBmcmFnbWVudC5tYXRjaCgvXihcXGQrKXgoXFxkKykkLyk7XG4gICAgICAgICAgICBpZiAod3hoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGhIaW50ID0gcGFyc2VJbnQod3hoWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SGludCA9IHBhcnNlSW50KHd4aFsyXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVybiAjdz0xMjMmaD00NSBvciAjd2lkdGg9Li4maGVpZ2h0PS4uXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhmcmFnbWVudC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBwYXJhbXMuZ2V0KFwid1wiKSB8fCBwYXJhbXMuZ2V0KFwid2lkdGhcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IHBhcmFtcy5nZXQoXCJoXCIpIHx8IHBhcmFtcy5nZXQoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHcgJiYgL15cXGQrJC8udGVzdCh3KSlcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhIaW50ID0gcGFyc2VJbnQodywgMTApO1xuICAgICAgICAgICAgICAgIGlmIChoICYmIC9eXFxkKyQvLnRlc3QoaCkpXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodEhpbnQgPSBwYXJzZUludChoLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCBpbnRyaW5zaWMgZGltZW5zaW9ucyBhbmQgY29tcHV0ZSBvdXRwdXQgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRVaW50MTZCRShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIChidWZbb2Zmc2V0XSA8PCA4KSB8IGJ1ZltvZmZzZXQgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkVWludDMyQkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKChidWZbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM10pID4+PlxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRyaW5zaWNXaWR0aDtcbiAgICAgICAgbGV0IGludHJpbnNpY0hlaWdodDtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRhdGEgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKGltYWdlVHlwZSA9PT0gXCJwbmdcIiAmJiBieXRlcy5sZW5ndGggPj0gMjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUG5nID0gYnl0ZXNbMF0gPT09IDB4ODkgJiZcbiAgICAgICAgICAgICAgICBieXRlc1sxXSA9PT0gMHg1MCAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzJdID09PSAweDRlICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbM10gPT09IDB4NDc7XG4gICAgICAgICAgICBpZiAoaXNQbmcpIHtcbiAgICAgICAgICAgICAgICBpbnRyaW5zaWNXaWR0aCA9IHJlYWRVaW50MzJCRShieXRlcywgMTYpO1xuICAgICAgICAgICAgICAgIGludHJpbnNpY0hlaWdodCA9IHJlYWRVaW50MzJCRShieXRlcywgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltYWdlVHlwZSA9PT0gXCJqcGdcIikge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDI7IC8vIHNraXAgU09JXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0ICsgOSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1tvZmZzZXRdICE9PSAweGZmKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBieXRlc1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkVWludDE2QkUoYnl0ZXMsIG9mZnNldCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDB4YzAgfHwgbWFya2VyID09PSAweGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpY0hlaWdodCA9IHJlYWRVaW50MTZCRShieXRlcywgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpY1dpZHRoID0gcmVhZFVpbnQxNkJFKGJ5dGVzLCBvZmZzZXQgKyA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyICsgbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltYWdlVHlwZSA9PT0gXCJnaWZcIiAmJiBieXRlcy5sZW5ndGggPj0gMTApIHtcbiAgICAgICAgICAgIGludHJpbnNpY1dpZHRoID0gYnl0ZXNbNl0gfCAoYnl0ZXNbN10gPDwgOCk7XG4gICAgICAgICAgICBpbnRyaW5zaWNIZWlnaHQgPSBieXRlc1s4XSB8IChieXRlc1s5XSA8PCA4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0V2lkdGg7XG4gICAgICAgIGxldCBvdXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGFzcGVjdCA9IGludHJpbnNpY1dpZHRoICYmIGludHJpbnNpY0hlaWdodFxuICAgICAgICAgICAgPyBpbnRyaW5zaWNXaWR0aCAvIGludHJpbnNpY0hlaWdodFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh3aWR0aEhpbnQgJiYgaGVpZ2h0SGludCkge1xuICAgICAgICAgICAgb3V0V2lkdGggPSB3aWR0aEhpbnQ7XG4gICAgICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpZHRoSGludCAmJiBhc3BlY3QpIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZCh3aWR0aEhpbnQgLyBhc3BlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWlnaHRIaW50ICYmIGFzcGVjdCkge1xuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gaGVpZ2h0SGludDtcbiAgICAgICAgICAgIG91dFdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChoZWlnaHRIaW50ICogYXNwZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW50cmluc2ljV2lkdGgpIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gTWF0aC5taW4oaW50cmluc2ljV2lkdGgsIDQwMCk7XG4gICAgICAgICAgICBpZiAoYXNwZWN0KVxuICAgICAgICAgICAgICAgIG91dEhlaWdodCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQob3V0V2lkdGggLyBhc3BlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gMjAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHBhcmFncmFwaCB3aXRoIGp1c3QgdGhlIGltYWdlLCBubyBoeXBlcmxpbmtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbWFnZVJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb246IG91dEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyB3aWR0aDogb3V0V2lkdGgsIGhlaWdodDogb3V0SGVpZ2h0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgd2lkdGg6IG91dFdpZHRoLCBoZWlnaHQ6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGltYWdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gcHJvY2Vzc0ltYWdlOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzdGFjazpcIiwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogXCJObyBzdGFjayBhdmFpbGFibGVcIik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgW0ltYWdlIGNvdWxkIG5vdCBiZSBkaXNwbGF5ZWQ6ICR7YWx0VGV4dH1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0YWxpY3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJGRjAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBwYXJhZ3JhcGggYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIHBhcmFncmFwaCB0ZXh0XG4gKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgVGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NQYXJhZ3JhcGgodGV4dCwgc3R5bGUpIHtcbiAgICAvLyBVc2UgcHJvY2Vzc0Zvcm1hdHRlZFRleHQgdG8gaGFuZGxlIGFsbCBpbmxpbmUgZm9ybWF0dGluZ1xuICAgIGNvbnN0IHRleHRSdW5zID0gcHJvY2Vzc0Zvcm1hdHRlZFRleHQodGV4dCwgc3R5bGUpO1xuICAgIC8vIERlZmF1bHQgYWxpZ25tZW50IHVzZXMgZGlyZWN0IGVudW0gdmFsdWVcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnRcbiAgICAgICAgPyBzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnQgPT09IFwiQ0VOVEVSXCJcbiAgICAgICAgICAgID8gQWxpZ25tZW50VHlwZS5DRU5URVJcbiAgICAgICAgICAgIDogc3R5bGUucGFyYWdyYXBoQWxpZ25tZW50ID09PSBcIlJJR0hUXCJcbiAgICAgICAgICAgICAgICA/IEFsaWdubWVudFR5cGUuUklHSFRcbiAgICAgICAgICAgICAgICA6IHN0eWxlLnBhcmFncmFwaEFsaWdubWVudCA9PT0gXCJKVVNUSUZJRURcIlxuICAgICAgICAgICAgICAgICAgICA/IEFsaWdubWVudFR5cGUuSlVTVElGSUVEXG4gICAgICAgICAgICAgICAgICAgIDogQWxpZ25tZW50VHlwZS5MRUZUXG4gICAgICAgIDogQWxpZ25tZW50VHlwZS5MRUZUO1xuICAgIC8vIE9ubHkgYXBwbHkgaW5kZW50IGZvciBqdXN0aWZpZWQgdGV4dFxuICAgIGNvbnN0IGluZGVudCA9IHN0eWxlLnBhcmFncmFwaEFsaWdubWVudCA9PT0gXCJKVVNUSUZJRURcIlxuICAgICAgICA/IHsgbGVmdDogMCwgcmlnaHQ6IDAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgIGNoaWxkcmVuOiB0ZXh0UnVucyxcbiAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBsaW5lOiBzdHlsZS5saW5lU3BhY2luZyAqIDI0MCxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkdownConversionError: function() { return /* binding */ MarkdownConversionError; },\n/* harmony export */   convertMarkdownToDocx: function() { return /* binding */ convertMarkdownToDocx; },\n/* harmony export */   downloadDocx: function() { return /* binding */ downloadDocx; },\n/* harmony export */   parseToDocxOptions: function() { return /* binding */ parseToDocxOptions; }\n/* harmony export */ });\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docx */ \"(app-pages-browser)/./node_modules/docx/dist/index.mjs\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/types.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js\");\n\n\n\n\nconst defaultStyle = {\n    titleSize: 32,\n    headingSpacing: 240,\n    paragraphSpacing: 240,\n    lineSpacing: 1.15,\n    paragraphAlignment: \"LEFT\",\n    direction: \"LTR\",\n};\nconst defaultOptions = {\n    documentType: \"document\",\n    style: defaultStyle,\n};\n/**\n * Custom error class for markdown conversion errors\n * @extends Error\n * @param message - The error message\n * @param context - The context of the error\n */\nclass MarkdownConversionError extends Error {\n    constructor(message, context) {\n        super(message);\n        this.context = context;\n        this.name = \"MarkdownConversionError\";\n    }\n}\n/**\n * Validates markdown input and options\n * @throws {MarkdownConversionError} If input is invalid\n */\nfunction validateInput(markdown, options) {\n    if (!markdown || typeof markdown !== \"string\") {\n        throw new MarkdownConversionError(\"Invalid markdown input: Markdown must be a non-empty string\");\n    }\n    if (options.style) {\n        const { titleSize, headingSpacing, paragraphSpacing, lineSpacing } = options.style;\n        if (titleSize && (titleSize < 8 || titleSize > 72)) {\n            throw new MarkdownConversionError(\"Invalid title size: Must be between 8 and 72 points\", { titleSize });\n        }\n        if (headingSpacing && (headingSpacing < 0 || headingSpacing > 720)) {\n            throw new MarkdownConversionError(\"Invalid heading spacing: Must be between 0 and 720 twips\", { headingSpacing });\n        }\n        if (paragraphSpacing && (paragraphSpacing < 0 || paragraphSpacing > 720)) {\n            throw new MarkdownConversionError(\"Invalid paragraph spacing: Must be between 0 and 720 twips\", { paragraphSpacing });\n        }\n        if (lineSpacing && (lineSpacing < 1 || lineSpacing > 3)) {\n            throw new MarkdownConversionError(\"Invalid line spacing: Must be between 1 and 3\", { lineSpacing });\n        }\n    }\n}\n/**\n * Convert Markdown to Docx file\n * @param markdown - The Markdown string to convert\n * @param options - The options for the conversion\n * @returns A Promise that resolves to a Blob containing the Docx file\n * @throws {MarkdownConversionError} If conversion fails\n */\nasync function convertMarkdownToDocx(markdown, options = defaultOptions) {\n    try {\n        const docxOptions = await parseToDocxOptions(markdown, options);\n        // Create the document with appropriate settings\n        const doc = new docx__WEBPACK_IMPORTED_MODULE_0__.Document(docxOptions);\n        return await docx__WEBPACK_IMPORTED_MODULE_0__.Packer.toBlob(doc);\n    }\n    catch (error) {\n        if (error instanceof MarkdownConversionError) {\n            throw error;\n        }\n        throw new MarkdownConversionError(`Failed to convert markdown to docx: ${error instanceof Error ? error.message : \"Unknown error\"}`, { originalError: error });\n    }\n}\n/**\n * Convert Markdown to Docx options\n * @param markdown - The Markdown string to convert\n * @param options - The options for the conversion\n * @returns A Promise that resolves to a Blob containing the Docx file\n * @throws {MarkdownConversionError} If conversion fails\n */\nasync function parseToDocxOptions(markdown, options = defaultOptions) {\n    try {\n        // Validate inputs early\n        validateInput(markdown, options);\n        const { style = defaultStyle, documentType = \"document\" } = options;\n        const docChildren = [];\n        const headings = [];\n        const lines = markdown.split(\"\\n\");\n        let inList = false;\n        let listItems = [];\n        let currentListNumber = 1;\n        let isCurrentListNumbered = false;\n        let numberedListSequenceId = 0;\n        let inCodeBlock = false;\n        let codeBlockContent = \"\";\n        let codeBlockLanguage;\n        let tableIndex = 0;\n        const tables = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.collectTables)(lines);\n        for (let i = 0; i < lines.length; i++) {\n            try {\n                const line = lines[i];\n                const trimmedLine = line.trim();\n                // Skip empty lines\n                if (!trimmedLine) {\n                    if (inCodeBlock) {\n                        codeBlockContent += \"\\n\";\n                    }\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({}));\n                    continue;\n                }\n                // Handle Page Break\n                if (trimmedLine === \"\\\\pagebreak\") {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({ children: [new docx__WEBPACK_IMPORTED_MODULE_0__.PageBreak()] }));\n                    continue;\n                }\n                // Handle Markdown Separators (e.g., ---)\n                if (/^\\s*---\\s*$/.test(trimmedLine)) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    // Skip the separator line\n                    continue;\n                }\n                // Handle TOC Placeholder\n                if (trimmedLine === \"[TOC]\") {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    // Create a paragraph and add a unique property to identify it later\n                    const tocPlaceholder = new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({});\n                    tocPlaceholder.__isTocPlaceholder = true; // Add temporary marker property\n                    docChildren.push(tocPlaceholder);\n                    continue;\n                }\n                // Handle code blocks\n                if (trimmedLine.startsWith(\"```\")) {\n                    if (!inCodeBlock) {\n                        // Start of code block\n                        inCodeBlock = true;\n                        codeBlockLanguage = trimmedLine.slice(3).trim() || undefined;\n                        codeBlockContent = \"\";\n                    }\n                    else {\n                        // End of code block\n                        inCodeBlock = false;\n                        docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processCodeBlock)(codeBlockContent.trim(), codeBlockLanguage, style));\n                        codeBlockContent = \"\";\n                        codeBlockLanguage = undefined;\n                    }\n                    continue;\n                }\n                if (inCodeBlock) {\n                    codeBlockContent += (codeBlockContent ? \"\\n\" : \"\") + line;\n                    continue;\n                }\n                // Process headings\n                if (trimmedLine.startsWith(\"#\")) {\n                    const match = trimmedLine.match(/^#+/);\n                    if (match) {\n                        const level = match[0].length;\n                        if (level >= 1 && level <= 5) {\n                            if (inList) {\n                                docChildren.push(...listItems);\n                                listItems = [];\n                                inList = false;\n                            }\n                            const headingText = trimmedLine.substring(level).trim();\n                            const config = {\n                                ..._types_js__WEBPACK_IMPORTED_MODULE_2__.headingConfigs[level],\n                                alignment: _types_js__WEBPACK_IMPORTED_MODULE_2__.headingConfigs[level].alignment || style.headingAlignment,\n                            };\n                            const { paragraph: headingParagraph, bookmarkId } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processHeading)(trimmedLine, config, style, documentType);\n                            headings.push({ text: headingText, level, bookmarkId });\n                            docChildren.push(headingParagraph);\n                            continue;\n                        }\n                        // Graceful degradation for unsupported heading levels\n                        console.warn(`Warning: Heading level ${level} is not supported. Converting to regular paragraph.`);\n                    }\n                }\n                // Handle tables\n                if (trimmedLine.startsWith(\"|\") && trimmedLine.endsWith(\"|\")) {\n                    // Support standard and aligned separator rows (with optional leading/trailing colons)\n                    const separatorRegex = /^\\s*\\|(?:\\s*:?-+:?\\s*\\|)+\\s*$/;\n                    if (i + 1 < lines.length &&\n                        (separatorRegex.test(lines[i + 1]) ||\n                            (i + 2 < lines.length && separatorRegex.test(lines[i + 2])))) {\n                        if (inList) {\n                            docChildren.push(...listItems);\n                            listItems = [];\n                            inList = false;\n                        }\n                        if (tableIndex < tables.length) {\n                            try {\n                                docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processTable)(tables[tableIndex], documentType));\n                                const tableRowCount = 2 + tables[tableIndex].rows.length;\n                                i += tableRowCount - 1;\n                                tableIndex++;\n                                continue;\n                            }\n                            catch (error) {\n                                console.warn(`Warning: Failed to process table at line ${i + 1}. Converting to regular text.`);\n                                // Fallback to regular text\n                                docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                                    children: [\n                                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                            text: trimmedLine.replace(/\\|/g, \"\").trim(),\n                                            color: \"000000\",\n                                        }),\n                                    ],\n                                    bidirectional: style.direction === \"RTL\",\n                                }));\n                                continue;\n                            }\n                        }\n                    }\n                }\n                // Handle lists\n                if (trimmedLine.startsWith(\"- \") || trimmedLine.startsWith(\"* \")) {\n                    // Reset if switching from numbered to bullet list\n                    if (isCurrentListNumbered) {\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    inList = true;\n                    const listText = trimmedLine.replace(/^[-*]\\s+/, \"\").trim();\n                    // Check if there's a bold section on the next line\n                    let boldText = \"\";\n                    if (i + 1 < lines.length &&\n                        lines[i + 1].trim().startsWith(\"**\") &&\n                        lines[i + 1].trim().endsWith(\"**\")) {\n                        boldText = lines[i + 1].trim().slice(2, -2); // Remove ** markers\n                        i++;\n                    }\n                    listItems.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processListItem)({ text: listText, boldText }, style));\n                    continue;\n                }\n                // Handle numbered lists\n                if (/^\\s*\\d+\\.\\s/.test(trimmedLine)) {\n                    // Check if we need to start a new numbered list sequence\n                    if (!isCurrentListNumbered || !inList) {\n                        // Starting a new numbered list sequence\n                        numberedListSequenceId++;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = true;\n                    }\n                    inList = true;\n                    const listText = trimmedLine.replace(/^\\s*\\d+\\.\\s/, \"\").trim();\n                    // Check if there's a bold section on the next line\n                    let boldText = \"\";\n                    if (i + 1 < lines.length &&\n                        lines[i + 1].trim().startsWith(\"**\") &&\n                        lines[i + 1].trim().endsWith(\"**\")) {\n                        boldText = lines[i + 1].trim().slice(2, -2); // Remove ** markers\n                        i++;\n                    }\n                    listItems.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processListItem)({\n                        text: listText,\n                        boldText,\n                        isNumbered: true,\n                        listNumber: currentListNumber,\n                        sequenceId: numberedListSequenceId,\n                    }, style));\n                    currentListNumber++;\n                    continue;\n                }\n                // Handle blockquotes\n                if (trimmedLine.startsWith(\"> \")) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    const quoteText = trimmedLine.replace(/^>\\s*/, \"\").trim();\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processBlockquote)(quoteText, style));\n                    continue;\n                }\n                // Handle comments\n                if (trimmedLine.startsWith(\"COMMENT:\")) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    const commentText = trimmedLine.replace(/^COMMENT:\\s*/, \"\").trim();\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processComment)(commentText, style));\n                    continue;\n                }\n                // Handle images\n                const imageMatch = trimmedLine.match(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/);\n                if (imageMatch) {\n                    const [_, altText, imageUrl] = imageMatch;\n                    // Process images synchronously to ensure they're fully loaded\n                    try {\n                        const imageParagraphs = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processImage)(altText, imageUrl, style);\n                        docChildren.push(...imageParagraphs);\n                    }\n                    catch (error) {\n                        console.error(`Error in image processing: ${error instanceof Error ? error.message : String(error)}`);\n                        docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: `[Image could not be loaded: ${altText}]`,\n                                    italics: true,\n                                    color: \"FF0000\",\n                                }),\n                            ],\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                            bidirectional: style.direction === \"RTL\",\n                        }));\n                    }\n                    continue;\n                }\n                // Handle standalone links (entire line is a single link) - inline links are handled in processParagraph\n                const linkMatch = trimmedLine.match(/^\\[([^\\]]+)\\]\\(([^)]+)\\)$/);\n                if (linkMatch) {\n                    const [_, text, url] = linkMatch;\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processLinkParagraph)(text, url, style));\n                    continue;\n                }\n                // Regular paragraph text with special formatting (use trimmedLine for processing)\n                if (!inList) {\n                    try {\n                        docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processParagraph)(trimmedLine, style));\n                    }\n                    catch (error) {\n                        // Fallback to plain text if formatting fails\n                        console.warn(`Warning: Failed to process text formatting at line ${i + 1}: ${error instanceof Error ? error.message : String(error)}. Using plain text.`);\n                        docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: trimmedLine,\n                                    color: \"000000\",\n                                    size: style.paragraphSize || 24,\n                                }),\n                            ],\n                            spacing: {\n                                before: style.paragraphSpacing,\n                                after: style.paragraphSpacing,\n                                line: style.lineSpacing * 240,\n                            },\n                            alignment: style.paragraphAlignment\n                                ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.paragraphAlignment]\n                                : undefined,\n                        }));\n                    }\n                    continue;\n                }\n                // Removed the fallback 'isContinuation' list item processing as it was causing type errors\n                // and needs a more robust implementation if required.\n            }\n            catch (error) {\n                // Log error and continue with next line\n                console.warn(`Warning: Failed to process line ${i + 1}: ${error instanceof Error ? error.message : \"Unknown error\"}. Skipping line.`);\n                continue;\n            }\n        }\n        // Handle any remaining code block\n        if (inCodeBlock && codeBlockContent) {\n            docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processCodeBlock)(codeBlockContent.trim(), codeBlockLanguage, style));\n        }\n        // Add any remaining list items\n        if (inList && listItems.length > 0) {\n            docChildren.push(...listItems);\n        }\n        // Generate TOC content\n        const tocContent = [];\n        if (headings.length > 0) {\n            // Optional: Add a title for the TOC\n            tocContent.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                text: \"Table of Contents\",\n                heading: \"Heading1\", // Or a specific TOC title style\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                spacing: { after: 240 },\n                bidirectional: style.direction === \"RTL\",\n            }));\n            headings.forEach((heading) => {\n                // Determine font size based on heading level\n                let fontSize;\n                let isBold = false;\n                let isItalic = false;\n                // Apply level-specific styles if provided\n                switch (heading.level) {\n                    case 1:\n                        fontSize = style.tocHeading1FontSize || style.tocFontSize;\n                        isBold =\n                            style.tocHeading1Bold !== undefined\n                                ? style.tocHeading1Bold\n                                : true;\n                        isItalic = style.tocHeading1Italic || false;\n                        break;\n                    case 2:\n                        fontSize = style.tocHeading2FontSize || style.tocFontSize;\n                        isBold =\n                            style.tocHeading2Bold !== undefined\n                                ? style.tocHeading2Bold\n                                : false;\n                        isItalic = style.tocHeading2Italic || false;\n                        break;\n                    case 3:\n                        fontSize = style.tocHeading3FontSize || style.tocFontSize;\n                        isBold = style.tocHeading3Bold || false;\n                        isItalic = style.tocHeading3Italic || false;\n                        break;\n                    case 4:\n                        fontSize = style.tocHeading4FontSize || style.tocFontSize;\n                        isBold = style.tocHeading4Bold || false;\n                        isItalic = style.tocHeading4Italic || false;\n                        break;\n                    case 5:\n                        fontSize = style.tocHeading5FontSize || style.tocFontSize;\n                        isBold = style.tocHeading5Bold || false;\n                        isItalic = style.tocHeading5Italic || false;\n                        break;\n                    default:\n                        fontSize = style.tocFontSize;\n                }\n                // Use default calculation if no specific size provided\n                if (!fontSize) {\n                    fontSize = style.paragraphSize\n                        ? style.paragraphSize - (heading.level - 1) * 2\n                        : 24 - (heading.level - 1) * 2;\n                }\n                tocContent.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.InternalHyperlink({\n                            anchor: heading.bookmarkId,\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: heading.text,\n                                    size: fontSize,\n                                    bold: isBold,\n                                    italics: isItalic,\n                                }),\n                            ],\n                        }),\n                    ],\n                    // Indentation based on heading level\n                    indent: { left: (heading.level - 1) * 400 },\n                    spacing: { after: 120 }, // Spacing between TOC items\n                    bidirectional: style.direction === \"RTL\",\n                }));\n            });\n        }\n        // Replace placeholder with TOC content\n        const finalDocChildren = [];\n        let tocInserted = false;\n        docChildren.forEach((child) => {\n            // Check for the marker property instead of inspecting content\n            if (child.__isTocPlaceholder === true) {\n                if (tocContent.length > 0 && !tocInserted) {\n                    finalDocChildren.push(...tocContent);\n                    tocInserted = true; // Ensure TOC is inserted only once\n                }\n                else {\n                    // If no headings were found or TOC already inserted, remove placeholder\n                    console.warn(\"TOC placeholder found, but no headings collected or TOC already inserted.\");\n                }\n            }\n            else {\n                finalDocChildren.push(child);\n            }\n        });\n        // Create numbering configurations for all numbered list sequences\n        const numberingConfigs = [];\n        for (let i = 1; i <= numberedListSequenceId; i++) {\n            numberingConfigs.push({\n                reference: `numbered-list-${i}`,\n                levels: [\n                    {\n                        level: 0,\n                        format: docx__WEBPACK_IMPORTED_MODULE_0__.LevelFormat.DECIMAL,\n                        text: \"%1.\",\n                        alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT,\n                        style: {\n                            paragraph: {\n                                indent: { left: 720, hanging: 260 },\n                            },\n                        },\n                    },\n                ],\n            });\n        }\n        // Create the document with appropriate settings\n        const docxOptions = {\n            numbering: {\n                config: numberingConfigs,\n            },\n            sections: [\n                {\n                    properties: {\n                        page: {\n                            margin: {\n                                top: 1440,\n                                right: 1080,\n                                bottom: 1440,\n                                left: 1080,\n                            },\n                            size: {\n                                orientation: docx__WEBPACK_IMPORTED_MODULE_0__.PageOrientation.PORTRAIT,\n                            },\n                        },\n                    },\n                    footers: {\n                        default: new docx__WEBPACK_IMPORTED_MODULE_0__.Footer({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                                    alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                                    children: [\n                                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                            children: [docx__WEBPACK_IMPORTED_MODULE_0__.PageNumber.CURRENT],\n                                        }),\n                                    ],\n                                }),\n                            ],\n                        }),\n                    },\n                    children: finalDocChildren,\n                },\n            ],\n            styles: {\n                paragraphStyles: [\n                    {\n                        id: \"Title\",\n                        name: \"Title\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                after: 240,\n                                line: style.lineSpacing * 240,\n                            },\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                        },\n                    },\n                    {\n                        id: \"Heading1\",\n                        name: \"Heading 1\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 360,\n                                after: 240,\n                            },\n                            outlineLevel: 1,\n                        },\n                    },\n                    {\n                        id: \"Heading2\",\n                        name: \"Heading 2\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 4,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 320,\n                                after: 160,\n                            },\n                            outlineLevel: 2,\n                        },\n                    },\n                    {\n                        id: \"Heading3\",\n                        name: \"Heading 3\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 8,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 280,\n                                after: 120,\n                            },\n                            outlineLevel: 3,\n                        },\n                    },\n                    {\n                        id: \"Heading4\",\n                        name: \"Heading 4\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 12,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 240,\n                                after: 120,\n                            },\n                            outlineLevel: 4,\n                        },\n                    },\n                    {\n                        id: \"Heading5\",\n                        name: \"Heading 5\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 16,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 220,\n                                after: 100,\n                            },\n                            outlineLevel: 5,\n                        },\n                    },\n                    {\n                        id: \"Strong\",\n                        name: \"Strong\",\n                        run: {\n                            bold: true,\n                        },\n                    },\n                ],\n            },\n        };\n        return docxOptions;\n    }\n    catch (error) {\n        if (error instanceof MarkdownConversionError) {\n            throw error;\n        }\n        throw new MarkdownConversionError(`Failed to convert markdown to docx: ${error instanceof Error ? error.message : \"Unknown error\"}`, { originalError: error });\n    }\n}\n/**\n * Downloads a DOCX file in the browser environment\n * @param blob - The Blob containing the DOCX file data\n * @param filename - The name to save the file as (defaults to \"document.docx\")\n * @throws {Error} If the function is called outside browser environment\n * @throws {Error} If invalid blob or filename is provided\n * @throws {Error} If file save fails\n */\nfunction downloadDocx(blob, filename = \"document.docx\") {\n    if (typeof window === \"undefined\") {\n        throw new Error(\"This function can only be used in browser environments\");\n    }\n    if (!(blob instanceof Blob)) {\n        throw new Error(\"Invalid blob provided\");\n    }\n    if (!filename || typeof filename !== \"string\") {\n        throw new Error(\"Invalid filename provided\");\n    }\n    try {\n        file_saver__WEBPACK_IMPORTED_MODULE_1__(blob, filename);\n    }\n    catch (error) {\n        console.error(\"Failed to save file:\", error);\n        throw new Error(`Failed to save file: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbW9odGFzaGFtL21kLXRvLWRvY3gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0SjtBQUM1SDtBQUNZO0FBQzRKO0FBQ3hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBMkQ7QUFDM0U7QUFDQSx1R0FBdUcsV0FBVztBQUNsSDtBQUNBO0FBQ0EsNEdBQTRHLGdCQUFnQjtBQUM1SDtBQUNBO0FBQ0EsOEdBQThHLGtCQUFrQjtBQUNoSTtBQUNBO0FBQ0EsaUdBQWlHLGFBQWE7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMENBQVE7QUFDaEMscUJBQXFCLHdDQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYseURBQXlELEtBQUssc0JBQXNCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrREFBa0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBEQUFhO0FBQ3BDLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJDQUFTLEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyQ0FBUyxHQUFHLGVBQWUsMkNBQVMsS0FBSztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQ0FBUyxHQUFHO0FBQzNELDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZEQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBYztBQUNqRCwyQ0FBMkMscURBQWM7QUFDekQ7QUFDQSxvQ0FBb0MsMENBQTBDLEVBQUUsMkRBQWM7QUFDOUYsNENBQTRDLHNDQUFzQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlEQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixNQUFNO0FBQy9GO0FBQ0EscURBQXFELDJDQUFTO0FBQzlEO0FBQ0EsNENBQTRDLHlDQUFPO0FBQ25EO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFlLEdBQUcsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4REFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkRBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5REFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsdURBQXVEO0FBQzNILDZDQUE2QywyQ0FBUztBQUN0RDtBQUNBLG9DQUFvQyx5Q0FBTztBQUMzQyx5RUFBeUUsUUFBUTtBQUNqRjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUNBQXVDLCtDQUFhO0FBQ3BEO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlFQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZEQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsTUFBTSxJQUFJLHVEQUF1RDtBQUM1Siw2Q0FBNkMsMkNBQVM7QUFDdEQ7QUFDQSxvQ0FBb0MseUNBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxrQ0FBa0MsK0NBQWE7QUFDL0M7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNLElBQUkseURBQXlEO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQ0FBUztBQUN6QztBQUNBO0FBQ0EsMkJBQTJCLCtDQUFhO0FBQ3hDLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkNBQVM7QUFDN0M7QUFDQSw0QkFBNEIsbURBQWlCO0FBQzdDO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0QsK0JBQStCLFlBQVk7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNkNBQVc7QUFDM0M7QUFDQSxtQ0FBbUMsK0NBQWE7QUFDaEQ7QUFDQTtBQUNBLDBDQUEwQyx5QkFBeUI7QUFDbkUsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2Q0FBNkMsaURBQWU7QUFDNUQsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxxQ0FBcUMsd0NBQU07QUFDM0M7QUFDQSxvQ0FBb0MsMkNBQVM7QUFDN0MsK0NBQStDLCtDQUFhO0FBQzVEO0FBQ0EsNENBQTRDLHlDQUFPO0FBQ25ELHVEQUF1RCw0Q0FBVTtBQUNqRSx5Q0FBeUM7QUFDekM7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHVDQUF1QywrQ0FBYTtBQUNwRCx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYseURBQXlELEtBQUssc0JBQXNCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseURBQXlEO0FBQ3pHO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Btb2h0YXNoYW0vbWQtdG8tZG9jeC9kaXN0L2luZGV4LmpzP2Y5NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRG9jdW1lbnQsIFBhcmFncmFwaCwgVGV4dFJ1biwgQWxpZ25tZW50VHlwZSwgUGFnZU9yaWVudGF0aW9uLCBQYWNrZXIsIFBhZ2VCcmVhaywgSW50ZXJuYWxIeXBlcmxpbmssIEZvb3RlciwgUGFnZU51bWJlciwgTGV2ZWxGb3JtYXQsIH0gZnJvbSBcImRvY3hcIjtcbmltcG9ydCBzYXZlQXMgZnJvbSBcImZpbGUtc2F2ZXJcIjtcbmltcG9ydCB7IGhlYWRpbmdDb25maWdzIH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcbmltcG9ydCB7IHByb2Nlc3NIZWFkaW5nLCBwcm9jZXNzVGFibGUsIHByb2Nlc3NMaXN0SXRlbSwgcHJvY2Vzc0Jsb2NrcXVvdGUsIHByb2Nlc3NDb21tZW50LCBjb2xsZWN0VGFibGVzLCBwcm9jZXNzQ29kZUJsb2NrLCBwcm9jZXNzTGlua1BhcmFncmFwaCwgcHJvY2Vzc0ltYWdlLCBwcm9jZXNzUGFyYWdyYXBoLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmNvbnN0IGRlZmF1bHRTdHlsZSA9IHtcbiAgICB0aXRsZVNpemU6IDMyLFxuICAgIGhlYWRpbmdTcGFjaW5nOiAyNDAsXG4gICAgcGFyYWdyYXBoU3BhY2luZzogMjQwLFxuICAgIGxpbmVTcGFjaW5nOiAxLjE1LFxuICAgIHBhcmFncmFwaEFsaWdubWVudDogXCJMRUZUXCIsXG4gICAgZGlyZWN0aW9uOiBcIkxUUlwiLFxufTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGRvY3VtZW50VHlwZTogXCJkb2N1bWVudFwiLFxuICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG59O1xuLyoqXG4gKiBDdXN0b20gZXJyb3IgY2xhc3MgZm9yIG1hcmtkb3duIGNvbnZlcnNpb24gZXJyb3JzXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCBvZiB0aGUgZXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIE1hcmtkb3duQ29udmVyc2lvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWFya2Rvd25Db252ZXJzaW9uRXJyb3JcIjtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyBtYXJrZG93biBpbnB1dCBhbmQgb3B0aW9uc1xuICogQHRocm93cyB7TWFya2Rvd25Db252ZXJzaW9uRXJyb3J9IElmIGlucHV0IGlzIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChtYXJrZG93biwgb3B0aW9ucykge1xuICAgIGlmICghbWFya2Rvd24gfHwgdHlwZW9mIG1hcmtkb3duICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihcIkludmFsaWQgbWFya2Rvd24gaW5wdXQ6IE1hcmtkb3duIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgICBjb25zdCB7IHRpdGxlU2l6ZSwgaGVhZGluZ1NwYWNpbmcsIHBhcmFncmFwaFNwYWNpbmcsIGxpbmVTcGFjaW5nIH0gPSBvcHRpb25zLnN0eWxlO1xuICAgICAgICBpZiAodGl0bGVTaXplICYmICh0aXRsZVNpemUgPCA4IHx8IHRpdGxlU2l6ZSA+IDcyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1hcmtkb3duQ29udmVyc2lvbkVycm9yKFwiSW52YWxpZCB0aXRsZSBzaXplOiBNdXN0IGJlIGJldHdlZW4gOCBhbmQgNzIgcG9pbnRzXCIsIHsgdGl0bGVTaXplIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkaW5nU3BhY2luZyAmJiAoaGVhZGluZ1NwYWNpbmcgPCAwIHx8IGhlYWRpbmdTcGFjaW5nID4gNzIwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1hcmtkb3duQ29udmVyc2lvbkVycm9yKFwiSW52YWxpZCBoZWFkaW5nIHNwYWNpbmc6IE11c3QgYmUgYmV0d2VlbiAwIGFuZCA3MjAgdHdpcHNcIiwgeyBoZWFkaW5nU3BhY2luZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYWdyYXBoU3BhY2luZyAmJiAocGFyYWdyYXBoU3BhY2luZyA8IDAgfHwgcGFyYWdyYXBoU3BhY2luZyA+IDcyMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihcIkludmFsaWQgcGFyYWdyYXBoIHNwYWNpbmc6IE11c3QgYmUgYmV0d2VlbiAwIGFuZCA3MjAgdHdpcHNcIiwgeyBwYXJhZ3JhcGhTcGFjaW5nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lU3BhY2luZyAmJiAobGluZVNwYWNpbmcgPCAxIHx8IGxpbmVTcGFjaW5nID4gMykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihcIkludmFsaWQgbGluZSBzcGFjaW5nOiBNdXN0IGJlIGJldHdlZW4gMSBhbmQgM1wiLCB7IGxpbmVTcGFjaW5nIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IE1hcmtkb3duIHRvIERvY3ggZmlsZVxuICogQHBhcmFtIG1hcmtkb3duIC0gVGhlIE1hcmtkb3duIHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgY29udmVyc2lvblxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBCbG9iIGNvbnRhaW5pbmcgdGhlIERvY3ggZmlsZVxuICogQHRocm93cyB7TWFya2Rvd25Db252ZXJzaW9uRXJyb3J9IElmIGNvbnZlcnNpb24gZmFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRNYXJrZG93blRvRG9jeChtYXJrZG93biwgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jeE9wdGlvbnMgPSBhd2FpdCBwYXJzZVRvRG9jeE9wdGlvbnMobWFya2Rvd24sIG9wdGlvbnMpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGRvY3VtZW50IHdpdGggYXBwcm9wcmlhdGUgc2V0dGluZ3NcbiAgICAgICAgY29uc3QgZG9jID0gbmV3IERvY3VtZW50KGRvY3hPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFBhY2tlci50b0Jsb2IoZG9jKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE1hcmtkb3duQ29udmVyc2lvbkVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTWFya2Rvd25Db252ZXJzaW9uRXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0IG1hcmtkb3duIHRvIGRvY3g6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn1gLCB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydCBNYXJrZG93biB0byBEb2N4IG9wdGlvbnNcbiAqIEBwYXJhbSBtYXJrZG93biAtIFRoZSBNYXJrZG93biBzdHJpbmcgdG8gY29udmVydFxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGNvbnZlcnNpb25cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmxvYiBjb250YWluaW5nIHRoZSBEb2N4IGZpbGVcbiAqIEB0aHJvd3Mge01hcmtkb3duQ29udmVyc2lvbkVycm9yfSBJZiBjb252ZXJzaW9uIGZhaWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVRvRG9jeE9wdGlvbnMobWFya2Rvd24sIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0cyBlYXJseVxuICAgICAgICB2YWxpZGF0ZUlucHV0KG1hcmtkb3duLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBzdHlsZSA9IGRlZmF1bHRTdHlsZSwgZG9jdW1lbnRUeXBlID0gXCJkb2N1bWVudFwiIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBkb2NDaGlsZHJlbiA9IFtdO1xuICAgICAgICBjb25zdCBoZWFkaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBsaW5lcyA9IG1hcmtkb3duLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICBsZXQgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgIGxldCBsaXN0SXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRMaXN0TnVtYmVyID0gMTtcbiAgICAgICAgbGV0IGlzQ3VycmVudExpc3ROdW1iZXJlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgbnVtYmVyZWRMaXN0U2VxdWVuY2VJZCA9IDA7XG4gICAgICAgIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgICAgICBsZXQgY29kZUJsb2NrQ29udGVudCA9IFwiXCI7XG4gICAgICAgIGxldCBjb2RlQmxvY2tMYW5ndWFnZTtcbiAgICAgICAgbGV0IHRhYmxlSW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0YWJsZXMgPSBjb2xsZWN0VGFibGVzKGxpbmVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGxpbmVzXG4gICAgICAgICAgICAgICAgaWYgKCF0cmltbWVkTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5Db2RlQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja0NvbnRlbnQgKz0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKC4uLmxpc3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3ROdW1iZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDdXJyZW50TGlzdE51bWJlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKHt9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgUGFnZSBCcmVha1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZSA9PT0gXCJcXFxccGFnZWJyZWFrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0TnVtYmVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudExpc3ROdW1iZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7IGNoaWxkcmVuOiBbbmV3IFBhZ2VCcmVhaygpXSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgTWFya2Rvd24gU2VwYXJhdG9ycyAoZS5nLiwgLS0tKVxuICAgICAgICAgICAgICAgIGlmICgvXlxccyotLS1cXHMqJC8udGVzdCh0cmltbWVkTGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0TnVtYmVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudExpc3ROdW1iZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIHNlcGFyYXRvciBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgVE9DIFBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSBcIltUT0NdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwYXJhZ3JhcGggYW5kIGFkZCBhIHVuaXF1ZSBwcm9wZXJ0eSB0byBpZGVudGlmeSBpdCBsYXRlclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2NQbGFjZWhvbGRlciA9IG5ldyBQYXJhZ3JhcGgoe30pO1xuICAgICAgICAgICAgICAgICAgICB0b2NQbGFjZWhvbGRlci5fX2lzVG9jUGxhY2Vob2xkZXIgPSB0cnVlOyAvLyBBZGQgdGVtcG9yYXJ5IG1hcmtlciBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKHRvY1BsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiYGBgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5Db2RlQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IG9mIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ29kZUJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja0xhbmd1YWdlID0gdHJpbW1lZExpbmUuc2xpY2UoMykudHJpbSgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIG9mIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ29kZUJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKHByb2Nlc3NDb2RlQmxvY2soY29kZUJsb2NrQ29udGVudC50cmltKCksIGNvZGVCbG9ja0xhbmd1YWdlLCBzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUJsb2NrQ29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tMYW5ndWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja0NvbnRlbnQgKz0gKGNvZGVCbG9ja0NvbnRlbnQgPyBcIlxcblwiIDogXCJcIikgKyBsaW5lO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBoZWFkaW5nc1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRyaW1tZWRMaW5lLm1hdGNoKC9eIysvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAxICYmIGxldmVsIDw9IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nVGV4dCA9IHRyaW1tZWRMaW5lLnN1YnN0cmluZyhsZXZlbCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGluZ0NvbmZpZ3NbbGV2ZWxdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IGhlYWRpbmdDb25maWdzW2xldmVsXS5hbGlnbm1lbnQgfHwgc3R5bGUuaGVhZGluZ0FsaWdubWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGFyYWdyYXBoOiBoZWFkaW5nUGFyYWdyYXBoLCBib29rbWFya0lkIH0gPSBwcm9jZXNzSGVhZGluZyh0cmltbWVkTGluZSwgY29uZmlnLCBzdHlsZSwgZG9jdW1lbnRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkaW5ncy5wdXNoKHsgdGV4dDogaGVhZGluZ1RleHQsIGxldmVsLCBib29rbWFya0lkIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goaGVhZGluZ1BhcmFncmFwaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHcmFjZWZ1bCBkZWdyYWRhdGlvbiBmb3IgdW5zdXBwb3J0ZWQgaGVhZGluZyBsZXZlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogSGVhZGluZyBsZXZlbCAke2xldmVsfSBpcyBub3Qgc3VwcG9ydGVkLiBDb252ZXJ0aW5nIHRvIHJlZ3VsYXIgcGFyYWdyYXBoLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0YWJsZXNcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aChcInxcIikgJiYgdHJpbW1lZExpbmUuZW5kc1dpdGgoXCJ8XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgc3RhbmRhcmQgYW5kIGFsaWduZWQgc2VwYXJhdG9yIHJvd3MgKHdpdGggb3B0aW9uYWwgbGVhZGluZy90cmFpbGluZyBjb2xvbnMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvclJlZ2V4ID0gL15cXHMqXFx8KD86XFxzKjo/LSs6P1xccypcXHwpK1xccyokLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yUmVnZXgudGVzdChsaW5lc1tpICsgMV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGkgKyAyIDwgbGluZXMubGVuZ3RoICYmIHNlcGFyYXRvclJlZ2V4LnRlc3QobGluZXNbaSArIDJdKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlSW5kZXggPCB0YWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChwcm9jZXNzVGFibGUodGFibGVzW3RhYmxlSW5kZXhdLCBkb2N1bWVudFR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVSb3dDb3VudCA9IDIgKyB0YWJsZXNbdGFibGVJbmRleF0ucm93cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gdGFibGVSb3dDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IEZhaWxlZCB0byBwcm9jZXNzIHRhYmxlIGF0IGxpbmUgJHtpICsgMX0uIENvbnZlcnRpbmcgdG8gcmVndWxhciB0ZXh0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byByZWd1bGFyIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0cmltbWVkTGluZS5yZXBsYWNlKC9cXHwvZywgXCJcIikudHJpbSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBsaXN0c1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiLSBcIikgfHwgdHJpbW1lZExpbmUuc3RhcnRzV2l0aChcIiogXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlmIHN3aXRjaGluZyBmcm9tIG51bWJlcmVkIHRvIGJ1bGxldCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRMaXN0TnVtYmVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0TnVtYmVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudExpc3ROdW1iZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUZXh0ID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXlstKl1cXHMrLywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYm9sZCBzZWN0aW9uIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvbGRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tpICsgMV0udHJpbSgpLnN0YXJ0c1dpdGgoXCIqKlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaSArIDFdLnRyaW0oKS5lbmRzV2l0aChcIioqXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2xkVGV4dCA9IGxpbmVzW2kgKyAxXS50cmltKCkuc2xpY2UoMiwgLTIpOyAvLyBSZW1vdmUgKiogbWFya2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcy5wdXNoKHByb2Nlc3NMaXN0SXRlbSh7IHRleHQ6IGxpc3RUZXh0LCBib2xkVGV4dCB9LCBzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG51bWJlcmVkIGxpc3RzXG4gICAgICAgICAgICAgICAgaWYgKC9eXFxzKlxcZCtcXC5cXHMvLnRlc3QodHJpbW1lZExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gc3RhcnQgYSBuZXcgbnVtYmVyZWQgbGlzdCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudExpc3ROdW1iZXJlZCB8fCAhaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydGluZyBhIG5ldyBudW1iZXJlZCBsaXN0IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJlZExpc3RTZXF1ZW5jZUlkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdE51bWJlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRMaXN0TnVtYmVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUZXh0ID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXlxccypcXGQrXFwuXFxzLywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYm9sZCBzZWN0aW9uIG9uIHRoZSBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvbGRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tpICsgMV0udHJpbSgpLnN0YXJ0c1dpdGgoXCIqKlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaSArIDFdLnRyaW0oKS5lbmRzV2l0aChcIioqXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2xkVGV4dCA9IGxpbmVzW2kgKyAxXS50cmltKCkuc2xpY2UoMiwgLTIpOyAvLyBSZW1vdmUgKiogbWFya2Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcy5wdXNoKHByb2Nlc3NMaXN0SXRlbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaXN0VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbGRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOdW1iZXJlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3ROdW1iZXI6IGN1cnJlbnRMaXN0TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VJZDogbnVtYmVyZWRMaXN0U2VxdWVuY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3ROdW1iZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBibG9ja3F1b3Rlc1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiPiBcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBxdW90ZVRleHQgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9ePlxccyovLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc0Jsb2NrcXVvdGUocXVvdGVUZXh0LCBzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoXCJDT01NRU5UOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKC4uLmxpc3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXkNPTU1FTlQ6XFxzKi8sIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChwcm9jZXNzQ29tbWVudChjb21tZW50VGV4dCwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbWFnZXNcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZU1hdGNoID0gdHJpbW1lZExpbmUubWF0Y2goLyFcXFsoW15cXF1dKilcXF1cXCgoW14pXSspXFwpLyk7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW18sIGFsdFRleHQsIGltYWdlVXJsXSA9IGltYWdlTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgaW1hZ2VzIHN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIHRoZXkncmUgZnVsbHkgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVBhcmFncmFwaHMgPSBhd2FpdCBwcm9jZXNzSW1hZ2UoYWx0VGV4dCwgaW1hZ2VVcmwsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4uaW1hZ2VQYXJhZ3JhcGhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGltYWdlIHByb2Nlc3Npbmc6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgW0ltYWdlIGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICR7YWx0VGV4dH1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0YWxpY3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJGRjAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YW5kYWxvbmUgbGlua3MgKGVudGlyZSBsaW5lIGlzIGEgc2luZ2xlIGxpbmspIC0gaW5saW5lIGxpbmtzIGFyZSBoYW5kbGVkIGluIHByb2Nlc3NQYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rTWF0Y2ggPSB0cmltbWVkTGluZS5tYXRjaCgvXlxcWyhbXlxcXV0rKVxcXVxcKChbXildKylcXCkkLyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbXywgdGV4dCwgdXJsXSA9IGxpbmtNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChwcm9jZXNzTGlua1BhcmFncmFwaCh0ZXh0LCB1cmwsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIHBhcmFncmFwaCB0ZXh0IHdpdGggc3BlY2lhbCBmb3JtYXR0aW5nICh1c2UgdHJpbW1lZExpbmUgZm9yIHByb2Nlc3NpbmcpXG4gICAgICAgICAgICAgICAgaWYgKCFpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc1BhcmFncmFwaCh0cmltbWVkTGluZSwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHQgaWYgZm9ybWF0dGluZyBmYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBGYWlsZWQgdG8gcHJvY2VzcyB0ZXh0IGZvcm1hdHRpbmcgYXQgbGluZSAke2kgKyAxfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcil9LiBVc2luZyBwbGFpbiB0ZXh0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0cmltbWVkTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0eWxlLmxpbmVTcGFjaW5nICogMjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBBbGlnbm1lbnRUeXBlW3N0eWxlLnBhcmFncmFwaEFsaWdubWVudF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZWQgdGhlIGZhbGxiYWNrICdpc0NvbnRpbnVhdGlvbicgbGlzdCBpdGVtIHByb2Nlc3NpbmcgYXMgaXQgd2FzIGNhdXNpbmcgdHlwZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAvLyBhbmQgbmVlZHMgYSBtb3JlIHJvYnVzdCBpbXBsZW1lbnRhdGlvbiBpZiByZXF1aXJlZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciBhbmQgY29udGludWUgd2l0aCBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IEZhaWxlZCB0byBwcm9jZXNzIGxpbmUgJHtpICsgMX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIn0uIFNraXBwaW5nIGxpbmUuYCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFueSByZW1haW5pbmcgY29kZSBibG9ja1xuICAgICAgICBpZiAoaW5Db2RlQmxvY2sgJiYgY29kZUJsb2NrQ29udGVudCkge1xuICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChwcm9jZXNzQ29kZUJsb2NrKGNvZGVCbG9ja0NvbnRlbnQudHJpbSgpLCBjb2RlQmxvY2tMYW5ndWFnZSwgc3R5bGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYW55IHJlbWFpbmluZyBsaXN0IGl0ZW1zXG4gICAgICAgIGlmIChpbkxpc3QgJiYgbGlzdEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZSBUT0MgY29udGVudFxuICAgICAgICBjb25zdCB0b2NDb250ZW50ID0gW107XG4gICAgICAgIGlmIChoZWFkaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBPcHRpb25hbDogQWRkIGEgdGl0bGUgZm9yIHRoZSBUT0NcbiAgICAgICAgICAgIHRvY0NvbnRlbnQucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlRhYmxlIG9mIENvbnRlbnRzXCIsXG4gICAgICAgICAgICAgICAgaGVhZGluZzogXCJIZWFkaW5nMVwiLCAvLyBPciBhIHNwZWNpZmljIFRPQyB0aXRsZSBzdHlsZVxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5DRU5URVIsXG4gICAgICAgICAgICAgICAgc3BhY2luZzogeyBhZnRlcjogMjQwIH0sXG4gICAgICAgICAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaGVhZGluZ3MuZm9yRWFjaCgoaGVhZGluZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBmb250IHNpemUgYmFzZWQgb24gaGVhZGluZyBsZXZlbFxuICAgICAgICAgICAgICAgIGxldCBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICBsZXQgaXNCb2xkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IGlzSXRhbGljID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbGV2ZWwtc3BlY2lmaWMgc3R5bGVzIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZWFkaW5nLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplID0gc3R5bGUudG9jSGVhZGluZzFGb250U2l6ZSB8fCBzdHlsZS50b2NGb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQm9sZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUudG9jSGVhZGluZzFCb2xkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsZS50b2NIZWFkaW5nMUJvbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJdGFsaWMgPSBzdHlsZS50b2NIZWFkaW5nMUl0YWxpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnRvY0hlYWRpbmcyRm9udFNpemUgfHwgc3R5bGUudG9jRm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JvbGQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnRvY0hlYWRpbmcyQm9sZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGUudG9jSGVhZGluZzJCb2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0l0YWxpYyA9IHN0eWxlLnRvY0hlYWRpbmcySXRhbGljIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplID0gc3R5bGUudG9jSGVhZGluZzNGb250U2l6ZSB8fCBzdHlsZS50b2NGb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQm9sZCA9IHN0eWxlLnRvY0hlYWRpbmczQm9sZCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSXRhbGljID0gc3R5bGUudG9jSGVhZGluZzNJdGFsaWMgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemUgPSBzdHlsZS50b2NIZWFkaW5nNEZvbnRTaXplIHx8IHN0eWxlLnRvY0ZvbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNCb2xkID0gc3R5bGUudG9jSGVhZGluZzRCb2xkIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJdGFsaWMgPSBzdHlsZS50b2NIZWFkaW5nNEl0YWxpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnRvY0hlYWRpbmc1Rm9udFNpemUgfHwgc3R5bGUudG9jRm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JvbGQgPSBzdHlsZS50b2NIZWFkaW5nNUJvbGQgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0l0YWxpYyA9IHN0eWxlLnRvY0hlYWRpbmc1SXRhbGljIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnRvY0ZvbnRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVc2UgZGVmYXVsdCBjYWxjdWxhdGlvbiBpZiBubyBzcGVjaWZpYyBzaXplIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnBhcmFncmFwaFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGUucGFyYWdyYXBoU2l6ZSAtIChoZWFkaW5nLmxldmVsIC0gMSkgKiAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDI0IC0gKGhlYWRpbmcubGV2ZWwgLSAxKSAqIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvY0NvbnRlbnQucHVzaChuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBJbnRlcm5hbEh5cGVybGluayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yOiBoZWFkaW5nLmJvb2ttYXJrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogaGVhZGluZy50ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiBpc0JvbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRlbnRhdGlvbiBiYXNlZCBvbiBoZWFkaW5nIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiAoaGVhZGluZy5sZXZlbCAtIDEpICogNDAwIH0sXG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDEyMCB9LCAvLyBTcGFjaW5nIGJldHdlZW4gVE9DIGl0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHBsYWNlaG9sZGVyIHdpdGggVE9DIGNvbnRlbnRcbiAgICAgICAgY29uc3QgZmluYWxEb2NDaGlsZHJlbiA9IFtdO1xuICAgICAgICBsZXQgdG9jSW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jQ2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgbWFya2VyIHByb3BlcnR5IGluc3RlYWQgb2YgaW5zcGVjdGluZyBjb250ZW50XG4gICAgICAgICAgICBpZiAoY2hpbGQuX19pc1RvY1BsYWNlaG9sZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvY0NvbnRlbnQubGVuZ3RoID4gMCAmJiAhdG9jSW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxEb2NDaGlsZHJlbi5wdXNoKC4uLnRvY0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0b2NJbnNlcnRlZCA9IHRydWU7IC8vIEVuc3VyZSBUT0MgaXMgaW5zZXJ0ZWQgb25seSBvbmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBoZWFkaW5ncyB3ZXJlIGZvdW5kIG9yIFRPQyBhbHJlYWR5IGluc2VydGVkLCByZW1vdmUgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVE9DIHBsYWNlaG9sZGVyIGZvdW5kLCBidXQgbm8gaGVhZGluZ3MgY29sbGVjdGVkIG9yIFRPQyBhbHJlYWR5IGluc2VydGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbERvY0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIG51bWJlcmluZyBjb25maWd1cmF0aW9ucyBmb3IgYWxsIG51bWJlcmVkIGxpc3Qgc2VxdWVuY2VzXG4gICAgICAgIGNvbnN0IG51bWJlcmluZ0NvbmZpZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbnVtYmVyZWRMaXN0U2VxdWVuY2VJZDsgaSsrKSB7XG4gICAgICAgICAgICBudW1iZXJpbmdDb25maWdzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogYG51bWJlcmVkLWxpc3QtJHtpfWAsXG4gICAgICAgICAgICAgICAgbGV2ZWxzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBMZXZlbEZvcm1hdC5ERUNJTUFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCIlMS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5MRUZULFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB7IGxlZnQ6IDcyMCwgaGFuZ2luZzogMjYwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZG9jdW1lbnQgd2l0aCBhcHByb3ByaWF0ZSBzZXR0aW5nc1xuICAgICAgICBjb25zdCBkb2N4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG51bWJlcmluZzoge1xuICAgICAgICAgICAgICAgIGNvbmZpZzogbnVtYmVyaW5nQ29uZmlncyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWN0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDE0NDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAxMDgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IDE0NDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDEwODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBQYWdlT3JpZW50YXRpb24uUE9SVFJBSVQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZvb3RlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG5ldyBGb290ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkNFTlRFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1BhZ2VOdW1iZXIuQ1VSUkVOVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBmaW5hbERvY0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc3R5bGVzOiB7XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoU3R5bGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIlRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlZE9uOiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrRm9ybWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUudGl0bGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogMjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBzdHlsZS5saW5lU3BhY2luZyAqIDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5DRU5URVIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJIZWFkaW5nMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJIZWFkaW5nIDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkT246IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVpY2tGb3JtYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS50aXRsZVNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogMzYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogMjQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZUxldmVsOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiSGVhZGluZzJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSGVhZGluZyAyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlZE9uOiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrRm9ybWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUudGl0bGVTaXplIC0gNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiAzMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiAxNjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lTGV2ZWw6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJIZWFkaW5nM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJIZWFkaW5nIDNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkT246IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVpY2tGb3JtYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS50aXRsZVNpemUgLSA4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IDI4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IDEyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVMZXZlbDogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIkhlYWRpbmc0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkhlYWRpbmcgNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWRPbjogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWlja0Zvcm1hdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnRpdGxlU2l6ZSAtIDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IDEyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVMZXZlbDogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIkhlYWRpbmc1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkhlYWRpbmcgNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWRPbjogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWlja0Zvcm1hdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnRpdGxlU2l6ZSAtIDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IDIyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVMZXZlbDogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIlN0cm9uZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTdHJvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZG9jeE9wdGlvbnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNYXJrZG93bkNvbnZlcnNpb25FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE1hcmtkb3duQ29udmVyc2lvbkVycm9yKGBGYWlsZWQgdG8gY29udmVydCBtYXJrZG93biB0byBkb2N4OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCwgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqIERvd25sb2FkcyBhIERPQ1ggZmlsZSBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICogQHBhcmFtIGJsb2IgLSBUaGUgQmxvYiBjb250YWluaW5nIHRoZSBET0NYIGZpbGUgZGF0YVxuICogQHBhcmFtIGZpbGVuYW1lIC0gVGhlIG5hbWUgdG8gc2F2ZSB0aGUgZmlsZSBhcyAoZGVmYXVsdHMgdG8gXCJkb2N1bWVudC5kb2N4XCIpXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvdXRzaWRlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpbnZhbGlkIGJsb2Igb3IgZmlsZW5hbWUgaXMgcHJvdmlkZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBmaWxlIHNhdmUgZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRG9jeChibG9iLCBmaWxlbmFtZSA9IFwiZG9jdW1lbnQuZG9jeFwiKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSB1c2VkIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzXCIpO1xuICAgIH1cbiAgICBpZiAoIShibG9iIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBibG9iIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lIHx8IHR5cGVvZiBmaWxlbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpbGVuYW1lIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBzYXZlQXMoYmxvYiwgZmlsZW5hbWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIGZpbGU6XCIsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2F2ZSBmaWxlOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/types.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultStyle: function() { return /* binding */ defaultStyle; },\n/* harmony export */   headingConfigs: function() { return /* binding */ headingConfigs; }\n/* harmony export */ });\nconst defaultStyle = {\n    titleSize: 32,\n    headingSpacing: 240,\n    paragraphSpacing: 240,\n    lineSpacing: 1.15,\n    direction: \"LTR\",\n    // Default font sizes\n    heading1Size: 32,\n    heading2Size: 28,\n    heading3Size: 24,\n    heading4Size: 20,\n    heading5Size: 18,\n    paragraphSize: 24,\n    listItemSize: 24,\n    codeBlockSize: 20,\n    blockquoteSize: 24,\n    // Default alignments\n    paragraphAlignment: \"LEFT\",\n    heading1Alignment: \"LEFT\",\n    heading2Alignment: \"LEFT\",\n    heading3Alignment: \"LEFT\",\n    heading4Alignment: \"LEFT\",\n    heading5Alignment: \"LEFT\",\n    blockquoteAlignment: \"LEFT\",\n    headingAlignment: \"LEFT\",\n};\nconst headingConfigs = {\n    1: { level: 1, size: 0, style: \"Title\" },\n    2: { level: 2, size: 0, style: \"Heading2\" },\n    3: { level: 3, size: 0 },\n    4: { level: 4, size: 0 },\n    5: { level: 5, size: 0 },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbW9odGFzaGFtL21kLXRvLWRvY3gvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFNBQVMsbUNBQW1DO0FBQzVDLFNBQVMsc0NBQXNDO0FBQy9DLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMsbUJBQW1CO0FBQzVCLFNBQVMsbUJBQW1CO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbW9odGFzaGFtL21kLXRvLWRvY3gvZGlzdC90eXBlcy5qcz8yYmRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gICAgdGl0bGVTaXplOiAzMixcbiAgICBoZWFkaW5nU3BhY2luZzogMjQwLFxuICAgIHBhcmFncmFwaFNwYWNpbmc6IDI0MCxcbiAgICBsaW5lU3BhY2luZzogMS4xNSxcbiAgICBkaXJlY3Rpb246IFwiTFRSXCIsXG4gICAgLy8gRGVmYXVsdCBmb250IHNpemVzXG4gICAgaGVhZGluZzFTaXplOiAzMixcbiAgICBoZWFkaW5nMlNpemU6IDI4LFxuICAgIGhlYWRpbmczU2l6ZTogMjQsXG4gICAgaGVhZGluZzRTaXplOiAyMCxcbiAgICBoZWFkaW5nNVNpemU6IDE4LFxuICAgIHBhcmFncmFwaFNpemU6IDI0LFxuICAgIGxpc3RJdGVtU2l6ZTogMjQsXG4gICAgY29kZUJsb2NrU2l6ZTogMjAsXG4gICAgYmxvY2txdW90ZVNpemU6IDI0LFxuICAgIC8vIERlZmF1bHQgYWxpZ25tZW50c1xuICAgIHBhcmFncmFwaEFsaWdubWVudDogXCJMRUZUXCIsXG4gICAgaGVhZGluZzFBbGlnbm1lbnQ6IFwiTEVGVFwiLFxuICAgIGhlYWRpbmcyQWxpZ25tZW50OiBcIkxFRlRcIixcbiAgICBoZWFkaW5nM0FsaWdubWVudDogXCJMRUZUXCIsXG4gICAgaGVhZGluZzRBbGlnbm1lbnQ6IFwiTEVGVFwiLFxuICAgIGhlYWRpbmc1QWxpZ25tZW50OiBcIkxFRlRcIixcbiAgICBibG9ja3F1b3RlQWxpZ25tZW50OiBcIkxFRlRcIixcbiAgICBoZWFkaW5nQWxpZ25tZW50OiBcIkxFRlRcIixcbn07XG5leHBvcnQgY29uc3QgaGVhZGluZ0NvbmZpZ3MgPSB7XG4gICAgMTogeyBsZXZlbDogMSwgc2l6ZTogMCwgc3R5bGU6IFwiVGl0bGVcIiB9LFxuICAgIDI6IHsgbGV2ZWw6IDIsIHNpemU6IDAsIHN0eWxlOiBcIkhlYWRpbmcyXCIgfSxcbiAgICAzOiB7IGxldmVsOiAzLCBzaXplOiAwIH0sXG4gICAgNDogeyBsZXZlbDogNCwgc2l6ZTogMCB9LFxuICAgIDU6IHsgbGV2ZWw6IDUsIHNpemU6IDAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@mohtasham/md-to-docx/dist/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/docx/dist/index.mjs":
/*!******************************************!*\
  !*** ./node_modules/docx/dist/index.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractNumbering: function() { return /* binding */ AbstractNumbering; },\n/* harmony export */   Alignment: function() { return /* binding */ Alignment; },\n/* harmony export */   AlignmentAttributes: function() { return /* binding */ AlignmentAttributes; },\n/* harmony export */   AlignmentType: function() { return /* binding */ AlignmentType; },\n/* harmony export */   AnnotationReference: function() { return /* binding */ AnnotationReference; },\n/* harmony export */   Attributes: function() { return /* binding */ Attributes; },\n/* harmony export */   BaseEmphasisMark: function() { return /* binding */ BaseEmphasisMark; },\n/* harmony export */   BaseXmlComponent: function() { return /* binding */ BaseXmlComponent; },\n/* harmony export */   Body: function() { return /* binding */ Body; },\n/* harmony export */   Bookmark: function() { return /* binding */ Bookmark; },\n/* harmony export */   BookmarkEnd: function() { return /* binding */ BookmarkEnd; },\n/* harmony export */   BookmarkStart: function() { return /* binding */ BookmarkStart; },\n/* harmony export */   Border: function() { return /* binding */ Border; },\n/* harmony export */   BorderElement: function() { return /* binding */ BorderElement; },\n/* harmony export */   BorderStyle: function() { return /* binding */ BorderStyle; },\n/* harmony export */   BuilderElement: function() { return /* binding */ BuilderElement; },\n/* harmony export */   CarriageReturn: function() { return /* binding */ CarriageReturn; },\n/* harmony export */   CharacterSet: function() { return /* binding */ CharacterSet; },\n/* harmony export */   CheckBox: function() { return /* binding */ CheckBox; },\n/* harmony export */   CheckBoxSymbolElement: function() { return /* binding */ CheckBoxSymbolElement; },\n/* harmony export */   CheckBoxUtil: function() { return /* binding */ CheckBoxUtil; },\n/* harmony export */   Column: function() { return /* binding */ Column; },\n/* harmony export */   ColumnBreak: function() { return /* binding */ ColumnBreak; },\n/* harmony export */   Columns: function() { return /* binding */ Columns; },\n/* harmony export */   Comment: function() { return /* binding */ Comment; },\n/* harmony export */   CommentRangeEnd: function() { return /* binding */ CommentRangeEnd; },\n/* harmony export */   CommentRangeStart: function() { return /* binding */ CommentRangeStart; },\n/* harmony export */   CommentReference: function() { return /* binding */ CommentReference; },\n/* harmony export */   Comments: function() { return /* binding */ Comments; },\n/* harmony export */   ConcreteHyperlink: function() { return /* binding */ ConcreteHyperlink; },\n/* harmony export */   ConcreteNumbering: function() { return /* binding */ ConcreteNumbering; },\n/* harmony export */   ContinuationSeparator: function() { return /* binding */ ContinuationSeparator; },\n/* harmony export */   DayLong: function() { return /* binding */ DayLong; },\n/* harmony export */   DayShort: function() { return /* binding */ DayShort; },\n/* harmony export */   DeletedTextRun: function() { return /* binding */ DeletedTextRun; },\n/* harmony export */   Document: function() { return /* binding */ File; },\n/* harmony export */   DocumentAttributeNamespaces: function() { return /* binding */ DocumentAttributeNamespaces; },\n/* harmony export */   DocumentAttributes: function() { return /* binding */ DocumentAttributes; },\n/* harmony export */   DocumentBackground: function() { return /* binding */ DocumentBackground; },\n/* harmony export */   DocumentBackgroundAttributes: function() { return /* binding */ DocumentBackgroundAttributes; },\n/* harmony export */   DocumentDefaults: function() { return /* binding */ DocumentDefaults; },\n/* harmony export */   DocumentGridType: function() { return /* binding */ DocumentGridType; },\n/* harmony export */   DotEmphasisMark: function() { return /* binding */ DotEmphasisMark; },\n/* harmony export */   Drawing: function() { return /* binding */ Drawing; },\n/* harmony export */   DropCapType: function() { return /* binding */ DropCapType; },\n/* harmony export */   EMPTY_OBJECT: function() { return /* binding */ EMPTY_OBJECT; },\n/* harmony export */   EmphasisMark: function() { return /* binding */ EmphasisMark; },\n/* harmony export */   EmphasisMarkType: function() { return /* binding */ EmphasisMarkType; },\n/* harmony export */   EmptyElement: function() { return /* binding */ EmptyElement; },\n/* harmony export */   EndnoteReference: function() { return /* binding */ EndnoteReference; },\n/* harmony export */   ExternalHyperlink: function() { return /* binding */ ExternalHyperlink; },\n/* harmony export */   File: function() { return /* binding */ File; },\n/* harmony export */   FileChild: function() { return /* binding */ FileChild; },\n/* harmony export */   FootNoteReferenceRunAttributes: function() { return /* binding */ FootNoteReferenceRunAttributes; },\n/* harmony export */   FootNotes: function() { return /* binding */ FootNotes; },\n/* harmony export */   Footer: function() { return /* binding */ Footer2; },\n/* harmony export */   FooterWrapper: function() { return /* binding */ FooterWrapper; },\n/* harmony export */   FootnoteReference: function() { return /* binding */ FootnoteReference; },\n/* harmony export */   FootnoteReferenceElement: function() { return /* binding */ FootnoteReferenceElement; },\n/* harmony export */   FootnoteReferenceRun: function() { return /* binding */ FootnoteReferenceRun; },\n/* harmony export */   FrameAnchorType: function() { return /* binding */ FrameAnchorType; },\n/* harmony export */   FrameWrap: function() { return /* binding */ FrameWrap; },\n/* harmony export */   GridSpan: function() { return /* binding */ GridSpan; },\n/* harmony export */   Header: function() { return /* binding */ Header2; },\n/* harmony export */   HeaderFooterReference: function() { return /* binding */ HeaderFooterReference; },\n/* harmony export */   HeaderFooterReferenceType: function() { return /* binding */ HeaderFooterReferenceType; },\n/* harmony export */   HeaderFooterType: function() { return /* binding */ HeaderFooterType; },\n/* harmony export */   HeaderWrapper: function() { return /* binding */ HeaderWrapper; },\n/* harmony export */   HeadingLevel: function() { return /* binding */ HeadingLevel; },\n/* harmony export */   HeightRule: function() { return /* binding */ HeightRule; },\n/* harmony export */   HighlightColor: function() { return /* binding */ HighlightColor; },\n/* harmony export */   HorizontalPositionAlign: function() { return /* binding */ HorizontalPositionAlign; },\n/* harmony export */   HorizontalPositionRelativeFrom: function() { return /* binding */ HorizontalPositionRelativeFrom; },\n/* harmony export */   HpsMeasureElement: function() { return /* binding */ HpsMeasureElement; },\n/* harmony export */   HyperlinkType: function() { return /* binding */ HyperlinkType; },\n/* harmony export */   IgnoreIfEmptyXmlComponent: function() { return /* binding */ IgnoreIfEmptyXmlComponent; },\n/* harmony export */   ImageRun: function() { return /* binding */ ImageRun; },\n/* harmony export */   ImportedRootElementAttributes: function() { return /* binding */ ImportedRootElementAttributes; },\n/* harmony export */   ImportedXmlComponent: function() { return /* binding */ ImportedXmlComponent; },\n/* harmony export */   Indent: function() { return /* binding */ Indent; },\n/* harmony export */   InitializableXmlComponent: function() { return /* binding */ InitializableXmlComponent; },\n/* harmony export */   InsertedTextRun: function() { return /* binding */ InsertedTextRun; },\n/* harmony export */   InternalHyperlink: function() { return /* binding */ InternalHyperlink; },\n/* harmony export */   LastRenderedPageBreak: function() { return /* binding */ LastRenderedPageBreak; },\n/* harmony export */   LeaderType: function() { return /* binding */ LeaderType; },\n/* harmony export */   Level: function() { return /* binding */ Level; },\n/* harmony export */   LevelBase: function() { return /* binding */ LevelBase; },\n/* harmony export */   LevelForOverride: function() { return /* binding */ LevelForOverride; },\n/* harmony export */   LevelFormat: function() { return /* binding */ LevelFormat; },\n/* harmony export */   LevelOverride: function() { return /* binding */ LevelOverride; },\n/* harmony export */   LevelSuffix: function() { return /* binding */ LevelSuffix; },\n/* harmony export */   LineNumberRestartFormat: function() { return /* binding */ LineNumberRestartFormat; },\n/* harmony export */   LineRuleType: function() { return /* binding */ LineRuleType; },\n/* harmony export */   Math: function() { return /* binding */ Math$1; },\n/* harmony export */   MathAngledBrackets: function() { return /* binding */ MathAngledBrackets; },\n/* harmony export */   MathCurlyBrackets: function() { return /* binding */ MathCurlyBrackets; },\n/* harmony export */   MathDegree: function() { return /* binding */ MathDegree; },\n/* harmony export */   MathDenominator: function() { return /* binding */ MathDenominator; },\n/* harmony export */   MathFraction: function() { return /* binding */ MathFraction; },\n/* harmony export */   MathFunction: function() { return /* binding */ MathFunction; },\n/* harmony export */   MathFunctionName: function() { return /* binding */ MathFunctionName; },\n/* harmony export */   MathFunctionProperties: function() { return /* binding */ MathFunctionProperties; },\n/* harmony export */   MathIntegral: function() { return /* binding */ MathIntegral; },\n/* harmony export */   MathLimit: function() { return /* binding */ MathLimit; },\n/* harmony export */   MathLimitLower: function() { return /* binding */ MathLimitLower; },\n/* harmony export */   MathLimitUpper: function() { return /* binding */ MathLimitUpper; },\n/* harmony export */   MathNumerator: function() { return /* binding */ MathNumerator; },\n/* harmony export */   MathPreSubSuperScript: function() { return /* binding */ MathPreSubSuperScript; },\n/* harmony export */   MathRadical: function() { return /* binding */ MathRadical; },\n/* harmony export */   MathRadicalProperties: function() { return /* binding */ MathRadicalProperties; },\n/* harmony export */   MathRoundBrackets: function() { return /* binding */ MathRoundBrackets; },\n/* harmony export */   MathRun: function() { return /* binding */ MathRun; },\n/* harmony export */   MathSquareBrackets: function() { return /* binding */ MathSquareBrackets; },\n/* harmony export */   MathSubScript: function() { return /* binding */ MathSubScript; },\n/* harmony export */   MathSubSuperScript: function() { return /* binding */ MathSubSuperScript; },\n/* harmony export */   MathSum: function() { return /* binding */ MathSum; },\n/* harmony export */   MathSuperScript: function() { return /* binding */ MathSuperScript; },\n/* harmony export */   Media: function() { return /* binding */ Media; },\n/* harmony export */   MonthLong: function() { return /* binding */ MonthLong; },\n/* harmony export */   MonthShort: function() { return /* binding */ MonthShort; },\n/* harmony export */   NextAttributeComponent: function() { return /* binding */ NextAttributeComponent; },\n/* harmony export */   NoBreakHyphen: function() { return /* binding */ NoBreakHyphen; },\n/* harmony export */   NumberFormat: function() { return /* binding */ NumberFormat$1; },\n/* harmony export */   NumberProperties: function() { return /* binding */ NumberProperties; },\n/* harmony export */   NumberValueElement: function() { return /* binding */ NumberValueElement; },\n/* harmony export */   Numbering: function() { return /* binding */ Numbering; },\n/* harmony export */   OnOffElement: function() { return /* binding */ OnOffElement; },\n/* harmony export */   OutlineLevel: function() { return /* binding */ OutlineLevel; },\n/* harmony export */   OverlapType: function() { return /* binding */ OverlapType; },\n/* harmony export */   Packer: function() { return /* binding */ Packer; },\n/* harmony export */   PageBorderDisplay: function() { return /* binding */ PageBorderDisplay; },\n/* harmony export */   PageBorderOffsetFrom: function() { return /* binding */ PageBorderOffsetFrom; },\n/* harmony export */   PageBorderZOrder: function() { return /* binding */ PageBorderZOrder; },\n/* harmony export */   PageBorders: function() { return /* binding */ PageBorders; },\n/* harmony export */   PageBreak: function() { return /* binding */ PageBreak; },\n/* harmony export */   PageBreakBefore: function() { return /* binding */ PageBreakBefore; },\n/* harmony export */   PageMargin: function() { return /* binding */ PageMargin; },\n/* harmony export */   PageNumber: function() { return /* binding */ PageNumber; },\n/* harmony export */   PageNumberElement: function() { return /* binding */ PageNumberElement; },\n/* harmony export */   PageNumberSeparator: function() { return /* binding */ PageNumberSeparator; },\n/* harmony export */   PageNumberType: function() { return /* binding */ PageNumberType; },\n/* harmony export */   PageNumberTypeAttributes: function() { return /* binding */ PageNumberTypeAttributes; },\n/* harmony export */   PageOrientation: function() { return /* binding */ PageOrientation; },\n/* harmony export */   PageReference: function() { return /* binding */ PageReference; },\n/* harmony export */   PageTextDirection: function() { return /* binding */ PageTextDirection; },\n/* harmony export */   PageTextDirectionType: function() { return /* binding */ PageTextDirectionType; },\n/* harmony export */   Paragraph: function() { return /* binding */ Paragraph; },\n/* harmony export */   ParagraphProperties: function() { return /* binding */ ParagraphProperties; },\n/* harmony export */   ParagraphPropertiesDefaults: function() { return /* binding */ ParagraphPropertiesDefaults; },\n/* harmony export */   PatchType: function() { return /* binding */ PatchType; },\n/* harmony export */   PositionalTab: function() { return /* binding */ PositionalTab; },\n/* harmony export */   PositionalTabAlignment: function() { return /* binding */ PositionalTabAlignment; },\n/* harmony export */   PositionalTabLeader: function() { return /* binding */ PositionalTabLeader; },\n/* harmony export */   PositionalTabRelativeTo: function() { return /* binding */ PositionalTabRelativeTo; },\n/* harmony export */   PrettifyType: function() { return /* binding */ PrettifyType; },\n/* harmony export */   RelativeHorizontalPosition: function() { return /* binding */ RelativeHorizontalPosition; },\n/* harmony export */   RelativeVerticalPosition: function() { return /* binding */ RelativeVerticalPosition; },\n/* harmony export */   Run: function() { return /* binding */ Run; },\n/* harmony export */   RunFonts: function() { return /* binding */ RunFonts; },\n/* harmony export */   RunProperties: function() { return /* binding */ RunProperties; },\n/* harmony export */   RunPropertiesChange: function() { return /* binding */ RunPropertiesChange; },\n/* harmony export */   RunPropertiesDefaults: function() { return /* binding */ RunPropertiesDefaults; },\n/* harmony export */   SectionProperties: function() { return /* binding */ SectionProperties; },\n/* harmony export */   SectionType: function() { return /* binding */ SectionType; },\n/* harmony export */   SectionTypeAttributes: function() { return /* binding */ SectionTypeAttributes; },\n/* harmony export */   Separator: function() { return /* binding */ Separator; },\n/* harmony export */   SequentialIdentifier: function() { return /* binding */ SequentialIdentifier; },\n/* harmony export */   Shading: function() { return /* binding */ Shading; },\n/* harmony export */   ShadingType: function() { return /* binding */ ShadingType; },\n/* harmony export */   SimpleField: function() { return /* binding */ SimpleField; },\n/* harmony export */   SimpleMailMergeField: function() { return /* binding */ SimpleMailMergeField; },\n/* harmony export */   SoftHyphen: function() { return /* binding */ SoftHyphen; },\n/* harmony export */   SpaceType: function() { return /* binding */ SpaceType; },\n/* harmony export */   Spacing: function() { return /* binding */ Spacing; },\n/* harmony export */   StringContainer: function() { return /* binding */ StringContainer; },\n/* harmony export */   StringEnumValueElement: function() { return /* binding */ StringEnumValueElement; },\n/* harmony export */   StringValueElement: function() { return /* binding */ StringValueElement; },\n/* harmony export */   Style: function() { return /* binding */ Style$1; },\n/* harmony export */   StyleForCharacter: function() { return /* binding */ StyleForCharacter; },\n/* harmony export */   StyleForParagraph: function() { return /* binding */ StyleForParagraph; },\n/* harmony export */   StyleLevel: function() { return /* binding */ StyleLevel; },\n/* harmony export */   Styles: function() { return /* binding */ Styles; },\n/* harmony export */   SymbolRun: function() { return /* binding */ SymbolRun; },\n/* harmony export */   TDirection: function() { return /* binding */ TDirection; },\n/* harmony export */   Tab: function() { return /* binding */ Tab; },\n/* harmony export */   TabAttributes: function() { return /* binding */ TabAttributes; },\n/* harmony export */   TabStop: function() { return /* binding */ TabStop; },\n/* harmony export */   TabStopItem: function() { return /* binding */ TabStopItem; },\n/* harmony export */   TabStopPosition: function() { return /* binding */ TabStopPosition; },\n/* harmony export */   TabStopType: function() { return /* binding */ TabStopType; },\n/* harmony export */   Table: function() { return /* binding */ Table; },\n/* harmony export */   TableAnchorType: function() { return /* binding */ TableAnchorType; },\n/* harmony export */   TableBorders: function() { return /* binding */ TableBorders; },\n/* harmony export */   TableCell: function() { return /* binding */ TableCell; },\n/* harmony export */   TableCellBorders: function() { return /* binding */ TableCellBorders; },\n/* harmony export */   TableFloatProperties: function() { return /* binding */ TableFloatProperties; },\n/* harmony export */   TableLayout: function() { return /* binding */ TableLayout; },\n/* harmony export */   TableLayoutType: function() { return /* binding */ TableLayoutType; },\n/* harmony export */   TableOfContents: function() { return /* binding */ TableOfContents; },\n/* harmony export */   TableProperties: function() { return /* binding */ TableProperties; },\n/* harmony export */   TableRow: function() { return /* binding */ TableRow; },\n/* harmony export */   TableRowHeight: function() { return /* binding */ TableRowHeight; },\n/* harmony export */   TableRowHeightAttributes: function() { return /* binding */ TableRowHeightAttributes; },\n/* harmony export */   TableRowProperties: function() { return /* binding */ TableRowProperties; },\n/* harmony export */   TableWidthElement: function() { return /* binding */ TableWidthElement; },\n/* harmony export */   TextDirection: function() { return /* binding */ TextDirection; },\n/* harmony export */   TextEffect: function() { return /* binding */ TextEffect; },\n/* harmony export */   TextRun: function() { return /* binding */ TextRun; },\n/* harmony export */   TextWrappingSide: function() { return /* binding */ TextWrappingSide; },\n/* harmony export */   TextWrappingType: function() { return /* binding */ TextWrappingType; },\n/* harmony export */   Textbox: function() { return /* binding */ Textbox; },\n/* harmony export */   ThematicBreak: function() { return /* binding */ ThematicBreak; },\n/* harmony export */   Type: function() { return /* binding */ Type; },\n/* harmony export */   Underline: function() { return /* binding */ Underline; },\n/* harmony export */   UnderlineType: function() { return /* binding */ UnderlineType; },\n/* harmony export */   VerticalAlign: function() { return /* binding */ VerticalAlign2; },\n/* harmony export */   VerticalAlignAttributes: function() { return /* binding */ VerticalAlignAttributes; },\n/* harmony export */   VerticalAlignElement: function() { return /* binding */ VerticalAlignElement; },\n/* harmony export */   VerticalAlignSection: function() { return /* binding */ VerticalAlignSection; },\n/* harmony export */   VerticalAlignTable: function() { return /* binding */ VerticalAlignTable; },\n/* harmony export */   VerticalMerge: function() { return /* binding */ VerticalMerge; },\n/* harmony export */   VerticalMergeType: function() { return /* binding */ VerticalMergeType; },\n/* harmony export */   VerticalPositionAlign: function() { return /* binding */ VerticalPositionAlign; },\n/* harmony export */   VerticalPositionRelativeFrom: function() { return /* binding */ VerticalPositionRelativeFrom; },\n/* harmony export */   WORKAROUND2: function() { return /* binding */ WORKAROUND2; },\n/* harmony export */   WORKAROUND3: function() { return /* binding */ WORKAROUND3; },\n/* harmony export */   WORKAROUND4: function() { return /* binding */ WORKAROUND4; },\n/* harmony export */   WidthType: function() { return /* binding */ WidthType; },\n/* harmony export */   WrapNone: function() { return /* binding */ WrapNone; },\n/* harmony export */   WrapSquare: function() { return /* binding */ WrapSquare; },\n/* harmony export */   WrapTight: function() { return /* binding */ WrapTight; },\n/* harmony export */   WrapTopAndBottom: function() { return /* binding */ WrapTopAndBottom; },\n/* harmony export */   XmlAttributeComponent: function() { return /* binding */ XmlAttributeComponent; },\n/* harmony export */   XmlComponent: function() { return /* binding */ XmlComponent; },\n/* harmony export */   YearLong: function() { return /* binding */ YearLong; },\n/* harmony export */   YearShort: function() { return /* binding */ YearShort; },\n/* harmony export */   abstractNumUniqueNumericIdGen: function() { return /* binding */ abstractNumUniqueNumericIdGen; },\n/* harmony export */   bookmarkUniqueNumericIdGen: function() { return /* binding */ bookmarkUniqueNumericIdGen; },\n/* harmony export */   concreteNumUniqueNumericIdGen: function() { return /* binding */ concreteNumUniqueNumericIdGen; },\n/* harmony export */   convertInchesToTwip: function() { return /* binding */ convertInchesToTwip; },\n/* harmony export */   convertMillimetersToTwip: function() { return /* binding */ convertMillimetersToTwip; },\n/* harmony export */   convertToXmlComponent: function() { return /* binding */ convertToXmlComponent; },\n/* harmony export */   createDocumentGrid: function() { return /* binding */ createDocumentGrid; },\n/* harmony export */   createFrameProperties: function() { return /* binding */ createFrameProperties; },\n/* harmony export */   createHorizontalPosition: function() { return /* binding */ createHorizontalPosition; },\n/* harmony export */   createLineNumberType: function() { return /* binding */ createLineNumberType; },\n/* harmony export */   createMathAccentCharacter: function() { return /* binding */ createMathAccentCharacter; },\n/* harmony export */   createMathBase: function() { return /* binding */ createMathBase; },\n/* harmony export */   createMathLimitLocation: function() { return /* binding */ createMathLimitLocation; },\n/* harmony export */   createMathNAryProperties: function() { return /* binding */ createMathNAryProperties; },\n/* harmony export */   createMathPreSubSuperScriptProperties: function() { return /* binding */ createMathPreSubSuperScriptProperties; },\n/* harmony export */   createMathSubScriptElement: function() { return /* binding */ createMathSubScriptElement; },\n/* harmony export */   createMathSubScriptProperties: function() { return /* binding */ createMathSubScriptProperties; },\n/* harmony export */   createMathSubSuperScriptProperties: function() { return /* binding */ createMathSubSuperScriptProperties; },\n/* harmony export */   createMathSuperScriptElement: function() { return /* binding */ createMathSuperScriptElement; },\n/* harmony export */   createMathSuperScriptProperties: function() { return /* binding */ createMathSuperScriptProperties; },\n/* harmony export */   createPageSize: function() { return /* binding */ createPageSize; },\n/* harmony export */   createSimplePos: function() { return /* binding */ createSimplePos; },\n/* harmony export */   createStringElement: function() { return /* binding */ createStringElement; },\n/* harmony export */   createVerticalPosition: function() { return /* binding */ createVerticalPosition; },\n/* harmony export */   dateTimeValue: function() { return /* binding */ dateTimeValue; },\n/* harmony export */   decimalNumber: function() { return /* binding */ decimalNumber; },\n/* harmony export */   docPropertiesUniqueNumericIdGen: function() { return /* binding */ docPropertiesUniqueNumericIdGen; },\n/* harmony export */   eighthPointMeasureValue: function() { return /* binding */ eighthPointMeasureValue; },\n/* harmony export */   hashedId: function() { return /* binding */ hashedId; },\n/* harmony export */   hexColorValue: function() { return /* binding */ hexColorValue; },\n/* harmony export */   hpsMeasureValue: function() { return /* binding */ hpsMeasureValue; },\n/* harmony export */   longHexNumber: function() { return /* binding */ longHexNumber; },\n/* harmony export */   measurementOrPercentValue: function() { return /* binding */ measurementOrPercentValue; },\n/* harmony export */   patchDetector: function() { return /* binding */ patchDetector; },\n/* harmony export */   patchDocument: function() { return /* binding */ patchDocument; },\n/* harmony export */   percentageValue: function() { return /* binding */ percentageValue; },\n/* harmony export */   pointMeasureValue: function() { return /* binding */ pointMeasureValue; },\n/* harmony export */   positiveUniversalMeasureValue: function() { return /* binding */ positiveUniversalMeasureValue; },\n/* harmony export */   sectionMarginDefaults: function() { return /* binding */ sectionMarginDefaults; },\n/* harmony export */   sectionPageSizeDefaults: function() { return /* binding */ sectionPageSizeDefaults; },\n/* harmony export */   shortHexNumber: function() { return /* binding */ shortHexNumber; },\n/* harmony export */   signedHpsMeasureValue: function() { return /* binding */ signedHpsMeasureValue; },\n/* harmony export */   signedTwipsMeasureValue: function() { return /* binding */ signedTwipsMeasureValue; },\n/* harmony export */   twipsMeasureValue: function() { return /* binding */ twipsMeasureValue; },\n/* harmony export */   uCharHexNumber: function() { return /* binding */ uCharHexNumber; },\n/* harmony export */   uniqueId: function() { return /* binding */ uniqueId; },\n/* harmony export */   uniqueNumericIdCreator: function() { return /* binding */ uniqueNumericIdCreator; },\n/* harmony export */   uniqueUuid: function() { return /* binding */ uniqueUuid; },\n/* harmony export */   universalMeasureValue: function() { return /* binding */ universalMeasureValue; },\n/* harmony export */   unsignedDecimalNumber: function() { return /* binding */ unsignedDecimalNumber; }\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nclass BaseXmlComponent {\n  constructor(rootKey) {\n    __publicField(this, \"rootKey\");\n    this.rootKey = rootKey;\n  }\n}\nconst EMPTY_OBJECT = Object.seal({});\nclass XmlComponent extends BaseXmlComponent {\n  constructor(rootKey) {\n    super(rootKey);\n    // eslint-disable-next-line functional/prefer-readonly-type, @typescript-eslint/no-explicit-any\n    __publicField(this, \"root\");\n    this.root = new Array();\n  }\n  // This method is called by the formatter to get the XML representation of this component.\n  // It is called recursively for all child components.\n  // It is a serializer to be used in the xml library.\n  // https://www.npmjs.com/package/xml\n  // Child components can override this method to customize the XML representation, or execute side effects.\n  prepForXml(context) {\n    var _a;\n    context.stack.push(this);\n    const children = this.root.map((comp) => {\n      if (comp instanceof BaseXmlComponent) {\n        return comp.prepForXml(context);\n      }\n      return comp;\n    }).filter((comp) => comp !== void 0);\n    context.stack.pop();\n    return {\n      [this.rootKey]: children.length ? children.length === 1 && ((_a = children[0]) == null ? void 0 : _a._attr) ? children[0] : children : EMPTY_OBJECT\n    };\n  }\n  /**\n   * @deprecated Do not use this method. It is only used internally by the library. It will be removed in a future version.\n   */\n  addChildElement(child) {\n    this.root.push(child);\n    return this;\n  }\n}\nclass IgnoreIfEmptyXmlComponent extends XmlComponent {\n  prepForXml(context) {\n    const result = super.prepForXml(context);\n    if (result && (typeof result[this.rootKey] !== \"object\" || Object.keys(result[this.rootKey]).length)) {\n      return result;\n    }\n    return void 0;\n  }\n}\nclass XmlAttributeComponent extends BaseXmlComponent {\n  constructor(root) {\n    super(\"_attr\");\n    __publicField(this, \"xmlKeys\");\n    this.root = root;\n  }\n  prepForXml(_) {\n    const attrs = {};\n    Object.entries(this.root).forEach(([key, value]) => {\n      if (value !== void 0) {\n        const newKey = this.xmlKeys && this.xmlKeys[key] || key;\n        attrs[newKey] = value;\n      }\n    });\n    return { _attr: attrs };\n  }\n}\nclass NextAttributeComponent extends BaseXmlComponent {\n  constructor(root) {\n    super(\"_attr\");\n    this.root = root;\n  }\n  prepForXml(_) {\n    const attrs = Object.values(this.root).filter(({ value }) => value !== void 0).reduce((acc, { key, value }) => __spreadProps(__spreadValues({}, acc), { [key]: value }), {});\n    return { _attr: attrs };\n  }\n}\nclass Attributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      val: \"w:val\",\n      color: \"w:color\",\n      fill: \"w:fill\",\n      space: \"w:space\",\n      sz: \"w:sz\",\n      type: \"w:type\",\n      rsidR: \"w:rsidR\",\n      rsidRPr: \"w:rsidRPr\",\n      rsidSect: \"w:rsidSect\",\n      w: \"w:w\",\n      h: \"w:h\",\n      top: \"w:top\",\n      right: \"w:right\",\n      bottom: \"w:bottom\",\n      left: \"w:left\",\n      header: \"w:header\",\n      footer: \"w:footer\",\n      gutter: \"w:gutter\",\n      linePitch: \"w:linePitch\",\n      pos: \"w:pos\"\n    });\n  }\n}\nvar commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nfunction getDefaultExportFromCjs$1(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar sax = {};\nvar events = { exports: {} };\nvar hasRequiredEvents;\nfunction requireEvents() {\n  if (hasRequiredEvents) return events.exports;\n  hasRequiredEvents = 1;\n  var R = typeof Reflect === \"object\" ? Reflect : null;\n  var ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply2(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n  var ReflectOwnKeys;\n  if (R && typeof R.ownKeys === \"function\") {\n    ReflectOwnKeys = R.ownKeys;\n  } else if (Object.getOwnPropertySymbols) {\n    ReflectOwnKeys = function ReflectOwnKeys2(target) {\n      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n    };\n  } else {\n    ReflectOwnKeys = function ReflectOwnKeys2(target) {\n      return Object.getOwnPropertyNames(target);\n    };\n  }\n  function ProcessEmitWarning(warning) {\n    if (console && console.warn) console.warn(warning);\n  }\n  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {\n    return value !== value;\n  };\n  function EventEmitter() {\n    EventEmitter.init.call(this);\n  }\n  events.exports = EventEmitter;\n  events.exports.once = once;\n  EventEmitter.EventEmitter = EventEmitter;\n  EventEmitter.prototype._events = void 0;\n  EventEmitter.prototype._eventsCount = 0;\n  EventEmitter.prototype._maxListeners = void 0;\n  var defaultMaxListeners = 10;\n  function checkListener(listener) {\n    if (typeof listener !== \"function\") {\n      throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n    }\n  }\n  Object.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n        throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n      }\n      defaultMaxListeners = arg;\n    }\n  });\n  EventEmitter.init = function() {\n    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {\n      this._events = /* @__PURE__ */ Object.create(null);\n      this._eventsCount = 0;\n    }\n    this._maxListeners = this._maxListeners || void 0;\n  };\n  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n      throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n    }\n    this._maxListeners = n;\n    return this;\n  };\n  function _getMaxListeners(that) {\n    if (that._maxListeners === void 0)\n      return EventEmitter.defaultMaxListeners;\n    return that._maxListeners;\n  }\n  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n    return _getMaxListeners(this);\n  };\n  EventEmitter.prototype.emit = function emit(type2) {\n    var args = [];\n    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n    var doError = type2 === \"error\";\n    var events2 = this._events;\n    if (events2 !== void 0)\n      doError = doError && events2.error === void 0;\n    else if (!doError)\n      return false;\n    if (doError) {\n      var er;\n      if (args.length > 0)\n        er = args[0];\n      if (er instanceof Error) {\n        throw er;\n      }\n      var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n      err.context = er;\n      throw err;\n    }\n    var handler = events2[type2];\n    if (handler === void 0)\n      return false;\n    if (typeof handler === \"function\") {\n      ReflectApply(handler, this, args);\n    } else {\n      var len = handler.length;\n      var listeners = arrayClone(handler, len);\n      for (var i = 0; i < len; ++i)\n        ReflectApply(listeners[i], this, args);\n    }\n    return true;\n  };\n  function _addListener(target, type2, listener, prepend) {\n    var m;\n    var events2;\n    var existing;\n    checkListener(listener);\n    events2 = target._events;\n    if (events2 === void 0) {\n      events2 = target._events = /* @__PURE__ */ Object.create(null);\n      target._eventsCount = 0;\n    } else {\n      if (events2.newListener !== void 0) {\n        target.emit(\n          \"newListener\",\n          type2,\n          listener.listener ? listener.listener : listener\n        );\n        events2 = target._events;\n      }\n      existing = events2[type2];\n    }\n    if (existing === void 0) {\n      existing = events2[type2] = listener;\n      ++target._eventsCount;\n    } else {\n      if (typeof existing === \"function\") {\n        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];\n      } else if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n      m = _getMaxListeners(target);\n      if (m > 0 && existing.length > m && !existing.warned) {\n        existing.warned = true;\n        var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type2) + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n        w.name = \"MaxListenersExceededWarning\";\n        w.emitter = target;\n        w.type = type2;\n        w.count = existing.length;\n        ProcessEmitWarning(w);\n      }\n    }\n    return target;\n  }\n  EventEmitter.prototype.addListener = function addListener(type2, listener) {\n    return _addListener(this, type2, listener, false);\n  };\n  EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {\n    return _addListener(this, type2, listener, true);\n  };\n  function onceWrapper() {\n    if (!this.fired) {\n      this.target.removeListener(this.type, this.wrapFn);\n      this.fired = true;\n      if (arguments.length === 0)\n        return this.listener.call(this.target);\n      return this.listener.apply(this.target, arguments);\n    }\n  }\n  function _onceWrap(target, type2, listener) {\n    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };\n    var wrapped = onceWrapper.bind(state2);\n    wrapped.listener = listener;\n    state2.wrapFn = wrapped;\n    return wrapped;\n  }\n  EventEmitter.prototype.once = function once2(type2, listener) {\n    checkListener(listener);\n    this.on(type2, _onceWrap(this, type2, listener));\n    return this;\n  };\n  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {\n    checkListener(listener);\n    this.prependListener(type2, _onceWrap(this, type2, listener));\n    return this;\n  };\n  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {\n    var list, events2, position, i, originalListener;\n    checkListener(listener);\n    events2 = this._events;\n    if (events2 === void 0)\n      return this;\n    list = events2[type2];\n    if (list === void 0)\n      return this;\n    if (list === listener || list.listener === listener) {\n      if (--this._eventsCount === 0)\n        this._events = /* @__PURE__ */ Object.create(null);\n      else {\n        delete events2[type2];\n        if (events2.removeListener)\n          this.emit(\"removeListener\", type2, list.listener || listener);\n      }\n    } else if (typeof list !== \"function\") {\n      position = -1;\n      for (i = list.length - 1; i >= 0; i--) {\n        if (list[i] === listener || list[i].listener === listener) {\n          originalListener = list[i].listener;\n          position = i;\n          break;\n        }\n      }\n      if (position < 0)\n        return this;\n      if (position === 0)\n        list.shift();\n      else {\n        spliceOne(list, position);\n      }\n      if (list.length === 1)\n        events2[type2] = list[0];\n      if (events2.removeListener !== void 0)\n        this.emit(\"removeListener\", type2, originalListener || listener);\n    }\n    return this;\n  };\n  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {\n    var listeners, events2, i;\n    events2 = this._events;\n    if (events2 === void 0)\n      return this;\n    if (events2.removeListener === void 0) {\n      if (arguments.length === 0) {\n        this._events = /* @__PURE__ */ Object.create(null);\n        this._eventsCount = 0;\n      } else if (events2[type2] !== void 0) {\n        if (--this._eventsCount === 0)\n          this._events = /* @__PURE__ */ Object.create(null);\n        else\n          delete events2[type2];\n      }\n      return this;\n    }\n    if (arguments.length === 0) {\n      var keys = Object.keys(events2);\n      var key;\n      for (i = 0; i < keys.length; ++i) {\n        key = keys[i];\n        if (key === \"removeListener\") continue;\n        this.removeAllListeners(key);\n      }\n      this.removeAllListeners(\"removeListener\");\n      this._events = /* @__PURE__ */ Object.create(null);\n      this._eventsCount = 0;\n      return this;\n    }\n    listeners = events2[type2];\n    if (typeof listeners === \"function\") {\n      this.removeListener(type2, listeners);\n    } else if (listeners !== void 0) {\n      for (i = listeners.length - 1; i >= 0; i--) {\n        this.removeListener(type2, listeners[i]);\n      }\n    }\n    return this;\n  };\n  function _listeners(target, type2, unwrap) {\n    var events2 = target._events;\n    if (events2 === void 0)\n      return [];\n    var evlistener = events2[type2];\n    if (evlistener === void 0)\n      return [];\n    if (typeof evlistener === \"function\")\n      return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n  }\n  EventEmitter.prototype.listeners = function listeners(type2) {\n    return _listeners(this, type2, true);\n  };\n  EventEmitter.prototype.rawListeners = function rawListeners(type2) {\n    return _listeners(this, type2, false);\n  };\n  EventEmitter.listenerCount = function(emitter, type2) {\n    if (typeof emitter.listenerCount === \"function\") {\n      return emitter.listenerCount(type2);\n    } else {\n      return listenerCount.call(emitter, type2);\n    }\n  };\n  EventEmitter.prototype.listenerCount = listenerCount;\n  function listenerCount(type2) {\n    var events2 = this._events;\n    if (events2 !== void 0) {\n      var evlistener = events2[type2];\n      if (typeof evlistener === \"function\") {\n        return 1;\n      } else if (evlistener !== void 0) {\n        return evlistener.length;\n      }\n    }\n    return 0;\n  }\n  EventEmitter.prototype.eventNames = function eventNames() {\n    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n  };\n  function arrayClone(arr, n) {\n    var copy = new Array(n);\n    for (var i = 0; i < n; ++i)\n      copy[i] = arr[i];\n    return copy;\n  }\n  function spliceOne(list, index) {\n    for (; index + 1 < list.length; index++)\n      list[index] = list[index + 1];\n    list.pop();\n  }\n  function unwrapListeners(arr) {\n    var ret = new Array(arr.length);\n    for (var i = 0; i < ret.length; ++i) {\n      ret[i] = arr[i].listener || arr[i];\n    }\n    return ret;\n  }\n  function once(emitter, name) {\n    return new Promise(function(resolve, reject) {\n      function errorListener(err) {\n        emitter.removeListener(name, resolver);\n        reject(err);\n      }\n      function resolver() {\n        if (typeof emitter.removeListener === \"function\") {\n          emitter.removeListener(\"error\", errorListener);\n        }\n        resolve([].slice.call(arguments));\n      }\n      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n      if (name !== \"error\") {\n        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n      }\n    });\n  }\n  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n    if (typeof emitter.on === \"function\") {\n      eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n    }\n  }\n  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n    if (typeof emitter.on === \"function\") {\n      if (flags.once) {\n        emitter.once(name, listener);\n      } else {\n        emitter.on(name, listener);\n      }\n    } else if (typeof emitter.addEventListener === \"function\") {\n      emitter.addEventListener(name, function wrapListener(arg) {\n        if (flags.once) {\n          emitter.removeEventListener(name, wrapListener);\n        }\n        listener(arg);\n      });\n    } else {\n      throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n    }\n  }\n  return events.exports;\n}\nvar inherits_browser = { exports: {} };\nvar hasRequiredInherits_browser;\nfunction requireInherits_browser() {\n  if (hasRequiredInherits_browser) return inherits_browser.exports;\n  hasRequiredInherits_browser = 1;\n  if (typeof Object.create === \"function\") {\n    inherits_browser.exports = function inherits(ctor, superCtor) {\n      if (superCtor) {\n        ctor.super_ = superCtor;\n        ctor.prototype = Object.create(superCtor.prototype, {\n          constructor: {\n            value: ctor,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      }\n    };\n  } else {\n    inherits_browser.exports = function inherits(ctor, superCtor) {\n      if (superCtor) {\n        ctor.super_ = superCtor;\n        var TempCtor = function() {\n        };\n        TempCtor.prototype = superCtor.prototype;\n        ctor.prototype = new TempCtor();\n        ctor.prototype.constructor = ctor;\n      }\n    };\n  }\n  return inherits_browser.exports;\n}\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar browser$1 = { exports: {} };\nvar process = browser$1.exports = {};\nvar cachedSetTimeout;\nvar cachedClearTimeout;\nfunction defaultSetTimout() {\n  throw new Error(\"setTimeout has not been defined\");\n}\nfunction defaultClearTimeout() {\n  throw new Error(\"clearTimeout has not been defined\");\n}\n(function() {\n  try {\n    if (typeof setTimeout === \"function\") {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n  try {\n    if (typeof clearTimeout === \"function\") {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    return setTimeout(fun, 0);\n  }\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n  try {\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e2) {\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    return clearTimeout(marker);\n  }\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n  try {\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      return cachedClearTimeout.call(null, marker);\n    } catch (e2) {\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n  if (queue.length) {\n    drainQueue();\n  }\n}\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n    queueIndex = -1;\n    len = queue.length;\n  }\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\nprocess.nextTick = function(fun) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n  queue.push(new Item(fun, args));\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n};\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\nItem.prototype.run = function() {\n  this.fun.apply(null, this.array);\n};\nprocess.title = \"browser\";\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \"\";\nprocess.versions = {};\nfunction noop() {\n}\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\nprocess.listeners = function(name) {\n  return [];\n};\nprocess.binding = function(name) {\n  throw new Error(\"process.binding is not supported\");\n};\nprocess.cwd = function() {\n  return \"/\";\n};\nprocess.chdir = function(dir) {\n  throw new Error(\"process.chdir is not supported\");\n};\nprocess.umask = function() {\n  return 0;\n};\nvar browserExports = browser$1.exports;\nconst process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);\nvar streamBrowser;\nvar hasRequiredStreamBrowser;\nfunction requireStreamBrowser() {\n  if (hasRequiredStreamBrowser) return streamBrowser;\n  hasRequiredStreamBrowser = 1;\n  streamBrowser = requireEvents().EventEmitter;\n  return streamBrowser;\n}\nvar buffer = {};\nvar base64Js = {};\nvar hasRequiredBase64Js;\nfunction requireBase64Js() {\n  if (hasRequiredBase64Js) return base64Js;\n  hasRequiredBase64Js = 1;\n  base64Js.byteLength = byteLength;\n  base64Js.toByteArray = toByteArray;\n  base64Js.fromByteArray = fromByteArray;\n  var lookup = [];\n  var revLookup = [];\n  var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n  var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n  }\n  revLookup[\"-\".charCodeAt(0)] = 62;\n  revLookup[\"_\".charCodeAt(0)] = 63;\n  function getLens(b64) {\n    var len2 = b64.length;\n    if (len2 % 4 > 0) {\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    }\n    var validLen = b64.indexOf(\"=\");\n    if (validLen === -1) validLen = len2;\n    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n    return [validLen, placeHoldersLen];\n  }\n  function byteLength(b64) {\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n  function _byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n  }\n  function toByteArray(b64) {\n    var tmp;\n    var lens = getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i2;\n    for (i2 = 0; i2 < len2; i2 += 4) {\n      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n      arr[curByte++] = tmp >> 16 & 255;\n      arr[curByte++] = tmp >> 8 & 255;\n      arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 2) {\n      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n      arr[curByte++] = tmp & 255;\n    }\n    if (placeHoldersLen === 1) {\n      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n      arr[curByte++] = tmp >> 8 & 255;\n      arr[curByte++] = tmp & 255;\n    }\n    return arr;\n  }\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n  }\n  function encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for (var i2 = start; i2 < end; i2 += 3) {\n      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n      output.push(tripletToBase64(tmp));\n    }\n    return output.join(\"\");\n  }\n  function fromByteArray(uint8) {\n    var tmp;\n    var len2 = uint8.length;\n    var extraBytes = len2 % 3;\n    var parts = [];\n    var maxChunkLength = 16383;\n    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n    }\n    if (extraBytes === 1) {\n      tmp = uint8[len2 - 1];\n      parts.push(\n        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n      );\n    } else if (extraBytes === 2) {\n      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n      parts.push(\n        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n      );\n    }\n    return parts.join(\"\");\n  }\n  return base64Js;\n}\nvar ieee754 = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar hasRequiredIeee754;\nfunction requireIeee754() {\n  if (hasRequiredIeee754) return ieee754;\n  hasRequiredIeee754 = 1;\n  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer2[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n    }\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {\n    }\n    if (e === 0) {\n      e = 1 - eBias;\n    } else if (e === eMax) {\n      return m ? NaN : (s ? -1 : 1) * Infinity;\n    } else {\n      m = m + Math.pow(2, mLen);\n      e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n  };\n  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n      m = isNaN(value) ? 1 : 0;\n      e = eMax;\n    } else {\n      e = Math.floor(Math.log(value) / Math.LN2);\n      if (value * (c = Math.pow(2, -e)) < 1) {\n        e--;\n        c *= 2;\n      }\n      if (e + eBias >= 1) {\n        value += rt / c;\n      } else {\n        value += rt * Math.pow(2, 1 - eBias);\n      }\n      if (value * c >= 2) {\n        e++;\n        c /= 2;\n      }\n      if (e + eBias >= eMax) {\n        m = 0;\n        e = eMax;\n      } else if (e + eBias >= 1) {\n        m = (value * c - 1) * Math.pow(2, mLen);\n        e = e + eBias;\n      } else {\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n        e = 0;\n      }\n    }\n    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n    }\n    e = e << mLen | m;\n    eLen += mLen;\n    for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n    }\n    buffer2[offset + i - d] |= s * 128;\n  };\n  return ieee754;\n}\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\nvar hasRequiredBuffer;\nfunction requireBuffer() {\n  if (hasRequiredBuffer) return buffer;\n  hasRequiredBuffer = 1;\n  (function(exports) {\n    var base64 = requireBase64Js();\n    var ieee7542 = requireIeee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer2;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        var arr = new Uint8Array(1);\n        var proto = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer2.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer2.isBuffer(this)) return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer2.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer2.isBuffer(this)) return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      var buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function Buffer2(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer2.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      var valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer2.from(valueOf, encodingOrOffset, length);\n      }\n      var b = fromObject(value);\n      if (b) return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer2.from(\n          value[Symbol.toPrimitive](\"string\"),\n          encodingOrOffset,\n          length\n        );\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer2.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer2, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer2.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer2.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer2.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer2.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      var length = byteLength(string, encoding) | 0;\n      var buf = createBuffer(length);\n      var actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      var length = array.length < 0 ? 0 : checked(array.length) | 0;\n      var buf = createBuffer(length);\n      for (var i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        var copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      var buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer2.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer2.isBuffer(obj)) {\n        var len = checked(obj.length) | 0;\n        var buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer2.alloc(+length);\n    }\n    Buffer2.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer2.prototype;\n    };\n    Buffer2.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);\n      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b) return 0;\n      var x = a.length;\n      var y = b.length;\n      for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    Buffer2.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer2.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer2.alloc(0);\n      }\n      var i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      var buffer2 = Buffer2.allocUnsafe(length);\n      var pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        var buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer2.length) {\n            Buffer2.from(buf).copy(buffer2, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer2,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer2.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer2, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer2;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer2.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      var len = string.length;\n      var mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0) return 0;\n      var loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      var loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding) encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer2.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      var i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer2.prototype.swap16 = function swap16() {\n      var len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (var i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap32 = function swap32() {\n      var len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (var i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer2.prototype.swap64 = function swap64() {\n      var len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (var i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer2.prototype.toString = function toString() {\n      var length = this.length;\n      if (length === 0) return \"\";\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;\n    Buffer2.prototype.equals = function equals(b) {\n      if (!Buffer2.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b) return true;\n      return Buffer2.compare(this, b) === 0;\n    };\n    Buffer2.prototype.inspect = function inspect() {\n      var str = \"\";\n      var max2 = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max2).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max2) str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;\n    }\n    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer2.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer2.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      var x = thisEnd - thisStart;\n      var y = end - start;\n      var len = Math.min(x, y);\n      var thisCopy = this.slice(thisStart, thisEnd);\n      var targetCopy = target.slice(start, end);\n      for (var i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {\n      if (buffer2.length === 0) return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer2.length - 1;\n      }\n      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;\n      if (byteOffset >= buffer2.length) {\n        if (dir) return -1;\n        else byteOffset = buffer2.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer2.from(val, encoding);\n      }\n      if (Buffer2.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      var indexSize = 1;\n      var arrLength = arr.length;\n      var valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      var i;\n      if (dir) {\n        var foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          var found = true;\n          for (var j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found) return i;\n        }\n      }\n      return -1;\n    }\n    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      var remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      var strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      for (var i = 0; i < length; ++i) {\n        var parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer2.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0) encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      var remaining = this.length - offset;\n      if (length === void 0 || length > remaining) length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding) encoding = \"utf8\";\n      var loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer2.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      var res = [];\n      var i = start;\n      while (i < end) {\n        var firstByte = buf[i];\n        var codePoint = null;\n        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          var secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      var len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      var res = \"\";\n      var i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      var ret = \"\";\n      end = Math.min(buf.length, end);\n      for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      var ret = \"\";\n      end = Math.min(buf.length, end);\n      for (var i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      var len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      var out = \"\";\n      for (var i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      var bytes = buf.slice(start, end);\n      var res = \"\";\n      for (var i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer2.prototype.slice = function slice(start, end) {\n      var len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start) end = start;\n      var newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer2.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      var val = this[offset];\n      var mul = 1;\n      var i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      var val = this[offset + --byteLength2];\n      var mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      var val = this[offset];\n      var mul = 1;\n      var i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      var i = byteLength2;\n      var mul = 1;\n      var val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128)) return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      var val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      var val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee7542.read(this, offset, true, 23, 4);\n    };\n    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee7542.read(this, offset, false, 23, 4);\n    };\n    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee7542.read(this, offset, true, 52, 8);\n    };\n    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee7542.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max2, min2) {\n      if (!Buffer2.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max2 || value < min2) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    }\n    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      var mul = 1;\n      var i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      var i = byteLength2 - 1;\n      var mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      var i = 0;\n      var mul = 1;\n      var sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        var limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      var i = byteLength2 - 1;\n      var mul = 1;\n      var sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0) value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0) value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function checkIEEE754(buf, value, offset, ext, max2, min2) {\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n      if (offset < 0) throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4);\n      }\n      ieee7542.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8);\n      }\n      ieee7542.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer2.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start;\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n      if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length) end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      var len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer2.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer2.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          var code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val) val = 0;\n      var i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);\n        var len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2) return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      var codePoint;\n      var length = string.length;\n      var leadSurrogate = null;\n      var bytes = [];\n      for (var i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0) break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0) break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0) break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      var byteArray = [];\n      for (var i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      var c, hi, lo;\n      var byteArray = [];\n      for (var i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      for (var i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type2) {\n      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = function() {\n      var alphabet = \"0123456789abcdef\";\n      var table = new Array(256);\n      for (var i = 0; i < 16; ++i) {\n        var i16 = i * 16;\n        for (var j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    }();\n  })(buffer);\n  return buffer;\n}\nvar util = {};\nvar types = {};\nvar shams$1;\nvar hasRequiredShams$1;\nfunction requireShams$1() {\n  if (hasRequiredShams$1) return shams$1;\n  hasRequiredShams$1 = 1;\n  shams$1 = function hasSymbols2() {\n    if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n      return false;\n    }\n    if (typeof Symbol.iterator === \"symbol\") {\n      return true;\n    }\n    var obj = {};\n    var sym = Symbol(\"test\");\n    var symObj = Object(sym);\n    if (typeof sym === \"string\") {\n      return false;\n    }\n    if (Object.prototype.toString.call(sym) !== \"[object Symbol]\") {\n      return false;\n    }\n    if (Object.prototype.toString.call(symObj) !== \"[object Symbol]\") {\n      return false;\n    }\n    var symVal = 42;\n    obj[sym] = symVal;\n    for (var _ in obj) {\n      return false;\n    }\n    if (typeof Object.keys === \"function\" && Object.keys(obj).length !== 0) {\n      return false;\n    }\n    if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(obj).length !== 0) {\n      return false;\n    }\n    var syms = Object.getOwnPropertySymbols(obj);\n    if (syms.length !== 1 || syms[0] !== sym) {\n      return false;\n    }\n    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {\n      return false;\n    }\n    if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n      var descriptor = (\n        /** @type {PropertyDescriptor} */\n        Object.getOwnPropertyDescriptor(obj, sym)\n      );\n      if (descriptor.value !== symVal || descriptor.enumerable !== true) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return shams$1;\n}\nvar shams;\nvar hasRequiredShams;\nfunction requireShams() {\n  if (hasRequiredShams) return shams;\n  hasRequiredShams = 1;\n  var hasSymbols2 = requireShams$1();\n  shams = function hasToStringTagShams() {\n    return hasSymbols2() && !!Symbol.toStringTag;\n  };\n  return shams;\n}\nvar esObjectAtoms;\nvar hasRequiredEsObjectAtoms;\nfunction requireEsObjectAtoms() {\n  if (hasRequiredEsObjectAtoms) return esObjectAtoms;\n  hasRequiredEsObjectAtoms = 1;\n  esObjectAtoms = Object;\n  return esObjectAtoms;\n}\nvar esErrors;\nvar hasRequiredEsErrors;\nfunction requireEsErrors() {\n  if (hasRequiredEsErrors) return esErrors;\n  hasRequiredEsErrors = 1;\n  esErrors = Error;\n  return esErrors;\n}\nvar _eval;\nvar hasRequired_eval;\nfunction require_eval() {\n  if (hasRequired_eval) return _eval;\n  hasRequired_eval = 1;\n  _eval = EvalError;\n  return _eval;\n}\nvar range;\nvar hasRequiredRange;\nfunction requireRange() {\n  if (hasRequiredRange) return range;\n  hasRequiredRange = 1;\n  range = RangeError;\n  return range;\n}\nvar ref;\nvar hasRequiredRef;\nfunction requireRef() {\n  if (hasRequiredRef) return ref;\n  hasRequiredRef = 1;\n  ref = ReferenceError;\n  return ref;\n}\nvar syntax;\nvar hasRequiredSyntax;\nfunction requireSyntax() {\n  if (hasRequiredSyntax) return syntax;\n  hasRequiredSyntax = 1;\n  syntax = SyntaxError;\n  return syntax;\n}\nvar type;\nvar hasRequiredType;\nfunction requireType() {\n  if (hasRequiredType) return type;\n  hasRequiredType = 1;\n  type = TypeError;\n  return type;\n}\nvar uri;\nvar hasRequiredUri;\nfunction requireUri() {\n  if (hasRequiredUri) return uri;\n  hasRequiredUri = 1;\n  uri = URIError;\n  return uri;\n}\nvar abs;\nvar hasRequiredAbs;\nfunction requireAbs() {\n  if (hasRequiredAbs) return abs;\n  hasRequiredAbs = 1;\n  abs = Math.abs;\n  return abs;\n}\nvar floor;\nvar hasRequiredFloor;\nfunction requireFloor() {\n  if (hasRequiredFloor) return floor;\n  hasRequiredFloor = 1;\n  floor = Math.floor;\n  return floor;\n}\nvar max;\nvar hasRequiredMax;\nfunction requireMax() {\n  if (hasRequiredMax) return max;\n  hasRequiredMax = 1;\n  max = Math.max;\n  return max;\n}\nvar min;\nvar hasRequiredMin;\nfunction requireMin() {\n  if (hasRequiredMin) return min;\n  hasRequiredMin = 1;\n  min = Math.min;\n  return min;\n}\nvar pow;\nvar hasRequiredPow;\nfunction requirePow() {\n  if (hasRequiredPow) return pow;\n  hasRequiredPow = 1;\n  pow = Math.pow;\n  return pow;\n}\nvar round;\nvar hasRequiredRound;\nfunction requireRound() {\n  if (hasRequiredRound) return round;\n  hasRequiredRound = 1;\n  round = Math.round;\n  return round;\n}\nvar _isNaN;\nvar hasRequired_isNaN;\nfunction require_isNaN() {\n  if (hasRequired_isNaN) return _isNaN;\n  hasRequired_isNaN = 1;\n  _isNaN = Number.isNaN || function isNaN2(a) {\n    return a !== a;\n  };\n  return _isNaN;\n}\nvar sign;\nvar hasRequiredSign;\nfunction requireSign() {\n  if (hasRequiredSign) return sign;\n  hasRequiredSign = 1;\n  var $isNaN = /* @__PURE__ */ require_isNaN();\n  sign = function sign2(number) {\n    if ($isNaN(number) || number === 0) {\n      return number;\n    }\n    return number < 0 ? -1 : 1;\n  };\n  return sign;\n}\nvar gOPD;\nvar hasRequiredGOPD;\nfunction requireGOPD() {\n  if (hasRequiredGOPD) return gOPD;\n  hasRequiredGOPD = 1;\n  gOPD = Object.getOwnPropertyDescriptor;\n  return gOPD;\n}\nvar gopd;\nvar hasRequiredGopd;\nfunction requireGopd() {\n  if (hasRequiredGopd) return gopd;\n  hasRequiredGopd = 1;\n  var $gOPD = /* @__PURE__ */ requireGOPD();\n  if ($gOPD) {\n    try {\n      $gOPD([], \"length\");\n    } catch (e) {\n      $gOPD = null;\n    }\n  }\n  gopd = $gOPD;\n  return gopd;\n}\nvar esDefineProperty;\nvar hasRequiredEsDefineProperty;\nfunction requireEsDefineProperty() {\n  if (hasRequiredEsDefineProperty) return esDefineProperty;\n  hasRequiredEsDefineProperty = 1;\n  var $defineProperty = Object.defineProperty || false;\n  if ($defineProperty) {\n    try {\n      $defineProperty({}, \"a\", { value: 1 });\n    } catch (e) {\n      $defineProperty = false;\n    }\n  }\n  esDefineProperty = $defineProperty;\n  return esDefineProperty;\n}\nvar hasSymbols;\nvar hasRequiredHasSymbols;\nfunction requireHasSymbols() {\n  if (hasRequiredHasSymbols) return hasSymbols;\n  hasRequiredHasSymbols = 1;\n  var origSymbol = typeof Symbol !== \"undefined\" && Symbol;\n  var hasSymbolSham = requireShams$1();\n  hasSymbols = function hasNativeSymbols() {\n    if (typeof origSymbol !== \"function\") {\n      return false;\n    }\n    if (typeof Symbol !== \"function\") {\n      return false;\n    }\n    if (typeof origSymbol(\"foo\") !== \"symbol\") {\n      return false;\n    }\n    if (typeof Symbol(\"bar\") !== \"symbol\") {\n      return false;\n    }\n    return hasSymbolSham();\n  };\n  return hasSymbols;\n}\nvar Reflect_getPrototypeOf;\nvar hasRequiredReflect_getPrototypeOf;\nfunction requireReflect_getPrototypeOf() {\n  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;\n  hasRequiredReflect_getPrototypeOf = 1;\n  Reflect_getPrototypeOf = typeof Reflect !== \"undefined\" && Reflect.getPrototypeOf || null;\n  return Reflect_getPrototypeOf;\n}\nvar Object_getPrototypeOf;\nvar hasRequiredObject_getPrototypeOf;\nfunction requireObject_getPrototypeOf() {\n  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;\n  hasRequiredObject_getPrototypeOf = 1;\n  var $Object = /* @__PURE__ */ requireEsObjectAtoms();\n  Object_getPrototypeOf = $Object.getPrototypeOf || null;\n  return Object_getPrototypeOf;\n}\nvar implementation;\nvar hasRequiredImplementation;\nfunction requireImplementation() {\n  if (hasRequiredImplementation) return implementation;\n  hasRequiredImplementation = 1;\n  var ERROR_MESSAGE = \"Function.prototype.bind called on incompatible \";\n  var toStr = Object.prototype.toString;\n  var max2 = Math.max;\n  var funcType = \"[object Function]\";\n  var concatty = function concatty2(a, b) {\n    var arr = [];\n    for (var i = 0; i < a.length; i += 1) {\n      arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n      arr[j + a.length] = b[j];\n    }\n    return arr;\n  };\n  var slicy = function slicy2(arrLike, offset) {\n    var arr = [];\n    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {\n      arr[j] = arrLike[i];\n    }\n    return arr;\n  };\n  var joiny = function(arr, joiner) {\n    var str = \"\";\n    for (var i = 0; i < arr.length; i += 1) {\n      str += arr[i];\n      if (i + 1 < arr.length) {\n        str += joiner;\n      }\n    }\n    return str;\n  };\n  implementation = function bind(that) {\n    var target = this;\n    if (typeof target !== \"function\" || toStr.apply(target) !== funcType) {\n      throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n    var bound;\n    var binder = function() {\n      if (this instanceof bound) {\n        var result = target.apply(\n          this,\n          concatty(args, arguments)\n        );\n        if (Object(result) === result) {\n          return result;\n        }\n        return this;\n      }\n      return target.apply(\n        that,\n        concatty(args, arguments)\n      );\n    };\n    var boundLength = max2(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n      boundArgs[i] = \"$\" + i;\n    }\n    bound = Function(\"binder\", \"return function (\" + joiny(boundArgs, \",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n    if (target.prototype) {\n      var Empty = function Empty2() {\n      };\n      Empty.prototype = target.prototype;\n      bound.prototype = new Empty();\n      Empty.prototype = null;\n    }\n    return bound;\n  };\n  return implementation;\n}\nvar functionBind;\nvar hasRequiredFunctionBind;\nfunction requireFunctionBind() {\n  if (hasRequiredFunctionBind) return functionBind;\n  hasRequiredFunctionBind = 1;\n  var implementation2 = requireImplementation();\n  functionBind = Function.prototype.bind || implementation2;\n  return functionBind;\n}\nvar functionCall;\nvar hasRequiredFunctionCall;\nfunction requireFunctionCall() {\n  if (hasRequiredFunctionCall) return functionCall;\n  hasRequiredFunctionCall = 1;\n  functionCall = Function.prototype.call;\n  return functionCall;\n}\nvar functionApply;\nvar hasRequiredFunctionApply;\nfunction requireFunctionApply() {\n  if (hasRequiredFunctionApply) return functionApply;\n  hasRequiredFunctionApply = 1;\n  functionApply = Function.prototype.apply;\n  return functionApply;\n}\nvar reflectApply;\nvar hasRequiredReflectApply;\nfunction requireReflectApply() {\n  if (hasRequiredReflectApply) return reflectApply;\n  hasRequiredReflectApply = 1;\n  reflectApply = typeof Reflect !== \"undefined\" && Reflect && Reflect.apply;\n  return reflectApply;\n}\nvar actualApply;\nvar hasRequiredActualApply;\nfunction requireActualApply() {\n  if (hasRequiredActualApply) return actualApply;\n  hasRequiredActualApply = 1;\n  var bind = requireFunctionBind();\n  var $apply = requireFunctionApply();\n  var $call = requireFunctionCall();\n  var $reflectApply = requireReflectApply();\n  actualApply = $reflectApply || bind.call($call, $apply);\n  return actualApply;\n}\nvar callBindApplyHelpers;\nvar hasRequiredCallBindApplyHelpers;\nfunction requireCallBindApplyHelpers() {\n  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;\n  hasRequiredCallBindApplyHelpers = 1;\n  var bind = requireFunctionBind();\n  var $TypeError = /* @__PURE__ */ requireType();\n  var $call = requireFunctionCall();\n  var $actualApply = requireActualApply();\n  callBindApplyHelpers = function callBindBasic(args) {\n    if (args.length < 1 || typeof args[0] !== \"function\") {\n      throw new $TypeError(\"a function is required\");\n    }\n    return $actualApply(bind, $call, args);\n  };\n  return callBindApplyHelpers;\n}\nvar get;\nvar hasRequiredGet;\nfunction requireGet() {\n  if (hasRequiredGet) return get;\n  hasRequiredGet = 1;\n  var callBind2 = requireCallBindApplyHelpers();\n  var gOPD2 = /* @__PURE__ */ requireGopd();\n  var hasProtoAccessor;\n  try {\n    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */\n    [].__proto__ === Array.prototype;\n  } catch (e) {\n    if (!e || typeof e !== \"object\" || !(\"code\" in e) || e.code !== \"ERR_PROTO_ACCESS\") {\n      throw e;\n    }\n  }\n  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(\n    Object.prototype,\n    /** @type {keyof typeof Object.prototype} */\n    \"__proto__\"\n  );\n  var $Object = Object;\n  var $getPrototypeOf = $Object.getPrototypeOf;\n  get = desc && typeof desc.get === \"function\" ? callBind2([desc.get]) : typeof $getPrototypeOf === \"function\" ? (\n    /** @type {import('./get')} */\n    function getDunder(value) {\n      return $getPrototypeOf(value == null ? value : $Object(value));\n    }\n  ) : false;\n  return get;\n}\nvar getProto;\nvar hasRequiredGetProto;\nfunction requireGetProto() {\n  if (hasRequiredGetProto) return getProto;\n  hasRequiredGetProto = 1;\n  var reflectGetProto = requireReflect_getPrototypeOf();\n  var originalGetProto = requireObject_getPrototypeOf();\n  var getDunderProto = /* @__PURE__ */ requireGet();\n  getProto = reflectGetProto ? function getProto2(O) {\n    return reflectGetProto(O);\n  } : originalGetProto ? function getProto2(O) {\n    if (!O || typeof O !== \"object\" && typeof O !== \"function\") {\n      throw new TypeError(\"getProto: not an object\");\n    }\n    return originalGetProto(O);\n  } : getDunderProto ? function getProto2(O) {\n    return getDunderProto(O);\n  } : null;\n  return getProto;\n}\nvar hasown;\nvar hasRequiredHasown;\nfunction requireHasown() {\n  if (hasRequiredHasown) return hasown;\n  hasRequiredHasown = 1;\n  var call = Function.prototype.call;\n  var $hasOwn = Object.prototype.hasOwnProperty;\n  var bind = requireFunctionBind();\n  hasown = bind.call(call, $hasOwn);\n  return hasown;\n}\nvar getIntrinsic;\nvar hasRequiredGetIntrinsic;\nfunction requireGetIntrinsic() {\n  if (hasRequiredGetIntrinsic) return getIntrinsic;\n  hasRequiredGetIntrinsic = 1;\n  var undefined$1;\n  var $Object = /* @__PURE__ */ requireEsObjectAtoms();\n  var $Error = /* @__PURE__ */ requireEsErrors();\n  var $EvalError = /* @__PURE__ */ require_eval();\n  var $RangeError = /* @__PURE__ */ requireRange();\n  var $ReferenceError = /* @__PURE__ */ requireRef();\n  var $SyntaxError = /* @__PURE__ */ requireSyntax();\n  var $TypeError = /* @__PURE__ */ requireType();\n  var $URIError = /* @__PURE__ */ requireUri();\n  var abs2 = /* @__PURE__ */ requireAbs();\n  var floor2 = /* @__PURE__ */ requireFloor();\n  var max2 = /* @__PURE__ */ requireMax();\n  var min2 = /* @__PURE__ */ requireMin();\n  var pow2 = /* @__PURE__ */ requirePow();\n  var round2 = /* @__PURE__ */ requireRound();\n  var sign2 = /* @__PURE__ */ requireSign();\n  var $Function = Function;\n  var getEvalledConstructor = function(expressionSyntax) {\n    try {\n      return $Function('\"use strict\"; return (' + expressionSyntax + \").constructor;\")();\n    } catch (e) {\n    }\n  };\n  var $gOPD = /* @__PURE__ */ requireGopd();\n  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();\n  var throwTypeError = function() {\n    throw new $TypeError();\n  };\n  var ThrowTypeError = $gOPD ? function() {\n    try {\n      arguments.callee;\n      return throwTypeError;\n    } catch (calleeThrows) {\n      try {\n        return $gOPD(arguments, \"callee\").get;\n      } catch (gOPDthrows) {\n        return throwTypeError;\n      }\n    }\n  }() : throwTypeError;\n  var hasSymbols2 = requireHasSymbols()();\n  var getProto2 = requireGetProto();\n  var $ObjectGPO = requireObject_getPrototypeOf();\n  var $ReflectGPO = requireReflect_getPrototypeOf();\n  var $apply = requireFunctionApply();\n  var $call = requireFunctionCall();\n  var needsEval = {};\n  var TypedArray = typeof Uint8Array === \"undefined\" || !getProto2 ? undefined$1 : getProto2(Uint8Array);\n  var INTRINSICS = {\n    __proto__: null,\n    \"%AggregateError%\": typeof AggregateError === \"undefined\" ? undefined$1 : AggregateError,\n    \"%Array%\": Array,\n    \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? undefined$1 : ArrayBuffer,\n    \"%ArrayIteratorPrototype%\": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,\n    \"%AsyncFromSyncIteratorPrototype%\": undefined$1,\n    \"%AsyncFunction%\": needsEval,\n    \"%AsyncGenerator%\": needsEval,\n    \"%AsyncGeneratorFunction%\": needsEval,\n    \"%AsyncIteratorPrototype%\": needsEval,\n    \"%Atomics%\": typeof Atomics === \"undefined\" ? undefined$1 : Atomics,\n    \"%BigInt%\": typeof BigInt === \"undefined\" ? undefined$1 : BigInt,\n    \"%BigInt64Array%\": typeof BigInt64Array === \"undefined\" ? undefined$1 : BigInt64Array,\n    \"%BigUint64Array%\": typeof BigUint64Array === \"undefined\" ? undefined$1 : BigUint64Array,\n    \"%Boolean%\": Boolean,\n    \"%DataView%\": typeof DataView === \"undefined\" ? undefined$1 : DataView,\n    \"%Date%\": Date,\n    \"%decodeURI%\": decodeURI,\n    \"%decodeURIComponent%\": decodeURIComponent,\n    \"%encodeURI%\": encodeURI,\n    \"%encodeURIComponent%\": encodeURIComponent,\n    \"%Error%\": $Error,\n    \"%eval%\": eval,\n    // eslint-disable-line no-eval\n    \"%EvalError%\": $EvalError,\n    \"%Float16Array%\": typeof Float16Array === \"undefined\" ? undefined$1 : Float16Array,\n    \"%Float32Array%\": typeof Float32Array === \"undefined\" ? undefined$1 : Float32Array,\n    \"%Float64Array%\": typeof Float64Array === \"undefined\" ? undefined$1 : Float64Array,\n    \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? undefined$1 : FinalizationRegistry,\n    \"%Function%\": $Function,\n    \"%GeneratorFunction%\": needsEval,\n    \"%Int8Array%\": typeof Int8Array === \"undefined\" ? undefined$1 : Int8Array,\n    \"%Int16Array%\": typeof Int16Array === \"undefined\" ? undefined$1 : Int16Array,\n    \"%Int32Array%\": typeof Int32Array === \"undefined\" ? undefined$1 : Int32Array,\n    \"%isFinite%\": isFinite,\n    \"%isNaN%\": isNaN,\n    \"%IteratorPrototype%\": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,\n    \"%JSON%\": typeof JSON === \"object\" ? JSON : undefined$1,\n    \"%Map%\": typeof Map === \"undefined\" ? undefined$1 : Map,\n    \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),\n    \"%Math%\": Math,\n    \"%Number%\": Number,\n    \"%Object%\": $Object,\n    \"%Object.getOwnPropertyDescriptor%\": $gOPD,\n    \"%parseFloat%\": parseFloat,\n    \"%parseInt%\": parseInt,\n    \"%Promise%\": typeof Promise === \"undefined\" ? undefined$1 : Promise,\n    \"%Proxy%\": typeof Proxy === \"undefined\" ? undefined$1 : Proxy,\n    \"%RangeError%\": $RangeError,\n    \"%ReferenceError%\": $ReferenceError,\n    \"%Reflect%\": typeof Reflect === \"undefined\" ? undefined$1 : Reflect,\n    \"%RegExp%\": RegExp,\n    \"%Set%\": typeof Set === \"undefined\" ? undefined$1 : Set,\n    \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),\n    \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? undefined$1 : SharedArrayBuffer,\n    \"%String%\": String,\n    \"%StringIteratorPrototype%\": hasSymbols2 && getProto2 ? getProto2(\"\"[Symbol.iterator]()) : undefined$1,\n    \"%Symbol%\": hasSymbols2 ? Symbol : undefined$1,\n    \"%SyntaxError%\": $SyntaxError,\n    \"%ThrowTypeError%\": ThrowTypeError,\n    \"%TypedArray%\": TypedArray,\n    \"%TypeError%\": $TypeError,\n    \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? undefined$1 : Uint8Array,\n    \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? undefined$1 : Uint8ClampedArray,\n    \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? undefined$1 : Uint16Array,\n    \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? undefined$1 : Uint32Array,\n    \"%URIError%\": $URIError,\n    \"%WeakMap%\": typeof WeakMap === \"undefined\" ? undefined$1 : WeakMap,\n    \"%WeakRef%\": typeof WeakRef === \"undefined\" ? undefined$1 : WeakRef,\n    \"%WeakSet%\": typeof WeakSet === \"undefined\" ? undefined$1 : WeakSet,\n    \"%Function.prototype.call%\": $call,\n    \"%Function.prototype.apply%\": $apply,\n    \"%Object.defineProperty%\": $defineProperty,\n    \"%Object.getPrototypeOf%\": $ObjectGPO,\n    \"%Math.abs%\": abs2,\n    \"%Math.floor%\": floor2,\n    \"%Math.max%\": max2,\n    \"%Math.min%\": min2,\n    \"%Math.pow%\": pow2,\n    \"%Math.round%\": round2,\n    \"%Math.sign%\": sign2,\n    \"%Reflect.getPrototypeOf%\": $ReflectGPO\n  };\n  if (getProto2) {\n    try {\n      null.error;\n    } catch (e) {\n      var errorProto = getProto2(getProto2(e));\n      INTRINSICS[\"%Error.prototype%\"] = errorProto;\n    }\n  }\n  var doEval = function doEval2(name) {\n    var value;\n    if (name === \"%AsyncFunction%\") {\n      value = getEvalledConstructor(\"async function () {}\");\n    } else if (name === \"%GeneratorFunction%\") {\n      value = getEvalledConstructor(\"function* () {}\");\n    } else if (name === \"%AsyncGeneratorFunction%\") {\n      value = getEvalledConstructor(\"async function* () {}\");\n    } else if (name === \"%AsyncGenerator%\") {\n      var fn = doEval2(\"%AsyncGeneratorFunction%\");\n      if (fn) {\n        value = fn.prototype;\n      }\n    } else if (name === \"%AsyncIteratorPrototype%\") {\n      var gen = doEval2(\"%AsyncGenerator%\");\n      if (gen && getProto2) {\n        value = getProto2(gen.prototype);\n      }\n    }\n    INTRINSICS[name] = value;\n    return value;\n  };\n  var LEGACY_ALIASES = {\n    __proto__: null,\n    \"%ArrayBufferPrototype%\": [\"ArrayBuffer\", \"prototype\"],\n    \"%ArrayPrototype%\": [\"Array\", \"prototype\"],\n    \"%ArrayProto_entries%\": [\"Array\", \"prototype\", \"entries\"],\n    \"%ArrayProto_forEach%\": [\"Array\", \"prototype\", \"forEach\"],\n    \"%ArrayProto_keys%\": [\"Array\", \"prototype\", \"keys\"],\n    \"%ArrayProto_values%\": [\"Array\", \"prototype\", \"values\"],\n    \"%AsyncFunctionPrototype%\": [\"AsyncFunction\", \"prototype\"],\n    \"%AsyncGenerator%\": [\"AsyncGeneratorFunction\", \"prototype\"],\n    \"%AsyncGeneratorPrototype%\": [\"AsyncGeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%BooleanPrototype%\": [\"Boolean\", \"prototype\"],\n    \"%DataViewPrototype%\": [\"DataView\", \"prototype\"],\n    \"%DatePrototype%\": [\"Date\", \"prototype\"],\n    \"%ErrorPrototype%\": [\"Error\", \"prototype\"],\n    \"%EvalErrorPrototype%\": [\"EvalError\", \"prototype\"],\n    \"%Float32ArrayPrototype%\": [\"Float32Array\", \"prototype\"],\n    \"%Float64ArrayPrototype%\": [\"Float64Array\", \"prototype\"],\n    \"%FunctionPrototype%\": [\"Function\", \"prototype\"],\n    \"%Generator%\": [\"GeneratorFunction\", \"prototype\"],\n    \"%GeneratorPrototype%\": [\"GeneratorFunction\", \"prototype\", \"prototype\"],\n    \"%Int8ArrayPrototype%\": [\"Int8Array\", \"prototype\"],\n    \"%Int16ArrayPrototype%\": [\"Int16Array\", \"prototype\"],\n    \"%Int32ArrayPrototype%\": [\"Int32Array\", \"prototype\"],\n    \"%JSONParse%\": [\"JSON\", \"parse\"],\n    \"%JSONStringify%\": [\"JSON\", \"stringify\"],\n    \"%MapPrototype%\": [\"Map\", \"prototype\"],\n    \"%NumberPrototype%\": [\"Number\", \"prototype\"],\n    \"%ObjectPrototype%\": [\"Object\", \"prototype\"],\n    \"%ObjProto_toString%\": [\"Object\", \"prototype\", \"toString\"],\n    \"%ObjProto_valueOf%\": [\"Object\", \"prototype\", \"valueOf\"],\n    \"%PromisePrototype%\": [\"Promise\", \"prototype\"],\n    \"%PromiseProto_then%\": [\"Promise\", \"prototype\", \"then\"],\n    \"%Promise_all%\": [\"Promise\", \"all\"],\n    \"%Promise_reject%\": [\"Promise\", \"reject\"],\n    \"%Promise_resolve%\": [\"Promise\", \"resolve\"],\n    \"%RangeErrorPrototype%\": [\"RangeError\", \"prototype\"],\n    \"%ReferenceErrorPrototype%\": [\"ReferenceError\", \"prototype\"],\n    \"%RegExpPrototype%\": [\"RegExp\", \"prototype\"],\n    \"%SetPrototype%\": [\"Set\", \"prototype\"],\n    \"%SharedArrayBufferPrototype%\": [\"SharedArrayBuffer\", \"prototype\"],\n    \"%StringPrototype%\": [\"String\", \"prototype\"],\n    \"%SymbolPrototype%\": [\"Symbol\", \"prototype\"],\n    \"%SyntaxErrorPrototype%\": [\"SyntaxError\", \"prototype\"],\n    \"%TypedArrayPrototype%\": [\"TypedArray\", \"prototype\"],\n    \"%TypeErrorPrototype%\": [\"TypeError\", \"prototype\"],\n    \"%Uint8ArrayPrototype%\": [\"Uint8Array\", \"prototype\"],\n    \"%Uint8ClampedArrayPrototype%\": [\"Uint8ClampedArray\", \"prototype\"],\n    \"%Uint16ArrayPrototype%\": [\"Uint16Array\", \"prototype\"],\n    \"%Uint32ArrayPrototype%\": [\"Uint32Array\", \"prototype\"],\n    \"%URIErrorPrototype%\": [\"URIError\", \"prototype\"],\n    \"%WeakMapPrototype%\": [\"WeakMap\", \"prototype\"],\n    \"%WeakSetPrototype%\": [\"WeakSet\", \"prototype\"]\n  };\n  var bind = requireFunctionBind();\n  var hasOwn = /* @__PURE__ */ requireHasown();\n  var $concat = bind.call($call, Array.prototype.concat);\n  var $spliceApply = bind.call($apply, Array.prototype.splice);\n  var $replace = bind.call($call, String.prototype.replace);\n  var $strSlice = bind.call($call, String.prototype.slice);\n  var $exec = bind.call($call, RegExp.prototype.exec);\n  var rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n  var reEscapeChar = /\\\\(\\\\)?/g;\n  var stringToPath = function stringToPath2(string) {\n    var first = $strSlice(string, 0, 1);\n    var last = $strSlice(string, -1);\n    if (first === \"%\" && last !== \"%\") {\n      throw new $SyntaxError(\"invalid intrinsic syntax, expected closing `%`\");\n    } else if (last === \"%\" && first !== \"%\") {\n      throw new $SyntaxError(\"invalid intrinsic syntax, expected opening `%`\");\n    }\n    var result = [];\n    $replace(string, rePropName, function(match, number, quote, subString) {\n      result[result.length] = quote ? $replace(subString, reEscapeChar, \"$1\") : number || match;\n    });\n    return result;\n  };\n  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {\n    var intrinsicName = name;\n    var alias;\n    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n      alias = LEGACY_ALIASES[intrinsicName];\n      intrinsicName = \"%\" + alias[0] + \"%\";\n    }\n    if (hasOwn(INTRINSICS, intrinsicName)) {\n      var value = INTRINSICS[intrinsicName];\n      if (value === needsEval) {\n        value = doEval(intrinsicName);\n      }\n      if (typeof value === \"undefined\" && !allowMissing) {\n        throw new $TypeError(\"intrinsic \" + name + \" exists, but is not available. Please file an issue!\");\n      }\n      return {\n        alias,\n        name: intrinsicName,\n        value\n      };\n    }\n    throw new $SyntaxError(\"intrinsic \" + name + \" does not exist!\");\n  };\n  getIntrinsic = function GetIntrinsic(name, allowMissing) {\n    if (typeof name !== \"string\" || name.length === 0) {\n      throw new $TypeError(\"intrinsic name must be a non-empty string\");\n    }\n    if (arguments.length > 1 && typeof allowMissing !== \"boolean\") {\n      throw new $TypeError('\"allowMissing\" argument must be a boolean');\n    }\n    if ($exec(/^%?[^%]*%?$/, name) === null) {\n      throw new $SyntaxError(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n    }\n    var parts = stringToPath(name);\n    var intrinsicBaseName = parts.length > 0 ? parts[0] : \"\";\n    var intrinsic = getBaseIntrinsic(\"%\" + intrinsicBaseName + \"%\", allowMissing);\n    var intrinsicRealName = intrinsic.name;\n    var value = intrinsic.value;\n    var skipFurtherCaching = false;\n    var alias = intrinsic.alias;\n    if (alias) {\n      intrinsicBaseName = alias[0];\n      $spliceApply(parts, $concat([0, 1], alias));\n    }\n    for (var i = 1, isOwn = true; i < parts.length; i += 1) {\n      var part = parts[i];\n      var first = $strSlice(part, 0, 1);\n      var last = $strSlice(part, -1);\n      if ((first === '\"' || first === \"'\" || first === \"`\" || (last === '\"' || last === \"'\" || last === \"`\")) && first !== last) {\n        throw new $SyntaxError(\"property names with quotes must have matching quotes\");\n      }\n      if (part === \"constructor\" || !isOwn) {\n        skipFurtherCaching = true;\n      }\n      intrinsicBaseName += \".\" + part;\n      intrinsicRealName = \"%\" + intrinsicBaseName + \"%\";\n      if (hasOwn(INTRINSICS, intrinsicRealName)) {\n        value = INTRINSICS[intrinsicRealName];\n      } else if (value != null) {\n        if (!(part in value)) {\n          if (!allowMissing) {\n            throw new $TypeError(\"base intrinsic for \" + name + \" exists, but the property is not available.\");\n          }\n          return void 0;\n        }\n        if ($gOPD && i + 1 >= parts.length) {\n          var desc = $gOPD(value, part);\n          isOwn = !!desc;\n          if (isOwn && \"get\" in desc && !(\"originalValue\" in desc.get)) {\n            value = desc.get;\n          } else {\n            value = value[part];\n          }\n        } else {\n          isOwn = hasOwn(value, part);\n          value = value[part];\n        }\n        if (isOwn && !skipFurtherCaching) {\n          INTRINSICS[intrinsicRealName] = value;\n        }\n      }\n    }\n    return value;\n  };\n  return getIntrinsic;\n}\nvar callBind = { exports: {} };\nvar defineDataProperty;\nvar hasRequiredDefineDataProperty;\nfunction requireDefineDataProperty() {\n  if (hasRequiredDefineDataProperty) return defineDataProperty;\n  hasRequiredDefineDataProperty = 1;\n  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();\n  var $SyntaxError = /* @__PURE__ */ requireSyntax();\n  var $TypeError = /* @__PURE__ */ requireType();\n  var gopd2 = /* @__PURE__ */ requireGopd();\n  defineDataProperty = function defineDataProperty2(obj, property, value) {\n    if (!obj || typeof obj !== \"object\" && typeof obj !== \"function\") {\n      throw new $TypeError(\"`obj` must be an object or a function`\");\n    }\n    if (typeof property !== \"string\" && typeof property !== \"symbol\") {\n      throw new $TypeError(\"`property` must be a string or a symbol`\");\n    }\n    if (arguments.length > 3 && typeof arguments[3] !== \"boolean\" && arguments[3] !== null) {\n      throw new $TypeError(\"`nonEnumerable`, if provided, must be a boolean or null\");\n    }\n    if (arguments.length > 4 && typeof arguments[4] !== \"boolean\" && arguments[4] !== null) {\n      throw new $TypeError(\"`nonWritable`, if provided, must be a boolean or null\");\n    }\n    if (arguments.length > 5 && typeof arguments[5] !== \"boolean\" && arguments[5] !== null) {\n      throw new $TypeError(\"`nonConfigurable`, if provided, must be a boolean or null\");\n    }\n    if (arguments.length > 6 && typeof arguments[6] !== \"boolean\") {\n      throw new $TypeError(\"`loose`, if provided, must be a boolean\");\n    }\n    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;\n    var nonWritable = arguments.length > 4 ? arguments[4] : null;\n    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;\n    var loose = arguments.length > 6 ? arguments[6] : false;\n    var desc = !!gopd2 && gopd2(obj, property);\n    if ($defineProperty) {\n      $defineProperty(obj, property, {\n        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,\n        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,\n        value,\n        writable: nonWritable === null && desc ? desc.writable : !nonWritable\n      });\n    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {\n      obj[property] = value;\n    } else {\n      throw new $SyntaxError(\"This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.\");\n    }\n  };\n  return defineDataProperty;\n}\nvar hasPropertyDescriptors_1;\nvar hasRequiredHasPropertyDescriptors;\nfunction requireHasPropertyDescriptors() {\n  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;\n  hasRequiredHasPropertyDescriptors = 1;\n  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();\n  var hasPropertyDescriptors = function hasPropertyDescriptors2() {\n    return !!$defineProperty;\n  };\n  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {\n    if (!$defineProperty) {\n      return null;\n    }\n    try {\n      return $defineProperty([], \"length\", { value: 1 }).length !== 1;\n    } catch (e) {\n      return true;\n    }\n  };\n  hasPropertyDescriptors_1 = hasPropertyDescriptors;\n  return hasPropertyDescriptors_1;\n}\nvar setFunctionLength;\nvar hasRequiredSetFunctionLength;\nfunction requireSetFunctionLength() {\n  if (hasRequiredSetFunctionLength) return setFunctionLength;\n  hasRequiredSetFunctionLength = 1;\n  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();\n  var define = /* @__PURE__ */ requireDefineDataProperty();\n  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();\n  var gOPD2 = /* @__PURE__ */ requireGopd();\n  var $TypeError = /* @__PURE__ */ requireType();\n  var $floor = GetIntrinsic(\"%Math.floor%\");\n  setFunctionLength = function setFunctionLength2(fn, length) {\n    if (typeof fn !== \"function\") {\n      throw new $TypeError(\"`fn` is not a function\");\n    }\n    if (typeof length !== \"number\" || length < 0 || length > 4294967295 || $floor(length) !== length) {\n      throw new $TypeError(\"`length` must be a positive 32-bit integer\");\n    }\n    var loose = arguments.length > 2 && !!arguments[2];\n    var functionLengthIsConfigurable = true;\n    var functionLengthIsWritable = true;\n    if (\"length\" in fn && gOPD2) {\n      var desc = gOPD2(fn, \"length\");\n      if (desc && !desc.configurable) {\n        functionLengthIsConfigurable = false;\n      }\n      if (desc && !desc.writable) {\n        functionLengthIsWritable = false;\n      }\n    }\n    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {\n      if (hasDescriptors) {\n        define(\n          /** @type {Parameters<define>[0]} */\n          fn,\n          \"length\",\n          length,\n          true,\n          true\n        );\n      } else {\n        define(\n          /** @type {Parameters<define>[0]} */\n          fn,\n          \"length\",\n          length\n        );\n      }\n    }\n    return fn;\n  };\n  return setFunctionLength;\n}\nvar hasRequiredCallBind;\nfunction requireCallBind() {\n  if (hasRequiredCallBind) return callBind.exports;\n  hasRequiredCallBind = 1;\n  (function(module) {\n    var bind = requireFunctionBind();\n    var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();\n    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();\n    var $TypeError = /* @__PURE__ */ requireType();\n    var $apply = GetIntrinsic(\"%Function.prototype.apply%\");\n    var $call = GetIntrinsic(\"%Function.prototype.call%\");\n    var $reflectApply = GetIntrinsic(\"%Reflect.apply%\", true) || bind.call($call, $apply);\n    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();\n    var $max = GetIntrinsic(\"%Math.max%\");\n    module.exports = function callBind2(originalFunction) {\n      if (typeof originalFunction !== \"function\") {\n        throw new $TypeError(\"a function is required\");\n      }\n      var func = $reflectApply(bind, $call, arguments);\n      return setFunctionLength2(\n        func,\n        1 + $max(0, originalFunction.length - (arguments.length - 1)),\n        true\n      );\n    };\n    var applyBind = function applyBind2() {\n      return $reflectApply(bind, $apply, arguments);\n    };\n    if ($defineProperty) {\n      $defineProperty(module.exports, \"apply\", { value: applyBind });\n    } else {\n      module.exports.apply = applyBind;\n    }\n  })(callBind);\n  return callBind.exports;\n}\nvar callBound;\nvar hasRequiredCallBound;\nfunction requireCallBound() {\n  if (hasRequiredCallBound) return callBound;\n  hasRequiredCallBound = 1;\n  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();\n  var callBind2 = requireCallBind();\n  var $indexOf = callBind2(GetIntrinsic(\"String.prototype.indexOf\"));\n  callBound = function callBoundIntrinsic(name, allowMissing) {\n    var intrinsic = GetIntrinsic(name, !!allowMissing);\n    if (typeof intrinsic === \"function\" && $indexOf(name, \".prototype.\") > -1) {\n      return callBind2(intrinsic);\n    }\n    return intrinsic;\n  };\n  return callBound;\n}\nvar isArguments;\nvar hasRequiredIsArguments;\nfunction requireIsArguments() {\n  if (hasRequiredIsArguments) return isArguments;\n  hasRequiredIsArguments = 1;\n  var hasToStringTag = requireShams()();\n  var callBound2 = requireCallBound();\n  var $toString = callBound2(\"Object.prototype.toString\");\n  var isStandardArguments = function isArguments2(value) {\n    if (hasToStringTag && value && typeof value === \"object\" && Symbol.toStringTag in value) {\n      return false;\n    }\n    return $toString(value) === \"[object Arguments]\";\n  };\n  var isLegacyArguments = function isArguments2(value) {\n    if (isStandardArguments(value)) {\n      return true;\n    }\n    return value !== null && typeof value === \"object\" && typeof value.length === \"number\" && value.length >= 0 && $toString(value) !== \"[object Array]\" && $toString(value.callee) === \"[object Function]\";\n  };\n  var supportsStandardArguments = function() {\n    return isStandardArguments(arguments);\n  }();\n  isStandardArguments.isLegacyArguments = isLegacyArguments;\n  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n  return isArguments;\n}\nvar isGeneratorFunction;\nvar hasRequiredIsGeneratorFunction;\nfunction requireIsGeneratorFunction() {\n  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;\n  hasRequiredIsGeneratorFunction = 1;\n  var toStr = Object.prototype.toString;\n  var fnToStr = Function.prototype.toString;\n  var isFnRegex = /^\\s*(?:function)?\\*/;\n  var hasToStringTag = requireShams()();\n  var getProto2 = Object.getPrototypeOf;\n  var getGeneratorFunc = function() {\n    if (!hasToStringTag) {\n      return false;\n    }\n    try {\n      return Function(\"return function*() {}\")();\n    } catch (e) {\n    }\n  };\n  var GeneratorFunction;\n  isGeneratorFunction = function isGeneratorFunction2(fn) {\n    if (typeof fn !== \"function\") {\n      return false;\n    }\n    if (isFnRegex.test(fnToStr.call(fn))) {\n      return true;\n    }\n    if (!hasToStringTag) {\n      var str = toStr.call(fn);\n      return str === \"[object GeneratorFunction]\";\n    }\n    if (!getProto2) {\n      return false;\n    }\n    if (typeof GeneratorFunction === \"undefined\") {\n      var generatorFunc = getGeneratorFunc();\n      GeneratorFunction = generatorFunc ? getProto2(generatorFunc) : false;\n    }\n    return getProto2(fn) === GeneratorFunction;\n  };\n  return isGeneratorFunction;\n}\nvar isCallable;\nvar hasRequiredIsCallable;\nfunction requireIsCallable() {\n  if (hasRequiredIsCallable) return isCallable;\n  hasRequiredIsCallable = 1;\n  var fnToStr = Function.prototype.toString;\n  var reflectApply2 = typeof Reflect === \"object\" && Reflect !== null && Reflect.apply;\n  var badArrayLike;\n  var isCallableMarker;\n  if (typeof reflectApply2 === \"function\" && typeof Object.defineProperty === \"function\") {\n    try {\n      badArrayLike = Object.defineProperty({}, \"length\", {\n        get: function() {\n          throw isCallableMarker;\n        }\n      });\n      isCallableMarker = {};\n      reflectApply2(function() {\n        throw 42;\n      }, null, badArrayLike);\n    } catch (_) {\n      if (_ !== isCallableMarker) {\n        reflectApply2 = null;\n      }\n    }\n  } else {\n    reflectApply2 = null;\n  }\n  var constructorRegex = /^\\s*class\\b/;\n  var isES6ClassFn = function isES6ClassFunction(value) {\n    try {\n      var fnStr = fnToStr.call(value);\n      return constructorRegex.test(fnStr);\n    } catch (e) {\n      return false;\n    }\n  };\n  var tryFunctionObject = function tryFunctionToStr(value) {\n    try {\n      if (isES6ClassFn(value)) {\n        return false;\n      }\n      fnToStr.call(value);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n  var toStr = Object.prototype.toString;\n  var objectClass = \"[object Object]\";\n  var fnClass = \"[object Function]\";\n  var genClass = \"[object GeneratorFunction]\";\n  var ddaClass = \"[object HTMLAllCollection]\";\n  var ddaClass2 = \"[object HTML document.all class]\";\n  var ddaClass3 = \"[object HTMLCollection]\";\n  var hasToStringTag = typeof Symbol === \"function\" && !!Symbol.toStringTag;\n  var isIE68 = !(0 in [,]);\n  var isDDA = function isDocumentDotAll() {\n    return false;\n  };\n  if (typeof document === \"object\") {\n    var all = document.all;\n    if (toStr.call(all) === toStr.call(document.all)) {\n      isDDA = function isDocumentDotAll(value) {\n        if ((isIE68 || !value) && (typeof value === \"undefined\" || typeof value === \"object\")) {\n          try {\n            var str = toStr.call(value);\n            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value(\"\") == null;\n          } catch (e) {\n          }\n        }\n        return false;\n      };\n    }\n  }\n  isCallable = reflectApply2 ? function isCallable2(value) {\n    if (isDDA(value)) {\n      return true;\n    }\n    if (!value) {\n      return false;\n    }\n    if (typeof value !== \"function\" && typeof value !== \"object\") {\n      return false;\n    }\n    try {\n      reflectApply2(value, null, badArrayLike);\n    } catch (e) {\n      if (e !== isCallableMarker) {\n        return false;\n      }\n    }\n    return !isES6ClassFn(value) && tryFunctionObject(value);\n  } : function isCallable2(value) {\n    if (isDDA(value)) {\n      return true;\n    }\n    if (!value) {\n      return false;\n    }\n    if (typeof value !== \"function\" && typeof value !== \"object\") {\n      return false;\n    }\n    if (hasToStringTag) {\n      return tryFunctionObject(value);\n    }\n    if (isES6ClassFn(value)) {\n      return false;\n    }\n    var strClass = toStr.call(value);\n    if (strClass !== fnClass && strClass !== genClass && !/^\\[object HTML/.test(strClass)) {\n      return false;\n    }\n    return tryFunctionObject(value);\n  };\n  return isCallable;\n}\nvar forEach_1;\nvar hasRequiredForEach;\nfunction requireForEach() {\n  if (hasRequiredForEach) return forEach_1;\n  hasRequiredForEach = 1;\n  var isCallable2 = requireIsCallable();\n  var toStr = Object.prototype.toString;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var forEachArray = function forEachArray2(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (hasOwnProperty.call(array, i)) {\n        if (receiver == null) {\n          iterator(array[i], i, array);\n        } else {\n          iterator.call(receiver, array[i], i, array);\n        }\n      }\n    }\n  };\n  var forEachString = function forEachString2(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n      if (receiver == null) {\n        iterator(string.charAt(i), i, string);\n      } else {\n        iterator.call(receiver, string.charAt(i), i, string);\n      }\n    }\n  };\n  var forEachObject = function forEachObject2(object, iterator, receiver) {\n    for (var k in object) {\n      if (hasOwnProperty.call(object, k)) {\n        if (receiver == null) {\n          iterator(object[k], k, object);\n        } else {\n          iterator.call(receiver, object[k], k, object);\n        }\n      }\n    }\n  };\n  var forEach = function forEach2(list, iterator, thisArg) {\n    if (!isCallable2(iterator)) {\n      throw new TypeError(\"iterator must be a function\");\n    }\n    var receiver;\n    if (arguments.length >= 3) {\n      receiver = thisArg;\n    }\n    if (toStr.call(list) === \"[object Array]\") {\n      forEachArray(list, iterator, receiver);\n    } else if (typeof list === \"string\") {\n      forEachString(list, iterator, receiver);\n    } else {\n      forEachObject(list, iterator, receiver);\n    }\n  };\n  forEach_1 = forEach;\n  return forEach_1;\n}\nvar possibleTypedArrayNames;\nvar hasRequiredPossibleTypedArrayNames;\nfunction requirePossibleTypedArrayNames() {\n  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;\n  hasRequiredPossibleTypedArrayNames = 1;\n  possibleTypedArrayNames = [\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\"\n  ];\n  return possibleTypedArrayNames;\n}\nvar availableTypedArrays;\nvar hasRequiredAvailableTypedArrays;\nfunction requireAvailableTypedArrays() {\n  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;\n  hasRequiredAvailableTypedArrays = 1;\n  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();\n  var g = typeof globalThis === \"undefined\" ? commonjsGlobal : globalThis;\n  availableTypedArrays = function availableTypedArrays2() {\n    var out = [];\n    for (var i = 0; i < possibleNames.length; i++) {\n      if (typeof g[possibleNames[i]] === \"function\") {\n        out[out.length] = possibleNames[i];\n      }\n    }\n    return out;\n  };\n  return availableTypedArrays;\n}\nvar whichTypedArray;\nvar hasRequiredWhichTypedArray;\nfunction requireWhichTypedArray() {\n  if (hasRequiredWhichTypedArray) return whichTypedArray;\n  hasRequiredWhichTypedArray = 1;\n  var forEach = requireForEach();\n  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();\n  var callBind2 = requireCallBind();\n  var callBound2 = requireCallBound();\n  var gOPD2 = /* @__PURE__ */ requireGopd();\n  var $toString = callBound2(\"Object.prototype.toString\");\n  var hasToStringTag = requireShams()();\n  var g = typeof globalThis === \"undefined\" ? commonjsGlobal : globalThis;\n  var typedArrays = availableTypedArrays2();\n  var $slice = callBound2(\"String.prototype.slice\");\n  var getPrototypeOf = Object.getPrototypeOf;\n  var $indexOf = callBound2(\"Array.prototype.indexOf\", true) || function indexOf(array, value) {\n    for (var i = 0; i < array.length; i += 1) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  var cache = { __proto__: null };\n  if (hasToStringTag && gOPD2 && getPrototypeOf) {\n    forEach(typedArrays, function(typedArray) {\n      var arr = new g[typedArray]();\n      if (Symbol.toStringTag in arr) {\n        var proto = getPrototypeOf(arr);\n        var descriptor = gOPD2(proto, Symbol.toStringTag);\n        if (!descriptor) {\n          var superProto = getPrototypeOf(proto);\n          descriptor = gOPD2(superProto, Symbol.toStringTag);\n        }\n        cache[\"$\" + typedArray] = callBind2(descriptor.get);\n      }\n    });\n  } else {\n    forEach(typedArrays, function(typedArray) {\n      var arr = new g[typedArray]();\n      var fn = arr.slice || arr.set;\n      if (fn) {\n        cache[\"$\" + typedArray] = callBind2(fn);\n      }\n    });\n  }\n  var tryTypedArrays = function tryAllTypedArrays(value) {\n    var found = false;\n    forEach(\n      // eslint-disable-next-line no-extra-parens\n      /** @type {Record<`\\$${TypedArrayName}`, Getter>} */\n      /** @type {any} */\n      cache,\n      /** @type {(getter: Getter, name: `\\$${import('.').TypedArrayName}`) => void} */\n      function(getter, typedArray) {\n        if (!found) {\n          try {\n            if (\"$\" + getter(value) === typedArray) {\n              found = $slice(typedArray, 1);\n            }\n          } catch (e) {\n          }\n        }\n      }\n    );\n    return found;\n  };\n  var trySlices = function tryAllSlices(value) {\n    var found = false;\n    forEach(\n      // eslint-disable-next-line no-extra-parens\n      /** @type {Record<`\\$${TypedArrayName}`, Getter>} */\n      /** @type {any} */\n      cache,\n      /** @type {(getter: typeof cache, name: `\\$${import('.').TypedArrayName}`) => void} */\n      function(getter, name) {\n        if (!found) {\n          try {\n            getter(value);\n            found = $slice(name, 1);\n          } catch (e) {\n          }\n        }\n      }\n    );\n    return found;\n  };\n  whichTypedArray = function whichTypedArray2(value) {\n    if (!value || typeof value !== \"object\") {\n      return false;\n    }\n    if (!hasToStringTag) {\n      var tag = $slice($toString(value), 8, -1);\n      if ($indexOf(typedArrays, tag) > -1) {\n        return tag;\n      }\n      if (tag !== \"Object\") {\n        return false;\n      }\n      return trySlices(value);\n    }\n    if (!gOPD2) {\n      return null;\n    }\n    return tryTypedArrays(value);\n  };\n  return whichTypedArray;\n}\nvar isTypedArray;\nvar hasRequiredIsTypedArray;\nfunction requireIsTypedArray() {\n  if (hasRequiredIsTypedArray) return isTypedArray;\n  hasRequiredIsTypedArray = 1;\n  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();\n  isTypedArray = function isTypedArray2(value) {\n    return !!whichTypedArray2(value);\n  };\n  return isTypedArray;\n}\nvar hasRequiredTypes;\nfunction requireTypes() {\n  if (hasRequiredTypes) return types;\n  hasRequiredTypes = 1;\n  (function(exports) {\n    var isArgumentsObject = requireIsArguments();\n    var isGeneratorFunction2 = requireIsGeneratorFunction();\n    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();\n    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();\n    function uncurryThis(f) {\n      return f.call.bind(f);\n    }\n    var BigIntSupported = typeof BigInt !== \"undefined\";\n    var SymbolSupported = typeof Symbol !== \"undefined\";\n    var ObjectToString = uncurryThis(Object.prototype.toString);\n    var numberValue = uncurryThis(Number.prototype.valueOf);\n    var stringValue = uncurryThis(String.prototype.valueOf);\n    var booleanValue = uncurryThis(Boolean.prototype.valueOf);\n    if (BigIntSupported) {\n      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n    }\n    if (SymbolSupported) {\n      var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n    }\n    function checkBoxedPrimitive(value, prototypeValueOf) {\n      if (typeof value !== \"object\") {\n        return false;\n      }\n      try {\n        prototypeValueOf(value);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    exports.isArgumentsObject = isArgumentsObject;\n    exports.isGeneratorFunction = isGeneratorFunction2;\n    exports.isTypedArray = isTypedArray2;\n    function isPromise(input) {\n      return typeof Promise !== \"undefined\" && input instanceof Promise || input !== null && typeof input === \"object\" && typeof input.then === \"function\" && typeof input.catch === \"function\";\n    }\n    exports.isPromise = isPromise;\n    function isArrayBufferView(value) {\n      if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n        return ArrayBuffer.isView(value);\n      }\n      return isTypedArray2(value) || isDataView(value);\n    }\n    exports.isArrayBufferView = isArrayBufferView;\n    function isUint8Array(value) {\n      return whichTypedArray2(value) === \"Uint8Array\";\n    }\n    exports.isUint8Array = isUint8Array;\n    function isUint8ClampedArray(value) {\n      return whichTypedArray2(value) === \"Uint8ClampedArray\";\n    }\n    exports.isUint8ClampedArray = isUint8ClampedArray;\n    function isUint16Array(value) {\n      return whichTypedArray2(value) === \"Uint16Array\";\n    }\n    exports.isUint16Array = isUint16Array;\n    function isUint32Array(value) {\n      return whichTypedArray2(value) === \"Uint32Array\";\n    }\n    exports.isUint32Array = isUint32Array;\n    function isInt8Array(value) {\n      return whichTypedArray2(value) === \"Int8Array\";\n    }\n    exports.isInt8Array = isInt8Array;\n    function isInt16Array(value) {\n      return whichTypedArray2(value) === \"Int16Array\";\n    }\n    exports.isInt16Array = isInt16Array;\n    function isInt32Array(value) {\n      return whichTypedArray2(value) === \"Int32Array\";\n    }\n    exports.isInt32Array = isInt32Array;\n    function isFloat32Array(value) {\n      return whichTypedArray2(value) === \"Float32Array\";\n    }\n    exports.isFloat32Array = isFloat32Array;\n    function isFloat64Array(value) {\n      return whichTypedArray2(value) === \"Float64Array\";\n    }\n    exports.isFloat64Array = isFloat64Array;\n    function isBigInt64Array(value) {\n      return whichTypedArray2(value) === \"BigInt64Array\";\n    }\n    exports.isBigInt64Array = isBigInt64Array;\n    function isBigUint64Array(value) {\n      return whichTypedArray2(value) === \"BigUint64Array\";\n    }\n    exports.isBigUint64Array = isBigUint64Array;\n    function isMapToString(value) {\n      return ObjectToString(value) === \"[object Map]\";\n    }\n    isMapToString.working = typeof Map !== \"undefined\" && isMapToString(/* @__PURE__ */ new Map());\n    function isMap(value) {\n      if (typeof Map === \"undefined\") {\n        return false;\n      }\n      return isMapToString.working ? isMapToString(value) : value instanceof Map;\n    }\n    exports.isMap = isMap;\n    function isSetToString(value) {\n      return ObjectToString(value) === \"[object Set]\";\n    }\n    isSetToString.working = typeof Set !== \"undefined\" && isSetToString(/* @__PURE__ */ new Set());\n    function isSet(value) {\n      if (typeof Set === \"undefined\") {\n        return false;\n      }\n      return isSetToString.working ? isSetToString(value) : value instanceof Set;\n    }\n    exports.isSet = isSet;\n    function isWeakMapToString(value) {\n      return ObjectToString(value) === \"[object WeakMap]\";\n    }\n    isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(/* @__PURE__ */ new WeakMap());\n    function isWeakMap(value) {\n      if (typeof WeakMap === \"undefined\") {\n        return false;\n      }\n      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;\n    }\n    exports.isWeakMap = isWeakMap;\n    function isWeakSetToString(value) {\n      return ObjectToString(value) === \"[object WeakSet]\";\n    }\n    isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(/* @__PURE__ */ new WeakSet());\n    function isWeakSet(value) {\n      return isWeakSetToString(value);\n    }\n    exports.isWeakSet = isWeakSet;\n    function isArrayBufferToString(value) {\n      return ObjectToString(value) === \"[object ArrayBuffer]\";\n    }\n    isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer());\n    function isArrayBuffer(value) {\n      if (typeof ArrayBuffer === \"undefined\") {\n        return false;\n      }\n      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;\n    }\n    exports.isArrayBuffer = isArrayBuffer;\n    function isDataViewToString(value) {\n      return ObjectToString(value) === \"[object DataView]\";\n    }\n    isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n    function isDataView(value) {\n      if (typeof DataView === \"undefined\") {\n        return false;\n      }\n      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;\n    }\n    exports.isDataView = isDataView;\n    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : void 0;\n    function isSharedArrayBufferToString(value) {\n      return ObjectToString(value) === \"[object SharedArrayBuffer]\";\n    }\n    function isSharedArrayBuffer(value) {\n      if (typeof SharedArrayBufferCopy === \"undefined\") {\n        return false;\n      }\n      if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n      }\n      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;\n    }\n    exports.isSharedArrayBuffer = isSharedArrayBuffer;\n    function isAsyncFunction(value) {\n      return ObjectToString(value) === \"[object AsyncFunction]\";\n    }\n    exports.isAsyncFunction = isAsyncFunction;\n    function isMapIterator(value) {\n      return ObjectToString(value) === \"[object Map Iterator]\";\n    }\n    exports.isMapIterator = isMapIterator;\n    function isSetIterator(value) {\n      return ObjectToString(value) === \"[object Set Iterator]\";\n    }\n    exports.isSetIterator = isSetIterator;\n    function isGeneratorObject(value) {\n      return ObjectToString(value) === \"[object Generator]\";\n    }\n    exports.isGeneratorObject = isGeneratorObject;\n    function isWebAssemblyCompiledModule(value) {\n      return ObjectToString(value) === \"[object WebAssembly.Module]\";\n    }\n    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n    function isNumberObject(value) {\n      return checkBoxedPrimitive(value, numberValue);\n    }\n    exports.isNumberObject = isNumberObject;\n    function isStringObject(value) {\n      return checkBoxedPrimitive(value, stringValue);\n    }\n    exports.isStringObject = isStringObject;\n    function isBooleanObject(value) {\n      return checkBoxedPrimitive(value, booleanValue);\n    }\n    exports.isBooleanObject = isBooleanObject;\n    function isBigIntObject(value) {\n      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n    }\n    exports.isBigIntObject = isBigIntObject;\n    function isSymbolObject(value) {\n      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n    }\n    exports.isSymbolObject = isSymbolObject;\n    function isBoxedPrimitive(value) {\n      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);\n    }\n    exports.isBoxedPrimitive = isBoxedPrimitive;\n    function isAnyArrayBuffer(value) {\n      return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(value) || isSharedArrayBuffer(value));\n    }\n    exports.isAnyArrayBuffer = isAnyArrayBuffer;\n    [\"isProxy\", \"isExternal\", \"isModuleNamespaceObject\"].forEach(function(method) {\n      Object.defineProperty(exports, method, {\n        enumerable: false,\n        value: function() {\n          throw new Error(method + \" is not supported in userland\");\n        }\n      });\n    });\n  })(types);\n  return types;\n}\nvar isBufferBrowser;\nvar hasRequiredIsBufferBrowser;\nfunction requireIsBufferBrowser() {\n  if (hasRequiredIsBufferBrowser) return isBufferBrowser;\n  hasRequiredIsBufferBrowser = 1;\n  isBufferBrowser = function isBuffer(arg) {\n    return arg && typeof arg === \"object\" && typeof arg.copy === \"function\" && typeof arg.fill === \"function\" && typeof arg.readUInt8 === \"function\";\n  };\n  return isBufferBrowser;\n}\nvar hasRequiredUtil;\nfunction requireUtil() {\n  if (hasRequiredUtil) return util;\n  hasRequiredUtil = 1;\n  (function(exports) {\n    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {\n      var keys = Object.keys(obj);\n      var descriptors = {};\n      for (var i = 0; i < keys.length; i++) {\n        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n      }\n      return descriptors;\n    };\n    var formatRegExp = /%[sdj%]/g;\n    exports.format = function(f) {\n      if (!isString(f)) {\n        var objects = [];\n        for (var i = 0; i < arguments.length; i++) {\n          objects.push(inspect(arguments[i]));\n        }\n        return objects.join(\" \");\n      }\n      var i = 1;\n      var args = arguments;\n      var len = args.length;\n      var str = String(f).replace(formatRegExp, function(x2) {\n        if (x2 === \"%%\") return \"%\";\n        if (i >= len) return x2;\n        switch (x2) {\n          case \"%s\":\n            return String(args[i++]);\n          case \"%d\":\n            return Number(args[i++]);\n          case \"%j\":\n            try {\n              return JSON.stringify(args[i++]);\n            } catch (_) {\n              return \"[Circular]\";\n            }\n          default:\n            return x2;\n        }\n      });\n      for (var x = args[i]; i < len; x = args[++i]) {\n        if (isNull(x) || !isObject(x)) {\n          str += \" \" + x;\n        } else {\n          str += \" \" + inspect(x);\n        }\n      }\n      return str;\n    };\n    exports.deprecate = function(fn, msg) {\n      if (typeof process$1 !== \"undefined\" && process$1.noDeprecation === true) {\n        return fn;\n      }\n      if (typeof process$1 === \"undefined\") {\n        return function() {\n          return exports.deprecate(fn, msg).apply(this, arguments);\n        };\n      }\n      var warned = false;\n      function deprecated() {\n        if (!warned) {\n          if (process$1.throwDeprecation) {\n            throw new Error(msg);\n          } else if (process$1.traceDeprecation) {\n            console.trace(msg);\n          } else {\n            console.error(msg);\n          }\n          warned = true;\n        }\n        return fn.apply(this, arguments);\n      }\n      return deprecated;\n    };\n    var debugs = {};\n    var debugEnvRegex = /^$/;\n    if (process$1.env.NODE_DEBUG) {\n      var debugEnv = process$1.env.NODE_DEBUG;\n      debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n      debugEnvRegex = new RegExp(\"^\" + debugEnv + \"$\", \"i\");\n    }\n    exports.debuglog = function(set) {\n      set = set.toUpperCase();\n      if (!debugs[set]) {\n        if (debugEnvRegex.test(set)) {\n          var pid = process$1.pid;\n          debugs[set] = function() {\n            var msg = exports.format.apply(exports, arguments);\n            console.error(\"%s %d: %s\", set, pid, msg);\n          };\n        } else {\n          debugs[set] = function() {\n          };\n        }\n      }\n      return debugs[set];\n    };\n    function inspect(obj, opts) {\n      var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n      };\n      if (arguments.length >= 3) ctx.depth = arguments[2];\n      if (arguments.length >= 4) ctx.colors = arguments[3];\n      if (isBoolean(opts)) {\n        ctx.showHidden = opts;\n      } else if (opts) {\n        exports._extend(ctx, opts);\n      }\n      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n      if (isUndefined(ctx.depth)) ctx.depth = 2;\n      if (isUndefined(ctx.colors)) ctx.colors = false;\n      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n      if (ctx.colors) ctx.stylize = stylizeWithColor;\n      return formatValue(ctx, obj, ctx.depth);\n    }\n    exports.inspect = inspect;\n    inspect.colors = {\n      \"bold\": [1, 22],\n      \"italic\": [3, 23],\n      \"underline\": [4, 24],\n      \"inverse\": [7, 27],\n      \"white\": [37, 39],\n      \"grey\": [90, 39],\n      \"black\": [30, 39],\n      \"blue\": [34, 39],\n      \"cyan\": [36, 39],\n      \"green\": [32, 39],\n      \"magenta\": [35, 39],\n      \"red\": [31, 39],\n      \"yellow\": [33, 39]\n    };\n    inspect.styles = {\n      \"special\": \"cyan\",\n      \"number\": \"yellow\",\n      \"boolean\": \"yellow\",\n      \"undefined\": \"grey\",\n      \"null\": \"bold\",\n      \"string\": \"green\",\n      \"date\": \"magenta\",\n      // \"name\": intentionally not styling\n      \"regexp\": \"red\"\n    };\n    function stylizeWithColor(str, styleType) {\n      var style = inspect.styles[styleType];\n      if (style) {\n        return \"\\x1B[\" + inspect.colors[style][0] + \"m\" + str + \"\\x1B[\" + inspect.colors[style][1] + \"m\";\n      } else {\n        return str;\n      }\n    }\n    function stylizeNoColor(str, styleType) {\n      return str;\n    }\n    function arrayToHash(array) {\n      var hash2 = {};\n      array.forEach(function(val, idx) {\n        hash2[val] = true;\n      });\n      return hash2;\n    }\n    function formatValue(ctx, value, recurseTimes) {\n      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n      }\n      var primitive = formatPrimitive(ctx, value);\n      if (primitive) {\n        return primitive;\n      }\n      var keys = Object.keys(value);\n      var visibleKeys = arrayToHash(keys);\n      if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n      }\n      if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n      }\n      if (keys.length === 0) {\n        if (isFunction(value)) {\n          var name = value.name ? \": \" + value.name : \"\";\n          return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n        }\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        if (isDate(value)) {\n          return ctx.stylize(Date.prototype.toString.call(value), \"date\");\n        }\n        if (isError(value)) {\n          return formatError(value);\n        }\n      }\n      var base = \"\", array = false, braces = [\"{\", \"}\"];\n      if (isArray(value)) {\n        array = true;\n        braces = [\"[\", \"]\"];\n      }\n      if (isFunction(value)) {\n        var n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n      }\n      if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n      }\n      if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n      }\n      if (isError(value)) {\n        base = \" \" + formatError(value);\n      }\n      if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n      }\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        } else {\n          return ctx.stylize(\"[Object]\", \"special\");\n        }\n      }\n      ctx.seen.push(value);\n      var output;\n      if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n      } else {\n        output = keys.map(function(key) {\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n      }\n      ctx.seen.pop();\n      return reduceToSingleString(output, base, braces);\n    }\n    function formatPrimitive(ctx, value) {\n      if (isUndefined(value))\n        return ctx.stylize(\"undefined\", \"undefined\");\n      if (isString(value)) {\n        var simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n        return ctx.stylize(simple, \"string\");\n      }\n      if (isNumber(value))\n        return ctx.stylize(\"\" + value, \"number\");\n      if (isBoolean(value))\n        return ctx.stylize(\"\" + value, \"boolean\");\n      if (isNull(value))\n        return ctx.stylize(\"null\", \"null\");\n    }\n    function formatError(value) {\n      return \"[\" + Error.prototype.toString.call(value) + \"]\";\n    }\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n      var output = [];\n      for (var i = 0, l = value.length; i < l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n          output.push(formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            String(i),\n            true\n          ));\n        } else {\n          output.push(\"\");\n        }\n      }\n      keys.forEach(function(key) {\n        if (!key.match(/^\\d+$/)) {\n          output.push(formatProperty(\n            ctx,\n            value,\n            recurseTimes,\n            visibleKeys,\n            key,\n            true\n          ));\n        }\n      });\n      return output;\n    }\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n      var name, str, desc;\n      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n      if (desc.get) {\n        if (desc.set) {\n          str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        } else {\n          str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n      } else {\n        if (desc.set) {\n          str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n      }\n      if (!hasOwnProperty(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n      }\n      if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n          if (isNull(recurseTimes)) {\n            str = formatValue(ctx, desc.value, null);\n          } else {\n            str = formatValue(ctx, desc.value, recurseTimes - 1);\n          }\n          if (str.indexOf(\"\\n\") > -1) {\n            if (array) {\n              str = str.split(\"\\n\").map(function(line) {\n                return \"  \" + line;\n              }).join(\"\\n\").slice(2);\n            } else {\n              str = \"\\n\" + str.split(\"\\n\").map(function(line) {\n                return \"   \" + line;\n              }).join(\"\\n\");\n            }\n          }\n        } else {\n          str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n      }\n      if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.slice(1, -1);\n          name = ctx.stylize(name, \"name\");\n        } else {\n          name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n          name = ctx.stylize(name, \"string\");\n        }\n      }\n      return name + \": \" + str;\n    }\n    function reduceToSingleString(output, base, braces) {\n      var length = output.reduce(function(prev, cur) {\n        if (cur.indexOf(\"\\n\") >= 0) ;\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n      }, 0);\n      if (length > 60) {\n        return braces[0] + (base === \"\" ? \"\" : base + \"\\n \") + \" \" + output.join(\",\\n  \") + \" \" + braces[1];\n      }\n      return braces[0] + base + \" \" + output.join(\", \") + \" \" + braces[1];\n    }\n    exports.types = requireTypes();\n    function isArray(ar) {\n      return Array.isArray(ar);\n    }\n    exports.isArray = isArray;\n    function isBoolean(arg) {\n      return typeof arg === \"boolean\";\n    }\n    exports.isBoolean = isBoolean;\n    function isNull(arg) {\n      return arg === null;\n    }\n    exports.isNull = isNull;\n    function isNullOrUndefined(arg) {\n      return arg == null;\n    }\n    exports.isNullOrUndefined = isNullOrUndefined;\n    function isNumber(arg) {\n      return typeof arg === \"number\";\n    }\n    exports.isNumber = isNumber;\n    function isString(arg) {\n      return typeof arg === \"string\";\n    }\n    exports.isString = isString;\n    function isSymbol(arg) {\n      return typeof arg === \"symbol\";\n    }\n    exports.isSymbol = isSymbol;\n    function isUndefined(arg) {\n      return arg === void 0;\n    }\n    exports.isUndefined = isUndefined;\n    function isRegExp(re) {\n      return isObject(re) && objectToString(re) === \"[object RegExp]\";\n    }\n    exports.isRegExp = isRegExp;\n    exports.types.isRegExp = isRegExp;\n    function isObject(arg) {\n      return typeof arg === \"object\" && arg !== null;\n    }\n    exports.isObject = isObject;\n    function isDate(d) {\n      return isObject(d) && objectToString(d) === \"[object Date]\";\n    }\n    exports.isDate = isDate;\n    exports.types.isDate = isDate;\n    function isError(e) {\n      return isObject(e) && (objectToString(e) === \"[object Error]\" || e instanceof Error);\n    }\n    exports.isError = isError;\n    exports.types.isNativeError = isError;\n    function isFunction(arg) {\n      return typeof arg === \"function\";\n    }\n    exports.isFunction = isFunction;\n    function isPrimitive(arg) {\n      return arg === null || typeof arg === \"boolean\" || typeof arg === \"number\" || typeof arg === \"string\" || typeof arg === \"symbol\" || // ES6 symbol\n      typeof arg === \"undefined\";\n    }\n    exports.isPrimitive = isPrimitive;\n    exports.isBuffer = requireIsBufferBrowser();\n    function objectToString(o) {\n      return Object.prototype.toString.call(o);\n    }\n    function pad(n) {\n      return n < 10 ? \"0\" + n.toString(10) : n.toString(10);\n    }\n    var months = [\n      \"Jan\",\n      \"Feb\",\n      \"Mar\",\n      \"Apr\",\n      \"May\",\n      \"Jun\",\n      \"Jul\",\n      \"Aug\",\n      \"Sep\",\n      \"Oct\",\n      \"Nov\",\n      \"Dec\"\n    ];\n    function timestamp() {\n      var d = /* @__PURE__ */ new Date();\n      var time = [\n        pad(d.getHours()),\n        pad(d.getMinutes()),\n        pad(d.getSeconds())\n      ].join(\":\");\n      return [d.getDate(), months[d.getMonth()], time].join(\" \");\n    }\n    exports.log = function() {\n      console.log(\"%s - %s\", timestamp(), exports.format.apply(exports, arguments));\n    };\n    exports.inherits = requireInherits_browser();\n    exports._extend = function(origin, add) {\n      if (!add || !isObject(add)) return origin;\n      var keys = Object.keys(add);\n      var i = keys.length;\n      while (i--) {\n        origin[keys[i]] = add[keys[i]];\n      }\n      return origin;\n    };\n    function hasOwnProperty(obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    }\n    var kCustomPromisifiedSymbol = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : void 0;\n    exports.promisify = function promisify(original) {\n      if (typeof original !== \"function\")\n        throw new TypeError('The \"original\" argument must be of type Function');\n      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n        var fn = original[kCustomPromisifiedSymbol];\n        if (typeof fn !== \"function\") {\n          throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n        }\n        Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n          value: fn,\n          enumerable: false,\n          writable: false,\n          configurable: true\n        });\n        return fn;\n      }\n      function fn() {\n        var promiseResolve, promiseReject;\n        var promise = new Promise(function(resolve, reject) {\n          promiseResolve = resolve;\n          promiseReject = reject;\n        });\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        args.push(function(err, value) {\n          if (err) {\n            promiseReject(err);\n          } else {\n            promiseResolve(value);\n          }\n        });\n        try {\n          original.apply(this, args);\n        } catch (err) {\n          promiseReject(err);\n        }\n        return promise;\n      }\n      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n        value: fn,\n        enumerable: false,\n        writable: false,\n        configurable: true\n      });\n      return Object.defineProperties(\n        fn,\n        getOwnPropertyDescriptors(original)\n      );\n    };\n    exports.promisify.custom = kCustomPromisifiedSymbol;\n    function callbackifyOnRejected(reason, cb) {\n      if (!reason) {\n        var newReason = new Error(\"Promise was rejected with a falsy value\");\n        newReason.reason = reason;\n        reason = newReason;\n      }\n      return cb(reason);\n    }\n    function callbackify(original) {\n      if (typeof original !== \"function\") {\n        throw new TypeError('The \"original\" argument must be of type Function');\n      }\n      function callbackified() {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n        var maybeCb = args.pop();\n        if (typeof maybeCb !== \"function\") {\n          throw new TypeError(\"The last argument must be of type Function\");\n        }\n        var self2 = this;\n        var cb = function() {\n          return maybeCb.apply(self2, arguments);\n        };\n        original.apply(this, args).then(\n          function(ret) {\n            process$1.nextTick(cb.bind(null, null, ret));\n          },\n          function(rej) {\n            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));\n          }\n        );\n      }\n      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n      Object.defineProperties(\n        callbackified,\n        getOwnPropertyDescriptors(original)\n      );\n      return callbackified;\n    }\n    exports.callbackify = callbackify;\n  })(util);\n  return util;\n}\nvar buffer_list;\nvar hasRequiredBuffer_list;\nfunction requireBuffer_list() {\n  if (hasRequiredBuffer_list) return buffer_list;\n  hasRequiredBuffer_list = 1;\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function(sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n    return keys;\n  }\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function(key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function(key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n    return target;\n  }\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n  }\n  var _require = requireBuffer(), Buffer2 = _require.Buffer;\n  var _require2 = requireUtil(), inspect = _require2.inspect;\n  var custom = inspect && inspect.custom || \"inspect\";\n  function copyBuffer(src, target, offset) {\n    Buffer2.prototype.copy.call(src, target, offset);\n  }\n  buffer_list = /* @__PURE__ */ function() {\n    function BufferList() {\n      _classCallCheck(this, BufferList);\n      this.head = null;\n      this.tail = null;\n      this.length = 0;\n    }\n    _createClass(BufferList, [{\n      key: \"push\",\n      value: function push(v) {\n        var entry = {\n          data: v,\n          next: null\n        };\n        if (this.length > 0) this.tail.next = entry;\n        else this.head = entry;\n        this.tail = entry;\n        ++this.length;\n      }\n    }, {\n      key: \"unshift\",\n      value: function unshift(v) {\n        var entry = {\n          data: v,\n          next: this.head\n        };\n        if (this.length === 0) this.tail = entry;\n        this.head = entry;\n        ++this.length;\n      }\n    }, {\n      key: \"shift\",\n      value: function shift() {\n        if (this.length === 0) return;\n        var ret = this.head.data;\n        if (this.length === 1) this.head = this.tail = null;\n        else this.head = this.head.next;\n        --this.length;\n        return ret;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this.head = this.tail = null;\n        this.length = 0;\n      }\n    }, {\n      key: \"join\",\n      value: function join(s) {\n        if (this.length === 0) return \"\";\n        var p = this.head;\n        var ret = \"\" + p.data;\n        while (p = p.next) {\n          ret += s + p.data;\n        }\n        return ret;\n      }\n    }, {\n      key: \"concat\",\n      value: function concat(n) {\n        if (this.length === 0) return Buffer2.alloc(0);\n        var ret = Buffer2.allocUnsafe(n >>> 0);\n        var p = this.head;\n        var i = 0;\n        while (p) {\n          copyBuffer(p.data, ret, i);\n          i += p.data.length;\n          p = p.next;\n        }\n        return ret;\n      }\n      // Consumes a specified amount of bytes or characters from the buffered data.\n    }, {\n      key: \"consume\",\n      value: function consume(n, hasStrings) {\n        var ret;\n        if (n < this.head.data.length) {\n          ret = this.head.data.slice(0, n);\n          this.head.data = this.head.data.slice(n);\n        } else if (n === this.head.data.length) {\n          ret = this.shift();\n        } else {\n          ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n        }\n        return ret;\n      }\n    }, {\n      key: \"first\",\n      value: function first() {\n        return this.head.data;\n      }\n      // Consumes a specified amount of characters from the buffered data.\n    }, {\n      key: \"_getString\",\n      value: function _getString(n) {\n        var p = this.head;\n        var c = 1;\n        var ret = p.data;\n        n -= ret.length;\n        while (p = p.next) {\n          var str = p.data;\n          var nb = n > str.length ? str.length : n;\n          if (nb === str.length) ret += str;\n          else ret += str.slice(0, n);\n          n -= nb;\n          if (n === 0) {\n            if (nb === str.length) {\n              ++c;\n              if (p.next) this.head = p.next;\n              else this.head = this.tail = null;\n            } else {\n              this.head = p;\n              p.data = str.slice(nb);\n            }\n            break;\n          }\n          ++c;\n        }\n        this.length -= c;\n        return ret;\n      }\n      // Consumes a specified amount of bytes from the buffered data.\n    }, {\n      key: \"_getBuffer\",\n      value: function _getBuffer(n) {\n        var ret = Buffer2.allocUnsafe(n);\n        var p = this.head;\n        var c = 1;\n        p.data.copy(ret);\n        n -= p.data.length;\n        while (p = p.next) {\n          var buf = p.data;\n          var nb = n > buf.length ? buf.length : n;\n          buf.copy(ret, ret.length - n, 0, nb);\n          n -= nb;\n          if (n === 0) {\n            if (nb === buf.length) {\n              ++c;\n              if (p.next) this.head = p.next;\n              else this.head = this.tail = null;\n            } else {\n              this.head = p;\n              p.data = buf.slice(nb);\n            }\n            break;\n          }\n          ++c;\n        }\n        this.length -= c;\n        return ret;\n      }\n      // Make sure the linked list only shows the minimal necessary information.\n    }, {\n      key: custom,\n      value: function value(_, options) {\n        return inspect(this, _objectSpread({}, options, {\n          // Only inspect one level.\n          depth: 0,\n          // It should not recurse.\n          customInspect: false\n        }));\n      }\n    }]);\n    return BufferList;\n  }();\n  return buffer_list;\n}\nvar destroy_1;\nvar hasRequiredDestroy;\nfunction requireDestroy() {\n  if (hasRequiredDestroy) return destroy_1;\n  hasRequiredDestroy = 1;\n  function destroy(err, cb) {\n    var _this = this;\n    var readableDestroyed = this._readableState && this._readableState.destroyed;\n    var writableDestroyed = this._writableState && this._writableState.destroyed;\n    if (readableDestroyed || writableDestroyed) {\n      if (cb) {\n        cb(err);\n      } else if (err) {\n        if (!this._writableState) {\n          process$1.nextTick(emitErrorNT, this, err);\n        } else if (!this._writableState.errorEmitted) {\n          this._writableState.errorEmitted = true;\n          process$1.nextTick(emitErrorNT, this, err);\n        }\n      }\n      return this;\n    }\n    if (this._readableState) {\n      this._readableState.destroyed = true;\n    }\n    if (this._writableState) {\n      this._writableState.destroyed = true;\n    }\n    this._destroy(err || null, function(err2) {\n      if (!cb && err2) {\n        if (!_this._writableState) {\n          process$1.nextTick(emitErrorAndCloseNT, _this, err2);\n        } else if (!_this._writableState.errorEmitted) {\n          _this._writableState.errorEmitted = true;\n          process$1.nextTick(emitErrorAndCloseNT, _this, err2);\n        } else {\n          process$1.nextTick(emitCloseNT, _this);\n        }\n      } else if (cb) {\n        process$1.nextTick(emitCloseNT, _this);\n        cb(err2);\n      } else {\n        process$1.nextTick(emitCloseNT, _this);\n      }\n    });\n    return this;\n  }\n  function emitErrorAndCloseNT(self2, err) {\n    emitErrorNT(self2, err);\n    emitCloseNT(self2);\n  }\n  function emitCloseNT(self2) {\n    if (self2._writableState && !self2._writableState.emitClose) return;\n    if (self2._readableState && !self2._readableState.emitClose) return;\n    self2.emit(\"close\");\n  }\n  function undestroy() {\n    if (this._readableState) {\n      this._readableState.destroyed = false;\n      this._readableState.reading = false;\n      this._readableState.ended = false;\n      this._readableState.endEmitted = false;\n    }\n    if (this._writableState) {\n      this._writableState.destroyed = false;\n      this._writableState.ended = false;\n      this._writableState.ending = false;\n      this._writableState.finalCalled = false;\n      this._writableState.prefinished = false;\n      this._writableState.finished = false;\n      this._writableState.errorEmitted = false;\n    }\n  }\n  function emitErrorNT(self2, err) {\n    self2.emit(\"error\", err);\n  }\n  function errorOrDestroy(stream, err) {\n    var rState = stream._readableState;\n    var wState = stream._writableState;\n    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);\n    else stream.emit(\"error\", err);\n  }\n  destroy_1 = {\n    destroy,\n    undestroy,\n    errorOrDestroy\n  };\n  return destroy_1;\n}\nvar errorsBrowser = {};\nvar hasRequiredErrorsBrowser;\nfunction requireErrorsBrowser() {\n  if (hasRequiredErrorsBrowser) return errorsBrowser;\n  hasRequiredErrorsBrowser = 1;\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n  var codes = {};\n  function createErrorType(code, message, Base) {\n    if (!Base) {\n      Base = Error;\n    }\n    function getMessage(arg1, arg2, arg3) {\n      if (typeof message === \"string\") {\n        return message;\n      } else {\n        return message(arg1, arg2, arg3);\n      }\n    }\n    var NodeError = /* @__PURE__ */ function(_Base) {\n      _inheritsLoose(NodeError2, _Base);\n      function NodeError2(arg1, arg2, arg3) {\n        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n      }\n      return NodeError2;\n    }(Base);\n    NodeError.prototype.name = Base.name;\n    NodeError.prototype.code = code;\n    codes[code] = NodeError;\n  }\n  function oneOf(expected, thing) {\n    if (Array.isArray(expected)) {\n      var len = expected.length;\n      expected = expected.map(function(i) {\n        return String(i);\n      });\n      if (len > 2) {\n        return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(\", \"), \", or \") + expected[len - 1];\n      } else if (len === 2) {\n        return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n      } else {\n        return \"of \".concat(thing, \" \").concat(expected[0]);\n      }\n    } else {\n      return \"of \".concat(thing, \" \").concat(String(expected));\n    }\n  }\n  function startsWith(str, search, pos) {\n    return str.substr(0, search.length) === search;\n  }\n  function endsWith(str, search, this_len) {\n    if (this_len === void 0 || this_len > str.length) {\n      this_len = str.length;\n    }\n    return str.substring(this_len - search.length, this_len) === search;\n  }\n  function includes(str, search, start) {\n    if (typeof start !== \"number\") {\n      start = 0;\n    }\n    if (start + search.length > str.length) {\n      return false;\n    } else {\n      return str.indexOf(search, start) !== -1;\n    }\n  }\n  createErrorType(\"ERR_INVALID_OPT_VALUE\", function(name, value) {\n    return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n  }, TypeError);\n  createErrorType(\"ERR_INVALID_ARG_TYPE\", function(name, expected, actual) {\n    var determiner;\n    if (typeof expected === \"string\" && startsWith(expected, \"not \")) {\n      determiner = \"must not be\";\n      expected = expected.replace(/^not /, \"\");\n    } else {\n      determiner = \"must be\";\n    }\n    var msg;\n    if (endsWith(name, \" argument\")) {\n      msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n    } else {\n      var type2 = includes(name, \".\") ? \"property\" : \"argument\";\n      msg = 'The \"'.concat(name, '\" ').concat(type2, \" \").concat(determiner, \" \").concat(oneOf(expected, \"type\"));\n    }\n    msg += \". Received type \".concat(typeof actual);\n    return msg;\n  }, TypeError);\n  createErrorType(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\");\n  createErrorType(\"ERR_METHOD_NOT_IMPLEMENTED\", function(name) {\n    return \"The \" + name + \" method is not implemented\";\n  });\n  createErrorType(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\");\n  createErrorType(\"ERR_STREAM_DESTROYED\", function(name) {\n    return \"Cannot call \" + name + \" after a stream was destroyed\";\n  });\n  createErrorType(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\");\n  createErrorType(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\");\n  createErrorType(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\");\n  createErrorType(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError);\n  createErrorType(\"ERR_UNKNOWN_ENCODING\", function(arg) {\n    return \"Unknown encoding: \" + arg;\n  }, TypeError);\n  createErrorType(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\");\n  errorsBrowser.codes = codes;\n  return errorsBrowser;\n}\nvar state;\nvar hasRequiredState;\nfunction requireState() {\n  if (hasRequiredState) return state;\n  hasRequiredState = 1;\n  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;\n  function highWaterMarkFrom(options, isDuplex, duplexKey) {\n    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n  }\n  function getHighWaterMark(state2, options, duplexKey, isDuplex) {\n    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n    if (hwm != null) {\n      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n        var name = isDuplex ? duplexKey : \"highWaterMark\";\n        throw new ERR_INVALID_OPT_VALUE(name, hwm);\n      }\n      return Math.floor(hwm);\n    }\n    return state2.objectMode ? 16 : 16 * 1024;\n  }\n  state = {\n    getHighWaterMark\n  };\n  return state;\n}\nvar browser;\nvar hasRequiredBrowser;\nfunction requireBrowser() {\n  if (hasRequiredBrowser) return browser;\n  hasRequiredBrowser = 1;\n  browser = deprecate;\n  function deprecate(fn, msg) {\n    if (config(\"noDeprecation\")) {\n      return fn;\n    }\n    var warned = false;\n    function deprecated() {\n      if (!warned) {\n        if (config(\"throwDeprecation\")) {\n          throw new Error(msg);\n        } else if (config(\"traceDeprecation\")) {\n          console.trace(msg);\n        } else {\n          console.warn(msg);\n        }\n        warned = true;\n      }\n      return fn.apply(this, arguments);\n    }\n    return deprecated;\n  }\n  function config(name) {\n    try {\n      if (!commonjsGlobal.localStorage) return false;\n    } catch (_) {\n      return false;\n    }\n    var val = commonjsGlobal.localStorage[name];\n    if (null == val) return false;\n    return String(val).toLowerCase() === \"true\";\n  }\n  return browser;\n}\nvar _stream_writable;\nvar hasRequired_stream_writable;\nfunction require_stream_writable() {\n  if (hasRequired_stream_writable) return _stream_writable;\n  hasRequired_stream_writable = 1;\n  _stream_writable = Writable;\n  function CorkedRequest(state2) {\n    var _this = this;\n    this.next = null;\n    this.entry = null;\n    this.finish = function() {\n      onCorkedFinish(_this, state2);\n    };\n  }\n  var Duplex;\n  Writable.WritableState = WritableState;\n  var internalUtil = {\n    deprecate: requireBrowser()\n  };\n  var Stream = requireStreamBrowser();\n  var Buffer2 = requireBuffer().Buffer;\n  var OurUint8Array = commonjsGlobal.Uint8Array || function() {\n  };\n  function _uint8ArrayToBuffer(chunk) {\n    return Buffer2.from(chunk);\n  }\n  function _isUint8Array(obj) {\n    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;\n  }\n  var destroyImpl = requireDestroy();\n  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;\n  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n  var errorOrDestroy = destroyImpl.errorOrDestroy;\n  requireInherits_browser()(Writable, Stream);\n  function nop() {\n  }\n  function WritableState(options, stream, isDuplex) {\n    Duplex = Duplex || require_stream_duplex();\n    options = options || {};\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    this.highWaterMark = getHighWaterMark(this, options, \"writableHighWaterMark\", isDuplex);\n    this.finalCalled = false;\n    this.needDrain = false;\n    this.ending = false;\n    this.ended = false;\n    this.finished = false;\n    this.destroyed = false;\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.length = 0;\n    this.writing = false;\n    this.corked = 0;\n    this.sync = true;\n    this.bufferProcessing = false;\n    this.onwrite = function(er) {\n      onwrite(stream, er);\n    };\n    this.writecb = null;\n    this.writelen = 0;\n    this.bufferedRequest = null;\n    this.lastBufferedRequest = null;\n    this.pendingcb = 0;\n    this.prefinished = false;\n    this.errorEmitted = false;\n    this.emitClose = options.emitClose !== false;\n    this.autoDestroy = !!options.autoDestroy;\n    this.bufferedRequestCount = 0;\n    this.corkedRequestsFree = new CorkedRequest(this);\n  }\n  WritableState.prototype.getBuffer = function getBuffer() {\n    var current = this.bufferedRequest;\n    var out = [];\n    while (current) {\n      out.push(current);\n      current = current.next;\n    }\n    return out;\n  };\n  (function() {\n    try {\n      Object.defineProperty(WritableState.prototype, \"buffer\", {\n        get: internalUtil.deprecate(function writableStateBufferGetter() {\n          return this.getBuffer();\n        }, \"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\", \"DEP0003\")\n      });\n    } catch (_) {\n    }\n  })();\n  var realHasInstance;\n  if (typeof Symbol === \"function\" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === \"function\") {\n    realHasInstance = Function.prototype[Symbol.hasInstance];\n    Object.defineProperty(Writable, Symbol.hasInstance, {\n      value: function value(object) {\n        if (realHasInstance.call(this, object)) return true;\n        if (this !== Writable) return false;\n        return object && object._writableState instanceof WritableState;\n      }\n    });\n  } else {\n    realHasInstance = function realHasInstance2(object) {\n      return object instanceof this;\n    };\n  }\n  function Writable(options) {\n    Duplex = Duplex || require_stream_duplex();\n    var isDuplex = this instanceof Duplex;\n    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n    this._writableState = new WritableState(options, this, isDuplex);\n    this.writable = true;\n    if (options) {\n      if (typeof options.write === \"function\") this._write = options.write;\n      if (typeof options.writev === \"function\") this._writev = options.writev;\n      if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n      if (typeof options.final === \"function\") this._final = options.final;\n    }\n    Stream.call(this);\n  }\n  Writable.prototype.pipe = function() {\n    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n  };\n  function writeAfterEnd(stream, cb) {\n    var er = new ERR_STREAM_WRITE_AFTER_END();\n    errorOrDestroy(stream, er);\n    process$1.nextTick(cb, er);\n  }\n  function validChunk(stream, state2, chunk, cb) {\n    var er;\n    if (chunk === null) {\n      er = new ERR_STREAM_NULL_VALUES();\n    } else if (typeof chunk !== \"string\" && !state2.objectMode) {\n      er = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\"], chunk);\n    }\n    if (er) {\n      errorOrDestroy(stream, er);\n      process$1.nextTick(cb, er);\n      return false;\n    }\n    return true;\n  }\n  Writable.prototype.write = function(chunk, encoding, cb) {\n    var state2 = this._writableState;\n    var ret = false;\n    var isBuf = !state2.objectMode && _isUint8Array(chunk);\n    if (isBuf && !Buffer2.isBuffer(chunk)) {\n      chunk = _uint8ArrayToBuffer(chunk);\n    }\n    if (typeof encoding === \"function\") {\n      cb = encoding;\n      encoding = null;\n    }\n    if (isBuf) encoding = \"buffer\";\n    else if (!encoding) encoding = state2.defaultEncoding;\n    if (typeof cb !== \"function\") cb = nop;\n    if (state2.ending) writeAfterEnd(this, cb);\n    else if (isBuf || validChunk(this, state2, chunk, cb)) {\n      state2.pendingcb++;\n      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);\n    }\n    return ret;\n  };\n  Writable.prototype.cork = function() {\n    this._writableState.corked++;\n  };\n  Writable.prototype.uncork = function() {\n    var state2 = this._writableState;\n    if (state2.corked) {\n      state2.corked--;\n      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);\n    }\n  };\n  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n    if (typeof encoding === \"string\") encoding = encoding.toLowerCase();\n    if (!([\"hex\", \"utf8\", \"utf-8\", \"ascii\", \"binary\", \"base64\", \"ucs2\", \"ucs-2\", \"utf16le\", \"utf-16le\", \"raw\"].indexOf((encoding + \"\").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n    this._writableState.defaultEncoding = encoding;\n    return this;\n  };\n  Object.defineProperty(Writable.prototype, \"writableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  });\n  function decodeChunk(state2, chunk, encoding) {\n    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === \"string\") {\n      chunk = Buffer2.from(chunk, encoding);\n    }\n    return chunk;\n  }\n  Object.defineProperty(Writable.prototype, \"writableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState.highWaterMark;\n    }\n  });\n  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {\n    if (!isBuf) {\n      var newChunk = decodeChunk(state2, chunk, encoding);\n      if (chunk !== newChunk) {\n        isBuf = true;\n        encoding = \"buffer\";\n        chunk = newChunk;\n      }\n    }\n    var len = state2.objectMode ? 1 : chunk.length;\n    state2.length += len;\n    var ret = state2.length < state2.highWaterMark;\n    if (!ret) state2.needDrain = true;\n    if (state2.writing || state2.corked) {\n      var last = state2.lastBufferedRequest;\n      state2.lastBufferedRequest = {\n        chunk,\n        encoding,\n        isBuf,\n        callback: cb,\n        next: null\n      };\n      if (last) {\n        last.next = state2.lastBufferedRequest;\n      } else {\n        state2.bufferedRequest = state2.lastBufferedRequest;\n      }\n      state2.bufferedRequestCount += 1;\n    } else {\n      doWrite(stream, state2, false, len, chunk, encoding, cb);\n    }\n    return ret;\n  }\n  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {\n    state2.writelen = len;\n    state2.writecb = cb;\n    state2.writing = true;\n    state2.sync = true;\n    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED(\"write\"));\n    else if (writev) stream._writev(chunk, state2.onwrite);\n    else stream._write(chunk, encoding, state2.onwrite);\n    state2.sync = false;\n  }\n  function onwriteError(stream, state2, sync, er, cb) {\n    --state2.pendingcb;\n    if (sync) {\n      process$1.nextTick(cb, er);\n      process$1.nextTick(finishMaybe, stream, state2);\n      stream._writableState.errorEmitted = true;\n      errorOrDestroy(stream, er);\n    } else {\n      cb(er);\n      stream._writableState.errorEmitted = true;\n      errorOrDestroy(stream, er);\n      finishMaybe(stream, state2);\n    }\n  }\n  function onwriteStateUpdate(state2) {\n    state2.writing = false;\n    state2.writecb = null;\n    state2.length -= state2.writelen;\n    state2.writelen = 0;\n  }\n  function onwrite(stream, er) {\n    var state2 = stream._writableState;\n    var sync = state2.sync;\n    var cb = state2.writecb;\n    if (typeof cb !== \"function\") throw new ERR_MULTIPLE_CALLBACK();\n    onwriteStateUpdate(state2);\n    if (er) onwriteError(stream, state2, sync, er, cb);\n    else {\n      var finished = needFinish(state2) || stream.destroyed;\n      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {\n        clearBuffer(stream, state2);\n      }\n      if (sync) {\n        process$1.nextTick(afterWrite, stream, state2, finished, cb);\n      } else {\n        afterWrite(stream, state2, finished, cb);\n      }\n    }\n  }\n  function afterWrite(stream, state2, finished, cb) {\n    if (!finished) onwriteDrain(stream, state2);\n    state2.pendingcb--;\n    cb();\n    finishMaybe(stream, state2);\n  }\n  function onwriteDrain(stream, state2) {\n    if (state2.length === 0 && state2.needDrain) {\n      state2.needDrain = false;\n      stream.emit(\"drain\");\n    }\n  }\n  function clearBuffer(stream, state2) {\n    state2.bufferProcessing = true;\n    var entry = state2.bufferedRequest;\n    if (stream._writev && entry && entry.next) {\n      var l = state2.bufferedRequestCount;\n      var buffer2 = new Array(l);\n      var holder = state2.corkedRequestsFree;\n      holder.entry = entry;\n      var count = 0;\n      var allBuffers = true;\n      while (entry) {\n        buffer2[count] = entry;\n        if (!entry.isBuf) allBuffers = false;\n        entry = entry.next;\n        count += 1;\n      }\n      buffer2.allBuffers = allBuffers;\n      doWrite(stream, state2, true, state2.length, buffer2, \"\", holder.finish);\n      state2.pendingcb++;\n      state2.lastBufferedRequest = null;\n      if (holder.next) {\n        state2.corkedRequestsFree = holder.next;\n        holder.next = null;\n      } else {\n        state2.corkedRequestsFree = new CorkedRequest(state2);\n      }\n      state2.bufferedRequestCount = 0;\n    } else {\n      while (entry) {\n        var chunk = entry.chunk;\n        var encoding = entry.encoding;\n        var cb = entry.callback;\n        var len = state2.objectMode ? 1 : chunk.length;\n        doWrite(stream, state2, false, len, chunk, encoding, cb);\n        entry = entry.next;\n        state2.bufferedRequestCount--;\n        if (state2.writing) {\n          break;\n        }\n      }\n      if (entry === null) state2.lastBufferedRequest = null;\n    }\n    state2.bufferedRequest = entry;\n    state2.bufferProcessing = false;\n  }\n  Writable.prototype._write = function(chunk, encoding, cb) {\n    cb(new ERR_METHOD_NOT_IMPLEMENTED(\"_write()\"));\n  };\n  Writable.prototype._writev = null;\n  Writable.prototype.end = function(chunk, encoding, cb) {\n    var state2 = this._writableState;\n    if (typeof chunk === \"function\") {\n      cb = chunk;\n      chunk = null;\n      encoding = null;\n    } else if (typeof encoding === \"function\") {\n      cb = encoding;\n      encoding = null;\n    }\n    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);\n    if (state2.corked) {\n      state2.corked = 1;\n      this.uncork();\n    }\n    if (!state2.ending) endWritable(this, state2, cb);\n    return this;\n  };\n  Object.defineProperty(Writable.prototype, \"writableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState.length;\n    }\n  });\n  function needFinish(state2) {\n    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;\n  }\n  function callFinal(stream, state2) {\n    stream._final(function(err) {\n      state2.pendingcb--;\n      if (err) {\n        errorOrDestroy(stream, err);\n      }\n      state2.prefinished = true;\n      stream.emit(\"prefinish\");\n      finishMaybe(stream, state2);\n    });\n  }\n  function prefinish(stream, state2) {\n    if (!state2.prefinished && !state2.finalCalled) {\n      if (typeof stream._final === \"function\" && !state2.destroyed) {\n        state2.pendingcb++;\n        state2.finalCalled = true;\n        process$1.nextTick(callFinal, stream, state2);\n      } else {\n        state2.prefinished = true;\n        stream.emit(\"prefinish\");\n      }\n    }\n  }\n  function finishMaybe(stream, state2) {\n    var need = needFinish(state2);\n    if (need) {\n      prefinish(stream, state2);\n      if (state2.pendingcb === 0) {\n        state2.finished = true;\n        stream.emit(\"finish\");\n        if (state2.autoDestroy) {\n          var rState = stream._readableState;\n          if (!rState || rState.autoDestroy && rState.endEmitted) {\n            stream.destroy();\n          }\n        }\n      }\n    }\n    return need;\n  }\n  function endWritable(stream, state2, cb) {\n    state2.ending = true;\n    finishMaybe(stream, state2);\n    if (cb) {\n      if (state2.finished) process$1.nextTick(cb);\n      else stream.once(\"finish\", cb);\n    }\n    state2.ended = true;\n    stream.writable = false;\n  }\n  function onCorkedFinish(corkReq, state2, err) {\n    var entry = corkReq.entry;\n    corkReq.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state2.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    state2.corkedRequestsFree.next = corkReq;\n  }\n  Object.defineProperty(Writable.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      if (this._writableState === void 0) {\n        return false;\n      }\n      return this._writableState.destroyed;\n    },\n    set: function set(value) {\n      if (!this._writableState) {\n        return;\n      }\n      this._writableState.destroyed = value;\n    }\n  });\n  Writable.prototype.destroy = destroyImpl.destroy;\n  Writable.prototype._undestroy = destroyImpl.undestroy;\n  Writable.prototype._destroy = function(err, cb) {\n    cb(err);\n  };\n  return _stream_writable;\n}\nvar _stream_duplex;\nvar hasRequired_stream_duplex;\nfunction require_stream_duplex() {\n  if (hasRequired_stream_duplex) return _stream_duplex;\n  hasRequired_stream_duplex = 1;\n  var objectKeys = Object.keys || function(obj) {\n    var keys2 = [];\n    for (var key in obj) {\n      keys2.push(key);\n    }\n    return keys2;\n  };\n  _stream_duplex = Duplex;\n  var Readable = require_stream_readable();\n  var Writable = require_stream_writable();\n  requireInherits_browser()(Duplex, Readable);\n  {\n    var keys = objectKeys(Writable.prototype);\n    for (var v = 0; v < keys.length; v++) {\n      var method = keys[v];\n      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n    }\n  }\n  function Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    this.allowHalfOpen = true;\n    if (options) {\n      if (options.readable === false) this.readable = false;\n      if (options.writable === false) this.writable = false;\n      if (options.allowHalfOpen === false) {\n        this.allowHalfOpen = false;\n        this.once(\"end\", onend);\n      }\n    }\n  }\n  Object.defineProperty(Duplex.prototype, \"writableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState.highWaterMark;\n    }\n  });\n  Object.defineProperty(Duplex.prototype, \"writableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  });\n  Object.defineProperty(Duplex.prototype, \"writableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._writableState.length;\n    }\n  });\n  function onend() {\n    if (this._writableState.ended) return;\n    process$1.nextTick(onEndNT, this);\n  }\n  function onEndNT(self2) {\n    self2.end();\n  }\n  Object.defineProperty(Duplex.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      if (this._readableState === void 0 || this._writableState === void 0) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    },\n    set: function set(value) {\n      if (this._readableState === void 0 || this._writableState === void 0) {\n        return;\n      }\n      this._readableState.destroyed = value;\n      this._writableState.destroyed = value;\n    }\n  });\n  return _stream_duplex;\n}\nvar string_decoder = {};\nvar safeBuffer = { exports: {} };\nvar hasRequiredSafeBuffer;\nfunction requireSafeBuffer() {\n  if (hasRequiredSafeBuffer) return safeBuffer.exports;\n  hasRequiredSafeBuffer = 1;\n  (function(module, exports) {\n    var buffer2 = requireBuffer();\n    var Buffer2 = buffer2.Buffer;\n    function copyProps(src, dst) {\n      for (var key in src) {\n        dst[key] = src[key];\n      }\n    }\n    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {\n      module.exports = buffer2;\n    } else {\n      copyProps(buffer2, exports);\n      exports.Buffer = SafeBuffer;\n    }\n    function SafeBuffer(arg, encodingOrOffset, length) {\n      return Buffer2(arg, encodingOrOffset, length);\n    }\n    copyProps(Buffer2, SafeBuffer);\n    SafeBuffer.from = function(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        throw new TypeError(\"Argument must not be a number\");\n      }\n      return Buffer2(arg, encodingOrOffset, length);\n    };\n    SafeBuffer.alloc = function(size, fill, encoding) {\n      if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n      }\n      var buf = Buffer2(size);\n      if (fill !== void 0) {\n        if (typeof encoding === \"string\") {\n          buf.fill(fill, encoding);\n        } else {\n          buf.fill(fill);\n        }\n      } else {\n        buf.fill(0);\n      }\n      return buf;\n    };\n    SafeBuffer.allocUnsafe = function(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n      }\n      return Buffer2(size);\n    };\n    SafeBuffer.allocUnsafeSlow = function(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError(\"Argument must be a number\");\n      }\n      return buffer2.SlowBuffer(size);\n    };\n  })(safeBuffer, safeBuffer.exports);\n  return safeBuffer.exports;\n}\nvar hasRequiredString_decoder;\nfunction requireString_decoder() {\n  if (hasRequiredString_decoder) return string_decoder;\n  hasRequiredString_decoder = 1;\n  var Buffer2 = requireSafeBuffer().Buffer;\n  var isEncoding = Buffer2.isEncoding || function(encoding) {\n    encoding = \"\" + encoding;\n    switch (encoding && encoding.toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n      case \"raw\":\n        return true;\n      default:\n        return false;\n    }\n  };\n  function _normalizeEncoding(enc) {\n    if (!enc) return \"utf8\";\n    var retried;\n    while (true) {\n      switch (enc) {\n        case \"utf8\":\n        case \"utf-8\":\n          return \"utf8\";\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return \"utf16le\";\n        case \"latin1\":\n        case \"binary\":\n          return \"latin1\";\n        case \"base64\":\n        case \"ascii\":\n        case \"hex\":\n          return enc;\n        default:\n          if (retried) return;\n          enc = (\"\" + enc).toLowerCase();\n          retried = true;\n      }\n    }\n  }\n  function normalizeEncoding(enc) {\n    var nenc = _normalizeEncoding(enc);\n    if (typeof nenc !== \"string\" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error(\"Unknown encoding: \" + enc);\n    return nenc || enc;\n  }\n  string_decoder.StringDecoder = StringDecoder;\n  function StringDecoder(encoding) {\n    this.encoding = normalizeEncoding(encoding);\n    var nb;\n    switch (this.encoding) {\n      case \"utf16le\":\n        this.text = utf16Text;\n        this.end = utf16End;\n        nb = 4;\n        break;\n      case \"utf8\":\n        this.fillLast = utf8FillLast;\n        nb = 4;\n        break;\n      case \"base64\":\n        this.text = base64Text;\n        this.end = base64End;\n        nb = 3;\n        break;\n      default:\n        this.write = simpleWrite;\n        this.end = simpleEnd;\n        return;\n    }\n    this.lastNeed = 0;\n    this.lastTotal = 0;\n    this.lastChar = Buffer2.allocUnsafe(nb);\n  }\n  StringDecoder.prototype.write = function(buf) {\n    if (buf.length === 0) return \"\";\n    var r;\n    var i;\n    if (this.lastNeed) {\n      r = this.fillLast(buf);\n      if (r === void 0) return \"\";\n      i = this.lastNeed;\n      this.lastNeed = 0;\n    } else {\n      i = 0;\n    }\n    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n    return r || \"\";\n  };\n  StringDecoder.prototype.end = utf8End;\n  StringDecoder.prototype.text = utf8Text;\n  StringDecoder.prototype.fillLast = function(buf) {\n    if (this.lastNeed <= buf.length) {\n      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n      return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n    this.lastNeed -= buf.length;\n  };\n  function utf8CheckByte(byte) {\n    if (byte <= 127) return 0;\n    else if (byte >> 5 === 6) return 2;\n    else if (byte >> 4 === 14) return 3;\n    else if (byte >> 3 === 30) return 4;\n    return byte >> 6 === 2 ? -1 : -2;\n  }\n  function utf8CheckIncomplete(self2, buf, i) {\n    var j = buf.length - 1;\n    if (j < i) return 0;\n    var nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n      if (nb > 0) self2.lastNeed = nb - 1;\n      return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n      if (nb > 0) self2.lastNeed = nb - 2;\n      return nb;\n    }\n    if (--j < i || nb === -2) return 0;\n    nb = utf8CheckByte(buf[j]);\n    if (nb >= 0) {\n      if (nb > 0) {\n        if (nb === 2) nb = 0;\n        else self2.lastNeed = nb - 3;\n      }\n      return nb;\n    }\n    return 0;\n  }\n  function utf8CheckExtraBytes(self2, buf, p) {\n    if ((buf[0] & 192) !== 128) {\n      self2.lastNeed = 0;\n      return \"\";\n    }\n    if (self2.lastNeed > 1 && buf.length > 1) {\n      if ((buf[1] & 192) !== 128) {\n        self2.lastNeed = 1;\n        return \"\";\n      }\n      if (self2.lastNeed > 2 && buf.length > 2) {\n        if ((buf[2] & 192) !== 128) {\n          self2.lastNeed = 2;\n          return \"\";\n        }\n      }\n    }\n  }\n  function utf8FillLast(buf) {\n    var p = this.lastTotal - this.lastNeed;\n    var r = utf8CheckExtraBytes(this, buf);\n    if (r !== void 0) return r;\n    if (this.lastNeed <= buf.length) {\n      buf.copy(this.lastChar, p, 0, this.lastNeed);\n      return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n    }\n    buf.copy(this.lastChar, p, 0, buf.length);\n    this.lastNeed -= buf.length;\n  }\n  function utf8Text(buf, i) {\n    var total = utf8CheckIncomplete(this, buf, i);\n    if (!this.lastNeed) return buf.toString(\"utf8\", i);\n    this.lastTotal = total;\n    var end = buf.length - (total - this.lastNeed);\n    buf.copy(this.lastChar, 0, end);\n    return buf.toString(\"utf8\", i, end);\n  }\n  function utf8End(buf) {\n    var r = buf && buf.length ? this.write(buf) : \"\";\n    if (this.lastNeed) return r + \"\";\n    return r;\n  }\n  function utf16Text(buf, i) {\n    if ((buf.length - i) % 2 === 0) {\n      var r = buf.toString(\"utf16le\", i);\n      if (r) {\n        var c = r.charCodeAt(r.length - 1);\n        if (c >= 55296 && c <= 56319) {\n          this.lastNeed = 2;\n          this.lastTotal = 4;\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n          return r.slice(0, -1);\n        }\n      }\n      return r;\n    }\n    this.lastNeed = 1;\n    this.lastTotal = 2;\n    this.lastChar[0] = buf[buf.length - 1];\n    return buf.toString(\"utf16le\", i, buf.length - 1);\n  }\n  function utf16End(buf) {\n    var r = buf && buf.length ? this.write(buf) : \"\";\n    if (this.lastNeed) {\n      var end = this.lastTotal - this.lastNeed;\n      return r + this.lastChar.toString(\"utf16le\", 0, end);\n    }\n    return r;\n  }\n  function base64Text(buf, i) {\n    var n = (buf.length - i) % 3;\n    if (n === 0) return buf.toString(\"base64\", i);\n    this.lastNeed = 3 - n;\n    this.lastTotal = 3;\n    if (n === 1) {\n      this.lastChar[0] = buf[buf.length - 1];\n    } else {\n      this.lastChar[0] = buf[buf.length - 2];\n      this.lastChar[1] = buf[buf.length - 1];\n    }\n    return buf.toString(\"base64\", i, buf.length - n);\n  }\n  function base64End(buf) {\n    var r = buf && buf.length ? this.write(buf) : \"\";\n    if (this.lastNeed) return r + this.lastChar.toString(\"base64\", 0, 3 - this.lastNeed);\n    return r;\n  }\n  function simpleWrite(buf) {\n    return buf.toString(this.encoding);\n  }\n  function simpleEnd(buf) {\n    return buf && buf.length ? this.write(buf) : \"\";\n  }\n  return string_decoder;\n}\nvar endOfStream;\nvar hasRequiredEndOfStream;\nfunction requireEndOfStream() {\n  if (hasRequiredEndOfStream) return endOfStream;\n  hasRequiredEndOfStream = 1;\n  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;\n  function once(callback) {\n    var called = false;\n    return function() {\n      if (called) return;\n      called = true;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      callback.apply(this, args);\n    };\n  }\n  function noop2() {\n  }\n  function isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === \"function\";\n  }\n  function eos(stream, opts, callback) {\n    if (typeof opts === \"function\") return eos(stream, null, opts);\n    if (!opts) opts = {};\n    callback = once(callback || noop2);\n    var readable = opts.readable || opts.readable !== false && stream.readable;\n    var writable = opts.writable || opts.writable !== false && stream.writable;\n    var onlegacyfinish = function onlegacyfinish2() {\n      if (!stream.writable) onfinish();\n    };\n    var writableEnded = stream._writableState && stream._writableState.finished;\n    var onfinish = function onfinish2() {\n      writable = false;\n      writableEnded = true;\n      if (!readable) callback.call(stream);\n    };\n    var readableEnded = stream._readableState && stream._readableState.endEmitted;\n    var onend = function onend2() {\n      readable = false;\n      readableEnded = true;\n      if (!writable) callback.call(stream);\n    };\n    var onerror = function onerror2(err) {\n      callback.call(stream, err);\n    };\n    var onclose = function onclose2() {\n      var err;\n      if (readable && !readableEnded) {\n        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n        return callback.call(stream, err);\n      }\n      if (writable && !writableEnded) {\n        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n        return callback.call(stream, err);\n      }\n    };\n    var onrequest = function onrequest2() {\n      stream.req.on(\"finish\", onfinish);\n    };\n    if (isRequest(stream)) {\n      stream.on(\"complete\", onfinish);\n      stream.on(\"abort\", onclose);\n      if (stream.req) onrequest();\n      else stream.on(\"request\", onrequest);\n    } else if (writable && !stream._writableState) {\n      stream.on(\"end\", onlegacyfinish);\n      stream.on(\"close\", onlegacyfinish);\n    }\n    stream.on(\"end\", onend);\n    stream.on(\"finish\", onfinish);\n    if (opts.error !== false) stream.on(\"error\", onerror);\n    stream.on(\"close\", onclose);\n    return function() {\n      stream.removeListener(\"complete\", onfinish);\n      stream.removeListener(\"abort\", onclose);\n      stream.removeListener(\"request\", onrequest);\n      if (stream.req) stream.req.removeListener(\"finish\", onfinish);\n      stream.removeListener(\"end\", onlegacyfinish);\n      stream.removeListener(\"close\", onlegacyfinish);\n      stream.removeListener(\"finish\", onfinish);\n      stream.removeListener(\"end\", onend);\n      stream.removeListener(\"error\", onerror);\n      stream.removeListener(\"close\", onclose);\n    };\n  }\n  endOfStream = eos;\n  return endOfStream;\n}\nvar async_iterator;\nvar hasRequiredAsync_iterator;\nfunction requireAsync_iterator() {\n  if (hasRequiredAsync_iterator) return async_iterator;\n  hasRequiredAsync_iterator = 1;\n  var _Object$setPrototypeO;\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  var finished = requireEndOfStream();\n  var kLastResolve = Symbol(\"lastResolve\");\n  var kLastReject = Symbol(\"lastReject\");\n  var kError = Symbol(\"error\");\n  var kEnded = Symbol(\"ended\");\n  var kLastPromise = Symbol(\"lastPromise\");\n  var kHandlePromise = Symbol(\"handlePromise\");\n  var kStream = Symbol(\"stream\");\n  function createIterResult(value, done) {\n    return {\n      value,\n      done\n    };\n  }\n  function readAndResolve(iter) {\n    var resolve = iter[kLastResolve];\n    if (resolve !== null) {\n      var data = iter[kStream].read();\n      if (data !== null) {\n        iter[kLastPromise] = null;\n        iter[kLastResolve] = null;\n        iter[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      }\n    }\n  }\n  function onReadable(iter) {\n    process$1.nextTick(readAndResolve, iter);\n  }\n  function wrapForNext(lastPromise, iter) {\n    return function(resolve, reject) {\n      lastPromise.then(function() {\n        if (iter[kEnded]) {\n          resolve(createIterResult(void 0, true));\n          return;\n        }\n        iter[kHandlePromise](resolve, reject);\n      }, reject);\n    };\n  }\n  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {\n  });\n  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n    get stream() {\n      return this[kStream];\n    },\n    next: function next() {\n      var _this = this;\n      var error = this[kError];\n      if (error !== null) {\n        return Promise.reject(error);\n      }\n      if (this[kEnded]) {\n        return Promise.resolve(createIterResult(void 0, true));\n      }\n      if (this[kStream].destroyed) {\n        return new Promise(function(resolve, reject) {\n          process$1.nextTick(function() {\n            if (_this[kError]) {\n              reject(_this[kError]);\n            } else {\n              resolve(createIterResult(void 0, true));\n            }\n          });\n        });\n      }\n      var lastPromise = this[kLastPromise];\n      var promise;\n      if (lastPromise) {\n        promise = new Promise(wrapForNext(lastPromise, this));\n      } else {\n        var data = this[kStream].read();\n        if (data !== null) {\n          return Promise.resolve(createIterResult(data, false));\n        }\n        promise = new Promise(this[kHandlePromise]);\n      }\n      this[kLastPromise] = promise;\n      return promise;\n    }\n  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {\n    return this;\n  }), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n    var _this2 = this;\n    return new Promise(function(resolve, reject) {\n      _this2[kStream].destroy(null, function(err) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(createIterResult(void 0, true));\n      });\n    });\n  }), _Object$setPrototypeO), AsyncIteratorPrototype);\n  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {\n    var _Object$create;\n    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n      value: stream,\n      writable: true\n    }), _defineProperty(_Object$create, kLastResolve, {\n      value: null,\n      writable: true\n    }), _defineProperty(_Object$create, kLastReject, {\n      value: null,\n      writable: true\n    }), _defineProperty(_Object$create, kError, {\n      value: null,\n      writable: true\n    }), _defineProperty(_Object$create, kEnded, {\n      value: stream._readableState.endEmitted,\n      writable: true\n    }), _defineProperty(_Object$create, kHandlePromise, {\n      value: function value(resolve, reject) {\n        var data = iterator[kStream].read();\n        if (data) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          resolve(createIterResult(data, false));\n        } else {\n          iterator[kLastResolve] = resolve;\n          iterator[kLastReject] = reject;\n        }\n      },\n      writable: true\n    }), _Object$create));\n    iterator[kLastPromise] = null;\n    finished(stream, function(err) {\n      if (err && err.code !== \"ERR_STREAM_PREMATURE_CLOSE\") {\n        var reject = iterator[kLastReject];\n        if (reject !== null) {\n          iterator[kLastPromise] = null;\n          iterator[kLastResolve] = null;\n          iterator[kLastReject] = null;\n          reject(err);\n        }\n        iterator[kError] = err;\n        return;\n      }\n      var resolve = iterator[kLastResolve];\n      if (resolve !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(void 0, true));\n      }\n      iterator[kEnded] = true;\n    });\n    stream.on(\"readable\", onReadable.bind(null, iterator));\n    return iterator;\n  };\n  async_iterator = createReadableStreamAsyncIterator;\n  return async_iterator;\n}\nvar fromBrowser;\nvar hasRequiredFromBrowser;\nfunction requireFromBrowser() {\n  if (hasRequiredFromBrowser) return fromBrowser;\n  hasRequiredFromBrowser = 1;\n  fromBrowser = function() {\n    throw new Error(\"Readable.from is not available in the browser\");\n  };\n  return fromBrowser;\n}\nvar _stream_readable;\nvar hasRequired_stream_readable;\nfunction require_stream_readable() {\n  if (hasRequired_stream_readable) return _stream_readable;\n  hasRequired_stream_readable = 1;\n  _stream_readable = Readable;\n  var Duplex;\n  Readable.ReadableState = ReadableState;\n  requireEvents().EventEmitter;\n  var EElistenerCount = function EElistenerCount2(emitter, type2) {\n    return emitter.listeners(type2).length;\n  };\n  var Stream = requireStreamBrowser();\n  var Buffer2 = requireBuffer().Buffer;\n  var OurUint8Array = commonjsGlobal.Uint8Array || function() {\n  };\n  function _uint8ArrayToBuffer(chunk) {\n    return Buffer2.from(chunk);\n  }\n  function _isUint8Array(obj) {\n    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;\n  }\n  var debugUtil = requireUtil();\n  var debug;\n  if (debugUtil && debugUtil.debuglog) {\n    debug = debugUtil.debuglog(\"stream\");\n  } else {\n    debug = function debug2() {\n    };\n  }\n  var BufferList = requireBuffer_list();\n  var destroyImpl = requireDestroy();\n  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;\n  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n  var StringDecoder;\n  var createReadableStreamAsyncIterator;\n  var from;\n  requireInherits_browser()(Readable, Stream);\n  var errorOrDestroy = destroyImpl.errorOrDestroy;\n  var kProxyEvents = [\"error\", \"close\", \"destroy\", \"pause\", \"resume\"];\n  function prependListener(emitter, event, fn) {\n    if (typeof emitter.prependListener === \"function\") return emitter.prependListener(event, fn);\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);\n    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);\n    else emitter._events[event] = [fn, emitter._events[event]];\n  }\n  function ReadableState(options, stream, isDuplex) {\n    Duplex = Duplex || require_stream_duplex();\n    options = options || {};\n    if (typeof isDuplex !== \"boolean\") isDuplex = stream instanceof Duplex;\n    this.objectMode = !!options.objectMode;\n    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    this.highWaterMark = getHighWaterMark(this, options, \"readableHighWaterMark\", isDuplex);\n    this.buffer = new BufferList();\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    this.sync = true;\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    this.resumeScheduled = false;\n    this.paused = true;\n    this.emitClose = options.emitClose !== false;\n    this.autoDestroy = !!options.autoDestroy;\n    this.destroyed = false;\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    this.awaitDrain = 0;\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;\n      this.decoder = new StringDecoder(options.encoding);\n      this.encoding = options.encoding;\n    }\n  }\n  function Readable(options) {\n    Duplex = Duplex || require_stream_duplex();\n    if (!(this instanceof Readable)) return new Readable(options);\n    var isDuplex = this instanceof Duplex;\n    this._readableState = new ReadableState(options, this, isDuplex);\n    this.readable = true;\n    if (options) {\n      if (typeof options.read === \"function\") this._read = options.read;\n      if (typeof options.destroy === \"function\") this._destroy = options.destroy;\n    }\n    Stream.call(this);\n  }\n  Object.defineProperty(Readable.prototype, \"destroyed\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      if (this._readableState === void 0) {\n        return false;\n      }\n      return this._readableState.destroyed;\n    },\n    set: function set(value) {\n      if (!this._readableState) {\n        return;\n      }\n      this._readableState.destroyed = value;\n    }\n  });\n  Readable.prototype.destroy = destroyImpl.destroy;\n  Readable.prototype._undestroy = destroyImpl.undestroy;\n  Readable.prototype._destroy = function(err, cb) {\n    cb(err);\n  };\n  Readable.prototype.push = function(chunk, encoding) {\n    var state2 = this._readableState;\n    var skipChunkCheck;\n    if (!state2.objectMode) {\n      if (typeof chunk === \"string\") {\n        encoding = encoding || state2.defaultEncoding;\n        if (encoding !== state2.encoding) {\n          chunk = Buffer2.from(chunk, encoding);\n          encoding = \"\";\n        }\n        skipChunkCheck = true;\n      }\n    } else {\n      skipChunkCheck = true;\n    }\n    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n  };\n  Readable.prototype.unshift = function(chunk) {\n    return readableAddChunk(this, chunk, null, true, false);\n  };\n  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n    debug(\"readableAddChunk\", chunk);\n    var state2 = stream._readableState;\n    if (chunk === null) {\n      state2.reading = false;\n      onEofChunk(stream, state2);\n    } else {\n      var er;\n      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);\n      if (er) {\n        errorOrDestroy(stream, er);\n      } else if (state2.objectMode || chunk && chunk.length > 0) {\n        if (typeof chunk !== \"string\" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {\n          chunk = _uint8ArrayToBuffer(chunk);\n        }\n        if (addToFront) {\n          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n          else addChunk(stream, state2, chunk, true);\n        } else if (state2.ended) {\n          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n        } else if (state2.destroyed) {\n          return false;\n        } else {\n          state2.reading = false;\n          if (state2.decoder && !encoding) {\n            chunk = state2.decoder.write(chunk);\n            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);\n            else maybeReadMore(stream, state2);\n          } else {\n            addChunk(stream, state2, chunk, false);\n          }\n        }\n      } else if (!addToFront) {\n        state2.reading = false;\n        maybeReadMore(stream, state2);\n      }\n    }\n    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);\n  }\n  function addChunk(stream, state2, chunk, addToFront) {\n    if (state2.flowing && state2.length === 0 && !state2.sync) {\n      state2.awaitDrain = 0;\n      stream.emit(\"data\", chunk);\n    } else {\n      state2.length += state2.objectMode ? 1 : chunk.length;\n      if (addToFront) state2.buffer.unshift(chunk);\n      else state2.buffer.push(chunk);\n      if (state2.needReadable) emitReadable(stream);\n    }\n    maybeReadMore(stream, state2);\n  }\n  function chunkInvalid(state2, chunk) {\n    var er;\n    if (!_isUint8Array(chunk) && typeof chunk !== \"string\" && chunk !== void 0 && !state2.objectMode) {\n      er = new ERR_INVALID_ARG_TYPE(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], chunk);\n    }\n    return er;\n  }\n  Readable.prototype.isPaused = function() {\n    return this._readableState.flowing === false;\n  };\n  Readable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;\n    var decoder = new StringDecoder(enc);\n    this._readableState.decoder = decoder;\n    this._readableState.encoding = this._readableState.decoder.encoding;\n    var p = this._readableState.buffer.head;\n    var content = \"\";\n    while (p !== null) {\n      content += decoder.write(p.data);\n      p = p.next;\n    }\n    this._readableState.buffer.clear();\n    if (content !== \"\") this._readableState.buffer.push(content);\n    this._readableState.length = content.length;\n    return this;\n  };\n  var MAX_HWM = 1073741824;\n  function computeNewHighWaterMark(n) {\n    if (n >= MAX_HWM) {\n      n = MAX_HWM;\n    } else {\n      n--;\n      n |= n >>> 1;\n      n |= n >>> 2;\n      n |= n >>> 4;\n      n |= n >>> 8;\n      n |= n >>> 16;\n      n++;\n    }\n    return n;\n  }\n  function howMuchToRead(n, state2) {\n    if (n <= 0 || state2.length === 0 && state2.ended) return 0;\n    if (state2.objectMode) return 1;\n    if (n !== n) {\n      if (state2.flowing && state2.length) return state2.buffer.head.data.length;\n      else return state2.length;\n    }\n    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);\n    if (n <= state2.length) return n;\n    if (!state2.ended) {\n      state2.needReadable = true;\n      return 0;\n    }\n    return state2.length;\n  }\n  Readable.prototype.read = function(n) {\n    debug(\"read\", n);\n    n = parseInt(n, 10);\n    var state2 = this._readableState;\n    var nOrig = n;\n    if (n !== 0) state2.emittedReadable = false;\n    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {\n      debug(\"read: emitReadable\", state2.length, state2.ended);\n      if (state2.length === 0 && state2.ended) endReadable(this);\n      else emitReadable(this);\n      return null;\n    }\n    n = howMuchToRead(n, state2);\n    if (n === 0 && state2.ended) {\n      if (state2.length === 0) endReadable(this);\n      return null;\n    }\n    var doRead = state2.needReadable;\n    debug(\"need readable\", doRead);\n    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {\n      doRead = true;\n      debug(\"length less than watermark\", doRead);\n    }\n    if (state2.ended || state2.reading) {\n      doRead = false;\n      debug(\"reading or ended\", doRead);\n    } else if (doRead) {\n      debug(\"do read\");\n      state2.reading = true;\n      state2.sync = true;\n      if (state2.length === 0) state2.needReadable = true;\n      this._read(state2.highWaterMark);\n      state2.sync = false;\n      if (!state2.reading) n = howMuchToRead(nOrig, state2);\n    }\n    var ret;\n    if (n > 0) ret = fromList(n, state2);\n    else ret = null;\n    if (ret === null) {\n      state2.needReadable = state2.length <= state2.highWaterMark;\n      n = 0;\n    } else {\n      state2.length -= n;\n      state2.awaitDrain = 0;\n    }\n    if (state2.length === 0) {\n      if (!state2.ended) state2.needReadable = true;\n      if (nOrig !== n && state2.ended) endReadable(this);\n    }\n    if (ret !== null) this.emit(\"data\", ret);\n    return ret;\n  };\n  function onEofChunk(stream, state2) {\n    debug(\"onEofChunk\");\n    if (state2.ended) return;\n    if (state2.decoder) {\n      var chunk = state2.decoder.end();\n      if (chunk && chunk.length) {\n        state2.buffer.push(chunk);\n        state2.length += state2.objectMode ? 1 : chunk.length;\n      }\n    }\n    state2.ended = true;\n    if (state2.sync) {\n      emitReadable(stream);\n    } else {\n      state2.needReadable = false;\n      if (!state2.emittedReadable) {\n        state2.emittedReadable = true;\n        emitReadable_(stream);\n      }\n    }\n  }\n  function emitReadable(stream) {\n    var state2 = stream._readableState;\n    debug(\"emitReadable\", state2.needReadable, state2.emittedReadable);\n    state2.needReadable = false;\n    if (!state2.emittedReadable) {\n      debug(\"emitReadable\", state2.flowing);\n      state2.emittedReadable = true;\n      process$1.nextTick(emitReadable_, stream);\n    }\n  }\n  function emitReadable_(stream) {\n    var state2 = stream._readableState;\n    debug(\"emitReadable_\", state2.destroyed, state2.length, state2.ended);\n    if (!state2.destroyed && (state2.length || state2.ended)) {\n      stream.emit(\"readable\");\n      state2.emittedReadable = false;\n    }\n    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;\n    flow(stream);\n  }\n  function maybeReadMore(stream, state2) {\n    if (!state2.readingMore) {\n      state2.readingMore = true;\n      process$1.nextTick(maybeReadMore_, stream, state2);\n    }\n  }\n  function maybeReadMore_(stream, state2) {\n    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {\n      var len = state2.length;\n      debug(\"maybeReadMore read 0\");\n      stream.read(0);\n      if (len === state2.length)\n        break;\n    }\n    state2.readingMore = false;\n  }\n  Readable.prototype._read = function(n) {\n    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED(\"_read()\"));\n  };\n  Readable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state2 = this._readableState;\n    switch (state2.pipesCount) {\n      case 0:\n        state2.pipes = dest;\n        break;\n      case 1:\n        state2.pipes = [state2.pipes, dest];\n        break;\n      default:\n        state2.pipes.push(dest);\n        break;\n    }\n    state2.pipesCount += 1;\n    debug(\"pipe count=%d opts=%j\", state2.pipesCount, pipeOpts);\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;\n    var endFn = doEnd ? onend : unpipe;\n    if (state2.endEmitted) process$1.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable, unpipeInfo) {\n      debug(\"onunpipe\");\n      if (readable === src) {\n        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n          unpipeInfo.hasUnpiped = true;\n          cleanup();\n        }\n      }\n    }\n    function onend() {\n      debug(\"onend\");\n      dest.end();\n    }\n    var ondrain = pipeOnDrain(src);\n    dest.on(\"drain\", ondrain);\n    var cleanedUp = false;\n    function cleanup() {\n      debug(\"cleanup\");\n      dest.removeListener(\"close\", onclose);\n      dest.removeListener(\"finish\", onfinish);\n      dest.removeListener(\"drain\", ondrain);\n      dest.removeListener(\"error\", onerror);\n      dest.removeListener(\"unpipe\", onunpipe);\n      src.removeListener(\"end\", onend);\n      src.removeListener(\"end\", unpipe);\n      src.removeListener(\"data\", ondata);\n      cleanedUp = true;\n      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n    src.on(\"data\", ondata);\n    function ondata(chunk) {\n      debug(\"ondata\");\n      var ret = dest.write(chunk);\n      debug(\"dest.write\", ret);\n      if (ret === false) {\n        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {\n          debug(\"false write response, pause\", state2.awaitDrain);\n          state2.awaitDrain++;\n        }\n        src.pause();\n      }\n    }\n    function onerror(er) {\n      debug(\"onerror\", er);\n      unpipe();\n      dest.removeListener(\"error\", onerror);\n      if (EElistenerCount(dest, \"error\") === 0) errorOrDestroy(dest, er);\n    }\n    prependListener(dest, \"error\", onerror);\n    function onclose() {\n      dest.removeListener(\"finish\", onfinish);\n      unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n      debug(\"onfinish\");\n      dest.removeListener(\"close\", onclose);\n      unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n      debug(\"unpipe\");\n      src.unpipe(dest);\n    }\n    dest.emit(\"pipe\", src);\n    if (!state2.flowing) {\n      debug(\"pipe resume\");\n      src.resume();\n    }\n    return dest;\n  };\n  function pipeOnDrain(src) {\n    return function pipeOnDrainFunctionResult() {\n      var state2 = src._readableState;\n      debug(\"pipeOnDrain\", state2.awaitDrain);\n      if (state2.awaitDrain) state2.awaitDrain--;\n      if (state2.awaitDrain === 0 && EElistenerCount(src, \"data\")) {\n        state2.flowing = true;\n        flow(src);\n      }\n    };\n  }\n  Readable.prototype.unpipe = function(dest) {\n    var state2 = this._readableState;\n    var unpipeInfo = {\n      hasUnpiped: false\n    };\n    if (state2.pipesCount === 0) return this;\n    if (state2.pipesCount === 1) {\n      if (dest && dest !== state2.pipes) return this;\n      if (!dest) dest = state2.pipes;\n      state2.pipes = null;\n      state2.pipesCount = 0;\n      state2.flowing = false;\n      if (dest) dest.emit(\"unpipe\", this, unpipeInfo);\n      return this;\n    }\n    if (!dest) {\n      var dests = state2.pipes;\n      var len = state2.pipesCount;\n      state2.pipes = null;\n      state2.pipesCount = 0;\n      state2.flowing = false;\n      for (var i = 0; i < len; i++) {\n        dests[i].emit(\"unpipe\", this, {\n          hasUnpiped: false\n        });\n      }\n      return this;\n    }\n    var index = indexOf(state2.pipes, dest);\n    if (index === -1) return this;\n    state2.pipes.splice(index, 1);\n    state2.pipesCount -= 1;\n    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];\n    dest.emit(\"unpipe\", this, unpipeInfo);\n    return this;\n  };\n  Readable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n    var state2 = this._readableState;\n    if (ev === \"data\") {\n      state2.readableListening = this.listenerCount(\"readable\") > 0;\n      if (state2.flowing !== false) this.resume();\n    } else if (ev === \"readable\") {\n      if (!state2.endEmitted && !state2.readableListening) {\n        state2.readableListening = state2.needReadable = true;\n        state2.flowing = false;\n        state2.emittedReadable = false;\n        debug(\"on readable\", state2.length, state2.reading);\n        if (state2.length) {\n          emitReadable(this);\n        } else if (!state2.reading) {\n          process$1.nextTick(nReadingNextTick, this);\n        }\n      }\n    }\n    return res;\n  };\n  Readable.prototype.addListener = Readable.prototype.on;\n  Readable.prototype.removeListener = function(ev, fn) {\n    var res = Stream.prototype.removeListener.call(this, ev, fn);\n    if (ev === \"readable\") {\n      process$1.nextTick(updateReadableListening, this);\n    }\n    return res;\n  };\n  Readable.prototype.removeAllListeners = function(ev) {\n    var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n    if (ev === \"readable\" || ev === void 0) {\n      process$1.nextTick(updateReadableListening, this);\n    }\n    return res;\n  };\n  function updateReadableListening(self2) {\n    var state2 = self2._readableState;\n    state2.readableListening = self2.listenerCount(\"readable\") > 0;\n    if (state2.resumeScheduled && !state2.paused) {\n      state2.flowing = true;\n    } else if (self2.listenerCount(\"data\") > 0) {\n      self2.resume();\n    }\n  }\n  function nReadingNextTick(self2) {\n    debug(\"readable nexttick read 0\");\n    self2.read(0);\n  }\n  Readable.prototype.resume = function() {\n    var state2 = this._readableState;\n    if (!state2.flowing) {\n      debug(\"resume\");\n      state2.flowing = !state2.readableListening;\n      resume(this, state2);\n    }\n    state2.paused = false;\n    return this;\n  };\n  function resume(stream, state2) {\n    if (!state2.resumeScheduled) {\n      state2.resumeScheduled = true;\n      process$1.nextTick(resume_, stream, state2);\n    }\n  }\n  function resume_(stream, state2) {\n    debug(\"resume\", state2.reading);\n    if (!state2.reading) {\n      stream.read(0);\n    }\n    state2.resumeScheduled = false;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state2.flowing && !state2.reading) stream.read(0);\n  }\n  Readable.prototype.pause = function() {\n    debug(\"call pause flowing=%j\", this._readableState.flowing);\n    if (this._readableState.flowing !== false) {\n      debug(\"pause\");\n      this._readableState.flowing = false;\n      this.emit(\"pause\");\n    }\n    this._readableState.paused = true;\n    return this;\n  };\n  function flow(stream) {\n    var state2 = stream._readableState;\n    debug(\"flow\", state2.flowing);\n    while (state2.flowing && stream.read() !== null) {\n    }\n  }\n  Readable.prototype.wrap = function(stream) {\n    var _this = this;\n    var state2 = this._readableState;\n    var paused = false;\n    stream.on(\"end\", function() {\n      debug(\"wrapped end\");\n      if (state2.decoder && !state2.ended) {\n        var chunk = state2.decoder.end();\n        if (chunk && chunk.length) _this.push(chunk);\n      }\n      _this.push(null);\n    });\n    stream.on(\"data\", function(chunk) {\n      debug(\"wrapped data\");\n      if (state2.decoder) chunk = state2.decoder.write(chunk);\n      if (state2.objectMode && (chunk === null || chunk === void 0)) return;\n      else if (!state2.objectMode && (!chunk || !chunk.length)) return;\n      var ret = _this.push(chunk);\n      if (!ret) {\n        paused = true;\n        stream.pause();\n      }\n    });\n    for (var i in stream) {\n      if (this[i] === void 0 && typeof stream[i] === \"function\") {\n        this[i] = /* @__PURE__ */ function methodWrap(method) {\n          return function methodWrapReturnFunction() {\n            return stream[method].apply(stream, arguments);\n          };\n        }(i);\n      }\n    }\n    for (var n = 0; n < kProxyEvents.length; n++) {\n      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n    }\n    this._read = function(n2) {\n      debug(\"wrapped _read\", n2);\n      if (paused) {\n        paused = false;\n        stream.resume();\n      }\n    };\n    return this;\n  };\n  if (typeof Symbol === \"function\") {\n    Readable.prototype[Symbol.asyncIterator] = function() {\n      if (createReadableStreamAsyncIterator === void 0) {\n        createReadableStreamAsyncIterator = requireAsync_iterator();\n      }\n      return createReadableStreamAsyncIterator(this);\n    };\n  }\n  Object.defineProperty(Readable.prototype, \"readableHighWaterMark\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._readableState.highWaterMark;\n    }\n  });\n  Object.defineProperty(Readable.prototype, \"readableBuffer\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._readableState && this._readableState.buffer;\n    }\n  });\n  Object.defineProperty(Readable.prototype, \"readableFlowing\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._readableState.flowing;\n    },\n    set: function set(state2) {\n      if (this._readableState) {\n        this._readableState.flowing = state2;\n      }\n    }\n  });\n  Readable._fromList = fromList;\n  Object.defineProperty(Readable.prototype, \"readableLength\", {\n    // making it explicit this property is not enumerable\n    // because otherwise some prototype manipulation in\n    // userland will fail\n    enumerable: false,\n    get: function get2() {\n      return this._readableState.length;\n    }\n  });\n  function fromList(n, state2) {\n    if (state2.length === 0) return null;\n    var ret;\n    if (state2.objectMode) ret = state2.buffer.shift();\n    else if (!n || n >= state2.length) {\n      if (state2.decoder) ret = state2.buffer.join(\"\");\n      else if (state2.buffer.length === 1) ret = state2.buffer.first();\n      else ret = state2.buffer.concat(state2.length);\n      state2.buffer.clear();\n    } else {\n      ret = state2.buffer.consume(n, state2.decoder);\n    }\n    return ret;\n  }\n  function endReadable(stream) {\n    var state2 = stream._readableState;\n    debug(\"endReadable\", state2.endEmitted);\n    if (!state2.endEmitted) {\n      state2.ended = true;\n      process$1.nextTick(endReadableNT, state2, stream);\n    }\n  }\n  function endReadableNT(state2, stream) {\n    debug(\"endReadableNT\", state2.endEmitted, state2.length);\n    if (!state2.endEmitted && state2.length === 0) {\n      state2.endEmitted = true;\n      stream.readable = false;\n      stream.emit(\"end\");\n      if (state2.autoDestroy) {\n        var wState = stream._writableState;\n        if (!wState || wState.autoDestroy && wState.finished) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  if (typeof Symbol === \"function\") {\n    Readable.from = function(iterable, opts) {\n      if (from === void 0) {\n        from = requireFromBrowser();\n      }\n      return from(Readable, iterable, opts);\n    };\n  }\n  function indexOf(xs, x) {\n    for (var i = 0, l = xs.length; i < l; i++) {\n      if (xs[i] === x) return i;\n    }\n    return -1;\n  }\n  return _stream_readable;\n}\nvar _stream_transform;\nvar hasRequired_stream_transform;\nfunction require_stream_transform() {\n  if (hasRequired_stream_transform) return _stream_transform;\n  hasRequired_stream_transform = 1;\n  _stream_transform = Transform;\n  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n  var Duplex = require_stream_duplex();\n  requireInherits_browser()(Transform, Duplex);\n  function afterTransform(er, data) {\n    var ts = this._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (cb === null) {\n      return this.emit(\"error\", new ERR_MULTIPLE_CALLBACK());\n    }\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (data != null)\n      this.push(data);\n    cb(er);\n    var rs = this._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n      this._read(rs.highWaterMark);\n    }\n  }\n  function Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = {\n      afterTransform: afterTransform.bind(this),\n      needTransform: false,\n      transforming: false,\n      writecb: null,\n      writechunk: null,\n      writeencoding: null\n    };\n    this._readableState.needReadable = true;\n    this._readableState.sync = false;\n    if (options) {\n      if (typeof options.transform === \"function\") this._transform = options.transform;\n      if (typeof options.flush === \"function\") this._flush = options.flush;\n    }\n    this.on(\"prefinish\", prefinish);\n  }\n  function prefinish() {\n    var _this = this;\n    if (typeof this._flush === \"function\" && !this._readableState.destroyed) {\n      this._flush(function(er, data) {\n        done(_this, er, data);\n      });\n    } else {\n      done(this, null, null);\n    }\n  }\n  Transform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n  };\n  Transform.prototype._transform = function(chunk, encoding, cb) {\n    cb(new ERR_METHOD_NOT_IMPLEMENTED(\"_transform()\"));\n  };\n  Transform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n      var rs = this._readableState;\n      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n  };\n  Transform.prototype._read = function(n) {\n    var ts = this._transformState;\n    if (ts.writechunk !== null && !ts.transforming) {\n      ts.transforming = true;\n      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n      ts.needTransform = true;\n    }\n  };\n  Transform.prototype._destroy = function(err, cb) {\n    Duplex.prototype._destroy.call(this, err, function(err2) {\n      cb(err2);\n    });\n  };\n  function done(stream, er, data) {\n    if (er) return stream.emit(\"error\", er);\n    if (data != null)\n      stream.push(data);\n    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n    return stream.push(null);\n  }\n  return _stream_transform;\n}\nvar _stream_passthrough;\nvar hasRequired_stream_passthrough;\nfunction require_stream_passthrough() {\n  if (hasRequired_stream_passthrough) return _stream_passthrough;\n  hasRequired_stream_passthrough = 1;\n  _stream_passthrough = PassThrough;\n  var Transform = require_stream_transform();\n  requireInherits_browser()(PassThrough, Transform);\n  function PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n  }\n  PassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n  };\n  return _stream_passthrough;\n}\nvar pipeline_1;\nvar hasRequiredPipeline;\nfunction requirePipeline() {\n  if (hasRequiredPipeline) return pipeline_1;\n  hasRequiredPipeline = 1;\n  var eos;\n  function once(callback) {\n    var called = false;\n    return function() {\n      if (called) return;\n      called = true;\n      callback.apply(void 0, arguments);\n    };\n  }\n  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n  function noop2(err) {\n    if (err) throw err;\n  }\n  function isRequest(stream) {\n    return stream.setHeader && typeof stream.abort === \"function\";\n  }\n  function destroyer(stream, reading, writing, callback) {\n    callback = once(callback);\n    var closed = false;\n    stream.on(\"close\", function() {\n      closed = true;\n    });\n    if (eos === void 0) eos = requireEndOfStream();\n    eos(stream, {\n      readable: reading,\n      writable: writing\n    }, function(err) {\n      if (err) return callback(err);\n      closed = true;\n      callback();\n    });\n    var destroyed = false;\n    return function(err) {\n      if (closed) return;\n      if (destroyed) return;\n      destroyed = true;\n      if (isRequest(stream)) return stream.abort();\n      if (typeof stream.destroy === \"function\") return stream.destroy();\n      callback(err || new ERR_STREAM_DESTROYED(\"pipe\"));\n    };\n  }\n  function call(fn) {\n    fn();\n  }\n  function pipe(from, to) {\n    return from.pipe(to);\n  }\n  function popCallback(streams) {\n    if (!streams.length) return noop2;\n    if (typeof streams[streams.length - 1] !== \"function\") return noop2;\n    return streams.pop();\n  }\n  function pipeline() {\n    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n      streams[_key] = arguments[_key];\n    }\n    var callback = popCallback(streams);\n    if (Array.isArray(streams[0])) streams = streams[0];\n    if (streams.length < 2) {\n      throw new ERR_MISSING_ARGS(\"streams\");\n    }\n    var error;\n    var destroys = streams.map(function(stream, i) {\n      var reading = i < streams.length - 1;\n      var writing = i > 0;\n      return destroyer(stream, reading, writing, function(err) {\n        if (!error) error = err;\n        if (err) destroys.forEach(call);\n        if (reading) return;\n        destroys.forEach(call);\n        callback(error);\n      });\n    });\n    return streams.reduce(pipe);\n  }\n  pipeline_1 = pipeline;\n  return pipeline_1;\n}\nvar streamBrowserify;\nvar hasRequiredStreamBrowserify;\nfunction requireStreamBrowserify() {\n  if (hasRequiredStreamBrowserify) return streamBrowserify;\n  hasRequiredStreamBrowserify = 1;\n  streamBrowserify = Stream;\n  var EE = requireEvents().EventEmitter;\n  var inherits = requireInherits_browser();\n  inherits(Stream, EE);\n  Stream.Readable = require_stream_readable();\n  Stream.Writable = require_stream_writable();\n  Stream.Duplex = require_stream_duplex();\n  Stream.Transform = require_stream_transform();\n  Stream.PassThrough = require_stream_passthrough();\n  Stream.finished = requireEndOfStream();\n  Stream.pipeline = requirePipeline();\n  Stream.Stream = Stream;\n  function Stream() {\n    EE.call(this);\n  }\n  Stream.prototype.pipe = function(dest, options) {\n    var source = this;\n    function ondata(chunk) {\n      if (dest.writable) {\n        if (false === dest.write(chunk) && source.pause) {\n          source.pause();\n        }\n      }\n    }\n    source.on(\"data\", ondata);\n    function ondrain() {\n      if (source.readable && source.resume) {\n        source.resume();\n      }\n    }\n    dest.on(\"drain\", ondrain);\n    if (!dest._isStdio && (!options || options.end !== false)) {\n      source.on(\"end\", onend);\n      source.on(\"close\", onclose);\n    }\n    var didOnEnd = false;\n    function onend() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n      dest.end();\n    }\n    function onclose() {\n      if (didOnEnd) return;\n      didOnEnd = true;\n      if (typeof dest.destroy === \"function\") dest.destroy();\n    }\n    function onerror(er) {\n      cleanup();\n      if (EE.listenerCount(this, \"error\") === 0) {\n        throw er;\n      }\n    }\n    source.on(\"error\", onerror);\n    dest.on(\"error\", onerror);\n    function cleanup() {\n      source.removeListener(\"data\", ondata);\n      dest.removeListener(\"drain\", ondrain);\n      source.removeListener(\"end\", onend);\n      source.removeListener(\"close\", onclose);\n      source.removeListener(\"error\", onerror);\n      dest.removeListener(\"error\", onerror);\n      source.removeListener(\"end\", cleanup);\n      source.removeListener(\"close\", cleanup);\n      dest.removeListener(\"close\", cleanup);\n    }\n    source.on(\"end\", cleanup);\n    source.on(\"close\", cleanup);\n    dest.on(\"close\", cleanup);\n    dest.emit(\"pipe\", source);\n    return dest;\n  };\n  return streamBrowserify;\n}\nvar hasRequiredSax;\nfunction requireSax() {\n  if (hasRequiredSax) return sax;\n  hasRequiredSax = 1;\n  (function(exports) {\n    (function(sax2) {\n      sax2.parser = function(strict, opt) {\n        return new SAXParser(strict, opt);\n      };\n      sax2.SAXParser = SAXParser;\n      sax2.SAXStream = SAXStream;\n      sax2.createStream = createStream;\n      sax2.MAX_BUFFER_LENGTH = 64 * 1024;\n      var buffers = [\n        \"comment\",\n        \"sgmlDecl\",\n        \"textNode\",\n        \"tagName\",\n        \"doctype\",\n        \"procInstName\",\n        \"procInstBody\",\n        \"entity\",\n        \"attribName\",\n        \"attribValue\",\n        \"cdata\",\n        \"script\"\n      ];\n      sax2.EVENTS = [\n        \"text\",\n        \"processinginstruction\",\n        \"sgmldeclaration\",\n        \"doctype\",\n        \"comment\",\n        \"opentagstart\",\n        \"attribute\",\n        \"opentag\",\n        \"closetag\",\n        \"opencdata\",\n        \"cdata\",\n        \"closecdata\",\n        \"error\",\n        \"end\",\n        \"ready\",\n        \"script\",\n        \"opennamespace\",\n        \"closenamespace\"\n      ];\n      function SAXParser(strict, opt) {\n        if (!(this instanceof SAXParser)) {\n          return new SAXParser(strict, opt);\n        }\n        var parser = this;\n        clearBuffers(parser);\n        parser.q = parser.c = \"\";\n        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;\n        parser.opt = opt || {};\n        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n        parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n        parser.tags = [];\n        parser.closed = parser.closedRoot = parser.sawRoot = false;\n        parser.tag = parser.error = null;\n        parser.strict = !!strict;\n        parser.noscript = !!(strict || parser.opt.noscript);\n        parser.state = S.BEGIN;\n        parser.strictEntities = parser.opt.strictEntities;\n        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);\n        parser.attribList = [];\n        if (parser.opt.xmlns) {\n          parser.ns = Object.create(rootNS);\n        }\n        parser.trackPosition = parser.opt.position !== false;\n        if (parser.trackPosition) {\n          parser.position = parser.line = parser.column = 0;\n        }\n        emit(parser, \"onready\");\n      }\n      if (!Object.create) {\n        Object.create = function(o) {\n          function F() {\n          }\n          F.prototype = o;\n          var newf = new F();\n          return newf;\n        };\n      }\n      if (!Object.keys) {\n        Object.keys = function(o) {\n          var a = [];\n          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n          return a;\n        };\n      }\n      function checkBufferLength(parser) {\n        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);\n        var maxActual = 0;\n        for (var i = 0, l = buffers.length; i < l; i++) {\n          var len = parser[buffers[i]].length;\n          if (len > maxAllowed) {\n            switch (buffers[i]) {\n              case \"textNode\":\n                closeText(parser);\n                break;\n              case \"cdata\":\n                emitNode(parser, \"oncdata\", parser.cdata);\n                parser.cdata = \"\";\n                break;\n              case \"script\":\n                emitNode(parser, \"onscript\", parser.script);\n                parser.script = \"\";\n                break;\n              default:\n                error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n            }\n          }\n          maxActual = Math.max(maxActual, len);\n        }\n        var m = sax2.MAX_BUFFER_LENGTH - maxActual;\n        parser.bufferCheckPosition = m + parser.position;\n      }\n      function clearBuffers(parser) {\n        for (var i = 0, l = buffers.length; i < l; i++) {\n          parser[buffers[i]] = \"\";\n        }\n      }\n      function flushBuffers(parser) {\n        closeText(parser);\n        if (parser.cdata !== \"\") {\n          emitNode(parser, \"oncdata\", parser.cdata);\n          parser.cdata = \"\";\n        }\n        if (parser.script !== \"\") {\n          emitNode(parser, \"onscript\", parser.script);\n          parser.script = \"\";\n        }\n      }\n      SAXParser.prototype = {\n        end: function() {\n          end(this);\n        },\n        write,\n        resume: function() {\n          this.error = null;\n          return this;\n        },\n        close: function() {\n          return this.write(null);\n        },\n        flush: function() {\n          flushBuffers(this);\n        }\n      };\n      var Stream;\n      try {\n        Stream = requireStreamBrowserify().Stream;\n      } catch (ex) {\n        Stream = function() {\n        };\n      }\n      var streamWraps = sax2.EVENTS.filter(function(ev) {\n        return ev !== \"error\" && ev !== \"end\";\n      });\n      function createStream(strict, opt) {\n        return new SAXStream(strict, opt);\n      }\n      function SAXStream(strict, opt) {\n        if (!(this instanceof SAXStream)) {\n          return new SAXStream(strict, opt);\n        }\n        Stream.apply(this);\n        this._parser = new SAXParser(strict, opt);\n        this.writable = true;\n        this.readable = true;\n        var me = this;\n        this._parser.onend = function() {\n          me.emit(\"end\");\n        };\n        this._parser.onerror = function(er) {\n          me.emit(\"error\", er);\n          me._parser.error = null;\n        };\n        this._decoder = null;\n        streamWraps.forEach(function(ev) {\n          Object.defineProperty(me, \"on\" + ev, {\n            get: function() {\n              return me._parser[\"on\" + ev];\n            },\n            set: function(h) {\n              if (!h) {\n                me.removeAllListeners(ev);\n                me._parser[\"on\" + ev] = h;\n                return h;\n              }\n              me.on(ev, h);\n            },\n            enumerable: true,\n            configurable: false\n          });\n        });\n      }\n      SAXStream.prototype = Object.create(Stream.prototype, {\n        constructor: {\n          value: SAXStream\n        }\n      });\n      SAXStream.prototype.write = function(data) {\n        if (typeof Buffer === \"function\" && typeof Buffer.isBuffer === \"function\" && Buffer.isBuffer(data)) {\n          if (!this._decoder) {\n            var SD = requireString_decoder().StringDecoder;\n            this._decoder = new SD(\"utf8\");\n          }\n          data = this._decoder.write(data);\n        }\n        this._parser.write(data.toString());\n        this.emit(\"data\", data);\n        return true;\n      };\n      SAXStream.prototype.end = function(chunk) {\n        if (chunk && chunk.length) {\n          this.write(chunk);\n        }\n        this._parser.end();\n        return true;\n      };\n      SAXStream.prototype.on = function(ev, handler) {\n        var me = this;\n        if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n          me._parser[\"on\" + ev] = function() {\n            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n            args.splice(0, 0, ev);\n            me.emit.apply(me, args);\n          };\n        }\n        return Stream.prototype.on.call(me, ev, handler);\n      };\n      var CDATA = \"[CDATA[\";\n      var DOCTYPE = \"DOCTYPE\";\n      var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n      var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n      var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n      var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n      function isWhitespace(c) {\n        return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\t\";\n      }\n      function isQuote(c) {\n        return c === '\"' || c === \"'\";\n      }\n      function isAttribEnd(c) {\n        return c === \">\" || isWhitespace(c);\n      }\n      function isMatch(regex, c) {\n        return regex.test(c);\n      }\n      function notMatch(regex, c) {\n        return !isMatch(regex, c);\n      }\n      var S = 0;\n      sax2.STATE = {\n        BEGIN: S++,\n        // leading byte order mark or whitespace\n        BEGIN_WHITESPACE: S++,\n        // leading whitespace\n        TEXT: S++,\n        // general stuff\n        TEXT_ENTITY: S++,\n        // &amp and such.\n        OPEN_WAKA: S++,\n        // <\n        SGML_DECL: S++,\n        // <!BLARG\n        SGML_DECL_QUOTED: S++,\n        // <!BLARG foo \"bar\n        DOCTYPE: S++,\n        // <!DOCTYPE\n        DOCTYPE_QUOTED: S++,\n        // <!DOCTYPE \"//blah\n        DOCTYPE_DTD: S++,\n        // <!DOCTYPE \"//blah\" [ ...\n        DOCTYPE_DTD_QUOTED: S++,\n        // <!DOCTYPE \"//blah\" [ \"foo\n        COMMENT_STARTING: S++,\n        // <!-\n        COMMENT: S++,\n        // <!--\n        COMMENT_ENDING: S++,\n        // <!-- blah -\n        COMMENT_ENDED: S++,\n        // <!-- blah --\n        CDATA: S++,\n        // <![CDATA[ something\n        CDATA_ENDING: S++,\n        // ]\n        CDATA_ENDING_2: S++,\n        // ]]\n        PROC_INST: S++,\n        // <?hi\n        PROC_INST_BODY: S++,\n        // <?hi there\n        PROC_INST_ENDING: S++,\n        // <?hi \"there\" ?\n        OPEN_TAG: S++,\n        // <strong\n        OPEN_TAG_SLASH: S++,\n        // <strong /\n        ATTRIB: S++,\n        // <a\n        ATTRIB_NAME: S++,\n        // <a foo\n        ATTRIB_NAME_SAW_WHITE: S++,\n        // <a foo _\n        ATTRIB_VALUE: S++,\n        // <a foo=\n        ATTRIB_VALUE_QUOTED: S++,\n        // <a foo=\"bar\n        ATTRIB_VALUE_CLOSED: S++,\n        // <a foo=\"bar\"\n        ATTRIB_VALUE_UNQUOTED: S++,\n        // <a foo=bar\n        ATTRIB_VALUE_ENTITY_Q: S++,\n        // <foo bar=\"&quot;\"\n        ATTRIB_VALUE_ENTITY_U: S++,\n        // <foo bar=&quot\n        CLOSE_TAG: S++,\n        // </a\n        CLOSE_TAG_SAW_WHITE: S++,\n        // </a   >\n        SCRIPT: S++,\n        // <script> ...\n        SCRIPT_ENDING: S++\n        // <script> ... <\n      };\n      sax2.XML_ENTITIES = {\n        \"amp\": \"&\",\n        \"gt\": \">\",\n        \"lt\": \"<\",\n        \"quot\": '\"',\n        \"apos\": \"'\"\n      };\n      sax2.ENTITIES = {\n        \"amp\": \"&\",\n        \"gt\": \">\",\n        \"lt\": \"<\",\n        \"quot\": '\"',\n        \"apos\": \"'\",\n        \"AElig\": 198,\n        \"Aacute\": 193,\n        \"Acirc\": 194,\n        \"Agrave\": 192,\n        \"Aring\": 197,\n        \"Atilde\": 195,\n        \"Auml\": 196,\n        \"Ccedil\": 199,\n        \"ETH\": 208,\n        \"Eacute\": 201,\n        \"Ecirc\": 202,\n        \"Egrave\": 200,\n        \"Euml\": 203,\n        \"Iacute\": 205,\n        \"Icirc\": 206,\n        \"Igrave\": 204,\n        \"Iuml\": 207,\n        \"Ntilde\": 209,\n        \"Oacute\": 211,\n        \"Ocirc\": 212,\n        \"Ograve\": 210,\n        \"Oslash\": 216,\n        \"Otilde\": 213,\n        \"Ouml\": 214,\n        \"THORN\": 222,\n        \"Uacute\": 218,\n        \"Ucirc\": 219,\n        \"Ugrave\": 217,\n        \"Uuml\": 220,\n        \"Yacute\": 221,\n        \"aacute\": 225,\n        \"acirc\": 226,\n        \"aelig\": 230,\n        \"agrave\": 224,\n        \"aring\": 229,\n        \"atilde\": 227,\n        \"auml\": 228,\n        \"ccedil\": 231,\n        \"eacute\": 233,\n        \"ecirc\": 234,\n        \"egrave\": 232,\n        \"eth\": 240,\n        \"euml\": 235,\n        \"iacute\": 237,\n        \"icirc\": 238,\n        \"igrave\": 236,\n        \"iuml\": 239,\n        \"ntilde\": 241,\n        \"oacute\": 243,\n        \"ocirc\": 244,\n        \"ograve\": 242,\n        \"oslash\": 248,\n        \"otilde\": 245,\n        \"ouml\": 246,\n        \"szlig\": 223,\n        \"thorn\": 254,\n        \"uacute\": 250,\n        \"ucirc\": 251,\n        \"ugrave\": 249,\n        \"uuml\": 252,\n        \"yacute\": 253,\n        \"yuml\": 255,\n        \"copy\": 169,\n        \"reg\": 174,\n        \"nbsp\": 160,\n        \"iexcl\": 161,\n        \"cent\": 162,\n        \"pound\": 163,\n        \"curren\": 164,\n        \"yen\": 165,\n        \"brvbar\": 166,\n        \"sect\": 167,\n        \"uml\": 168,\n        \"ordf\": 170,\n        \"laquo\": 171,\n        \"not\": 172,\n        \"shy\": 173,\n        \"macr\": 175,\n        \"deg\": 176,\n        \"plusmn\": 177,\n        \"sup1\": 185,\n        \"sup2\": 178,\n        \"sup3\": 179,\n        \"acute\": 180,\n        \"micro\": 181,\n        \"para\": 182,\n        \"middot\": 183,\n        \"cedil\": 184,\n        \"ordm\": 186,\n        \"raquo\": 187,\n        \"frac14\": 188,\n        \"frac12\": 189,\n        \"frac34\": 190,\n        \"iquest\": 191,\n        \"times\": 215,\n        \"divide\": 247,\n        \"OElig\": 338,\n        \"oelig\": 339,\n        \"Scaron\": 352,\n        \"scaron\": 353,\n        \"Yuml\": 376,\n        \"fnof\": 402,\n        \"circ\": 710,\n        \"tilde\": 732,\n        \"Alpha\": 913,\n        \"Beta\": 914,\n        \"Gamma\": 915,\n        \"Delta\": 916,\n        \"Epsilon\": 917,\n        \"Zeta\": 918,\n        \"Eta\": 919,\n        \"Theta\": 920,\n        \"Iota\": 921,\n        \"Kappa\": 922,\n        \"Lambda\": 923,\n        \"Mu\": 924,\n        \"Nu\": 925,\n        \"Xi\": 926,\n        \"Omicron\": 927,\n        \"Pi\": 928,\n        \"Rho\": 929,\n        \"Sigma\": 931,\n        \"Tau\": 932,\n        \"Upsilon\": 933,\n        \"Phi\": 934,\n        \"Chi\": 935,\n        \"Psi\": 936,\n        \"Omega\": 937,\n        \"alpha\": 945,\n        \"beta\": 946,\n        \"gamma\": 947,\n        \"delta\": 948,\n        \"epsilon\": 949,\n        \"zeta\": 950,\n        \"eta\": 951,\n        \"theta\": 952,\n        \"iota\": 953,\n        \"kappa\": 954,\n        \"lambda\": 955,\n        \"mu\": 956,\n        \"nu\": 957,\n        \"xi\": 958,\n        \"omicron\": 959,\n        \"pi\": 960,\n        \"rho\": 961,\n        \"sigmaf\": 962,\n        \"sigma\": 963,\n        \"tau\": 964,\n        \"upsilon\": 965,\n        \"phi\": 966,\n        \"chi\": 967,\n        \"psi\": 968,\n        \"omega\": 969,\n        \"thetasym\": 977,\n        \"upsih\": 978,\n        \"piv\": 982,\n        \"ensp\": 8194,\n        \"emsp\": 8195,\n        \"thinsp\": 8201,\n        \"zwnj\": 8204,\n        \"zwj\": 8205,\n        \"lrm\": 8206,\n        \"rlm\": 8207,\n        \"ndash\": 8211,\n        \"mdash\": 8212,\n        \"lsquo\": 8216,\n        \"rsquo\": 8217,\n        \"sbquo\": 8218,\n        \"ldquo\": 8220,\n        \"rdquo\": 8221,\n        \"bdquo\": 8222,\n        \"dagger\": 8224,\n        \"Dagger\": 8225,\n        \"bull\": 8226,\n        \"hellip\": 8230,\n        \"permil\": 8240,\n        \"prime\": 8242,\n        \"Prime\": 8243,\n        \"lsaquo\": 8249,\n        \"rsaquo\": 8250,\n        \"oline\": 8254,\n        \"frasl\": 8260,\n        \"euro\": 8364,\n        \"image\": 8465,\n        \"weierp\": 8472,\n        \"real\": 8476,\n        \"trade\": 8482,\n        \"alefsym\": 8501,\n        \"larr\": 8592,\n        \"uarr\": 8593,\n        \"rarr\": 8594,\n        \"darr\": 8595,\n        \"harr\": 8596,\n        \"crarr\": 8629,\n        \"lArr\": 8656,\n        \"uArr\": 8657,\n        \"rArr\": 8658,\n        \"dArr\": 8659,\n        \"hArr\": 8660,\n        \"forall\": 8704,\n        \"part\": 8706,\n        \"exist\": 8707,\n        \"empty\": 8709,\n        \"nabla\": 8711,\n        \"isin\": 8712,\n        \"notin\": 8713,\n        \"ni\": 8715,\n        \"prod\": 8719,\n        \"sum\": 8721,\n        \"minus\": 8722,\n        \"lowast\": 8727,\n        \"radic\": 8730,\n        \"prop\": 8733,\n        \"infin\": 8734,\n        \"ang\": 8736,\n        \"and\": 8743,\n        \"or\": 8744,\n        \"cap\": 8745,\n        \"cup\": 8746,\n        \"int\": 8747,\n        \"there4\": 8756,\n        \"sim\": 8764,\n        \"cong\": 8773,\n        \"asymp\": 8776,\n        \"ne\": 8800,\n        \"equiv\": 8801,\n        \"le\": 8804,\n        \"ge\": 8805,\n        \"sub\": 8834,\n        \"sup\": 8835,\n        \"nsub\": 8836,\n        \"sube\": 8838,\n        \"supe\": 8839,\n        \"oplus\": 8853,\n        \"otimes\": 8855,\n        \"perp\": 8869,\n        \"sdot\": 8901,\n        \"lceil\": 8968,\n        \"rceil\": 8969,\n        \"lfloor\": 8970,\n        \"rfloor\": 8971,\n        \"lang\": 9001,\n        \"rang\": 9002,\n        \"loz\": 9674,\n        \"spades\": 9824,\n        \"clubs\": 9827,\n        \"hearts\": 9829,\n        \"diams\": 9830\n      };\n      Object.keys(sax2.ENTITIES).forEach(function(key) {\n        var e = sax2.ENTITIES[key];\n        var s2 = typeof e === \"number\" ? String.fromCharCode(e) : e;\n        sax2.ENTITIES[key] = s2;\n      });\n      for (var s in sax2.STATE) {\n        sax2.STATE[sax2.STATE[s]] = s;\n      }\n      S = sax2.STATE;\n      function emit(parser, event, data) {\n        parser[event] && parser[event](data);\n      }\n      function emitNode(parser, nodeType, data) {\n        if (parser.textNode) closeText(parser);\n        emit(parser, nodeType, data);\n      }\n      function closeText(parser) {\n        parser.textNode = textopts(parser.opt, parser.textNode);\n        if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n        parser.textNode = \"\";\n      }\n      function textopts(opt, text) {\n        if (opt.trim) text = text.trim();\n        if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n        return text;\n      }\n      function error(parser, er) {\n        closeText(parser);\n        if (parser.trackPosition) {\n          er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n        }\n        er = new Error(er);\n        parser.error = er;\n        emit(parser, \"onerror\", er);\n        return parser;\n      }\n      function end(parser) {\n        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, \"Unclosed root tag\");\n        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {\n          error(parser, \"Unexpected end\");\n        }\n        closeText(parser);\n        parser.c = \"\";\n        parser.closed = true;\n        emit(parser, \"onend\");\n        SAXParser.call(parser, parser.strict, parser.opt);\n        return parser;\n      }\n      function strictFail(parser, message) {\n        if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n          throw new Error(\"bad call to strictFail\");\n        }\n        if (parser.strict) {\n          error(parser, message);\n        }\n      }\n      function newTag(parser) {\n        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n        var parent = parser.tags[parser.tags.length - 1] || parser;\n        var tag = parser.tag = { name: parser.tagName, attributes: {} };\n        if (parser.opt.xmlns) {\n          tag.ns = parent.ns;\n        }\n        parser.attribList.length = 0;\n        emitNode(parser, \"onopentagstart\", tag);\n      }\n      function qname(name, attribute) {\n        var i = name.indexOf(\":\");\n        var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n        var prefix = qualName[0];\n        var local = qualName[1];\n        if (attribute && name === \"xmlns\") {\n          prefix = \"xmlns\";\n          local = \"\";\n        }\n        return { prefix, local };\n      }\n      function attrib(parser) {\n        if (!parser.strict) {\n          parser.attribName = parser.attribName[parser.looseCase]();\n        }\n        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n          parser.attribName = parser.attribValue = \"\";\n          return;\n        }\n        if (parser.opt.xmlns) {\n          var qn = qname(parser.attribName, true);\n          var prefix = qn.prefix;\n          var local = qn.local;\n          if (prefix === \"xmlns\") {\n            if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n              strictFail(\n                parser,\n                \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\nActual: \" + parser.attribValue\n              );\n            } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n              strictFail(\n                parser,\n                \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\nActual: \" + parser.attribValue\n              );\n            } else {\n              var tag = parser.tag;\n              var parent = parser.tags[parser.tags.length - 1] || parser;\n              if (tag.ns === parent.ns) {\n                tag.ns = Object.create(parent.ns);\n              }\n              tag.ns[local] = parser.attribValue;\n            }\n          }\n          parser.attribList.push([parser.attribName, parser.attribValue]);\n        } else {\n          parser.tag.attributes[parser.attribName] = parser.attribValue;\n          emitNode(parser, \"onattribute\", {\n            name: parser.attribName,\n            value: parser.attribValue\n          });\n        }\n        parser.attribName = parser.attribValue = \"\";\n      }\n      function openTag(parser, selfClosing) {\n        if (parser.opt.xmlns) {\n          var tag = parser.tag;\n          var qn = qname(parser.tagName);\n          tag.prefix = qn.prefix;\n          tag.local = qn.local;\n          tag.uri = tag.ns[qn.prefix] || \"\";\n          if (tag.prefix && !tag.uri) {\n            strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n            tag.uri = qn.prefix;\n          }\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns && parent.ns !== tag.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n              emitNode(parser, \"onopennamespace\", {\n                prefix: p,\n                uri: tag.ns[p]\n              });\n            });\n          }\n          for (var i = 0, l = parser.attribList.length; i < l; i++) {\n            var nv = parser.attribList[i];\n            var name = nv[0];\n            var value = nv[1];\n            var qualName = qname(name, true);\n            var prefix = qualName.prefix;\n            var local = qualName.local;\n            var uri2 = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n            var a = {\n              name,\n              value,\n              prefix,\n              local,\n              uri: uri2\n            };\n            if (prefix && prefix !== \"xmlns\" && !uri2) {\n              strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n              a.uri = prefix;\n            }\n            parser.tag.attributes[name] = a;\n            emitNode(parser, \"onattribute\", a);\n          }\n          parser.attribList.length = 0;\n        }\n        parser.tag.isSelfClosing = !!selfClosing;\n        parser.sawRoot = true;\n        parser.tags.push(parser.tag);\n        emitNode(parser, \"onopentag\", parser.tag);\n        if (!selfClosing) {\n          if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n            parser.state = S.SCRIPT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          parser.tag = null;\n          parser.tagName = \"\";\n        }\n        parser.attribName = parser.attribValue = \"\";\n        parser.attribList.length = 0;\n      }\n      function closeTag(parser) {\n        if (!parser.tagName) {\n          strictFail(parser, \"Weird empty close tag.\");\n          parser.textNode += \"</>\";\n          parser.state = S.TEXT;\n          return;\n        }\n        if (parser.script) {\n          if (parser.tagName !== \"script\") {\n            parser.script += \"</\" + parser.tagName + \">\";\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n            return;\n          }\n          emitNode(parser, \"onscript\", parser.script);\n          parser.script = \"\";\n        }\n        var t = parser.tags.length;\n        var tagName = parser.tagName;\n        if (!parser.strict) {\n          tagName = tagName[parser.looseCase]();\n        }\n        var closeTo = tagName;\n        while (t--) {\n          var close = parser.tags[t];\n          if (close.name !== closeTo) {\n            strictFail(parser, \"Unexpected close tag\");\n          } else {\n            break;\n          }\n        }\n        if (t < 0) {\n          strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n          parser.textNode += \"</\" + parser.tagName + \">\";\n          parser.state = S.TEXT;\n          return;\n        }\n        parser.tagName = tagName;\n        var s2 = parser.tags.length;\n        while (s2-- > t) {\n          var tag = parser.tag = parser.tags.pop();\n          parser.tagName = parser.tag.name;\n          emitNode(parser, \"onclosetag\", parser.tagName);\n          var x = {};\n          for (var i in tag.ns) {\n            x[i] = tag.ns[i];\n          }\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (parser.opt.xmlns && tag.ns !== parent.ns) {\n            Object.keys(tag.ns).forEach(function(p) {\n              var n = tag.ns[p];\n              emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n            });\n          }\n        }\n        if (t === 0) parser.closedRoot = true;\n        parser.tagName = parser.attribValue = parser.attribName = \"\";\n        parser.attribList.length = 0;\n        parser.state = S.TEXT;\n      }\n      function parseEntity(parser) {\n        var entity = parser.entity;\n        var entityLC = entity.toLowerCase();\n        var num;\n        var numStr = \"\";\n        if (parser.ENTITIES[entity]) {\n          return parser.ENTITIES[entity];\n        }\n        if (parser.ENTITIES[entityLC]) {\n          return parser.ENTITIES[entityLC];\n        }\n        entity = entityLC;\n        if (entity.charAt(0) === \"#\") {\n          if (entity.charAt(1) === \"x\") {\n            entity = entity.slice(2);\n            num = parseInt(entity, 16);\n            numStr = num.toString(16);\n          } else {\n            entity = entity.slice(1);\n            num = parseInt(entity, 10);\n            numStr = num.toString(10);\n          }\n        }\n        entity = entity.replace(/^0+/, \"\");\n        if (isNaN(num) || numStr.toLowerCase() !== entity) {\n          strictFail(parser, \"Invalid character entity\");\n          return \"&\" + parser.entity + \";\";\n        }\n        return String.fromCodePoint(num);\n      }\n      function beginWhiteSpace(parser, c) {\n        if (c === \"<\") {\n          parser.state = S.OPEN_WAKA;\n          parser.startTagPosition = parser.position;\n        } else if (!isWhitespace(c)) {\n          strictFail(parser, \"Non-whitespace before first tag.\");\n          parser.textNode = c;\n          parser.state = S.TEXT;\n        }\n      }\n      function charAt(chunk, i) {\n        var result = \"\";\n        if (i < chunk.length) {\n          result = chunk.charAt(i);\n        }\n        return result;\n      }\n      function write(chunk) {\n        var parser = this;\n        if (this.error) {\n          throw this.error;\n        }\n        if (parser.closed) {\n          return error(\n            parser,\n            \"Cannot write after close. Assign an onready handler.\"\n          );\n        }\n        if (chunk === null) {\n          return end(parser);\n        }\n        if (typeof chunk === \"object\") {\n          chunk = chunk.toString();\n        }\n        var i = 0;\n        var c = \"\";\n        while (true) {\n          c = charAt(chunk, i++);\n          parser.c = c;\n          if (!c) {\n            break;\n          }\n          if (parser.trackPosition) {\n            parser.position++;\n            if (c === \"\\n\") {\n              parser.line++;\n              parser.column = 0;\n            } else {\n              parser.column++;\n            }\n          }\n          switch (parser.state) {\n            case S.BEGIN:\n              parser.state = S.BEGIN_WHITESPACE;\n              if (c === \"\\uFEFF\") {\n                continue;\n              }\n              beginWhiteSpace(parser, c);\n              continue;\n            case S.BEGIN_WHITESPACE:\n              beginWhiteSpace(parser, c);\n              continue;\n            case S.TEXT:\n              if (parser.sawRoot && !parser.closedRoot) {\n                var starti = i - 1;\n                while (c && c !== \"<\" && c !== \"&\") {\n                  c = charAt(chunk, i++);\n                  if (c && parser.trackPosition) {\n                    parser.position++;\n                    if (c === \"\\n\") {\n                      parser.line++;\n                      parser.column = 0;\n                    } else {\n                      parser.column++;\n                    }\n                  }\n                }\n                parser.textNode += chunk.substring(starti, i - 1);\n              }\n              if (c === \"<\" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n                parser.state = S.OPEN_WAKA;\n                parser.startTagPosition = parser.position;\n              } else {\n                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n                  strictFail(parser, \"Text data outside of root node.\");\n                }\n                if (c === \"&\") {\n                  parser.state = S.TEXT_ENTITY;\n                } else {\n                  parser.textNode += c;\n                }\n              }\n              continue;\n            case S.SCRIPT:\n              if (c === \"<\") {\n                parser.state = S.SCRIPT_ENDING;\n              } else {\n                parser.script += c;\n              }\n              continue;\n            case S.SCRIPT_ENDING:\n              if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n              } else {\n                parser.script += \"<\" + c;\n                parser.state = S.SCRIPT;\n              }\n              continue;\n            case S.OPEN_WAKA:\n              if (c === \"!\") {\n                parser.state = S.SGML_DECL;\n                parser.sgmlDecl = \"\";\n              } else if (isWhitespace(c)) ;\n              else if (isMatch(nameStart, c)) {\n                parser.state = S.OPEN_TAG;\n                parser.tagName = c;\n              } else if (c === \"/\") {\n                parser.state = S.CLOSE_TAG;\n                parser.tagName = \"\";\n              } else if (c === \"?\") {\n                parser.state = S.PROC_INST;\n                parser.procInstName = parser.procInstBody = \"\";\n              } else {\n                strictFail(parser, \"Unencoded <\");\n                if (parser.startTagPosition + 1 < parser.position) {\n                  var pad = parser.position - parser.startTagPosition;\n                  c = new Array(pad).join(\" \") + c;\n                }\n                parser.textNode += \"<\" + c;\n                parser.state = S.TEXT;\n              }\n              continue;\n            case S.SGML_DECL:\n              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n                emitNode(parser, \"onopencdata\");\n                parser.state = S.CDATA;\n                parser.sgmlDecl = \"\";\n                parser.cdata = \"\";\n              } else if (parser.sgmlDecl + c === \"--\") {\n                parser.state = S.COMMENT;\n                parser.comment = \"\";\n                parser.sgmlDecl = \"\";\n              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n                parser.state = S.DOCTYPE;\n                if (parser.doctype || parser.sawRoot) {\n                  strictFail(\n                    parser,\n                    \"Inappropriately located doctype declaration\"\n                  );\n                }\n                parser.doctype = \"\";\n                parser.sgmlDecl = \"\";\n              } else if (c === \">\") {\n                emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n                parser.sgmlDecl = \"\";\n                parser.state = S.TEXT;\n              } else if (isQuote(c)) {\n                parser.state = S.SGML_DECL_QUOTED;\n                parser.sgmlDecl += c;\n              } else {\n                parser.sgmlDecl += c;\n              }\n              continue;\n            case S.SGML_DECL_QUOTED:\n              if (c === parser.q) {\n                parser.state = S.SGML_DECL;\n                parser.q = \"\";\n              }\n              parser.sgmlDecl += c;\n              continue;\n            case S.DOCTYPE:\n              if (c === \">\") {\n                parser.state = S.TEXT;\n                emitNode(parser, \"ondoctype\", parser.doctype);\n                parser.doctype = true;\n              } else {\n                parser.doctype += c;\n                if (c === \"[\") {\n                  parser.state = S.DOCTYPE_DTD;\n                } else if (isQuote(c)) {\n                  parser.state = S.DOCTYPE_QUOTED;\n                  parser.q = c;\n                }\n              }\n              continue;\n            case S.DOCTYPE_QUOTED:\n              parser.doctype += c;\n              if (c === parser.q) {\n                parser.q = \"\";\n                parser.state = S.DOCTYPE;\n              }\n              continue;\n            case S.DOCTYPE_DTD:\n              parser.doctype += c;\n              if (c === \"]\") {\n                parser.state = S.DOCTYPE;\n              } else if (isQuote(c)) {\n                parser.state = S.DOCTYPE_DTD_QUOTED;\n                parser.q = c;\n              }\n              continue;\n            case S.DOCTYPE_DTD_QUOTED:\n              parser.doctype += c;\n              if (c === parser.q) {\n                parser.state = S.DOCTYPE_DTD;\n                parser.q = \"\";\n              }\n              continue;\n            case S.COMMENT:\n              if (c === \"-\") {\n                parser.state = S.COMMENT_ENDING;\n              } else {\n                parser.comment += c;\n              }\n              continue;\n            case S.COMMENT_ENDING:\n              if (c === \"-\") {\n                parser.state = S.COMMENT_ENDED;\n                parser.comment = textopts(parser.opt, parser.comment);\n                if (parser.comment) {\n                  emitNode(parser, \"oncomment\", parser.comment);\n                }\n                parser.comment = \"\";\n              } else {\n                parser.comment += \"-\" + c;\n                parser.state = S.COMMENT;\n              }\n              continue;\n            case S.COMMENT_ENDED:\n              if (c !== \">\") {\n                strictFail(parser, \"Malformed comment\");\n                parser.comment += \"--\" + c;\n                parser.state = S.COMMENT;\n              } else {\n                parser.state = S.TEXT;\n              }\n              continue;\n            case S.CDATA:\n              if (c === \"]\") {\n                parser.state = S.CDATA_ENDING;\n              } else {\n                parser.cdata += c;\n              }\n              continue;\n            case S.CDATA_ENDING:\n              if (c === \"]\") {\n                parser.state = S.CDATA_ENDING_2;\n              } else {\n                parser.cdata += \"]\" + c;\n                parser.state = S.CDATA;\n              }\n              continue;\n            case S.CDATA_ENDING_2:\n              if (c === \">\") {\n                if (parser.cdata) {\n                  emitNode(parser, \"oncdata\", parser.cdata);\n                }\n                emitNode(parser, \"onclosecdata\");\n                parser.cdata = \"\";\n                parser.state = S.TEXT;\n              } else if (c === \"]\") {\n                parser.cdata += \"]\";\n              } else {\n                parser.cdata += \"]]\" + c;\n                parser.state = S.CDATA;\n              }\n              continue;\n            case S.PROC_INST:\n              if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n              } else if (isWhitespace(c)) {\n                parser.state = S.PROC_INST_BODY;\n              } else {\n                parser.procInstName += c;\n              }\n              continue;\n            case S.PROC_INST_BODY:\n              if (!parser.procInstBody && isWhitespace(c)) {\n                continue;\n              } else if (c === \"?\") {\n                parser.state = S.PROC_INST_ENDING;\n              } else {\n                parser.procInstBody += c;\n              }\n              continue;\n            case S.PROC_INST_ENDING:\n              if (c === \">\") {\n                emitNode(parser, \"onprocessinginstruction\", {\n                  name: parser.procInstName,\n                  body: parser.procInstBody\n                });\n                parser.procInstName = parser.procInstBody = \"\";\n                parser.state = S.TEXT;\n              } else {\n                parser.procInstBody += \"?\" + c;\n                parser.state = S.PROC_INST_BODY;\n              }\n              continue;\n            case S.OPEN_TAG:\n              if (isMatch(nameBody, c)) {\n                parser.tagName += c;\n              } else {\n                newTag(parser);\n                if (c === \">\") {\n                  openTag(parser);\n                } else if (c === \"/\") {\n                  parser.state = S.OPEN_TAG_SLASH;\n                } else {\n                  if (!isWhitespace(c)) {\n                    strictFail(parser, \"Invalid character in tag name\");\n                  }\n                  parser.state = S.ATTRIB;\n                }\n              }\n              continue;\n            case S.OPEN_TAG_SLASH:\n              if (c === \">\") {\n                openTag(parser, true);\n                closeTag(parser);\n              } else {\n                strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n                parser.state = S.ATTRIB;\n              }\n              continue;\n            case S.ATTRIB:\n              if (isWhitespace(c)) {\n                continue;\n              } else if (c === \">\") {\n                openTag(parser);\n              } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else if (isMatch(nameStart, c)) {\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_NAME:\n              if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n              } else if (c === \">\") {\n                strictFail(parser, \"Attribute without value\");\n                parser.attribValue = parser.attribName;\n                attrib(parser);\n                openTag(parser);\n              } else if (isWhitespace(c)) {\n                parser.state = S.ATTRIB_NAME_SAW_WHITE;\n              } else if (isMatch(nameBody, c)) {\n                parser.attribName += c;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_NAME_SAW_WHITE:\n              if (c === \"=\") {\n                parser.state = S.ATTRIB_VALUE;\n              } else if (isWhitespace(c)) {\n                continue;\n              } else {\n                strictFail(parser, \"Attribute without value\");\n                parser.tag.attributes[parser.attribName] = \"\";\n                parser.attribValue = \"\";\n                emitNode(parser, \"onattribute\", {\n                  name: parser.attribName,\n                  value: \"\"\n                });\n                parser.attribName = \"\";\n                if (c === \">\") {\n                  openTag(parser);\n                } else if (isMatch(nameStart, c)) {\n                  parser.attribName = c;\n                  parser.state = S.ATTRIB_NAME;\n                } else {\n                  strictFail(parser, \"Invalid attribute name\");\n                  parser.state = S.ATTRIB;\n                }\n              }\n              continue;\n            case S.ATTRIB_VALUE:\n              if (isWhitespace(c)) {\n                continue;\n              } else if (isQuote(c)) {\n                parser.q = c;\n                parser.state = S.ATTRIB_VALUE_QUOTED;\n              } else {\n                strictFail(parser, \"Unquoted attribute value\");\n                parser.state = S.ATTRIB_VALUE_UNQUOTED;\n                parser.attribValue = c;\n              }\n              continue;\n            case S.ATTRIB_VALUE_QUOTED:\n              if (c !== parser.q) {\n                if (c === \"&\") {\n                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n                } else {\n                  parser.attribValue += c;\n                }\n                continue;\n              }\n              attrib(parser);\n              parser.q = \"\";\n              parser.state = S.ATTRIB_VALUE_CLOSED;\n              continue;\n            case S.ATTRIB_VALUE_CLOSED:\n              if (isWhitespace(c)) {\n                parser.state = S.ATTRIB;\n              } else if (c === \">\") {\n                openTag(parser);\n              } else if (c === \"/\") {\n                parser.state = S.OPEN_TAG_SLASH;\n              } else if (isMatch(nameStart, c)) {\n                strictFail(parser, \"No whitespace between attributes\");\n                parser.attribName = c;\n                parser.attribValue = \"\";\n                parser.state = S.ATTRIB_NAME;\n              } else {\n                strictFail(parser, \"Invalid attribute name\");\n              }\n              continue;\n            case S.ATTRIB_VALUE_UNQUOTED:\n              if (!isAttribEnd(c)) {\n                if (c === \"&\") {\n                  parser.state = S.ATTRIB_VALUE_ENTITY_U;\n                } else {\n                  parser.attribValue += c;\n                }\n                continue;\n              }\n              attrib(parser);\n              if (c === \">\") {\n                openTag(parser);\n              } else {\n                parser.state = S.ATTRIB;\n              }\n              continue;\n            case S.CLOSE_TAG:\n              if (!parser.tagName) {\n                if (isWhitespace(c)) {\n                  continue;\n                } else if (notMatch(nameStart, c)) {\n                  if (parser.script) {\n                    parser.script += \"</\" + c;\n                    parser.state = S.SCRIPT;\n                  } else {\n                    strictFail(parser, \"Invalid tagname in closing tag.\");\n                  }\n                } else {\n                  parser.tagName = c;\n                }\n              } else if (c === \">\") {\n                closeTag(parser);\n              } else if (isMatch(nameBody, c)) {\n                parser.tagName += c;\n              } else if (parser.script) {\n                parser.script += \"</\" + parser.tagName;\n                parser.tagName = \"\";\n                parser.state = S.SCRIPT;\n              } else {\n                if (!isWhitespace(c)) {\n                  strictFail(parser, \"Invalid tagname in closing tag\");\n                }\n                parser.state = S.CLOSE_TAG_SAW_WHITE;\n              }\n              continue;\n            case S.CLOSE_TAG_SAW_WHITE:\n              if (isWhitespace(c)) {\n                continue;\n              }\n              if (c === \">\") {\n                closeTag(parser);\n              } else {\n                strictFail(parser, \"Invalid characters in closing tag\");\n              }\n              continue;\n            case S.TEXT_ENTITY:\n            case S.ATTRIB_VALUE_ENTITY_Q:\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState;\n              var buffer2;\n              switch (parser.state) {\n                case S.TEXT_ENTITY:\n                  returnState = S.TEXT;\n                  buffer2 = \"textNode\";\n                  break;\n                case S.ATTRIB_VALUE_ENTITY_Q:\n                  returnState = S.ATTRIB_VALUE_QUOTED;\n                  buffer2 = \"attribValue\";\n                  break;\n                case S.ATTRIB_VALUE_ENTITY_U:\n                  returnState = S.ATTRIB_VALUE_UNQUOTED;\n                  buffer2 = \"attribValue\";\n                  break;\n              }\n              if (c === \";\") {\n                parser[buffer2] += parseEntity(parser);\n                parser.entity = \"\";\n                parser.state = returnState;\n              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n                parser.entity += c;\n              } else {\n                strictFail(parser, \"Invalid character in entity name\");\n                parser[buffer2] += \"&\" + parser.entity + c;\n                parser.entity = \"\";\n                parser.state = returnState;\n              }\n              continue;\n            default:\n              throw new Error(parser, \"Unknown state: \" + parser.state);\n          }\n        }\n        if (parser.position >= parser.bufferCheckPosition) {\n          checkBufferLength(parser);\n        }\n        return parser;\n      }\n      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n      if (!String.fromCodePoint) {\n        (function() {\n          var stringFromCharCode = String.fromCharCode;\n          var floor2 = Math.floor;\n          var fromCodePoint = function() {\n            var MAX_SIZE = 16384;\n            var codeUnits = [];\n            var highSurrogate;\n            var lowSurrogate;\n            var index = -1;\n            var length = arguments.length;\n            if (!length) {\n              return \"\";\n            }\n            var result = \"\";\n            while (++index < length) {\n              var codePoint = Number(arguments[index]);\n              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n              codePoint < 0 || // not a valid Unicode code point\n              codePoint > 1114111 || // not a valid Unicode code point\n              floor2(codePoint) !== codePoint) {\n                throw RangeError(\"Invalid code point: \" + codePoint);\n              }\n              if (codePoint <= 65535) {\n                codeUnits.push(codePoint);\n              } else {\n                codePoint -= 65536;\n                highSurrogate = (codePoint >> 10) + 55296;\n                lowSurrogate = codePoint % 1024 + 56320;\n                codeUnits.push(highSurrogate, lowSurrogate);\n              }\n              if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode.apply(null, codeUnits);\n                codeUnits.length = 0;\n              }\n            }\n            return result;\n          };\n          if (Object.defineProperty) {\n            Object.defineProperty(String, \"fromCodePoint\", {\n              value: fromCodePoint,\n              configurable: true,\n              writable: true\n            });\n          } else {\n            String.fromCodePoint = fromCodePoint;\n          }\n        })();\n      }\n    })(exports);\n  })(sax);\n  return sax;\n}\nvar arrayHelper;\nvar hasRequiredArrayHelper;\nfunction requireArrayHelper() {\n  if (hasRequiredArrayHelper) return arrayHelper;\n  hasRequiredArrayHelper = 1;\n  arrayHelper = {\n    isArray: function(value) {\n      if (Array.isArray) {\n        return Array.isArray(value);\n      }\n      return Object.prototype.toString.call(value) === \"[object Array]\";\n    }\n  };\n  return arrayHelper;\n}\nvar optionsHelper;\nvar hasRequiredOptionsHelper;\nfunction requireOptionsHelper() {\n  if (hasRequiredOptionsHelper) return optionsHelper;\n  hasRequiredOptionsHelper = 1;\n  var isArray = requireArrayHelper().isArray;\n  optionsHelper = {\n    copyOptions: function(options) {\n      var key, copy = {};\n      for (key in options) {\n        if (options.hasOwnProperty(key)) {\n          copy[key] = options[key];\n        }\n      }\n      return copy;\n    },\n    ensureFlagExists: function(item, options) {\n      if (!(item in options) || typeof options[item] !== \"boolean\") {\n        options[item] = false;\n      }\n    },\n    ensureSpacesExists: function(options) {\n      if (!(\"spaces\" in options) || typeof options.spaces !== \"number\" && typeof options.spaces !== \"string\") {\n        options.spaces = 0;\n      }\n    },\n    ensureAlwaysArrayExists: function(options) {\n      if (!(\"alwaysArray\" in options) || typeof options.alwaysArray !== \"boolean\" && !isArray(options.alwaysArray)) {\n        options.alwaysArray = false;\n      }\n    },\n    ensureKeyExists: function(key, options) {\n      if (!(key + \"Key\" in options) || typeof options[key + \"Key\"] !== \"string\") {\n        options[key + \"Key\"] = options.compact ? \"_\" + key : key;\n      }\n    },\n    checkFnExists: function(key, options) {\n      return key + \"Fn\" in options;\n    }\n  };\n  return optionsHelper;\n}\nvar xml2js;\nvar hasRequiredXml2js;\nfunction requireXml2js() {\n  if (hasRequiredXml2js) return xml2js;\n  hasRequiredXml2js = 1;\n  var sax2 = requireSax();\n  var helper = requireOptionsHelper();\n  var isArray = requireArrayHelper().isArray;\n  var options;\n  var currentElement;\n  function validateOptions(userOptions) {\n    options = helper.copyOptions(userOptions);\n    helper.ensureFlagExists(\"ignoreDeclaration\", options);\n    helper.ensureFlagExists(\"ignoreInstruction\", options);\n    helper.ensureFlagExists(\"ignoreAttributes\", options);\n    helper.ensureFlagExists(\"ignoreText\", options);\n    helper.ensureFlagExists(\"ignoreComment\", options);\n    helper.ensureFlagExists(\"ignoreCdata\", options);\n    helper.ensureFlagExists(\"ignoreDoctype\", options);\n    helper.ensureFlagExists(\"compact\", options);\n    helper.ensureFlagExists(\"alwaysChildren\", options);\n    helper.ensureFlagExists(\"addParent\", options);\n    helper.ensureFlagExists(\"trim\", options);\n    helper.ensureFlagExists(\"nativeType\", options);\n    helper.ensureFlagExists(\"nativeTypeAttributes\", options);\n    helper.ensureFlagExists(\"sanitize\", options);\n    helper.ensureFlagExists(\"instructionHasAttributes\", options);\n    helper.ensureFlagExists(\"captureSpacesBetweenElements\", options);\n    helper.ensureAlwaysArrayExists(options);\n    helper.ensureKeyExists(\"declaration\", options);\n    helper.ensureKeyExists(\"instruction\", options);\n    helper.ensureKeyExists(\"attributes\", options);\n    helper.ensureKeyExists(\"text\", options);\n    helper.ensureKeyExists(\"comment\", options);\n    helper.ensureKeyExists(\"cdata\", options);\n    helper.ensureKeyExists(\"doctype\", options);\n    helper.ensureKeyExists(\"type\", options);\n    helper.ensureKeyExists(\"name\", options);\n    helper.ensureKeyExists(\"elements\", options);\n    helper.ensureKeyExists(\"parent\", options);\n    helper.checkFnExists(\"doctype\", options);\n    helper.checkFnExists(\"instruction\", options);\n    helper.checkFnExists(\"cdata\", options);\n    helper.checkFnExists(\"comment\", options);\n    helper.checkFnExists(\"text\", options);\n    helper.checkFnExists(\"instructionName\", options);\n    helper.checkFnExists(\"elementName\", options);\n    helper.checkFnExists(\"attributeName\", options);\n    helper.checkFnExists(\"attributeValue\", options);\n    helper.checkFnExists(\"attributes\", options);\n    return options;\n  }\n  function nativeType(value) {\n    var nValue = Number(value);\n    if (!isNaN(nValue)) {\n      return nValue;\n    }\n    var bValue = value.toLowerCase();\n    if (bValue === \"true\") {\n      return true;\n    } else if (bValue === \"false\") {\n      return false;\n    }\n    return value;\n  }\n  function addField(type2, value) {\n    var key;\n    if (options.compact) {\n      if (!currentElement[options[type2 + \"Key\"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + \"Key\"]) !== -1 : options.alwaysArray)) {\n        currentElement[options[type2 + \"Key\"]] = [];\n      }\n      if (currentElement[options[type2 + \"Key\"]] && !isArray(currentElement[options[type2 + \"Key\"]])) {\n        currentElement[options[type2 + \"Key\"]] = [currentElement[options[type2 + \"Key\"]]];\n      }\n      if (type2 + \"Fn\" in options && typeof value === \"string\") {\n        value = options[type2 + \"Fn\"](value, currentElement);\n      }\n      if (type2 === \"instruction\" && (\"instructionFn\" in options || \"instructionNameFn\" in options)) {\n        for (key in value) {\n          if (value.hasOwnProperty(key)) {\n            if (\"instructionFn\" in options) {\n              value[key] = options.instructionFn(value[key], key, currentElement);\n            } else {\n              var temp = value[key];\n              delete value[key];\n              value[options.instructionNameFn(key, temp, currentElement)] = temp;\n            }\n          }\n        }\n      }\n      if (isArray(currentElement[options[type2 + \"Key\"]])) {\n        currentElement[options[type2 + \"Key\"]].push(value);\n      } else {\n        currentElement[options[type2 + \"Key\"]] = value;\n      }\n    } else {\n      if (!currentElement[options.elementsKey]) {\n        currentElement[options.elementsKey] = [];\n      }\n      var element = {};\n      element[options.typeKey] = type2;\n      if (type2 === \"instruction\") {\n        for (key in value) {\n          if (value.hasOwnProperty(key)) {\n            break;\n          }\n        }\n        element[options.nameKey] = \"instructionNameFn\" in options ? options.instructionNameFn(key, value, currentElement) : key;\n        if (options.instructionHasAttributes) {\n          element[options.attributesKey] = value[key][options.attributesKey];\n          if (\"instructionFn\" in options) {\n            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);\n          }\n        } else {\n          if (\"instructionFn\" in options) {\n            value[key] = options.instructionFn(value[key], key, currentElement);\n          }\n          element[options.instructionKey] = value[key];\n        }\n      } else {\n        if (type2 + \"Fn\" in options) {\n          value = options[type2 + \"Fn\"](value, currentElement);\n        }\n        element[options[type2 + \"Key\"]] = value;\n      }\n      if (options.addParent) {\n        element[options.parentKey] = currentElement;\n      }\n      currentElement[options.elementsKey].push(element);\n    }\n  }\n  function manipulateAttributes(attributes) {\n    if (\"attributesFn\" in options && attributes) {\n      attributes = options.attributesFn(attributes, currentElement);\n    }\n    if ((options.trim || \"attributeValueFn\" in options || \"attributeNameFn\" in options || options.nativeTypeAttributes) && attributes) {\n      var key;\n      for (key in attributes) {\n        if (attributes.hasOwnProperty(key)) {\n          if (options.trim) attributes[key] = attributes[key].trim();\n          if (options.nativeTypeAttributes) {\n            attributes[key] = nativeType(attributes[key]);\n          }\n          if (\"attributeValueFn\" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);\n          if (\"attributeNameFn\" in options) {\n            var temp = attributes[key];\n            delete attributes[key];\n            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;\n          }\n        }\n      }\n    }\n    return attributes;\n  }\n  function onInstruction(instruction) {\n    var attributes = {};\n    if (instruction.body && (instruction.name.toLowerCase() === \"xml\" || options.instructionHasAttributes)) {\n      var attrsRegExp = /([\\w:-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|(\\w+))\\s*/g;\n      var match;\n      while ((match = attrsRegExp.exec(instruction.body)) !== null) {\n        attributes[match[1]] = match[2] || match[3] || match[4];\n      }\n      attributes = manipulateAttributes(attributes);\n    }\n    if (instruction.name.toLowerCase() === \"xml\") {\n      if (options.ignoreDeclaration) {\n        return;\n      }\n      currentElement[options.declarationKey] = {};\n      if (Object.keys(attributes).length) {\n        currentElement[options.declarationKey][options.attributesKey] = attributes;\n      }\n      if (options.addParent) {\n        currentElement[options.declarationKey][options.parentKey] = currentElement;\n      }\n    } else {\n      if (options.ignoreInstruction) {\n        return;\n      }\n      if (options.trim) {\n        instruction.body = instruction.body.trim();\n      }\n      var value = {};\n      if (options.instructionHasAttributes && Object.keys(attributes).length) {\n        value[instruction.name] = {};\n        value[instruction.name][options.attributesKey] = attributes;\n      } else {\n        value[instruction.name] = instruction.body;\n      }\n      addField(\"instruction\", value);\n    }\n  }\n  function onStartElement(name, attributes) {\n    var element;\n    if (typeof name === \"object\") {\n      attributes = name.attributes;\n      name = name.name;\n    }\n    attributes = manipulateAttributes(attributes);\n    if (\"elementNameFn\" in options) {\n      name = options.elementNameFn(name, currentElement);\n    }\n    if (options.compact) {\n      element = {};\n      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n        element[options.attributesKey] = {};\n        var key;\n        for (key in attributes) {\n          if (attributes.hasOwnProperty(key)) {\n            element[options.attributesKey][key] = attributes[key];\n          }\n        }\n      }\n      if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {\n        currentElement[name] = [];\n      }\n      if (currentElement[name] && !isArray(currentElement[name])) {\n        currentElement[name] = [currentElement[name]];\n      }\n      if (isArray(currentElement[name])) {\n        currentElement[name].push(element);\n      } else {\n        currentElement[name] = element;\n      }\n    } else {\n      if (!currentElement[options.elementsKey]) {\n        currentElement[options.elementsKey] = [];\n      }\n      element = {};\n      element[options.typeKey] = \"element\";\n      element[options.nameKey] = name;\n      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {\n        element[options.attributesKey] = attributes;\n      }\n      if (options.alwaysChildren) {\n        element[options.elementsKey] = [];\n      }\n      currentElement[options.elementsKey].push(element);\n    }\n    element[options.parentKey] = currentElement;\n    currentElement = element;\n  }\n  function onText(text) {\n    if (options.ignoreText) {\n      return;\n    }\n    if (!text.trim() && !options.captureSpacesBetweenElements) {\n      return;\n    }\n    if (options.trim) {\n      text = text.trim();\n    }\n    if (options.nativeType) {\n      text = nativeType(text);\n    }\n    if (options.sanitize) {\n      text = text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    addField(\"text\", text);\n  }\n  function onComment(comment) {\n    if (options.ignoreComment) {\n      return;\n    }\n    if (options.trim) {\n      comment = comment.trim();\n    }\n    addField(\"comment\", comment);\n  }\n  function onEndElement(name) {\n    var parentElement = currentElement[options.parentKey];\n    if (!options.addParent) {\n      delete currentElement[options.parentKey];\n    }\n    currentElement = parentElement;\n  }\n  function onCdata(cdata) {\n    if (options.ignoreCdata) {\n      return;\n    }\n    if (options.trim) {\n      cdata = cdata.trim();\n    }\n    addField(\"cdata\", cdata);\n  }\n  function onDoctype(doctype) {\n    if (options.ignoreDoctype) {\n      return;\n    }\n    doctype = doctype.replace(/^ /, \"\");\n    if (options.trim) {\n      doctype = doctype.trim();\n    }\n    addField(\"doctype\", doctype);\n  }\n  function onError(error) {\n    error.note = error;\n  }\n  xml2js = function(xml2, userOptions) {\n    var parser = sax2.parser(true, {});\n    var result = {};\n    currentElement = result;\n    options = validateOptions(userOptions);\n    {\n      parser.opt = { strictEntities: true };\n      parser.onopentag = onStartElement;\n      parser.ontext = onText;\n      parser.oncomment = onComment;\n      parser.onclosetag = onEndElement;\n      parser.onerror = onError;\n      parser.oncdata = onCdata;\n      parser.ondoctype = onDoctype;\n      parser.onprocessinginstruction = onInstruction;\n    }\n    {\n      parser.write(xml2).close();\n    }\n    if (result[options.elementsKey]) {\n      var temp = result[options.elementsKey];\n      delete result[options.elementsKey];\n      result[options.elementsKey] = temp;\n      delete result.text;\n    }\n    return result;\n  };\n  return xml2js;\n}\nvar xml2json;\nvar hasRequiredXml2json;\nfunction requireXml2json() {\n  if (hasRequiredXml2json) return xml2json;\n  hasRequiredXml2json = 1;\n  var helper = requireOptionsHelper();\n  var xml2js2 = requireXml2js();\n  function validateOptions(userOptions) {\n    var options = helper.copyOptions(userOptions);\n    helper.ensureSpacesExists(options);\n    return options;\n  }\n  xml2json = function(xml2, userOptions) {\n    var options, js, json, parentKey;\n    options = validateOptions(userOptions);\n    js = xml2js2(xml2, options);\n    parentKey = \"compact\" in options && options.compact ? \"_parent\" : \"parent\";\n    if (\"addParent\" in options && options.addParent) {\n      json = JSON.stringify(js, function(k, v) {\n        return k === parentKey ? \"_\" : v;\n      }, options.spaces);\n    } else {\n      json = JSON.stringify(js, null, options.spaces);\n    }\n    return json.replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n  };\n  return xml2json;\n}\nvar js2xml;\nvar hasRequiredJs2xml;\nfunction requireJs2xml() {\n  if (hasRequiredJs2xml) return js2xml;\n  hasRequiredJs2xml = 1;\n  var helper = requireOptionsHelper();\n  var isArray = requireArrayHelper().isArray;\n  var currentElement, currentElementName;\n  function validateOptions(userOptions) {\n    var options = helper.copyOptions(userOptions);\n    helper.ensureFlagExists(\"ignoreDeclaration\", options);\n    helper.ensureFlagExists(\"ignoreInstruction\", options);\n    helper.ensureFlagExists(\"ignoreAttributes\", options);\n    helper.ensureFlagExists(\"ignoreText\", options);\n    helper.ensureFlagExists(\"ignoreComment\", options);\n    helper.ensureFlagExists(\"ignoreCdata\", options);\n    helper.ensureFlagExists(\"ignoreDoctype\", options);\n    helper.ensureFlagExists(\"compact\", options);\n    helper.ensureFlagExists(\"indentText\", options);\n    helper.ensureFlagExists(\"indentCdata\", options);\n    helper.ensureFlagExists(\"indentAttributes\", options);\n    helper.ensureFlagExists(\"indentInstruction\", options);\n    helper.ensureFlagExists(\"fullTagEmptyElement\", options);\n    helper.ensureFlagExists(\"noQuotesForNativeAttributes\", options);\n    helper.ensureSpacesExists(options);\n    if (typeof options.spaces === \"number\") {\n      options.spaces = Array(options.spaces + 1).join(\" \");\n    }\n    helper.ensureKeyExists(\"declaration\", options);\n    helper.ensureKeyExists(\"instruction\", options);\n    helper.ensureKeyExists(\"attributes\", options);\n    helper.ensureKeyExists(\"text\", options);\n    helper.ensureKeyExists(\"comment\", options);\n    helper.ensureKeyExists(\"cdata\", options);\n    helper.ensureKeyExists(\"doctype\", options);\n    helper.ensureKeyExists(\"type\", options);\n    helper.ensureKeyExists(\"name\", options);\n    helper.ensureKeyExists(\"elements\", options);\n    helper.checkFnExists(\"doctype\", options);\n    helper.checkFnExists(\"instruction\", options);\n    helper.checkFnExists(\"cdata\", options);\n    helper.checkFnExists(\"comment\", options);\n    helper.checkFnExists(\"text\", options);\n    helper.checkFnExists(\"instructionName\", options);\n    helper.checkFnExists(\"elementName\", options);\n    helper.checkFnExists(\"attributeName\", options);\n    helper.checkFnExists(\"attributeValue\", options);\n    helper.checkFnExists(\"attributes\", options);\n    helper.checkFnExists(\"fullTagEmptyElement\", options);\n    return options;\n  }\n  function writeIndentation(options, depth, firstLine) {\n    return (!firstLine && options.spaces ? \"\\n\" : \"\") + Array(depth + 1).join(options.spaces);\n  }\n  function writeAttributes(attributes, options, depth) {\n    if (options.ignoreAttributes) {\n      return \"\";\n    }\n    if (\"attributesFn\" in options) {\n      attributes = options.attributesFn(attributes, currentElementName, currentElement);\n    }\n    var key, attr, attrName, quote, result = [];\n    for (key in attributes) {\n      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {\n        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== \"string\" ? \"\" : '\"';\n        attr = \"\" + attributes[key];\n        attr = attr.replace(/\"/g, \"&quot;\");\n        attrName = \"attributeNameFn\" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;\n        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : \" \");\n        result.push(attrName + \"=\" + quote + (\"attributeValueFn\" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);\n      }\n    }\n    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {\n      result.push(writeIndentation(options, depth, false));\n    }\n    return result.join(\"\");\n  }\n  function writeDeclaration(declaration, options, depth) {\n    currentElement = declaration;\n    currentElementName = \"xml\";\n    return options.ignoreDeclaration ? \"\" : \"<?xml\" + writeAttributes(declaration[options.attributesKey], options, depth) + \"?>\";\n  }\n  function writeInstruction(instruction, options, depth) {\n    if (options.ignoreInstruction) {\n      return \"\";\n    }\n    var key;\n    for (key in instruction) {\n      if (instruction.hasOwnProperty(key)) {\n        break;\n      }\n    }\n    var instructionName = \"instructionNameFn\" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;\n    if (typeof instruction[key] === \"object\") {\n      currentElement = instruction;\n      currentElementName = instructionName;\n      return \"<?\" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + \"?>\";\n    } else {\n      var instructionValue = instruction[key] ? instruction[key] : \"\";\n      if (\"instructionFn\" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);\n      return \"<?\" + instructionName + (instructionValue ? \" \" + instructionValue : \"\") + \"?>\";\n    }\n  }\n  function writeComment(comment, options) {\n    return options.ignoreComment ? \"\" : \"<!--\" + (\"commentFn\" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + \"-->\";\n  }\n  function writeCdata(cdata, options) {\n    return options.ignoreCdata ? \"\" : \"<![CDATA[\" + (\"cdataFn\" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(\"]]>\", \"]]]]><![CDATA[>\")) + \"]]>\";\n  }\n  function writeDoctype(doctype, options) {\n    return options.ignoreDoctype ? \"\" : \"<!DOCTYPE \" + (\"doctypeFn\" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + \">\";\n  }\n  function writeText(text, options) {\n    if (options.ignoreText) return \"\";\n    text = \"\" + text;\n    text = text.replace(/&amp;/g, \"&\");\n    text = text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    return \"textFn\" in options ? options.textFn(text, currentElementName, currentElement) : text;\n  }\n  function hasContent(element, options) {\n    var i;\n    if (element.elements && element.elements.length) {\n      for (i = 0; i < element.elements.length; ++i) {\n        switch (element.elements[i][options.typeKey]) {\n          case \"text\":\n            if (options.indentText) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case \"cdata\":\n            if (options.indentCdata) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case \"instruction\":\n            if (options.indentInstruction) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case \"doctype\":\n          case \"comment\":\n          case \"element\":\n            return true;\n          default:\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n  function writeElement(element, options, depth) {\n    currentElement = element;\n    currentElementName = element.name;\n    var xml2 = [], elementName = \"elementNameFn\" in options ? options.elementNameFn(element.name, element) : element.name;\n    xml2.push(\"<\" + elementName);\n    if (element[options.attributesKey]) {\n      xml2.push(writeAttributes(element[options.attributesKey], options, depth));\n    }\n    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey][\"xml:space\"] === \"preserve\";\n    if (!withClosingTag) {\n      if (\"fullTagEmptyElementFn\" in options) {\n        withClosingTag = options.fullTagEmptyElementFn(element.name, element);\n      } else {\n        withClosingTag = options.fullTagEmptyElement;\n      }\n    }\n    if (withClosingTag) {\n      xml2.push(\">\");\n      if (element[options.elementsKey] && element[options.elementsKey].length) {\n        xml2.push(writeElements(element[options.elementsKey], options, depth + 1));\n        currentElement = element;\n        currentElementName = element.name;\n      }\n      xml2.push(options.spaces && hasContent(element, options) ? \"\\n\" + Array(depth + 1).join(options.spaces) : \"\");\n      xml2.push(\"</\" + elementName + \">\");\n    } else {\n      xml2.push(\"/>\");\n    }\n    return xml2.join(\"\");\n  }\n  function writeElements(elements, options, depth, firstLine) {\n    return elements.reduce(function(xml2, element) {\n      var indent = writeIndentation(options, depth, firstLine && !xml2);\n      switch (element.type) {\n        case \"element\":\n          return xml2 + indent + writeElement(element, options, depth);\n        case \"comment\":\n          return xml2 + indent + writeComment(element[options.commentKey], options);\n        case \"doctype\":\n          return xml2 + indent + writeDoctype(element[options.doctypeKey], options);\n        case \"cdata\":\n          return xml2 + (options.indentCdata ? indent : \"\") + writeCdata(element[options.cdataKey], options);\n        case \"text\":\n          return xml2 + (options.indentText ? indent : \"\") + writeText(element[options.textKey], options);\n        case \"instruction\":\n          var instruction = {};\n          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];\n          return xml2 + (options.indentInstruction ? indent : \"\") + writeInstruction(instruction, options, depth);\n      }\n    }, \"\");\n  }\n  function hasContentCompact(element, options, anyContent) {\n    var key;\n    for (key in element) {\n      if (element.hasOwnProperty(key)) {\n        switch (key) {\n          case options.parentKey:\n          case options.attributesKey:\n            break;\n          // skip to next key\n          case options.textKey:\n            if (options.indentText || anyContent) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case options.cdataKey:\n            if (options.indentCdata || anyContent) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case options.instructionKey:\n            if (options.indentInstruction || anyContent) {\n              return true;\n            }\n            break;\n          // skip to next key\n          case options.doctypeKey:\n          case options.commentKey:\n            return true;\n          default:\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n  function writeElementCompact(element, name, options, depth, indent) {\n    currentElement = element;\n    currentElementName = name;\n    var elementName = \"elementNameFn\" in options ? options.elementNameFn(name, element) : name;\n    if (typeof element === \"undefined\" || element === null || element === \"\") {\n      return \"fullTagEmptyElementFn\" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? \"<\" + elementName + \"></\" + elementName + \">\" : \"<\" + elementName + \"/>\";\n    }\n    var xml2 = [];\n    if (name) {\n      xml2.push(\"<\" + elementName);\n      if (typeof element !== \"object\") {\n        xml2.push(\">\" + writeText(element, options) + \"</\" + elementName + \">\");\n        return xml2.join(\"\");\n      }\n      if (element[options.attributesKey]) {\n        xml2.push(writeAttributes(element[options.attributesKey], options, depth));\n      }\n      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey][\"xml:space\"] === \"preserve\";\n      if (!withClosingTag) {\n        if (\"fullTagEmptyElementFn\" in options) {\n          withClosingTag = options.fullTagEmptyElementFn(name, element);\n        } else {\n          withClosingTag = options.fullTagEmptyElement;\n        }\n      }\n      if (withClosingTag) {\n        xml2.push(\">\");\n      } else {\n        xml2.push(\"/>\");\n        return xml2.join(\"\");\n      }\n    }\n    xml2.push(writeElementsCompact(element, options, depth + 1, false));\n    currentElement = element;\n    currentElementName = name;\n    if (name) {\n      xml2.push((indent ? writeIndentation(options, depth, false) : \"\") + \"</\" + elementName + \">\");\n    }\n    return xml2.join(\"\");\n  }\n  function writeElementsCompact(element, options, depth, firstLine) {\n    var i, key, nodes, xml2 = [];\n    for (key in element) {\n      if (element.hasOwnProperty(key)) {\n        nodes = isArray(element[key]) ? element[key] : [element[key]];\n        for (i = 0; i < nodes.length; ++i) {\n          switch (key) {\n            case options.declarationKey:\n              xml2.push(writeDeclaration(nodes[i], options, depth));\n              break;\n            case options.instructionKey:\n              xml2.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : \"\") + writeInstruction(nodes[i], options, depth));\n              break;\n            case options.attributesKey:\n            case options.parentKey:\n              break;\n            // skip\n            case options.textKey:\n              xml2.push((options.indentText ? writeIndentation(options, depth, firstLine) : \"\") + writeText(nodes[i], options));\n              break;\n            case options.cdataKey:\n              xml2.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : \"\") + writeCdata(nodes[i], options));\n              break;\n            case options.doctypeKey:\n              xml2.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));\n              break;\n            case options.commentKey:\n              xml2.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));\n              break;\n            default:\n              xml2.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));\n          }\n          firstLine = firstLine && !xml2.length;\n        }\n      }\n    }\n    return xml2.join(\"\");\n  }\n  js2xml = function(js, options) {\n    options = validateOptions(options);\n    var xml2 = [];\n    currentElement = js;\n    currentElementName = \"_root_\";\n    if (options.compact) {\n      xml2.push(writeElementsCompact(js, options, 0, true));\n    } else {\n      if (js[options.declarationKey]) {\n        xml2.push(writeDeclaration(js[options.declarationKey], options, 0));\n      }\n      if (js[options.elementsKey] && js[options.elementsKey].length) {\n        xml2.push(writeElements(js[options.elementsKey], options, 0, !xml2.length));\n      }\n    }\n    return xml2.join(\"\");\n  };\n  return js2xml;\n}\nvar json2xml;\nvar hasRequiredJson2xml;\nfunction requireJson2xml() {\n  if (hasRequiredJson2xml) return json2xml;\n  hasRequiredJson2xml = 1;\n  var js2xml2 = requireJs2xml();\n  json2xml = function(json, options) {\n    if (json instanceof Buffer) {\n      json = json.toString();\n    }\n    var js = null;\n    if (typeof json === \"string\") {\n      try {\n        js = JSON.parse(json);\n      } catch (e) {\n        throw new Error(\"The JSON structure is invalid\");\n      }\n    } else {\n      js = json;\n    }\n    return js2xml2(js, options);\n  };\n  return json2xml;\n}\nvar lib;\nvar hasRequiredLib;\nfunction requireLib() {\n  if (hasRequiredLib) return lib;\n  hasRequiredLib = 1;\n  var xml2js2 = requireXml2js();\n  var xml2json2 = requireXml2json();\n  var js2xml2 = requireJs2xml();\n  var json2xml2 = requireJson2xml();\n  lib = {\n    xml2js: xml2js2,\n    xml2json: xml2json2,\n    js2xml: js2xml2,\n    json2xml: json2xml2\n  };\n  return lib;\n}\nvar libExports = requireLib();\nconst convertToXmlComponent = (element) => {\n  switch (element.type) {\n    case void 0:\n    case \"element\":\n      const xmlComponent = new ImportedXmlComponent(element.name, element.attributes);\n      const childElements = element.elements || [];\n      for (const childElm of childElements) {\n        const child = convertToXmlComponent(childElm);\n        if (child !== void 0) {\n          xmlComponent.push(child);\n        }\n      }\n      return xmlComponent;\n    case \"text\":\n      return element.text;\n    default:\n      return void 0;\n  }\n};\nclass ImportedXmlComponentAttributes extends XmlAttributeComponent {\n  // noop\n}\nclass ImportedXmlComponent extends XmlComponent {\n  /**\n   * Converts the xml string to a XmlComponent tree.\n   *\n   * @param importedContent xml content of the imported component\n   */\n  static fromXmlString(importedContent) {\n    const xmlObj = libExports.xml2js(importedContent, { compact: false });\n    return convertToXmlComponent(xmlObj);\n  }\n  /**\n   * Converts the xml string to a XmlComponent tree.\n   *\n   * @param importedContent xml content of the imported component\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(rootKey, _attr) {\n    super(rootKey);\n    if (_attr) {\n      this.root.push(new ImportedXmlComponentAttributes(_attr));\n    }\n  }\n  push(xmlComponent) {\n    this.root.push(xmlComponent);\n  }\n}\nclass ImportedRootElementAttributes extends XmlComponent {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(_attr) {\n    super(\"\");\n    this._attr = _attr;\n  }\n  prepForXml(_) {\n    return {\n      _attr: this._attr\n    };\n  }\n}\nconst WORKAROUND3 = \"\";\nclass InitializableXmlComponent extends XmlComponent {\n  constructor(rootKey, initComponent) {\n    super(rootKey);\n    if (initComponent) {\n      this.root = initComponent.root;\n    }\n  }\n}\nconst decimalNumber = (val) => {\n  if (isNaN(val)) {\n    throw new Error(`Invalid value '${val}' specified. Must be an integer.`);\n  }\n  return Math.floor(val);\n};\nconst unsignedDecimalNumber = (val) => {\n  const value = decimalNumber(val);\n  if (value < 0) {\n    throw new Error(`Invalid value '${val}' specified. Must be a positive integer.`);\n  }\n  return value;\n};\nconst hexBinary = (val, length) => {\n  const expectedLength = length * 2;\n  if (val.length !== expectedLength || isNaN(Number(`0x${val}`))) {\n    throw new Error(`Invalid hex value '${val}'. Expected ${expectedLength} digit hex value`);\n  }\n  return val;\n};\nconst longHexNumber = (val) => hexBinary(val, 4);\nconst shortHexNumber = (val) => hexBinary(val, 2);\nconst uCharHexNumber = (val) => hexBinary(val, 1);\nconst universalMeasureValue = (val) => {\n  const unit = val.slice(-2);\n  const amount = val.substring(0, val.length - 2);\n  return `${Number(amount)}${unit}`;\n};\nconst positiveUniversalMeasureValue = (val) => {\n  const value = universalMeasureValue(val);\n  if (parseFloat(value) < 0) {\n    throw new Error(`Invalid value '${value}' specified. Expected a positive number.`);\n  }\n  return value;\n};\nconst hexColorValue = (val) => {\n  if (val === \"auto\") {\n    return val;\n  }\n  const color = val.charAt(0) === \"#\" ? val.substring(1) : val;\n  return hexBinary(color, 3);\n};\nconst signedTwipsMeasureValue = (val) => typeof val === \"string\" ? universalMeasureValue(val) : decimalNumber(val);\nconst hpsMeasureValue = (val) => typeof val === \"string\" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);\nconst signedHpsMeasureValue = (val) => typeof val === \"string\" ? universalMeasureValue(val) : decimalNumber(val);\nconst twipsMeasureValue = (val) => typeof val === \"string\" ? positiveUniversalMeasureValue(val) : unsignedDecimalNumber(val);\nconst percentageValue = (val) => {\n  const percent = val.substring(0, val.length - 1);\n  return `${Number(percent)}%`;\n};\nconst measurementOrPercentValue = (val) => {\n  if (typeof val === \"number\") {\n    return decimalNumber(val);\n  }\n  if (val.slice(-1) === \"%\") {\n    return percentageValue(val);\n  }\n  return universalMeasureValue(val);\n};\nconst eighthPointMeasureValue = unsignedDecimalNumber;\nconst pointMeasureValue = unsignedDecimalNumber;\nconst dateTimeValue = (val) => val.toISOString();\nclass OnOffElement extends XmlComponent {\n  constructor(name, val = true) {\n    super(name);\n    if (val !== true) {\n      this.root.push(new Attributes({ val }));\n    }\n  }\n}\nclass HpsMeasureElement extends XmlComponent {\n  constructor(name, val) {\n    super(name);\n    this.root.push(new Attributes({ val: hpsMeasureValue(val) }));\n  }\n}\nclass EmptyElement extends XmlComponent {\n}\nclass StringValueElement extends XmlComponent {\n  constructor(name, val) {\n    super(name);\n    this.root.push(new Attributes({ val }));\n  }\n}\nconst createStringElement = (name, value) => new BuilderElement({\n  name,\n  attributes: {\n    value: { key: \"w:val\", value }\n  }\n});\nclass NumberValueElement extends XmlComponent {\n  constructor(name, val) {\n    super(name);\n    this.root.push(new Attributes({ val }));\n  }\n}\nclass StringEnumValueElement extends XmlComponent {\n  constructor(name, val) {\n    super(name);\n    this.root.push(new Attributes({ val }));\n  }\n}\nclass StringContainer extends XmlComponent {\n  constructor(name, val) {\n    super(name);\n    this.root.push(val);\n  }\n}\nclass BuilderElement extends XmlComponent {\n  constructor({\n    name,\n    attributes,\n    children\n  }) {\n    super(name);\n    if (attributes) {\n      this.root.push(new NextAttributeComponent(attributes));\n    }\n    if (children) {\n      this.root.push(...children);\n    }\n  }\n}\nconst AlignmentType = {\n  /** Align Start */\n  START: \"start\",\n  /** Align Center */\n  CENTER: \"center\",\n  /** End */\n  END: \"end\",\n  /** Justified */\n  BOTH: \"both\",\n  /** Medium Kashida Length */\n  MEDIUM_KASHIDA: \"mediumKashida\",\n  /** Distribute All Characters Equally */\n  DISTRIBUTE: \"distribute\",\n  /** Align to List Tab */\n  NUM_TAB: \"numTab\",\n  /** Widest Kashida Length */\n  HIGH_KASHIDA: \"highKashida\",\n  /** Low Kashida Length */\n  LOW_KASHIDA: \"lowKashida\",\n  /** Thai Language Justification */\n  THAI_DISTRIBUTE: \"thaiDistribute\",\n  /** Align Left */\n  LEFT: \"left\",\n  /** Align Right */\n  RIGHT: \"right\",\n  /** Justified */\n  JUSTIFIED: \"both\"\n};\nclass AlignmentAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass Alignment extends XmlComponent {\n  constructor(type2) {\n    super(\"w:jc\");\n    this.root.push(new AlignmentAttributes({ val: type2 }));\n  }\n}\nclass BorderElement extends XmlComponent {\n  constructor(elementName, { color, size, space, style }) {\n    super(elementName);\n    this.root.push(\n      new BordersAttributes({\n        style,\n        color: color === void 0 ? void 0 : hexColorValue(color),\n        size: size === void 0 ? void 0 : eighthPointMeasureValue(size),\n        space: space === void 0 ? void 0 : pointMeasureValue(space)\n      })\n    );\n  }\n}\nclass BordersAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      style: \"w:val\",\n      color: \"w:color\",\n      size: \"w:sz\",\n      space: \"w:space\"\n    });\n  }\n}\nconst BorderStyle = {\n  /** a single line */\n  SINGLE: \"single\",\n  /** a line with a series of alternating thin and thick strokes */\n  DASH_DOT_STROKED: \"dashDotStroked\",\n  /** a dashed line */\n  DASHED: \"dashed\",\n  /** a dashed line with small gaps */\n  DASH_SMALL_GAP: \"dashSmallGap\",\n  /** a line with alternating dots and dashes */\n  DOT_DASH: \"dotDash\",\n  /** a line with a repeating dot - dot - dash sequence */\n  DOT_DOT_DASH: \"dotDotDash\",\n  /** a dotted line */\n  DOTTED: \"dotted\",\n  /** a double line */\n  DOUBLE: \"double\",\n  /** a double wavy line */\n  DOUBLE_WAVE: \"doubleWave\",\n  /** an inset set of lines */\n  INSET: \"inset\",\n  /** no border */\n  NIL: \"nil\",\n  /** no border */\n  NONE: \"none\",\n  /** an outset set of lines */\n  OUTSET: \"outset\",\n  /** a single line */\n  THICK: \"thick\",\n  /** a thick line contained within a thin line with a large-sized intermediate gap */\n  THICK_THIN_LARGE_GAP: \"thickThinLargeGap\",\n  /** a thick line contained within a thin line with a medium-sized intermediate gap */\n  THICK_THIN_MEDIUM_GAP: \"thickThinMediumGap\",\n  /** a thick line contained within a thin line with a small intermediate gap */\n  THICK_THIN_SMALL_GAP: \"thickThinSmallGap\",\n  /** a thin line contained within a thick line with a large-sized intermediate gap */\n  THIN_THICK_LARGE_GAP: \"thinThickLargeGap\",\n  /** a thick line contained within a thin line with a medium-sized intermediate gap */\n  THIN_THICK_MEDIUM_GAP: \"thinThickMediumGap\",\n  /** a thick line contained within a thin line with a small intermediate gap */\n  THIN_THICK_SMALL_GAP: \"thinThickSmallGap\",\n  /** a thin-thick-thin line with a large gap */\n  THIN_THICK_THIN_LARGE_GAP: \"thinThickThinLargeGap\",\n  /** a thin-thick-thin line with a medium gap */\n  THIN_THICK_THIN_MEDIUM_GAP: \"thinThickThinMediumGap\",\n  /** a thin-thick-thin line with a small gap */\n  THIN_THICK_THIN_SMALL_GAP: \"thinThickThinSmallGap\",\n  /** a three-staged gradient line, getting darker towards the paragraph */\n  THREE_D_EMBOSS: \"threeDEmboss\",\n  /** a three-staged gradient like, getting darker away from the paragraph */\n  THREE_D_ENGRAVE: \"threeDEngrave\",\n  /** a triple line */\n  TRIPLE: \"triple\",\n  /** a wavy line */\n  WAVE: \"wave\"\n};\nclass Border extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:pBdr\");\n    if (options.top) {\n      this.root.push(new BorderElement(\"w:top\", options.top));\n    }\n    if (options.bottom) {\n      this.root.push(new BorderElement(\"w:bottom\", options.bottom));\n    }\n    if (options.left) {\n      this.root.push(new BorderElement(\"w:left\", options.left));\n    }\n    if (options.right) {\n      this.root.push(new BorderElement(\"w:right\", options.right));\n    }\n  }\n}\nclass ThematicBreak extends XmlComponent {\n  constructor() {\n    super(\"w:pBdr\");\n    const bottom = new BorderElement(\"w:bottom\", {\n      color: \"auto\",\n      space: 1,\n      style: BorderStyle.SINGLE,\n      size: 6\n    });\n    this.root.push(bottom);\n  }\n}\nclass Indent extends XmlComponent {\n  constructor({ start, end, left, right, hanging, firstLine }) {\n    super(\"w:ind\");\n    this.root.push(\n      new NextAttributeComponent({\n        start: {\n          key: \"w:start\",\n          value: start === void 0 ? void 0 : signedTwipsMeasureValue(start)\n        },\n        end: {\n          key: \"w:end\",\n          value: end === void 0 ? void 0 : signedTwipsMeasureValue(end)\n        },\n        left: {\n          key: \"w:left\",\n          value: left === void 0 ? void 0 : signedTwipsMeasureValue(left)\n        },\n        right: {\n          key: \"w:right\",\n          value: right === void 0 ? void 0 : signedTwipsMeasureValue(right)\n        },\n        hanging: {\n          key: \"w:hanging\",\n          value: hanging === void 0 ? void 0 : twipsMeasureValue(hanging)\n        },\n        firstLine: {\n          key: \"w:firstLine\",\n          value: firstLine === void 0 ? void 0 : twipsMeasureValue(firstLine)\n        }\n      })\n    );\n  }\n}\nlet Break$1 = class Break extends XmlComponent {\n  constructor() {\n    super(\"w:br\");\n  }\n};\nconst FieldCharacterType = {\n  BEGIN: \"begin\",\n  END: \"end\",\n  SEPARATE: \"separate\"\n};\nclass FidCharAttrs extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { type: \"w:fldCharType\", dirty: \"w:dirty\" });\n  }\n}\nclass Begin extends XmlComponent {\n  constructor(dirty) {\n    super(\"w:fldChar\");\n    this.root.push(new FidCharAttrs({ type: FieldCharacterType.BEGIN, dirty }));\n  }\n}\nclass Separate extends XmlComponent {\n  constructor(dirty) {\n    super(\"w:fldChar\");\n    this.root.push(new FidCharAttrs({ type: FieldCharacterType.SEPARATE, dirty }));\n  }\n}\nclass End extends XmlComponent {\n  constructor(dirty) {\n    super(\"w:fldChar\");\n    this.root.push(new FidCharAttrs({ type: FieldCharacterType.END, dirty }));\n  }\n}\nconst HorizontalPositionAlign = {\n  CENTER: \"center\",\n  INSIDE: \"inside\",\n  LEFT: \"left\",\n  OUTSIDE: \"outside\",\n  RIGHT: \"right\"\n};\nconst VerticalPositionAlign = {\n  BOTTOM: \"bottom\",\n  CENTER: \"center\",\n  INSIDE: \"inside\",\n  OUTSIDE: \"outside\",\n  TOP: \"top\"\n};\nconst NumberFormat$1 = {\n  DECIMAL: \"decimal\",\n  UPPER_ROMAN: \"upperRoman\",\n  LOWER_ROMAN: \"lowerRoman\",\n  UPPER_LETTER: \"upperLetter\",\n  LOWER_LETTER: \"lowerLetter\",\n  ORDINAL: \"ordinal\",\n  CARDINAL_TEXT: \"cardinalText\",\n  ORDINAL_TEXT: \"ordinalText\",\n  HEX: \"hex\",\n  CHICAGO: \"chicago\",\n  IDEOGRAPH_DIGITAL: \"ideographDigital\",\n  JAPANESE_COUNTING: \"japaneseCounting\",\n  AIUEO: \"aiueo\",\n  IROHA: \"iroha\",\n  DECIMAL_FULL_WIDTH: \"decimalFullWidth\",\n  DECIMAL_HALF_WIDTH: \"decimalHalfWidth\",\n  JAPANESE_LEGAL: \"japaneseLegal\",\n  JAPANESE_DIGITAL_TEN_THOUSAND: \"japaneseDigitalTenThousand\",\n  DECIMAL_ENCLOSED_CIRCLE: \"decimalEnclosedCircle\",\n  DECIMAL_FULL_WIDTH_2: \"decimalFullWidth2\",\n  AIUEO_FULL_WIDTH: \"aiueoFullWidth\",\n  IROHA_FULL_WIDTH: \"irohaFullWidth\",\n  DECIMAL_ZERO: \"decimalZero\",\n  BULLET: \"bullet\",\n  GANADA: \"ganada\",\n  CHOSUNG: \"chosung\",\n  DECIMAL_ENCLOSED_FULL_STOP: \"decimalEnclosedFullstop\",\n  DECIMAL_ENCLOSED_PAREN: \"decimalEnclosedParen\",\n  DECIMAL_ENCLOSED_CIRCLE_CHINESE: \"decimalEnclosedCircleChinese\",\n  IDEOGRAPH_ENCLOSED_CIRCLE: \"ideographEnclosedCircle\",\n  IDEOGRAPH_TRADITIONAL: \"ideographTraditional\",\n  IDEOGRAPH_ZODIAC: \"ideographZodiac\",\n  IDEOGRAPH_ZODIAC_TRADITIONAL: \"ideographZodiacTraditional\",\n  TAIWANESE_COUNTING: \"taiwaneseCounting\",\n  IDEOGRAPH_LEGAL_TRADITIONAL: \"ideographLegalTraditional\",\n  TAIWANESE_COUNTING_THOUSAND: \"taiwaneseCountingThousand\",\n  TAIWANESE_DIGITAL: \"taiwaneseDigital\",\n  CHINESE_COUNTING: \"chineseCounting\",\n  CHINESE_LEGAL_SIMPLIFIED: \"chineseLegalSimplified\",\n  CHINESE_COUNTING_TEN_THOUSAND: \"chineseCountingThousand\",\n  KOREAN_DIGITAL: \"koreanDigital\",\n  KOREAN_COUNTING: \"koreanCounting\",\n  KOREAN_LEGAL: \"koreanLegal\",\n  KOREAN_DIGITAL_2: \"koreanDigital2\",\n  VIETNAMESE_COUNTING: \"vietnameseCounting\",\n  RUSSIAN_LOWER: \"russianLower\",\n  RUSSIAN_UPPER: \"russianUpper\",\n  NONE: \"none\",\n  NUMBER_IN_DASH: \"numberInDash\",\n  HEBREW_1: \"hebrew1\",\n  HEBREW_2: \"hebrew2\",\n  ARABIC_ALPHA: \"arabicAlpha\",\n  ARABIC_ABJAD: \"arabicAbjad\",\n  HINDI_VOWELS: \"hindiVowels\",\n  HINDI_CONSONANTS: \"hindiConsonants\",\n  HINDI_NUMBERS: \"hindiNumbers\",\n  HINDI_COUNTING: \"hindiCounting\",\n  THAI_LETTERS: \"thaiLetters\",\n  THAI_NUMBERS: \"thaiNumbers\",\n  THAI_COUNTING: \"thaiCounting\",\n  BAHT_TEXT: \"bahtText\",\n  DOLLAR_TEXT: \"dollarText\"\n  //   <xsd:enumeration value=\"custom\"/>\n};\nconst SpaceType = {\n  DEFAULT: \"default\",\n  PRESERVE: \"preserve\"\n};\nclass TextAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { space: \"xml:space\" });\n  }\n}\nclass Page extends XmlComponent {\n  constructor() {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"PAGE\");\n  }\n}\nclass NumberOfPages extends XmlComponent {\n  constructor() {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"NUMPAGES\");\n  }\n}\nclass NumberOfPagesSection extends XmlComponent {\n  constructor() {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"SECTIONPAGES\");\n  }\n}\nclass CurrentSection extends XmlComponent {\n  constructor() {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"SECTION\");\n  }\n}\nclass ShadingAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      fill: \"w:fill\",\n      color: \"w:color\",\n      type: \"w:val\"\n    });\n  }\n}\nclass Shading extends XmlComponent {\n  constructor({ fill, color, type: type2 }) {\n    super(\"w:shd\");\n    this.root.push(\n      new ShadingAttributes({\n        fill: fill === void 0 ? void 0 : hexColorValue(fill),\n        color: color === void 0 ? void 0 : hexColorValue(color),\n        type: type2\n      })\n    );\n  }\n}\nconst ShadingType = {\n  CLEAR: \"clear\",\n  DIAGONAL_CROSS: \"diagCross\",\n  DIAGONAL_STRIPE: \"diagStripe\",\n  HORIZONTAL_CROSS: \"horzCross\",\n  HORIZONTAL_STRIPE: \"horzStripe\",\n  NIL: \"nil\",\n  PERCENT_5: \"pct5\",\n  PERCENT_10: \"pct10\",\n  PERCENT_12: \"pct12\",\n  PERCENT_15: \"pct15\",\n  PERCENT_20: \"pct20\",\n  PERCENT_25: \"pct25\",\n  PERCENT_30: \"pct30\",\n  PERCENT_35: \"pct35\",\n  PERCENT_37: \"pct37\",\n  PERCENT_40: \"pct40\",\n  PERCENT_45: \"pct45\",\n  PERCENT_50: \"pct50\",\n  PERCENT_55: \"pct55\",\n  PERCENT_60: \"pct60\",\n  PERCENT_62: \"pct62\",\n  PERCENT_65: \"pct65\",\n  PERCENT_70: \"pct70\",\n  PERCENT_75: \"pct75\",\n  PERCENT_80: \"pct80\",\n  PERCENT_85: \"pct85\",\n  PERCENT_87: \"pct87\",\n  PERCENT_90: \"pct90\",\n  PERCENT_95: \"pct95\",\n  REVERSE_DIAGONAL_STRIPE: \"reverseDiagStripe\",\n  SOLID: \"solid\",\n  THIN_DIAGONAL_CROSS: \"thinDiagCross\",\n  THIN_DIAGONAL_STRIPE: \"thinDiagStripe\",\n  THIN_HORIZONTAL_CROSS: \"thinHorzCross\",\n  THIN_REVERSE_DIAGONAL_STRIPE: \"thinReverseDiagStripe\",\n  THIN_VERTICAL_STRIPE: \"thinVertStripe\",\n  VERTICAL_STRIPE: \"vertStripe\"\n};\nclass ChangeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"w:id\",\n      author: \"w:author\",\n      date: \"w:date\"\n    });\n  }\n}\nconst EmphasisMarkType = {\n  DOT: \"dot\"\n};\nclass BaseEmphasisMark extends XmlComponent {\n  constructor(emphasisMarkType) {\n    super(\"w:em\");\n    this.root.push(\n      new Attributes({\n        val: emphasisMarkType\n      })\n    );\n  }\n}\nclass EmphasisMark extends BaseEmphasisMark {\n  constructor(emphasisMarkType = EmphasisMarkType.DOT) {\n    super(emphasisMarkType);\n  }\n}\nclass DotEmphasisMark extends BaseEmphasisMark {\n  constructor() {\n    super(EmphasisMarkType.DOT);\n  }\n}\nclass CharacterSpacing extends XmlComponent {\n  constructor(value) {\n    super(\"w:spacing\");\n    this.root.push(\n      new Attributes({\n        val: signedTwipsMeasureValue(value)\n      })\n    );\n  }\n}\nclass Color extends XmlComponent {\n  constructor(color) {\n    super(\"w:color\");\n    this.root.push(\n      new Attributes({\n        val: hexColorValue(color)\n      })\n    );\n  }\n}\nclass Highlight extends XmlComponent {\n  constructor(color) {\n    super(\"w:highlight\");\n    this.root.push(\n      new Attributes({\n        val: color\n      })\n    );\n  }\n}\nclass HighlightComplexScript extends XmlComponent {\n  constructor(color) {\n    super(\"w:highlightCs\");\n    this.root.push(\n      new Attributes({\n        val: color\n      })\n    );\n  }\n}\nconst createLanguageComponent = (options) => new BuilderElement({\n  name: \"w:lang\",\n  attributes: {\n    value: {\n      key: \"w:val\",\n      value: options.value\n    },\n    eastAsia: {\n      key: \"w:eastAsia\",\n      value: options.eastAsia\n    },\n    bidirectional: {\n      key: \"w:bidi\",\n      value: options.bidirectional\n    }\n  }\n});\nclass RunFontAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      ascii: \"w:ascii\",\n      cs: \"w:cs\",\n      eastAsia: \"w:eastAsia\",\n      hAnsi: \"w:hAnsi\",\n      hint: \"w:hint\"\n    });\n  }\n}\nclass RunFonts extends XmlComponent {\n  constructor(nameOrAttrs, hint) {\n    super(\"w:rFonts\");\n    if (typeof nameOrAttrs === \"string\") {\n      const name = nameOrAttrs;\n      this.root.push(\n        new RunFontAttributes({\n          ascii: name,\n          cs: name,\n          eastAsia: name,\n          hAnsi: name,\n          hint\n        })\n      );\n    } else {\n      const attrs = nameOrAttrs;\n      this.root.push(new RunFontAttributes(attrs));\n    }\n  }\n}\nlet VerticalAlign$1 = class VerticalAlign extends XmlComponent {\n  constructor(type2) {\n    super(\"w:vertAlign\");\n    this.root.push(\n      new Attributes({\n        val: type2\n      })\n    );\n  }\n};\nclass SuperScript extends VerticalAlign$1 {\n  constructor() {\n    super(\"superscript\");\n  }\n}\nclass SubScript extends VerticalAlign$1 {\n  constructor() {\n    super(\"subscript\");\n  }\n}\nconst UnderlineType = {\n  SINGLE: \"single\",\n  WORDS: \"words\",\n  DOUBLE: \"double\",\n  THICK: \"thick\",\n  DOTTED: \"dotted\",\n  DOTTEDHEAVY: \"dottedHeavy\",\n  DASH: \"dash\",\n  DASHEDHEAVY: \"dashedHeavy\",\n  DASHLONG: \"dashLong\",\n  DASHLONGHEAVY: \"dashLongHeavy\",\n  DOTDASH: \"dotDash\",\n  DASHDOTHEAVY: \"dashDotHeavy\",\n  DOTDOTDASH: \"dotDotDash\",\n  DASHDOTDOTHEAVY: \"dashDotDotHeavy\",\n  WAVE: \"wave\",\n  WAVYHEAVY: \"wavyHeavy\",\n  WAVYDOUBLE: \"wavyDouble\",\n  NONE: \"none\"\n};\nclass Underline extends XmlComponent {\n  constructor(underlineType = UnderlineType.SINGLE, color) {\n    super(\"w:u\");\n    this.root.push(\n      new Attributes({\n        val: underlineType,\n        color: color === void 0 ? void 0 : hexColorValue(color)\n      })\n    );\n  }\n}\nconst TextEffect = {\n  BLINK_BACKGROUND: \"blinkBackground\",\n  LIGHTS: \"lights\",\n  ANTS_BLACK: \"antsBlack\",\n  ANTS_RED: \"antsRed\",\n  SHIMMER: \"shimmer\",\n  SPARKLE: \"sparkle\",\n  NONE: \"none\"\n};\nconst HighlightColor = {\n  BLACK: \"black\",\n  BLUE: \"blue\",\n  CYAN: \"cyan\",\n  DARK_BLUE: \"darkBlue\",\n  DARK_CYAN: \"darkCyan\",\n  DARK_GRAY: \"darkGray\",\n  DARK_GREEN: \"darkGreen\",\n  DARK_MAGENTA: \"darkMagenta\",\n  DARK_RED: \"darkRed\",\n  DARK_YELLOW: \"darkYellow\",\n  GREEN: \"green\",\n  LIGHT_GRAY: \"lightGray\",\n  MAGENTA: \"magenta\",\n  NONE: \"none\",\n  RED: \"red\",\n  WHITE: \"white\",\n  YELLOW: \"yellow\"\n};\nclass RunProperties extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    var _a, _b;\n    super(\"w:rPr\");\n    if (!options) {\n      return;\n    }\n    if (options.style) {\n      this.push(new StringValueElement(\"w:rStyle\", options.style));\n    }\n    if (options.font) {\n      if (typeof options.font === \"string\") {\n        this.push(new RunFonts(options.font));\n      } else if (\"name\" in options.font) {\n        this.push(new RunFonts(options.font.name, options.font.hint));\n      } else {\n        this.push(new RunFonts(options.font));\n      }\n    }\n    if (options.bold !== void 0) {\n      this.push(new OnOffElement(\"w:b\", options.bold));\n    }\n    if (options.boldComplexScript === void 0 && options.bold !== void 0 || options.boldComplexScript) {\n      this.push(new OnOffElement(\"w:bCs\", (_a = options.boldComplexScript) != null ? _a : options.bold));\n    }\n    if (options.italics !== void 0) {\n      this.push(new OnOffElement(\"w:i\", options.italics));\n    }\n    if (options.italicsComplexScript === void 0 && options.italics !== void 0 || options.italicsComplexScript) {\n      this.push(new OnOffElement(\"w:iCs\", (_b = options.italicsComplexScript) != null ? _b : options.italics));\n    }\n    if (options.smallCaps !== void 0) {\n      this.push(new OnOffElement(\"w:smallCaps\", options.smallCaps));\n    } else if (options.allCaps !== void 0) {\n      this.push(new OnOffElement(\"w:caps\", options.allCaps));\n    }\n    if (options.strike !== void 0) {\n      this.push(new OnOffElement(\"w:strike\", options.strike));\n    }\n    if (options.doubleStrike !== void 0) {\n      this.push(new OnOffElement(\"w:dstrike\", options.doubleStrike));\n    }\n    if (options.emboss !== void 0) {\n      this.push(new OnOffElement(\"w:emboss\", options.emboss));\n    }\n    if (options.imprint !== void 0) {\n      this.push(new OnOffElement(\"w:imprint\", options.imprint));\n    }\n    if (options.noProof !== void 0) {\n      this.push(new OnOffElement(\"w:noProof\", options.noProof));\n    }\n    if (options.snapToGrid !== void 0) {\n      this.push(new OnOffElement(\"w:snapToGrid\", options.snapToGrid));\n    }\n    if (options.vanish) {\n      this.push(new OnOffElement(\"w:vanish\", options.vanish));\n    }\n    if (options.color) {\n      this.push(new Color(options.color));\n    }\n    if (options.characterSpacing) {\n      this.push(new CharacterSpacing(options.characterSpacing));\n    }\n    if (options.scale !== void 0) {\n      this.push(new NumberValueElement(\"w:w\", options.scale));\n    }\n    if (options.kern) {\n      this.push(new HpsMeasureElement(\"w:kern\", options.kern));\n    }\n    if (options.position) {\n      this.push(new StringValueElement(\"w:position\", options.position));\n    }\n    if (options.size !== void 0) {\n      this.push(new HpsMeasureElement(\"w:sz\", options.size));\n    }\n    const szCs = options.sizeComplexScript === void 0 || options.sizeComplexScript === true ? options.size : options.sizeComplexScript;\n    if (szCs) {\n      this.push(new HpsMeasureElement(\"w:szCs\", szCs));\n    }\n    if (options.highlight) {\n      this.push(new Highlight(options.highlight));\n    }\n    const highlightCs = options.highlightComplexScript === void 0 || options.highlightComplexScript === true ? options.highlight : options.highlightComplexScript;\n    if (highlightCs) {\n      this.push(new HighlightComplexScript(highlightCs));\n    }\n    if (options.underline) {\n      this.push(new Underline(options.underline.type, options.underline.color));\n    }\n    if (options.effect) {\n      this.push(new StringValueElement(\"w:effect\", options.effect));\n    }\n    if (options.border) {\n      this.push(new BorderElement(\"w:bdr\", options.border));\n    }\n    if (options.shading) {\n      this.push(new Shading(options.shading));\n    }\n    if (options.subScript) {\n      this.push(new SubScript());\n    }\n    if (options.superScript) {\n      this.push(new SuperScript());\n    }\n    if (options.rightToLeft !== void 0) {\n      this.push(new OnOffElement(\"w:rtl\", options.rightToLeft));\n    }\n    if (options.emphasisMark) {\n      this.push(new EmphasisMark(options.emphasisMark.type));\n    }\n    if (options.language) {\n      this.push(createLanguageComponent(options.language));\n    }\n    if (options.specVanish) {\n      this.push(new OnOffElement(\"w:specVanish\", options.vanish));\n    }\n    if (options.math) {\n      this.push(new OnOffElement(\"w:oMath\", options.math));\n    }\n    if (options.revision) {\n      this.push(new RunPropertiesChange(options.revision));\n    }\n  }\n  push(item) {\n    this.root.push(item);\n  }\n}\nclass RunPropertiesChange extends XmlComponent {\n  constructor(options) {\n    super(\"w:rPrChange\");\n    this.root.push(\n      new ChangeAttributes({\n        id: options.id,\n        author: options.author,\n        date: options.date\n      })\n    );\n    this.addChildElement(new RunProperties(options));\n  }\n}\nclass Text extends XmlComponent {\n  constructor(options) {\n    var _a;\n    super(\"w:t\");\n    if (typeof options === \"string\") {\n      this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n      this.root.push(options);\n    } else {\n      this.root.push(new TextAttributes({ space: (_a = options.space) != null ? _a : SpaceType.DEFAULT }));\n      this.root.push(options.text);\n    }\n  }\n}\nconst PageNumber = {\n  CURRENT: \"CURRENT\",\n  TOTAL_PAGES: \"TOTAL_PAGES\",\n  TOTAL_PAGES_IN_SECTION: \"TOTAL_PAGES_IN_SECTION\",\n  CURRENT_SECTION: \"SECTION\"\n};\nclass Run extends XmlComponent {\n  constructor(options) {\n    super(\"w:r\");\n    __publicField(this, \"properties\");\n    this.properties = new RunProperties(options);\n    this.root.push(this.properties);\n    if (options.break) {\n      for (let i = 0; i < options.break; i++) {\n        this.root.push(new Break$1());\n      }\n    }\n    if (options.children) {\n      for (const child of options.children) {\n        if (typeof child === \"string\") {\n          switch (child) {\n            case PageNumber.CURRENT:\n              this.root.push(new Begin());\n              this.root.push(new Page());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            case PageNumber.TOTAL_PAGES:\n              this.root.push(new Begin());\n              this.root.push(new NumberOfPages());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            case PageNumber.TOTAL_PAGES_IN_SECTION:\n              this.root.push(new Begin());\n              this.root.push(new NumberOfPagesSection());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            case PageNumber.CURRENT_SECTION:\n              this.root.push(new Begin());\n              this.root.push(new CurrentSection());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            default:\n              this.root.push(new Text(child));\n              break;\n          }\n          continue;\n        }\n        this.root.push(child);\n      }\n    } else if (options.text !== void 0) {\n      this.root.push(new Text(options.text));\n    }\n  }\n}\nclass TextRun extends Run {\n  constructor(options) {\n    super(typeof options === \"string\" ? { text: options } : options);\n  }\n}\nclass SymbolAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      char: \"w:char\",\n      symbolfont: \"w:font\"\n    });\n  }\n}\nlet Symbol$1 = class Symbol2 extends XmlComponent {\n  constructor(char = \"\", symbolfont = \"Wingdings\") {\n    super(\"w:sym\");\n    this.root.push(new SymbolAttributes({ char, symbolfont }));\n  }\n};\nclass SymbolRun extends Run {\n  constructor(options) {\n    if (typeof options === \"string\") {\n      super({});\n      this.root.push(new Symbol$1(options));\n      return this;\n    }\n    super(options);\n    this.root.push(new Symbol$1(options.char, options.symbolfont));\n  }\n}\nvar hash$1 = {};\nvar utils = {};\nvar minimalisticAssert;\nvar hasRequiredMinimalisticAssert;\nfunction requireMinimalisticAssert() {\n  if (hasRequiredMinimalisticAssert) return minimalisticAssert;\n  hasRequiredMinimalisticAssert = 1;\n  minimalisticAssert = assert;\n  function assert(val, msg) {\n    if (!val)\n      throw new Error(msg || \"Assertion failed\");\n  }\n  assert.equal = function assertEqual(l, r, msg) {\n    if (l != r)\n      throw new Error(msg || \"Assertion failed: \" + l + \" != \" + r);\n  };\n  return minimalisticAssert;\n}\nvar hasRequiredUtils;\nfunction requireUtils() {\n  if (hasRequiredUtils) return utils;\n  hasRequiredUtils = 1;\n  var assert = requireMinimalisticAssert();\n  var inherits = requireInherits_browser();\n  utils.inherits = inherits;\n  function isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 64512) !== 55296) {\n      return false;\n    }\n    if (i < 0 || i + 1 >= msg.length) {\n      return false;\n    }\n    return (msg.charCodeAt(i + 1) & 64512) === 56320;\n  }\n  function toArray(msg, enc) {\n    if (Array.isArray(msg))\n      return msg.slice();\n    if (!msg)\n      return [];\n    var res = [];\n    if (typeof msg === \"string\") {\n      if (!enc) {\n        var p = 0;\n        for (var i = 0; i < msg.length; i++) {\n          var c = msg.charCodeAt(i);\n          if (c < 128) {\n            res[p++] = c;\n          } else if (c < 2048) {\n            res[p++] = c >> 6 | 192;\n            res[p++] = c & 63 | 128;\n          } else if (isSurrogatePair(msg, i)) {\n            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);\n            res[p++] = c >> 18 | 240;\n            res[p++] = c >> 12 & 63 | 128;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          } else {\n            res[p++] = c >> 12 | 224;\n            res[p++] = c >> 6 & 63 | 128;\n            res[p++] = c & 63 | 128;\n          }\n        }\n      } else if (enc === \"hex\") {\n        msg = msg.replace(/[^a-z0-9]+/ig, \"\");\n        if (msg.length % 2 !== 0)\n          msg = \"0\" + msg;\n        for (i = 0; i < msg.length; i += 2)\n          res.push(parseInt(msg[i] + msg[i + 1], 16));\n      }\n    } else {\n      for (i = 0; i < msg.length; i++)\n        res[i] = msg[i] | 0;\n    }\n    return res;\n  }\n  utils.toArray = toArray;\n  function toHex(msg) {\n    var res = \"\";\n    for (var i = 0; i < msg.length; i++)\n      res += zero2(msg[i].toString(16));\n    return res;\n  }\n  utils.toHex = toHex;\n  function htonl(w) {\n    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;\n    return res >>> 0;\n  }\n  utils.htonl = htonl;\n  function toHex32(msg, endian) {\n    var res = \"\";\n    for (var i = 0; i < msg.length; i++) {\n      var w = msg[i];\n      if (endian === \"little\")\n        w = htonl(w);\n      res += zero8(w.toString(16));\n    }\n    return res;\n  }\n  utils.toHex32 = toHex32;\n  function zero2(word) {\n    if (word.length === 1)\n      return \"0\" + word;\n    else\n      return word;\n  }\n  utils.zero2 = zero2;\n  function zero8(word) {\n    if (word.length === 7)\n      return \"0\" + word;\n    else if (word.length === 6)\n      return \"00\" + word;\n    else if (word.length === 5)\n      return \"000\" + word;\n    else if (word.length === 4)\n      return \"0000\" + word;\n    else if (word.length === 3)\n      return \"00000\" + word;\n    else if (word.length === 2)\n      return \"000000\" + word;\n    else if (word.length === 1)\n      return \"0000000\" + word;\n    else\n      return word;\n  }\n  utils.zero8 = zero8;\n  function join32(msg, start, end, endian) {\n    var len = end - start;\n    assert(len % 4 === 0);\n    var res = new Array(len / 4);\n    for (var i = 0, k = start; i < res.length; i++, k += 4) {\n      var w;\n      if (endian === \"big\")\n        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];\n      else\n        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];\n      res[i] = w >>> 0;\n    }\n    return res;\n  }\n  utils.join32 = join32;\n  function split32(msg, endian) {\n    var res = new Array(msg.length * 4);\n    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n      var m = msg[i];\n      if (endian === \"big\") {\n        res[k] = m >>> 24;\n        res[k + 1] = m >>> 16 & 255;\n        res[k + 2] = m >>> 8 & 255;\n        res[k + 3] = m & 255;\n      } else {\n        res[k + 3] = m >>> 24;\n        res[k + 2] = m >>> 16 & 255;\n        res[k + 1] = m >>> 8 & 255;\n        res[k] = m & 255;\n      }\n    }\n    return res;\n  }\n  utils.split32 = split32;\n  function rotr32(w, b) {\n    return w >>> b | w << 32 - b;\n  }\n  utils.rotr32 = rotr32;\n  function rotl32(w, b) {\n    return w << b | w >>> 32 - b;\n  }\n  utils.rotl32 = rotl32;\n  function sum32(a, b) {\n    return a + b >>> 0;\n  }\n  utils.sum32 = sum32;\n  function sum32_3(a, b, c) {\n    return a + b + c >>> 0;\n  }\n  utils.sum32_3 = sum32_3;\n  function sum32_4(a, b, c, d) {\n    return a + b + c + d >>> 0;\n  }\n  utils.sum32_4 = sum32_4;\n  function sum32_5(a, b, c, d, e) {\n    return a + b + c + d + e >>> 0;\n  }\n  utils.sum32_5 = sum32_5;\n  function sum64(buf, pos, ah, al) {\n    var bh = buf[pos];\n    var bl = buf[pos + 1];\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    buf[pos] = hi >>> 0;\n    buf[pos + 1] = lo;\n  }\n  utils.sum64 = sum64;\n  function sum64_hi(ah, al, bh, bl) {\n    var lo = al + bl >>> 0;\n    var hi = (lo < al ? 1 : 0) + ah + bh;\n    return hi >>> 0;\n  }\n  utils.sum64_hi = sum64_hi;\n  function sum64_lo(ah, al, bh, bl) {\n    var lo = al + bl;\n    return lo >>> 0;\n  }\n  utils.sum64_lo = sum64_lo;\n  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    var hi = ah + bh + ch + dh + carry;\n    return hi >>> 0;\n  }\n  utils.sum64_4_hi = sum64_4_hi;\n  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n    var lo = al + bl + cl + dl;\n    return lo >>> 0;\n  }\n  utils.sum64_4_lo = sum64_4_lo;\n  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var carry = 0;\n    var lo = al;\n    lo = lo + bl >>> 0;\n    carry += lo < al ? 1 : 0;\n    lo = lo + cl >>> 0;\n    carry += lo < cl ? 1 : 0;\n    lo = lo + dl >>> 0;\n    carry += lo < dl ? 1 : 0;\n    lo = lo + el >>> 0;\n    carry += lo < el ? 1 : 0;\n    var hi = ah + bh + ch + dh + eh + carry;\n    return hi >>> 0;\n  }\n  utils.sum64_5_hi = sum64_5_hi;\n  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n    var lo = al + bl + cl + dl + el;\n    return lo >>> 0;\n  }\n  utils.sum64_5_lo = sum64_5_lo;\n  function rotr64_hi(ah, al, num) {\n    var r = al << 32 - num | ah >>> num;\n    return r >>> 0;\n  }\n  utils.rotr64_hi = rotr64_hi;\n  function rotr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n  utils.rotr64_lo = rotr64_lo;\n  function shr64_hi(ah, al, num) {\n    return ah >>> num;\n  }\n  utils.shr64_hi = shr64_hi;\n  function shr64_lo(ah, al, num) {\n    var r = ah << 32 - num | al >>> num;\n    return r >>> 0;\n  }\n  utils.shr64_lo = shr64_lo;\n  return utils;\n}\nvar common$1 = {};\nvar hasRequiredCommon$1;\nfunction requireCommon$1() {\n  if (hasRequiredCommon$1) return common$1;\n  hasRequiredCommon$1 = 1;\n  var utils2 = requireUtils();\n  var assert = requireMinimalisticAssert();\n  function BlockHash() {\n    this.pending = null;\n    this.pendingTotal = 0;\n    this.blockSize = this.constructor.blockSize;\n    this.outSize = this.constructor.outSize;\n    this.hmacStrength = this.constructor.hmacStrength;\n    this.padLength = this.constructor.padLength / 8;\n    this.endian = \"big\";\n    this._delta8 = this.blockSize / 8;\n    this._delta32 = this.blockSize / 32;\n  }\n  common$1.BlockHash = BlockHash;\n  BlockHash.prototype.update = function update(msg, enc) {\n    msg = utils2.toArray(msg, enc);\n    if (!this.pending)\n      this.pending = msg;\n    else\n      this.pending = this.pending.concat(msg);\n    this.pendingTotal += msg.length;\n    if (this.pending.length >= this._delta8) {\n      msg = this.pending;\n      var r = msg.length % this._delta8;\n      this.pending = msg.slice(msg.length - r, msg.length);\n      if (this.pending.length === 0)\n        this.pending = null;\n      msg = utils2.join32(msg, 0, msg.length - r, this.endian);\n      for (var i = 0; i < msg.length; i += this._delta32)\n        this._update(msg, i, i + this._delta32);\n    }\n    return this;\n  };\n  BlockHash.prototype.digest = function digest(enc) {\n    this.update(this._pad());\n    assert(this.pending === null);\n    return this._digest(enc);\n  };\n  BlockHash.prototype._pad = function pad() {\n    var len = this.pendingTotal;\n    var bytes = this._delta8;\n    var k = bytes - (len + this.padLength) % bytes;\n    var res = new Array(k + this.padLength);\n    res[0] = 128;\n    for (var i = 1; i < k; i++)\n      res[i] = 0;\n    len <<= 3;\n    if (this.endian === \"big\") {\n      for (var t = 8; t < this.padLength; t++)\n        res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = len >>> 24 & 255;\n      res[i++] = len >>> 16 & 255;\n      res[i++] = len >>> 8 & 255;\n      res[i++] = len & 255;\n    } else {\n      res[i++] = len & 255;\n      res[i++] = len >>> 8 & 255;\n      res[i++] = len >>> 16 & 255;\n      res[i++] = len >>> 24 & 255;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      res[i++] = 0;\n      for (t = 8; t < this.padLength; t++)\n        res[i++] = 0;\n    }\n    return res;\n  };\n  return common$1;\n}\nvar sha = {};\nvar common = {};\nvar hasRequiredCommon;\nfunction requireCommon() {\n  if (hasRequiredCommon) return common;\n  hasRequiredCommon = 1;\n  var utils2 = requireUtils();\n  var rotr32 = utils2.rotr32;\n  function ft_1(s, x, y, z) {\n    if (s === 0)\n      return ch32(x, y, z);\n    if (s === 1 || s === 3)\n      return p32(x, y, z);\n    if (s === 2)\n      return maj32(x, y, z);\n  }\n  common.ft_1 = ft_1;\n  function ch32(x, y, z) {\n    return x & y ^ ~x & z;\n  }\n  common.ch32 = ch32;\n  function maj32(x, y, z) {\n    return x & y ^ x & z ^ y & z;\n  }\n  common.maj32 = maj32;\n  function p32(x, y, z) {\n    return x ^ y ^ z;\n  }\n  common.p32 = p32;\n  function s0_256(x) {\n    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n  }\n  common.s0_256 = s0_256;\n  function s1_256(x) {\n    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n  }\n  common.s1_256 = s1_256;\n  function g0_256(x) {\n    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;\n  }\n  common.g0_256 = g0_256;\n  function g1_256(x) {\n    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;\n  }\n  common.g1_256 = g1_256;\n  return common;\n}\nvar _1;\nvar hasRequired_1;\nfunction require_1() {\n  if (hasRequired_1) return _1;\n  hasRequired_1 = 1;\n  var utils2 = requireUtils();\n  var common2 = requireCommon$1();\n  var shaCommon = requireCommon();\n  var rotl32 = utils2.rotl32;\n  var sum32 = utils2.sum32;\n  var sum32_5 = utils2.sum32_5;\n  var ft_1 = shaCommon.ft_1;\n  var BlockHash = common2.BlockHash;\n  var sha1_K = [\n    1518500249,\n    1859775393,\n    2400959708,\n    3395469782\n  ];\n  function SHA1() {\n    if (!(this instanceof SHA1))\n      return new SHA1();\n    BlockHash.call(this);\n    this.h = [\n      1732584193,\n      4023233417,\n      2562383102,\n      271733878,\n      3285377520\n    ];\n    this.W = new Array(80);\n  }\n  utils2.inherits(SHA1, BlockHash);\n  _1 = SHA1;\n  SHA1.blockSize = 512;\n  SHA1.outSize = 160;\n  SHA1.hmacStrength = 80;\n  SHA1.padLength = 64;\n  SHA1.prototype._update = function _update(msg, start) {\n    var W = this.W;\n    for (var i = 0; i < 16; i++)\n      W[i] = msg[start + i];\n    for (; i < W.length; i++)\n      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n    for (i = 0; i < W.length; i++) {\n      var s = ~~(i / 20);\n      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n      e = d;\n      d = c;\n      c = rotl32(b, 30);\n      b = a;\n      a = t;\n    }\n    this.h[0] = sum32(this.h[0], a);\n    this.h[1] = sum32(this.h[1], b);\n    this.h[2] = sum32(this.h[2], c);\n    this.h[3] = sum32(this.h[3], d);\n    this.h[4] = sum32(this.h[4], e);\n  };\n  SHA1.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h, \"big\");\n    else\n      return utils2.split32(this.h, \"big\");\n  };\n  return _1;\n}\nvar _256;\nvar hasRequired_256;\nfunction require_256() {\n  if (hasRequired_256) return _256;\n  hasRequired_256 = 1;\n  var utils2 = requireUtils();\n  var common2 = requireCommon$1();\n  var shaCommon = requireCommon();\n  var assert = requireMinimalisticAssert();\n  var sum32 = utils2.sum32;\n  var sum32_4 = utils2.sum32_4;\n  var sum32_5 = utils2.sum32_5;\n  var ch32 = shaCommon.ch32;\n  var maj32 = shaCommon.maj32;\n  var s0_256 = shaCommon.s0_256;\n  var s1_256 = shaCommon.s1_256;\n  var g0_256 = shaCommon.g0_256;\n  var g1_256 = shaCommon.g1_256;\n  var BlockHash = common2.BlockHash;\n  var sha256_K = [\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ];\n  function SHA256() {\n    if (!(this instanceof SHA256))\n      return new SHA256();\n    BlockHash.call(this);\n    this.h = [\n      1779033703,\n      3144134277,\n      1013904242,\n      2773480762,\n      1359893119,\n      2600822924,\n      528734635,\n      1541459225\n    ];\n    this.k = sha256_K;\n    this.W = new Array(64);\n  }\n  utils2.inherits(SHA256, BlockHash);\n  _256 = SHA256;\n  SHA256.blockSize = 512;\n  SHA256.outSize = 256;\n  SHA256.hmacStrength = 192;\n  SHA256.padLength = 64;\n  SHA256.prototype._update = function _update(msg, start) {\n    var W = this.W;\n    for (var i = 0; i < 16; i++)\n      W[i] = msg[start + i];\n    for (; i < W.length; i++)\n      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n    var a = this.h[0];\n    var b = this.h[1];\n    var c = this.h[2];\n    var d = this.h[3];\n    var e = this.h[4];\n    var f = this.h[5];\n    var g = this.h[6];\n    var h = this.h[7];\n    assert(this.k.length === W.length);\n    for (i = 0; i < W.length; i++) {\n      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n      var T2 = sum32(s0_256(a), maj32(a, b, c));\n      h = g;\n      g = f;\n      f = e;\n      e = sum32(d, T1);\n      d = c;\n      c = b;\n      b = a;\n      a = sum32(T1, T2);\n    }\n    this.h[0] = sum32(this.h[0], a);\n    this.h[1] = sum32(this.h[1], b);\n    this.h[2] = sum32(this.h[2], c);\n    this.h[3] = sum32(this.h[3], d);\n    this.h[4] = sum32(this.h[4], e);\n    this.h[5] = sum32(this.h[5], f);\n    this.h[6] = sum32(this.h[6], g);\n    this.h[7] = sum32(this.h[7], h);\n  };\n  SHA256.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h, \"big\");\n    else\n      return utils2.split32(this.h, \"big\");\n  };\n  return _256;\n}\nvar _224;\nvar hasRequired_224;\nfunction require_224() {\n  if (hasRequired_224) return _224;\n  hasRequired_224 = 1;\n  var utils2 = requireUtils();\n  var SHA256 = require_256();\n  function SHA224() {\n    if (!(this instanceof SHA224))\n      return new SHA224();\n    SHA256.call(this);\n    this.h = [\n      3238371032,\n      914150663,\n      812702999,\n      4144912697,\n      4290775857,\n      1750603025,\n      1694076839,\n      3204075428\n    ];\n  }\n  utils2.inherits(SHA224, SHA256);\n  _224 = SHA224;\n  SHA224.blockSize = 512;\n  SHA224.outSize = 224;\n  SHA224.hmacStrength = 192;\n  SHA224.padLength = 64;\n  SHA224.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h.slice(0, 7), \"big\");\n    else\n      return utils2.split32(this.h.slice(0, 7), \"big\");\n  };\n  return _224;\n}\nvar _512;\nvar hasRequired_512;\nfunction require_512() {\n  if (hasRequired_512) return _512;\n  hasRequired_512 = 1;\n  var utils2 = requireUtils();\n  var common2 = requireCommon$1();\n  var assert = requireMinimalisticAssert();\n  var rotr64_hi = utils2.rotr64_hi;\n  var rotr64_lo = utils2.rotr64_lo;\n  var shr64_hi = utils2.shr64_hi;\n  var shr64_lo = utils2.shr64_lo;\n  var sum64 = utils2.sum64;\n  var sum64_hi = utils2.sum64_hi;\n  var sum64_lo = utils2.sum64_lo;\n  var sum64_4_hi = utils2.sum64_4_hi;\n  var sum64_4_lo = utils2.sum64_4_lo;\n  var sum64_5_hi = utils2.sum64_5_hi;\n  var sum64_5_lo = utils2.sum64_5_lo;\n  var BlockHash = common2.BlockHash;\n  var sha512_K = [\n    1116352408,\n    3609767458,\n    1899447441,\n    602891725,\n    3049323471,\n    3964484399,\n    3921009573,\n    2173295548,\n    961987163,\n    4081628472,\n    1508970993,\n    3053834265,\n    2453635748,\n    2937671579,\n    2870763221,\n    3664609560,\n    3624381080,\n    2734883394,\n    310598401,\n    1164996542,\n    607225278,\n    1323610764,\n    1426881987,\n    3590304994,\n    1925078388,\n    4068182383,\n    2162078206,\n    991336113,\n    2614888103,\n    633803317,\n    3248222580,\n    3479774868,\n    3835390401,\n    2666613458,\n    4022224774,\n    944711139,\n    264347078,\n    2341262773,\n    604807628,\n    2007800933,\n    770255983,\n    1495990901,\n    1249150122,\n    1856431235,\n    1555081692,\n    3175218132,\n    1996064986,\n    2198950837,\n    2554220882,\n    3999719339,\n    2821834349,\n    766784016,\n    2952996808,\n    2566594879,\n    3210313671,\n    3203337956,\n    3336571891,\n    1034457026,\n    3584528711,\n    2466948901,\n    113926993,\n    3758326383,\n    338241895,\n    168717936,\n    666307205,\n    1188179964,\n    773529912,\n    1546045734,\n    1294757372,\n    1522805485,\n    1396182291,\n    2643833823,\n    1695183700,\n    2343527390,\n    1986661051,\n    1014477480,\n    2177026350,\n    1206759142,\n    2456956037,\n    344077627,\n    2730485921,\n    1290863460,\n    2820302411,\n    3158454273,\n    3259730800,\n    3505952657,\n    3345764771,\n    106217008,\n    3516065817,\n    3606008344,\n    3600352804,\n    1432725776,\n    4094571909,\n    1467031594,\n    275423344,\n    851169720,\n    430227734,\n    3100823752,\n    506948616,\n    1363258195,\n    659060556,\n    3750685593,\n    883997877,\n    3785050280,\n    958139571,\n    3318307427,\n    1322822218,\n    3812723403,\n    1537002063,\n    2003034995,\n    1747873779,\n    3602036899,\n    1955562222,\n    1575990012,\n    2024104815,\n    1125592928,\n    2227730452,\n    2716904306,\n    2361852424,\n    442776044,\n    2428436474,\n    593698344,\n    2756734187,\n    3733110249,\n    3204031479,\n    2999351573,\n    3329325298,\n    3815920427,\n    3391569614,\n    3928383900,\n    3515267271,\n    566280711,\n    3940187606,\n    3454069534,\n    4118630271,\n    4000239992,\n    116418474,\n    1914138554,\n    174292421,\n    2731055270,\n    289380356,\n    3203993006,\n    460393269,\n    320620315,\n    685471733,\n    587496836,\n    852142971,\n    1086792851,\n    1017036298,\n    365543100,\n    1126000580,\n    2618297676,\n    1288033470,\n    3409855158,\n    1501505948,\n    4234509866,\n    1607167915,\n    987167468,\n    1816402316,\n    1246189591\n  ];\n  function SHA512() {\n    if (!(this instanceof SHA512))\n      return new SHA512();\n    BlockHash.call(this);\n    this.h = [\n      1779033703,\n      4089235720,\n      3144134277,\n      2227873595,\n      1013904242,\n      4271175723,\n      2773480762,\n      1595750129,\n      1359893119,\n      2917565137,\n      2600822924,\n      725511199,\n      528734635,\n      4215389547,\n      1541459225,\n      327033209\n    ];\n    this.k = sha512_K;\n    this.W = new Array(160);\n  }\n  utils2.inherits(SHA512, BlockHash);\n  _512 = SHA512;\n  SHA512.blockSize = 1024;\n  SHA512.outSize = 512;\n  SHA512.hmacStrength = 192;\n  SHA512.padLength = 128;\n  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n    var W = this.W;\n    for (var i = 0; i < 32; i++)\n      W[i] = msg[start + i];\n    for (; i < W.length; i += 2) {\n      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);\n      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n      var c1_hi = W[i - 14];\n      var c1_lo = W[i - 13];\n      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);\n      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n      var c3_hi = W[i - 32];\n      var c3_lo = W[i - 31];\n      W[i] = sum64_4_hi(\n        c0_hi,\n        c0_lo,\n        c1_hi,\n        c1_lo,\n        c2_hi,\n        c2_lo,\n        c3_hi,\n        c3_lo\n      );\n      W[i + 1] = sum64_4_lo(\n        c0_hi,\n        c0_lo,\n        c1_hi,\n        c1_lo,\n        c2_hi,\n        c2_lo,\n        c3_hi,\n        c3_lo\n      );\n    }\n  };\n  SHA512.prototype._update = function _update(msg, start) {\n    this._prepareBlock(msg, start);\n    var W = this.W;\n    var ah = this.h[0];\n    var al = this.h[1];\n    var bh = this.h[2];\n    var bl = this.h[3];\n    var ch = this.h[4];\n    var cl = this.h[5];\n    var dh = this.h[6];\n    var dl = this.h[7];\n    var eh = this.h[8];\n    var el = this.h[9];\n    var fh = this.h[10];\n    var fl = this.h[11];\n    var gh = this.h[12];\n    var gl = this.h[13];\n    var hh = this.h[14];\n    var hl = this.h[15];\n    assert(this.k.length === W.length);\n    for (var i = 0; i < W.length; i += 2) {\n      var c0_hi = hh;\n      var c0_lo = hl;\n      var c1_hi = s1_512_hi(eh, el);\n      var c1_lo = s1_512_lo(eh, el);\n      var c2_hi = ch64_hi(eh, el, fh, fl, gh);\n      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n      var c3_hi = this.k[i];\n      var c3_lo = this.k[i + 1];\n      var c4_hi = W[i];\n      var c4_lo = W[i + 1];\n      var T1_hi = sum64_5_hi(\n        c0_hi,\n        c0_lo,\n        c1_hi,\n        c1_lo,\n        c2_hi,\n        c2_lo,\n        c3_hi,\n        c3_lo,\n        c4_hi,\n        c4_lo\n      );\n      var T1_lo = sum64_5_lo(\n        c0_hi,\n        c0_lo,\n        c1_hi,\n        c1_lo,\n        c2_hi,\n        c2_lo,\n        c3_hi,\n        c3_lo,\n        c4_hi,\n        c4_lo\n      );\n      c0_hi = s0_512_hi(ah, al);\n      c0_lo = s0_512_lo(ah, al);\n      c1_hi = maj64_hi(ah, al, bh, bl, ch);\n      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n      el = sum64_lo(dl, dl, T1_hi, T1_lo);\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n    }\n    sum64(this.h, 0, ah, al);\n    sum64(this.h, 2, bh, bl);\n    sum64(this.h, 4, ch, cl);\n    sum64(this.h, 6, dh, dl);\n    sum64(this.h, 8, eh, el);\n    sum64(this.h, 10, fh, fl);\n    sum64(this.h, 12, gh, gl);\n    sum64(this.h, 14, hh, hl);\n  };\n  SHA512.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h, \"big\");\n    else\n      return utils2.split32(this.h, \"big\");\n  };\n  function ch64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ ~xh & zh;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function ch64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ ~xl & zl;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function maj64_hi(xh, xl, yh, yl, zh) {\n    var r = xh & yh ^ xh & zh ^ yh & zh;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function maj64_lo(xh, xl, yh, yl, zh, zl) {\n    var r = xl & yl ^ xl & zl ^ yl & zl;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function s0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi(xh, xl, 28);\n    var c1_hi = rotr64_hi(xl, xh, 2);\n    var c2_hi = rotr64_hi(xl, xh, 7);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function s0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo(xh, xl, 28);\n    var c1_lo = rotr64_lo(xl, xh, 2);\n    var c2_lo = rotr64_lo(xl, xh, 7);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function s1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi(xh, xl, 14);\n    var c1_hi = rotr64_hi(xh, xl, 18);\n    var c2_hi = rotr64_hi(xl, xh, 9);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function s1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo(xh, xl, 14);\n    var c1_lo = rotr64_lo(xh, xl, 18);\n    var c2_lo = rotr64_lo(xl, xh, 9);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function g0_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi(xh, xl, 1);\n    var c1_hi = rotr64_hi(xh, xl, 8);\n    var c2_hi = shr64_hi(xh, xl, 7);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function g0_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo(xh, xl, 1);\n    var c1_lo = rotr64_lo(xh, xl, 8);\n    var c2_lo = shr64_lo(xh, xl, 7);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function g1_512_hi(xh, xl) {\n    var c0_hi = rotr64_hi(xh, xl, 19);\n    var c1_hi = rotr64_hi(xl, xh, 29);\n    var c2_hi = shr64_hi(xh, xl, 6);\n    var r = c0_hi ^ c1_hi ^ c2_hi;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  function g1_512_lo(xh, xl) {\n    var c0_lo = rotr64_lo(xh, xl, 19);\n    var c1_lo = rotr64_lo(xl, xh, 29);\n    var c2_lo = shr64_lo(xh, xl, 6);\n    var r = c0_lo ^ c1_lo ^ c2_lo;\n    if (r < 0)\n      r += 4294967296;\n    return r;\n  }\n  return _512;\n}\nvar _384;\nvar hasRequired_384;\nfunction require_384() {\n  if (hasRequired_384) return _384;\n  hasRequired_384 = 1;\n  var utils2 = requireUtils();\n  var SHA512 = require_512();\n  function SHA384() {\n    if (!(this instanceof SHA384))\n      return new SHA384();\n    SHA512.call(this);\n    this.h = [\n      3418070365,\n      3238371032,\n      1654270250,\n      914150663,\n      2438529370,\n      812702999,\n      355462360,\n      4144912697,\n      1731405415,\n      4290775857,\n      2394180231,\n      1750603025,\n      3675008525,\n      1694076839,\n      1203062813,\n      3204075428\n    ];\n  }\n  utils2.inherits(SHA384, SHA512);\n  _384 = SHA384;\n  SHA384.blockSize = 1024;\n  SHA384.outSize = 384;\n  SHA384.hmacStrength = 192;\n  SHA384.padLength = 128;\n  SHA384.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h.slice(0, 12), \"big\");\n    else\n      return utils2.split32(this.h.slice(0, 12), \"big\");\n  };\n  return _384;\n}\nvar hasRequiredSha;\nfunction requireSha() {\n  if (hasRequiredSha) return sha;\n  hasRequiredSha = 1;\n  sha.sha1 = require_1();\n  sha.sha224 = require_224();\n  sha.sha256 = require_256();\n  sha.sha384 = require_384();\n  sha.sha512 = require_512();\n  return sha;\n}\nvar ripemd = {};\nvar hasRequiredRipemd;\nfunction requireRipemd() {\n  if (hasRequiredRipemd) return ripemd;\n  hasRequiredRipemd = 1;\n  var utils2 = requireUtils();\n  var common2 = requireCommon$1();\n  var rotl32 = utils2.rotl32;\n  var sum32 = utils2.sum32;\n  var sum32_3 = utils2.sum32_3;\n  var sum32_4 = utils2.sum32_4;\n  var BlockHash = common2.BlockHash;\n  function RIPEMD160() {\n    if (!(this instanceof RIPEMD160))\n      return new RIPEMD160();\n    BlockHash.call(this);\n    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    this.endian = \"little\";\n  }\n  utils2.inherits(RIPEMD160, BlockHash);\n  ripemd.ripemd160 = RIPEMD160;\n  RIPEMD160.blockSize = 512;\n  RIPEMD160.outSize = 160;\n  RIPEMD160.hmacStrength = 192;\n  RIPEMD160.padLength = 64;\n  RIPEMD160.prototype._update = function update(msg, start) {\n    var A = this.h[0];\n    var B = this.h[1];\n    var C = this.h[2];\n    var D = this.h[3];\n    var E = this.h[4];\n    var Ah = A;\n    var Bh = B;\n    var Ch = C;\n    var Dh = D;\n    var Eh = E;\n    for (var j = 0; j < 80; j++) {\n      var T = sum32(\n        rotl32(\n          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n          s[j]\n        ),\n        E\n      );\n      A = E;\n      E = D;\n      D = rotl32(C, 10);\n      C = B;\n      B = T;\n      T = sum32(\n        rotl32(\n          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n          sh[j]\n        ),\n        Eh\n      );\n      Ah = Eh;\n      Eh = Dh;\n      Dh = rotl32(Ch, 10);\n      Ch = Bh;\n      Bh = T;\n    }\n    T = sum32_3(this.h[1], C, Dh);\n    this.h[1] = sum32_3(this.h[2], D, Eh);\n    this.h[2] = sum32_3(this.h[3], E, Ah);\n    this.h[3] = sum32_3(this.h[4], A, Bh);\n    this.h[4] = sum32_3(this.h[0], B, Ch);\n    this.h[0] = T;\n  };\n  RIPEMD160.prototype._digest = function digest(enc) {\n    if (enc === \"hex\")\n      return utils2.toHex32(this.h, \"little\");\n    else\n      return utils2.split32(this.h, \"little\");\n  };\n  function f(j, x, y, z) {\n    if (j <= 15)\n      return x ^ y ^ z;\n    else if (j <= 31)\n      return x & y | ~x & z;\n    else if (j <= 47)\n      return (x | ~y) ^ z;\n    else if (j <= 63)\n      return x & z | y & ~z;\n    else\n      return x ^ (y | ~z);\n  }\n  function K(j) {\n    if (j <= 15)\n      return 0;\n    else if (j <= 31)\n      return 1518500249;\n    else if (j <= 47)\n      return 1859775393;\n    else if (j <= 63)\n      return 2400959708;\n    else\n      return 2840853838;\n  }\n  function Kh(j) {\n    if (j <= 15)\n      return 1352829926;\n    else if (j <= 31)\n      return 1548603684;\n    else if (j <= 47)\n      return 1836072691;\n    else if (j <= 63)\n      return 2053994217;\n    else\n      return 0;\n  }\n  var r = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    7,\n    4,\n    13,\n    1,\n    10,\n    6,\n    15,\n    3,\n    12,\n    0,\n    9,\n    5,\n    2,\n    14,\n    11,\n    8,\n    3,\n    10,\n    14,\n    4,\n    9,\n    15,\n    8,\n    1,\n    2,\n    7,\n    0,\n    6,\n    13,\n    11,\n    5,\n    12,\n    1,\n    9,\n    11,\n    10,\n    0,\n    8,\n    12,\n    4,\n    13,\n    3,\n    7,\n    15,\n    14,\n    5,\n    6,\n    2,\n    4,\n    0,\n    5,\n    9,\n    7,\n    12,\n    2,\n    10,\n    14,\n    1,\n    3,\n    8,\n    11,\n    6,\n    15,\n    13\n  ];\n  var rh = [\n    5,\n    14,\n    7,\n    0,\n    9,\n    2,\n    11,\n    4,\n    13,\n    6,\n    15,\n    8,\n    1,\n    10,\n    3,\n    12,\n    6,\n    11,\n    3,\n    7,\n    0,\n    13,\n    5,\n    10,\n    14,\n    15,\n    8,\n    12,\n    4,\n    9,\n    1,\n    2,\n    15,\n    5,\n    1,\n    3,\n    7,\n    14,\n    6,\n    9,\n    11,\n    8,\n    12,\n    2,\n    10,\n    0,\n    4,\n    13,\n    8,\n    6,\n    4,\n    1,\n    3,\n    11,\n    15,\n    0,\n    5,\n    12,\n    2,\n    13,\n    9,\n    7,\n    10,\n    14,\n    12,\n    15,\n    10,\n    4,\n    1,\n    5,\n    8,\n    7,\n    6,\n    2,\n    13,\n    14,\n    0,\n    3,\n    9,\n    11\n  ];\n  var s = [\n    11,\n    14,\n    15,\n    12,\n    5,\n    8,\n    7,\n    9,\n    11,\n    13,\n    14,\n    15,\n    6,\n    7,\n    9,\n    8,\n    7,\n    6,\n    8,\n    13,\n    11,\n    9,\n    7,\n    15,\n    7,\n    12,\n    15,\n    9,\n    11,\n    7,\n    13,\n    12,\n    11,\n    13,\n    6,\n    7,\n    14,\n    9,\n    13,\n    15,\n    14,\n    8,\n    13,\n    6,\n    5,\n    12,\n    7,\n    5,\n    11,\n    12,\n    14,\n    15,\n    14,\n    15,\n    9,\n    8,\n    9,\n    14,\n    5,\n    6,\n    8,\n    6,\n    5,\n    12,\n    9,\n    15,\n    5,\n    11,\n    6,\n    8,\n    13,\n    12,\n    5,\n    12,\n    13,\n    14,\n    11,\n    8,\n    5,\n    6\n  ];\n  var sh = [\n    8,\n    9,\n    9,\n    11,\n    13,\n    15,\n    15,\n    5,\n    7,\n    7,\n    8,\n    11,\n    14,\n    14,\n    12,\n    6,\n    9,\n    13,\n    15,\n    7,\n    12,\n    8,\n    9,\n    11,\n    7,\n    7,\n    12,\n    7,\n    6,\n    15,\n    13,\n    11,\n    9,\n    7,\n    15,\n    11,\n    8,\n    6,\n    6,\n    14,\n    12,\n    13,\n    5,\n    14,\n    13,\n    13,\n    7,\n    5,\n    15,\n    5,\n    8,\n    11,\n    14,\n    14,\n    6,\n    14,\n    6,\n    9,\n    12,\n    9,\n    12,\n    5,\n    15,\n    8,\n    8,\n    5,\n    12,\n    9,\n    12,\n    5,\n    14,\n    6,\n    8,\n    13,\n    6,\n    5,\n    15,\n    13,\n    11,\n    11\n  ];\n  return ripemd;\n}\nvar hmac;\nvar hasRequiredHmac;\nfunction requireHmac() {\n  if (hasRequiredHmac) return hmac;\n  hasRequiredHmac = 1;\n  var utils2 = requireUtils();\n  var assert = requireMinimalisticAssert();\n  function Hmac(hash2, key, enc) {\n    if (!(this instanceof Hmac))\n      return new Hmac(hash2, key, enc);\n    this.Hash = hash2;\n    this.blockSize = hash2.blockSize / 8;\n    this.outSize = hash2.outSize / 8;\n    this.inner = null;\n    this.outer = null;\n    this._init(utils2.toArray(key, enc));\n  }\n  hmac = Hmac;\n  Hmac.prototype._init = function init(key) {\n    if (key.length > this.blockSize)\n      key = new this.Hash().update(key).digest();\n    assert(key.length <= this.blockSize);\n    for (var i = key.length; i < this.blockSize; i++)\n      key.push(0);\n    for (i = 0; i < key.length; i++)\n      key[i] ^= 54;\n    this.inner = new this.Hash().update(key);\n    for (i = 0; i < key.length; i++)\n      key[i] ^= 106;\n    this.outer = new this.Hash().update(key);\n  };\n  Hmac.prototype.update = function update(msg, enc) {\n    this.inner.update(msg, enc);\n    return this;\n  };\n  Hmac.prototype.digest = function digest(enc) {\n    this.outer.update(this.inner.digest());\n    return this.outer.digest(enc);\n  };\n  return hmac;\n}\nvar hasRequiredHash;\nfunction requireHash() {\n  if (hasRequiredHash) return hash$1;\n  hasRequiredHash = 1;\n  (function(exports) {\n    var hash2 = exports;\n    hash2.utils = requireUtils();\n    hash2.common = requireCommon$1();\n    hash2.sha = requireSha();\n    hash2.ripemd = requireRipemd();\n    hash2.hmac = requireHmac();\n    hash2.sha1 = hash2.sha.sha1;\n    hash2.sha256 = hash2.sha.sha256;\n    hash2.sha224 = hash2.sha.sha224;\n    hash2.sha384 = hash2.sha.sha384;\n    hash2.sha512 = hash2.sha.sha512;\n    hash2.ripemd160 = hash2.ripemd.ripemd160;\n  })(hash$1);\n  return hash$1;\n}\nvar hashExports = requireHash();\nconst hash = /* @__PURE__ */ getDefaultExportFromCjs$1(hashExports);\nlet urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = \"\";\n    let i = size | 0;\n    while (i--) {\n      id += alphabet[Math.random() * alphabet.length | 0];\n    }\n    return id;\n  };\n};\nlet nanoid = (size = 21) => {\n  let id = \"\";\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\nconst convertMillimetersToTwip = (millimeters) => Math.floor(millimeters / 25.4 * 72 * 20);\nconst convertInchesToTwip = (inches) => Math.floor(inches * 72 * 20);\nconst uniqueNumericIdCreator = (initial = 0) => {\n  let currentCount = initial;\n  return () => ++currentCount;\n};\nconst abstractNumUniqueNumericIdGen = () => uniqueNumericIdCreator();\nconst concreteNumUniqueNumericIdGen = () => uniqueNumericIdCreator(1);\nconst docPropertiesUniqueNumericIdGen = () => uniqueNumericIdCreator();\nconst bookmarkUniqueNumericIdGen = () => uniqueNumericIdCreator();\nconst uniqueId = () => nanoid().toLowerCase();\nconst hashedId = (data) => hash.sha1().update(data instanceof ArrayBuffer ? new Uint8Array(data) : data).digest(\"hex\");\nconst generateUuidPart = (count) => customAlphabet(\"1234567890abcdef\", count)();\nconst uniqueUuid = () => `${generateUuidPart(8)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(4)}-${generateUuidPart(12)}`;\nconst HorizontalPositionRelativeFrom = {\n  /**\n   * ## Character\n   *\n   * Specifies that the horizontal positioning shall be relative to the position of the anchor within its run content.\n   */\n  CHARACTER: \"character\",\n  /**\n   * ## Column\n   *\n   * Specifies that the horizontal positioning shall be relative to the extents of the column which contains its anchor.\n   */\n  COLUMN: \"column\",\n  /**\n   * ## Inside Margin\n   *\n   * Specifies that the horizontal positioning shall be relative to the inside margin of the current page (the left margin on odd pages, right on even pages).\n   */\n  INSIDE_MARGIN: \"insideMargin\",\n  /**\n   * ## Left Margin\n   *\n   * Specifies that the horizontal positioning shall be relative to the left margin of the page.\n   */\n  LEFT_MARGIN: \"leftMargin\",\n  /**\n   * ## Page Margin\n   *\n   * Specifies that the horizontal positioning shall be relative to the page margins.\n   */\n  MARGIN: \"margin\",\n  /**\n   * ## Outside Margin\n   *\n   * Specifies that the horizontal positioning shall be relative to the outside margin of the current page (the right margin on odd pages, left on even pages).\n   */\n  OUTSIDE_MARGIN: \"outsideMargin\",\n  /**\n   * ## Page Edge\n   *\n   * Specifies that the horizontal positioning shall be relative to the edge of the page.\n   */\n  PAGE: \"page\",\n  /**\n   * ## Right Margin\n   *\n   * Specifies that the horizontal positioning shall be relative to the right margin of the page.\n   */\n  RIGHT_MARGIN: \"rightMargin\"\n};\nconst VerticalPositionRelativeFrom = {\n  /**\n   * ## Bottom Margin\n   *\n   * Specifies that the vertical positioning shall be relative to the bottom margin of the current page.\n   */\n  BOTTOM_MARGIN: \"bottomMargin\",\n  /**\n   * ## Inside Margin\n   *\n   * Specifies that the vertical positioning shall be relative to the inside margin of the current page.\n   */\n  INSIDE_MARGIN: \"insideMargin\",\n  /**\n   * ## Line\n   *\n   * Specifies that the vertical positioning shall be relative to the line containing the anchor character.\n   */\n  LINE: \"line\",\n  /**\n   * ## Page Margin\n   *\n   * Specifies that the vertical positioning shall be relative to the page margins.\n   */\n  MARGIN: \"margin\",\n  /**\n   * ## Outside Margin\n   *\n   * Specifies that the vertical positioning shall be relative to the outside margin of the current page.\n   */\n  OUTSIDE_MARGIN: \"outsideMargin\",\n  /**\n   * ## Page Edge\n   *\n   * Specifies that the vertical positioning shall be relative to the edge of the page.\n   */\n  PAGE: \"page\",\n  /**\n   * ## Paragraph\n   *\n   * Specifies that the vertical positioning shall be relative to the paragraph which contains the drawing anchor.\n   */\n  PARAGRAPH: \"paragraph\",\n  /**\n   * ## Top Margin\n   *\n   * Specifies that the vertical positioning shall be relative to the top margin of the current page.\n   */\n  TOP_MARGIN: \"topMargin\"\n};\nconst createSimplePos = () => new BuilderElement({\n  name: \"wp:simplePos\",\n  // NOTE: It's not fully supported in Microsoft Word, but this element is needed anyway\n  attributes: {\n    x: { key: \"x\", value: 0 },\n    y: { key: \"y\", value: 0 }\n  }\n});\nconst createAlign = (value) => new BuilderElement({\n  name: \"wp:align\",\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  children: [value]\n});\nconst createPositionOffset = (offsetValue) => new BuilderElement({\n  name: \"wp:posOffset\",\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  children: [offsetValue.toString()]\n});\nconst createHorizontalPosition = ({ relative, align, offset }) => new BuilderElement({\n  name: \"wp:positionH\",\n  attributes: {\n    relativeFrom: { key: \"relativeFrom\", value: relative != null ? relative : HorizontalPositionRelativeFrom.PAGE }\n  },\n  children: [\n    (() => {\n      if (align) {\n        return createAlign(align);\n      } else if (offset !== void 0) {\n        return createPositionOffset(offset);\n      } else {\n        throw new Error(\"There is no configuration provided for floating position (Align or offset)\");\n      }\n    })()\n  ]\n});\nconst createVerticalPosition = ({ relative, align, offset }) => new BuilderElement({\n  name: \"wp:positionV\",\n  attributes: {\n    relativeFrom: { key: \"relativeFrom\", value: relative != null ? relative : VerticalPositionRelativeFrom.PAGE }\n  },\n  children: [\n    (() => {\n      if (align) {\n        return createAlign(align);\n      } else if (offset !== void 0) {\n        return createPositionOffset(offset);\n      } else {\n        throw new Error(\"There is no configuration provided for floating position (Align or offset)\");\n      }\n    })()\n  ]\n});\nclass GraphicDataAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      uri: \"uri\"\n    });\n  }\n}\nconst createSvgBlip = (mediaData) => new BuilderElement({\n  name: \"asvg:svgBlip\",\n  attributes: {\n    asvg: {\n      key: \"xmlns:asvg\",\n      value: \"http://schemas.microsoft.com/office/drawing/2016/SVG/main\"\n    },\n    embed: {\n      key: \"r:embed\",\n      value: `rId{${mediaData.fileName}}`\n    }\n  }\n});\nconst createExtention = (mediaData) => new BuilderElement({\n  name: \"a:ext\",\n  attributes: {\n    uri: {\n      key: \"uri\",\n      value: \"{96DAC541-7B7A-43D3-8B79-37D633B846F1}\"\n    }\n  },\n  children: [createSvgBlip(mediaData)]\n});\nconst createExtentionList = (mediaData) => new BuilderElement({\n  name: \"a:extLst\",\n  children: [createExtention(mediaData)]\n});\nconst createBlip = (mediaData) => new BuilderElement({\n  name: \"a:blip\",\n  attributes: {\n    embed: {\n      key: \"r:embed\",\n      value: `rId{${mediaData.type === \"svg\" ? mediaData.fallback.fileName : mediaData.fileName}}`\n    },\n    cstate: {\n      key: \"cstate\",\n      value: \"none\"\n    }\n  },\n  children: mediaData.type === \"svg\" ? [createExtentionList(mediaData)] : []\n});\nclass SourceRectangle extends XmlComponent {\n  constructor() {\n    super(\"a:srcRect\");\n  }\n}\nclass FillRectangle extends XmlComponent {\n  constructor() {\n    super(\"a:fillRect\");\n  }\n}\nclass Stretch extends XmlComponent {\n  constructor() {\n    super(\"a:stretch\");\n    this.root.push(new FillRectangle());\n  }\n}\nclass BlipFill extends XmlComponent {\n  constructor(mediaData) {\n    super(\"pic:blipFill\");\n    this.root.push(createBlip(mediaData));\n    this.root.push(new SourceRectangle());\n    this.root.push(new Stretch());\n  }\n}\nclass PicLocksAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      noChangeAspect: \"noChangeAspect\",\n      noChangeArrowheads: \"noChangeArrowheads\"\n    });\n  }\n}\nclass PicLocks extends XmlComponent {\n  constructor() {\n    super(\"a:picLocks\");\n    this.root.push(\n      new PicLocksAttributes({\n        noChangeAspect: 1,\n        noChangeArrowheads: 1\n      })\n    );\n  }\n}\nclass ChildNonVisualProperties extends XmlComponent {\n  constructor() {\n    super(\"pic:cNvPicPr\");\n    this.root.push(new PicLocks());\n  }\n}\nconst createHyperlinkClick = (linkId, hasXmlNs) => new BuilderElement({\n  name: \"a:hlinkClick\",\n  attributes: __spreadProps(__spreadValues({}, hasXmlNs ? {\n    xmlns: {\n      key: \"xmlns:a\",\n      value: \"http://schemas.openxmlformats.org/drawingml/2006/main\"\n    }\n  } : {}), {\n    id: {\n      key: \"r:id\",\n      value: `rId${linkId}`\n    }\n  })\n});\nclass NonVisualPropertiesAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"id\",\n      name: \"name\",\n      descr: \"descr\"\n    });\n  }\n}\nclass NonVisualProperties extends XmlComponent {\n  constructor() {\n    super(\"pic:cNvPr\");\n    this.root.push(\n      new NonVisualPropertiesAttributes({\n        id: 0,\n        name: \"\",\n        descr: \"\"\n      })\n    );\n  }\n  prepForXml(context) {\n    for (let i = context.stack.length - 1; i >= 0; i--) {\n      const element = context.stack[i];\n      if (!(element instanceof ConcreteHyperlink)) {\n        continue;\n      }\n      this.root.push(createHyperlinkClick(element.linkId, false));\n      break;\n    }\n    return super.prepForXml(context);\n  }\n}\nclass NonVisualPicProperties extends XmlComponent {\n  constructor() {\n    super(\"pic:nvPicPr\");\n    this.root.push(new NonVisualProperties());\n    this.root.push(new ChildNonVisualProperties());\n  }\n}\nclass PicAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns:pic\"\n    });\n  }\n}\nclass ExtentsAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      cx: \"cx\",\n      cy: \"cy\"\n    });\n  }\n}\nclass Extents extends XmlComponent {\n  constructor(x, y) {\n    super(\"a:ext\");\n    __publicField(this, \"attributes\");\n    this.attributes = new ExtentsAttributes({\n      cx: x,\n      cy: y\n    });\n    this.root.push(this.attributes);\n  }\n}\nclass OffsetAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      x: \"x\",\n      y: \"y\"\n    });\n  }\n}\nclass Offset extends XmlComponent {\n  constructor() {\n    super(\"a:off\");\n    this.root.push(\n      new OffsetAttributes({\n        x: 0,\n        y: 0\n      })\n    );\n  }\n}\nclass FormAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      flipVertical: \"flipV\",\n      flipHorizontal: \"flipH\",\n      rotation: \"rot\"\n    });\n  }\n}\nclass Form extends XmlComponent {\n  constructor(options) {\n    var _a, _b;\n    super(\"a:xfrm\");\n    __publicField(this, \"extents\");\n    this.root.push(\n      new FormAttributes({\n        flipVertical: (_a = options.flip) == null ? void 0 : _a.vertical,\n        flipHorizontal: (_b = options.flip) == null ? void 0 : _b.horizontal,\n        rotation: options.rotation\n      })\n    );\n    this.extents = new Extents(options.emus.x, options.emus.y);\n    this.root.push(new Offset());\n    this.root.push(this.extents);\n  }\n}\nconst createNoFill = () => new BuilderElement({ name: \"a:noFill\" });\nconst createSolidRgbColor = (options) => new BuilderElement({\n  name: \"a:srgbClr\",\n  attributes: {\n    value: {\n      key: \"val\",\n      value: options.value\n    }\n  }\n});\nconst createSchemeColor = (options) => new BuilderElement({\n  name: \"a:schemeClr\",\n  attributes: {\n    value: {\n      key: \"val\",\n      value: options.value\n    }\n  }\n});\nconst createSolidFill = (options) => new BuilderElement({\n  name: \"a:solidFill\",\n  children: [options.type === \"rgb\" ? createSolidRgbColor(options) : createSchemeColor(options)]\n});\nconst createOutline = (options) => new BuilderElement({\n  name: \"a:ln\",\n  attributes: {\n    width: {\n      key: \"w\",\n      value: options.width\n    },\n    cap: {\n      key: \"cap\",\n      value: options.cap\n    },\n    compoundLine: {\n      key: \"cmpd\",\n      value: options.compoundLine\n    },\n    align: {\n      key: \"algn\",\n      value: options.align\n    }\n  },\n  children: [\n    options.type === \"noFill\" ? createNoFill() : options.solidFillType === \"rgb\" ? createSolidFill({\n      type: \"rgb\",\n      value: options.value\n    }) : createSolidFill({\n      type: \"scheme\",\n      value: options.value\n    })\n  ]\n});\nclass AdjustmentValues extends XmlComponent {\n  constructor() {\n    super(\"a:avLst\");\n  }\n}\nclass PresetGeometryAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      prst: \"prst\"\n    });\n  }\n}\nclass PresetGeometry extends XmlComponent {\n  constructor() {\n    super(\"a:prstGeom\");\n    this.root.push(\n      new PresetGeometryAttributes({\n        prst: \"rect\"\n      })\n    );\n    this.root.push(new AdjustmentValues());\n  }\n}\nclass ShapePropertiesAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      bwMode: \"bwMode\"\n    });\n  }\n}\nclass ShapeProperties extends XmlComponent {\n  constructor({ outline, transform }) {\n    super(\"pic:spPr\");\n    __publicField(this, \"form\");\n    this.root.push(\n      new ShapePropertiesAttributes({\n        bwMode: \"auto\"\n      })\n    );\n    this.form = new Form(transform);\n    this.root.push(this.form);\n    this.root.push(new PresetGeometry());\n    if (outline) {\n      this.root.push(createNoFill());\n      this.root.push(createOutline(outline));\n    }\n  }\n}\nclass Pic extends XmlComponent {\n  constructor({\n    mediaData,\n    transform,\n    outline\n  }) {\n    super(\"pic:pic\");\n    this.root.push(\n      new PicAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/drawingml/2006/picture\"\n      })\n    );\n    this.root.push(new NonVisualPicProperties());\n    this.root.push(new BlipFill(mediaData));\n    this.root.push(new ShapeProperties({ transform, outline }));\n  }\n}\nclass GraphicData extends XmlComponent {\n  constructor({\n    mediaData,\n    transform,\n    outline\n  }) {\n    super(\"a:graphicData\");\n    __publicField(this, \"pic\");\n    this.root.push(\n      new GraphicDataAttributes({\n        uri: \"http://schemas.openxmlformats.org/drawingml/2006/picture\"\n      })\n    );\n    this.pic = new Pic({ mediaData, transform, outline });\n    this.root.push(this.pic);\n  }\n}\nclass GraphicAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      a: \"xmlns:a\"\n    });\n  }\n}\nclass Graphic extends XmlComponent {\n  constructor({\n    mediaData,\n    transform,\n    outline\n  }) {\n    super(\"a:graphic\");\n    __publicField(this, \"data\");\n    this.root.push(\n      new GraphicAttributes({\n        a: \"http://schemas.openxmlformats.org/drawingml/2006/main\"\n      })\n    );\n    this.data = new GraphicData({ mediaData, transform, outline });\n    this.root.push(this.data);\n  }\n}\nconst TextWrappingType = {\n  NONE: 0,\n  SQUARE: 1,\n  TIGHT: 2,\n  TOP_AND_BOTTOM: 3\n};\nconst TextWrappingSide = {\n  BOTH_SIDES: \"bothSides\",\n  LEFT: \"left\",\n  RIGHT: \"right\",\n  LARGEST: \"largest\"\n};\nclass WrapNone extends XmlComponent {\n  constructor() {\n    super(\"wp:wrapNone\");\n  }\n}\nclass WrapSquareAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      distT: \"distT\",\n      distB: \"distB\",\n      distL: \"distL\",\n      distR: \"distR\",\n      wrapText: \"wrapText\"\n    });\n  }\n}\nclass WrapSquare extends XmlComponent {\n  constructor(textWrapping, margins = {\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0\n  }) {\n    super(\"wp:wrapSquare\");\n    this.root.push(\n      new WrapSquareAttributes({\n        wrapText: textWrapping.side || TextWrappingSide.BOTH_SIDES,\n        distT: margins.top,\n        distB: margins.bottom,\n        distL: margins.left,\n        distR: margins.right\n      })\n    );\n  }\n}\nclass WrapTightAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      distT: \"distT\",\n      distB: \"distB\"\n    });\n  }\n}\nclass WrapTight extends XmlComponent {\n  constructor(margins = {\n    top: 0,\n    bottom: 0\n  }) {\n    super(\"wp:wrapTight\");\n    this.root.push(\n      new WrapTightAttributes({\n        distT: margins.top,\n        distB: margins.bottom\n      })\n    );\n  }\n}\nclass WrapTopAndBottomAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      distT: \"distT\",\n      distB: \"distB\"\n    });\n  }\n}\nclass WrapTopAndBottom extends XmlComponent {\n  constructor(margins = {\n    top: 0,\n    bottom: 0\n  }) {\n    super(\"wp:wrapTopAndBottom\");\n    this.root.push(\n      new WrapTopAndBottomAttributes({\n        distT: margins.top,\n        distB: margins.bottom\n      })\n    );\n  }\n}\nclass DocProperties extends XmlComponent {\n  constructor({ name, description, title } = { name: \"\", description: \"\", title: \"\" }) {\n    super(\"wp:docPr\");\n    __publicField(this, \"docPropertiesUniqueNumericId\", docPropertiesUniqueNumericIdGen());\n    const attributes = {\n      id: {\n        key: \"id\",\n        value: this.docPropertiesUniqueNumericId()\n      },\n      name: {\n        key: \"name\",\n        value: name\n      }\n    };\n    if (description !== null && description !== void 0) {\n      attributes.description = {\n        key: \"descr\",\n        value: description\n      };\n    }\n    if (title !== null && title !== void 0) {\n      attributes.title = {\n        key: \"title\",\n        value: title\n      };\n    }\n    this.root.push(new NextAttributeComponent(attributes));\n  }\n  prepForXml(context) {\n    for (let i = context.stack.length - 1; i >= 0; i--) {\n      const element = context.stack[i];\n      if (!(element instanceof ConcreteHyperlink)) {\n        continue;\n      }\n      this.root.push(createHyperlinkClick(element.linkId, true));\n      break;\n    }\n    return super.prepForXml(context);\n  }\n}\nconst createEffectExtent = ({ top, right, bottom, left }) => new BuilderElement({\n  name: \"wp:effectExtent\",\n  attributes: {\n    top: {\n      key: \"t\",\n      value: top\n    },\n    right: {\n      key: \"r\",\n      value: right\n    },\n    bottom: {\n      key: \"b\",\n      value: bottom\n    },\n    left: {\n      key: \"l\",\n      value: left\n    }\n  }\n});\nconst createExtent = ({ x, y }) => new BuilderElement({\n  name: \"wp:extent\",\n  attributes: {\n    x: { key: \"cx\", value: x },\n    y: { key: \"cy\", value: y }\n  }\n});\nclass GraphicFrameLockAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns:a\",\n      noChangeAspect: \"noChangeAspect\"\n    });\n  }\n}\nclass GraphicFrameLocks extends XmlComponent {\n  constructor() {\n    super(\"a:graphicFrameLocks\");\n    this.root.push(\n      new GraphicFrameLockAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/drawingml/2006/main\",\n        noChangeAspect: 1\n      })\n    );\n  }\n}\nconst createGraphicFrameProperties = () => new BuilderElement({\n  name: \"wp:cNvGraphicFramePr\",\n  children: [new GraphicFrameLocks()]\n});\nclass AnchorAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      distT: \"distT\",\n      distB: \"distB\",\n      distL: \"distL\",\n      distR: \"distR\",\n      allowOverlap: \"allowOverlap\",\n      behindDoc: \"behindDoc\",\n      layoutInCell: \"layoutInCell\",\n      locked: \"locked\",\n      relativeHeight: \"relativeHeight\",\n      simplePos: \"simplePos\"\n    });\n  }\n}\nclass Anchor extends XmlComponent {\n  constructor({\n    mediaData,\n    transform,\n    drawingOptions\n  }) {\n    super(\"wp:anchor\");\n    const floating = __spreadValues({\n      allowOverlap: true,\n      behindDocument: false,\n      lockAnchor: false,\n      layoutInCell: true,\n      verticalPosition: {},\n      horizontalPosition: {}\n    }, drawingOptions.floating);\n    this.root.push(\n      new AnchorAttributes({\n        distT: floating.margins ? floating.margins.top || 0 : 0,\n        distB: floating.margins ? floating.margins.bottom || 0 : 0,\n        distL: floating.margins ? floating.margins.left || 0 : 0,\n        distR: floating.margins ? floating.margins.right || 0 : 0,\n        simplePos: \"0\",\n        // note: word doesn't fully support - so we use 0\n        allowOverlap: floating.allowOverlap === true ? \"1\" : \"0\",\n        behindDoc: floating.behindDocument === true ? \"1\" : \"0\",\n        locked: floating.lockAnchor === true ? \"1\" : \"0\",\n        layoutInCell: floating.layoutInCell === true ? \"1\" : \"0\",\n        relativeHeight: floating.zIndex ? floating.zIndex : transform.emus.y\n      })\n    );\n    this.root.push(createSimplePos());\n    this.root.push(createHorizontalPosition(floating.horizontalPosition));\n    this.root.push(createVerticalPosition(floating.verticalPosition));\n    this.root.push(createExtent({ x: transform.emus.x, y: transform.emus.y }));\n    this.root.push(createEffectExtent({ top: 0, right: 0, bottom: 0, left: 0 }));\n    if (drawingOptions.floating !== void 0 && drawingOptions.floating.wrap !== void 0) {\n      switch (drawingOptions.floating.wrap.type) {\n        case TextWrappingType.SQUARE:\n          this.root.push(new WrapSquare(drawingOptions.floating.wrap, drawingOptions.floating.margins));\n          break;\n        case TextWrappingType.TIGHT:\n          this.root.push(new WrapTight(drawingOptions.floating.margins));\n          break;\n        case TextWrappingType.TOP_AND_BOTTOM:\n          this.root.push(new WrapTopAndBottom(drawingOptions.floating.margins));\n          break;\n        case TextWrappingType.NONE:\n        default:\n          this.root.push(new WrapNone());\n      }\n    } else {\n      this.root.push(new WrapNone());\n    }\n    this.root.push(new DocProperties(drawingOptions.docProperties));\n    this.root.push(createGraphicFrameProperties());\n    this.root.push(new Graphic({ mediaData, transform, outline: drawingOptions.outline }));\n  }\n}\nconst createInline = ({ mediaData, transform, docProperties, outline }) => {\n  var _a, _b, _c, _d;\n  return new BuilderElement({\n    name: \"wp:inline\",\n    attributes: {\n      distanceTop: {\n        key: \"distT\",\n        value: 0\n      },\n      distanceBottom: {\n        key: \"distB\",\n        value: 0\n      },\n      distanceLeft: {\n        key: \"distL\",\n        value: 0\n      },\n      distanceRight: {\n        key: \"distR\",\n        value: 0\n      }\n    },\n    children: [\n      createExtent({ x: transform.emus.x, y: transform.emus.y }),\n      createEffectExtent(\n        outline ? {\n          top: ((_a = outline.width) != null ? _a : 9525) * 2,\n          right: ((_b = outline.width) != null ? _b : 9525) * 2,\n          bottom: ((_c = outline.width) != null ? _c : 9525) * 2,\n          left: ((_d = outline.width) != null ? _d : 9525) * 2\n        } : { top: 0, right: 0, bottom: 0, left: 0 }\n      ),\n      new DocProperties(docProperties),\n      createGraphicFrameProperties(),\n      new Graphic({ mediaData, transform, outline })\n    ]\n  });\n};\nclass Drawing extends XmlComponent {\n  constructor(imageData, drawingOptions = {}) {\n    super(\"w:drawing\");\n    if (!drawingOptions.floating) {\n      this.root.push(\n        createInline({\n          mediaData: imageData,\n          transform: imageData.transformation,\n          docProperties: drawingOptions.docProperties,\n          outline: drawingOptions.outline\n        })\n      );\n    } else {\n      this.root.push(new Anchor({ mediaData: imageData, transform: imageData.transformation, drawingOptions }));\n    }\n  }\n}\nconst convertDataURIToBinary = (dataURI) => {\n  if (typeof atob === \"function\") {\n    const BASE64_MARKER = \";base64,\";\n    const base64Index = dataURI.indexOf(BASE64_MARKER);\n    const base64IndexWithOffset = base64Index === -1 ? 0 : base64Index + BASE64_MARKER.length;\n    return new Uint8Array(\n      atob(dataURI.substring(base64IndexWithOffset)).split(\"\").map((c) => c.charCodeAt(0))\n    );\n  } else {\n    const b = require(\"buffer\");\n    return new b.Buffer(dataURI, \"base64\");\n  }\n};\nconst standardizeData = (data) => typeof data === \"string\" ? convertDataURIToBinary(data) : data;\nconst createImageData = (options, key) => ({\n  data: standardizeData(options.data),\n  fileName: key,\n  transformation: {\n    pixels: {\n      x: Math.round(options.transformation.width),\n      y: Math.round(options.transformation.height)\n    },\n    emus: {\n      x: Math.round(options.transformation.width * 9525),\n      y: Math.round(options.transformation.height * 9525)\n    },\n    flip: options.transformation.flip,\n    rotation: options.transformation.rotation ? options.transformation.rotation * 6e4 : void 0\n  }\n});\nclass ImageRun extends Run {\n  constructor(options) {\n    super({});\n    __publicField(this, \"imageData\");\n    const hash2 = hashedId(options.data);\n    const key = `${hash2}.${options.type}`;\n    this.imageData = options.type === \"svg\" ? __spreadProps(__spreadValues({\n      type: options.type\n    }, createImageData(options, key)), {\n      fallback: __spreadValues({\n        type: options.fallback.type\n      }, createImageData(\n        __spreadProps(__spreadValues({}, options.fallback), {\n          transformation: options.transformation\n        }),\n        `${hashedId(options.fallback.data)}.${options.fallback.type}`\n      ))\n    }) : __spreadValues({\n      type: options.type\n    }, createImageData(options, key));\n    const drawing = new Drawing(this.imageData, {\n      floating: options.floating,\n      docProperties: options.altText,\n      outline: options.outline\n    });\n    this.root.push(drawing);\n  }\n  prepForXml(context) {\n    context.file.Media.addImage(this.imageData.fileName, this.imageData);\n    if (this.imageData.type === \"svg\") {\n      context.file.Media.addImage(this.imageData.fallback.fileName, this.imageData.fallback);\n    }\n    return super.prepForXml(context);\n  }\n}\nclass SequentialIdentifierInstruction extends XmlComponent {\n  constructor(identifier) {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(`SEQ ${identifier}`);\n  }\n}\nclass SequentialIdentifier extends Run {\n  constructor(identifier) {\n    super({});\n    this.root.push(new Begin(true));\n    this.root.push(new SequentialIdentifierInstruction(identifier));\n    this.root.push(new Separate());\n    this.root.push(new End());\n  }\n}\nclass FldSimpleAttrs extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { instr: \"w:instr\" });\n  }\n}\nclass SimpleField extends XmlComponent {\n  constructor(instruction, cachedValue) {\n    super(\"w:fldSimple\");\n    this.root.push(new FldSimpleAttrs({ instr: instruction }));\n    if (cachedValue !== void 0) {\n      this.root.push(new TextRun(cachedValue));\n    }\n  }\n}\nclass SimpleMailMergeField extends SimpleField {\n  constructor(fieldName) {\n    super(` MERGEFIELD ${fieldName} `, `${fieldName}`);\n  }\n}\nclass RelationshipsAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns\"\n    });\n  }\n}\nclass RelationshipAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"Id\",\n      type: \"Type\",\n      target: \"Target\",\n      targetMode: \"TargetMode\"\n    });\n  }\n}\nconst TargetModeType = {\n  EXTERNAL: \"External\"\n};\nclass Relationship extends XmlComponent {\n  constructor(id, type2, target, targetMode) {\n    super(\"Relationship\");\n    this.root.push(\n      new RelationshipAttributes({\n        id,\n        type: type2,\n        target,\n        targetMode\n      })\n    );\n  }\n}\nclass Relationships extends XmlComponent {\n  constructor() {\n    super(\"Relationships\");\n    this.root.push(\n      new RelationshipsAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/package/2006/relationships\"\n      })\n    );\n  }\n  createRelationship(id, type2, target, targetMode) {\n    const relationship = new Relationship(`rId${id}`, type2, target, targetMode);\n    this.root.push(relationship);\n    return relationship;\n  }\n  get RelationshipCount() {\n    return this.root.length - 1;\n  }\n}\nclass CommentAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { id: \"w:id\", initials: \"w:initials\", author: \"w:author\", date: \"w:date\" });\n  }\n}\nclass CommentRangeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { id: \"w:id\" });\n  }\n}\nclass RootCommentsAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      \"xmlns:cx\": \"xmlns:cx\",\n      \"xmlns:cx1\": \"xmlns:cx1\",\n      \"xmlns:cx2\": \"xmlns:cx2\",\n      \"xmlns:cx3\": \"xmlns:cx3\",\n      \"xmlns:cx4\": \"xmlns:cx4\",\n      \"xmlns:cx5\": \"xmlns:cx5\",\n      \"xmlns:cx6\": \"xmlns:cx6\",\n      \"xmlns:cx7\": \"xmlns:cx7\",\n      \"xmlns:cx8\": \"xmlns:cx8\",\n      \"xmlns:mc\": \"xmlns:mc\",\n      \"xmlns:aink\": \"xmlns:aink\",\n      \"xmlns:am3d\": \"xmlns:am3d\",\n      \"xmlns:o\": \"xmlns:o\",\n      \"xmlns:r\": \"xmlns:r\",\n      \"xmlns:m\": \"xmlns:m\",\n      \"xmlns:v\": \"xmlns:v\",\n      \"xmlns:wp14\": \"xmlns:wp14\",\n      \"xmlns:wp\": \"xmlns:wp\",\n      \"xmlns:w10\": \"xmlns:w10\",\n      \"xmlns:w\": \"xmlns:w\",\n      \"xmlns:w14\": \"xmlns:w14\",\n      \"xmlns:w15\": \"xmlns:w15\",\n      \"xmlns:w16cex\": \"xmlns:w16cex\",\n      \"xmlns:w16cid\": \"xmlns:w16cid\",\n      \"xmlns:w16\": \"xmlns:w16\",\n      \"xmlns:w16sdtdh\": \"xmlns:w16sdtdh\",\n      \"xmlns:w16se\": \"xmlns:w16se\",\n      \"xmlns:wpg\": \"xmlns:wpg\",\n      \"xmlns:wpi\": \"xmlns:wpi\",\n      \"xmlns:wne\": \"xmlns:wne\",\n      \"xmlns:wps\": \"xmlns:wps\"\n    });\n  }\n}\nclass CommentRangeStart extends XmlComponent {\n  constructor(id) {\n    super(\"w:commentRangeStart\");\n    this.root.push(new CommentRangeAttributes({ id }));\n  }\n}\nclass CommentRangeEnd extends XmlComponent {\n  constructor(id) {\n    super(\"w:commentRangeEnd\");\n    this.root.push(new CommentRangeAttributes({ id }));\n  }\n}\nclass CommentReference extends XmlComponent {\n  constructor(id) {\n    super(\"w:commentReference\");\n    this.root.push(new CommentRangeAttributes({ id }));\n  }\n}\nclass Comment extends XmlComponent {\n  constructor({ id, initials, author, date = /* @__PURE__ */ new Date(), children }) {\n    super(\"w:comment\");\n    this.root.push(\n      new CommentAttributes({\n        id,\n        initials,\n        author,\n        date: date.toISOString()\n      })\n    );\n    for (const child of children) {\n      this.root.push(child);\n    }\n  }\n}\nclass Comments extends XmlComponent {\n  constructor({ children }) {\n    super(\"w:comments\");\n    __publicField(this, \"relationships\");\n    this.root.push(\n      new RootCommentsAttributes({\n        \"xmlns:cx\": \"http://schemas.microsoft.com/office/drawing/2014/chartex\",\n        \"xmlns:cx1\": \"http://schemas.microsoft.com/office/drawing/2015/9/8/chartex\",\n        \"xmlns:cx2\": \"http://schemas.microsoft.com/office/drawing/2015/10/21/chartex\",\n        \"xmlns:cx3\": \"http://schemas.microsoft.com/office/drawing/2016/5/9/chartex\",\n        \"xmlns:cx4\": \"http://schemas.microsoft.com/office/drawing/2016/5/10/chartex\",\n        \"xmlns:cx5\": \"http://schemas.microsoft.com/office/drawing/2016/5/11/chartex\",\n        \"xmlns:cx6\": \"http://schemas.microsoft.com/office/drawing/2016/5/12/chartex\",\n        \"xmlns:cx7\": \"http://schemas.microsoft.com/office/drawing/2016/5/13/chartex\",\n        \"xmlns:cx8\": \"http://schemas.microsoft.com/office/drawing/2016/5/14/chartex\",\n        \"xmlns:mc\": \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n        \"xmlns:aink\": \"http://schemas.microsoft.com/office/drawing/2016/ink\",\n        \"xmlns:am3d\": \"http://schemas.microsoft.com/office/drawing/2017/model3d\",\n        \"xmlns:o\": \"urn:schemas-microsoft-com:office:office\",\n        \"xmlns:r\": \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n        \"xmlns:m\": \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n        \"xmlns:v\": \"urn:schemas-microsoft-com:vml\",\n        \"xmlns:wp14\": \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n        \"xmlns:wp\": \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n        \"xmlns:w10\": \"urn:schemas-microsoft-com:office:word\",\n        \"xmlns:w\": \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n        \"xmlns:w14\": \"http://schemas.microsoft.com/office/word/2010/wordml\",\n        \"xmlns:w15\": \"http://schemas.microsoft.com/office/word/2012/wordml\",\n        \"xmlns:w16cex\": \"http://schemas.microsoft.com/office/word/2018/wordml/cex\",\n        \"xmlns:w16cid\": \"http://schemas.microsoft.com/office/word/2016/wordml/cid\",\n        \"xmlns:w16\": \"http://schemas.microsoft.com/office/word/2018/wordml\",\n        \"xmlns:w16sdtdh\": \"http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash\",\n        \"xmlns:w16se\": \"http://schemas.microsoft.com/office/word/2015/wordml/symex\",\n        \"xmlns:wpg\": \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n        \"xmlns:wpi\": \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n        \"xmlns:wne\": \"http://schemas.microsoft.com/office/word/2006/wordml\",\n        \"xmlns:wps\": \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\"\n      })\n    );\n    for (const child of children) {\n      this.root.push(new Comment(child));\n    }\n    this.relationships = new Relationships();\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n}\nclass NoBreakHyphen extends EmptyElement {\n  constructor() {\n    super(\"w:noBreakHyphen\");\n  }\n}\nclass SoftHyphen extends EmptyElement {\n  constructor() {\n    super(\"w:softHyphen\");\n  }\n}\nclass DayShort extends EmptyElement {\n  constructor() {\n    super(\"w:dayShort\");\n  }\n}\nclass MonthShort extends EmptyElement {\n  constructor() {\n    super(\"w:monthShort\");\n  }\n}\nclass YearShort extends EmptyElement {\n  constructor() {\n    super(\"w:yearShort\");\n  }\n}\nclass DayLong extends EmptyElement {\n  constructor() {\n    super(\"w:dayLong\");\n  }\n}\nclass MonthLong extends EmptyElement {\n  constructor() {\n    super(\"w:monthLong\");\n  }\n}\nclass YearLong extends EmptyElement {\n  constructor() {\n    super(\"w:yearLong\");\n  }\n}\nclass AnnotationReference extends EmptyElement {\n  constructor() {\n    super(\"w:annotationRef\");\n  }\n}\nclass FootnoteReferenceElement extends EmptyElement {\n  constructor() {\n    super(\"w:footnoteRef\");\n  }\n}\nclass EndnoteReference extends EmptyElement {\n  constructor() {\n    super(\"w:endnoteRef\");\n  }\n}\nclass Separator extends EmptyElement {\n  constructor() {\n    super(\"w:separator\");\n  }\n}\nclass ContinuationSeparator extends EmptyElement {\n  constructor() {\n    super(\"w:continuationSeparator\");\n  }\n}\nclass PageNumberElement extends EmptyElement {\n  constructor() {\n    super(\"w:pgNum\");\n  }\n}\nclass CarriageReturn extends EmptyElement {\n  constructor() {\n    super(\"w:cr\");\n  }\n}\nclass Tab extends EmptyElement {\n  constructor() {\n    super(\"w:tab\");\n  }\n}\nclass LastRenderedPageBreak extends EmptyElement {\n  constructor() {\n    super(\"w:lastRenderedPageBreak\");\n  }\n}\nconst PositionalTabAlignment = {\n  LEFT: \"left\",\n  CENTER: \"center\",\n  RIGHT: \"right\"\n};\nconst PositionalTabRelativeTo = {\n  MARGIN: \"margin\",\n  INDENT: \"indent\"\n};\nconst PositionalTabLeader = {\n  NONE: \"none\",\n  DOT: \"dot\",\n  HYPHEN: \"hyphen\",\n  UNDERSCORE: \"underscore\",\n  MIDDLE_DOT: \"middleDot\"\n};\nclass PositionalTab extends XmlComponent {\n  constructor(options) {\n    super(\"w:ptab\");\n    this.root.push(\n      new NextAttributeComponent({\n        alignment: {\n          key: \"w:alignment\",\n          value: options.alignment\n        },\n        relativeTo: {\n          key: \"w:relativeTo\",\n          value: options.relativeTo\n        },\n        leader: {\n          key: \"w:leader\",\n          value: options.leader\n        }\n      })\n    );\n  }\n}\nconst BreakType = {\n  COLUMN: \"column\",\n  PAGE: \"page\"\n  // textWrapping breaks are the default and already exposed via the \"Run\" class\n};\nclass Break2 extends XmlComponent {\n  constructor(type2) {\n    super(\"w:br\");\n    this.root.push(\n      new Attributes({\n        type: type2\n      })\n    );\n  }\n}\nclass PageBreak extends Run {\n  constructor() {\n    super({});\n    this.root.push(new Break2(BreakType.PAGE));\n  }\n}\nclass ColumnBreak extends Run {\n  constructor() {\n    super({});\n    this.root.push(new Break2(BreakType.COLUMN));\n  }\n}\nclass PageBreakBefore extends XmlComponent {\n  constructor() {\n    super(\"w:pageBreakBefore\");\n  }\n}\nconst LineRuleType = {\n  AT_LEAST: \"atLeast\",\n  EXACTLY: \"exactly\",\n  EXACT: \"exact\",\n  AUTO: \"auto\"\n};\nclass SpacingAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      after: \"w:after\",\n      before: \"w:before\",\n      line: \"w:line\",\n      lineRule: \"w:lineRule\",\n      beforeAutoSpacing: \"w:beforeAutospacing\",\n      afterAutoSpacing: \"w:afterAutospacing\"\n    });\n  }\n}\nclass Spacing extends XmlComponent {\n  constructor(options) {\n    super(\"w:spacing\");\n    this.root.push(new SpacingAttributes(options));\n  }\n}\nconst HeadingLevel = {\n  HEADING_1: \"Heading1\",\n  HEADING_2: \"Heading2\",\n  HEADING_3: \"Heading3\",\n  HEADING_4: \"Heading4\",\n  HEADING_5: \"Heading5\",\n  HEADING_6: \"Heading6\",\n  TITLE: \"Title\"\n};\nlet Style$1 = class Style extends XmlComponent {\n  constructor(styleId) {\n    super(\"w:pStyle\");\n    this.root.push(\n      new Attributes({\n        val: styleId\n      })\n    );\n  }\n};\nclass TabStop extends XmlComponent {\n  constructor(tabDefinitions) {\n    super(\"w:tabs\");\n    for (const tabDefinition of tabDefinitions) {\n      this.root.push(new TabStopItem(tabDefinition));\n    }\n  }\n}\nconst TabStopType = {\n  LEFT: \"left\",\n  RIGHT: \"right\",\n  CENTER: \"center\",\n  BAR: \"bar\",\n  CLEAR: \"clear\",\n  DECIMAL: \"decimal\",\n  END: \"end\",\n  NUM: \"num\",\n  START: \"start\"\n};\nconst LeaderType = {\n  DOT: \"dot\",\n  HYPHEN: \"hyphen\",\n  MIDDLE_DOT: \"middleDot\",\n  NONE: \"none\",\n  UNDERSCORE: \"underscore\"\n};\nconst TabStopPosition = {\n  MAX: 9026\n};\nclass TabAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\", pos: \"w:pos\", leader: \"w:leader\" });\n  }\n}\nclass TabStopItem extends XmlComponent {\n  constructor({ type: type2, position, leader }) {\n    super(\"w:tab\");\n    this.root.push(\n      new TabAttributes({\n        val: type2,\n        pos: position,\n        leader\n      })\n    );\n  }\n}\nclass NumberProperties extends XmlComponent {\n  constructor(numberId, indentLevel) {\n    super(\"w:numPr\");\n    this.root.push(new IndentLevel(indentLevel));\n    this.root.push(new NumberId(numberId));\n  }\n}\nclass IndentLevel extends XmlComponent {\n  constructor(level) {\n    super(\"w:ilvl\");\n    if (level > 9) {\n      throw new Error(\n        \"Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7\"\n      );\n    }\n    this.root.push(\n      new Attributes({\n        val: level\n      })\n    );\n  }\n}\nclass NumberId extends XmlComponent {\n  constructor(id) {\n    super(\"w:numId\");\n    this.root.push(\n      new Attributes({\n        val: typeof id === \"string\" ? `{${id}}` : id\n      })\n    );\n  }\n}\nclass FileChild extends XmlComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"fileChild\", Symbol());\n  }\n}\nclass HyperlinkAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"r:id\",\n      history: \"w:history\",\n      anchor: \"w:anchor\"\n    });\n  }\n}\nconst HyperlinkType = {\n  INTERNAL: \"INTERNAL\",\n  EXTERNAL: \"EXTERNAL\"\n};\nclass ConcreteHyperlink extends XmlComponent {\n  constructor(children, relationshipId, anchor) {\n    super(\"w:hyperlink\");\n    __publicField(this, \"linkId\");\n    this.linkId = relationshipId;\n    const props = {\n      history: 1,\n      anchor: anchor ? anchor : void 0,\n      id: !anchor ? `rId${this.linkId}` : void 0\n    };\n    const attributes = new HyperlinkAttributes(props);\n    this.root.push(attributes);\n    children.forEach((child) => {\n      this.root.push(child);\n    });\n  }\n}\nclass InternalHyperlink extends ConcreteHyperlink {\n  constructor(options) {\n    super(options.children, uniqueId(), options.anchor);\n  }\n}\nclass ExternalHyperlink extends XmlComponent {\n  constructor(options) {\n    super(\"w:externalHyperlink\");\n    this.options = options;\n  }\n}\nclass BookmarkStartAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"w:id\",\n      name: \"w:name\"\n    });\n  }\n}\nclass BookmarkEndAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"w:id\"\n    });\n  }\n}\nclass Bookmark {\n  constructor(options) {\n    __publicField(this, \"bookmarkUniqueNumericId\", bookmarkUniqueNumericIdGen());\n    __publicField(this, \"start\");\n    __publicField(this, \"children\");\n    __publicField(this, \"end\");\n    const linkId = this.bookmarkUniqueNumericId();\n    this.start = new BookmarkStart(options.id, linkId);\n    this.children = options.children;\n    this.end = new BookmarkEnd(linkId);\n  }\n}\nclass BookmarkStart extends XmlComponent {\n  constructor(id, linkId) {\n    super(\"w:bookmarkStart\");\n    const attributes = new BookmarkStartAttributes({\n      name: id,\n      id: linkId\n    });\n    this.root.push(attributes);\n  }\n}\nclass BookmarkEnd extends XmlComponent {\n  constructor(linkId) {\n    super(\"w:bookmarkEnd\");\n    const attributes = new BookmarkEndAttributes({\n      id: linkId\n    });\n    this.root.push(attributes);\n  }\n}\nclass OutlineLevel extends XmlComponent {\n  constructor(level) {\n    super(\"w:outlineLvl\");\n    this.level = level;\n    this.root.push(\n      new Attributes({\n        val: level\n      })\n    );\n  }\n}\nclass PageReferenceFieldInstruction extends XmlComponent {\n  constructor(bookmarkId, options = {}) {\n    super(\"w:instrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    let instruction = `PAGEREF ${bookmarkId}`;\n    if (options.hyperlink) {\n      instruction = `${instruction} \\\\h`;\n    }\n    if (options.useRelativePosition) {\n      instruction = `${instruction} \\\\p`;\n    }\n    this.root.push(instruction);\n  }\n}\nclass PageReference extends Run {\n  constructor(bookmarkId, options = {}) {\n    super({\n      children: [new Begin(true), new PageReferenceFieldInstruction(bookmarkId, options), new End()]\n    });\n  }\n}\nconst VerticalAlignTable = {\n  TOP: \"top\",\n  CENTER: \"center\",\n  BOTTOM: \"bottom\"\n};\nconst VerticalAlignSection = __spreadProps(__spreadValues({}, VerticalAlignTable), {\n  BOTH: \"both\"\n});\nconst VerticalAlign2 = VerticalAlignSection;\nclass VerticalAlignAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      verticalAlign: \"w:val\"\n    });\n  }\n}\nclass VerticalAlignElement extends XmlComponent {\n  constructor(value) {\n    super(\"w:vAlign\");\n    this.root.push(new VerticalAlignAttributes({ verticalAlign: value }));\n  }\n}\nclass Columns extends XmlComponent {\n  constructor({ space, count, separate, equalWidth, children }) {\n    super(\"w:cols\");\n    this.root.push(\n      new NextAttributeComponent({\n        space: { key: \"w:space\", value: space === void 0 ? void 0 : twipsMeasureValue(space) },\n        count: { key: \"w:num\", value: count === void 0 ? void 0 : decimalNumber(count) },\n        separate: { key: \"w:sep\", value: separate },\n        equalWidth: { key: \"w:equalWidth\", value: equalWidth }\n      })\n    );\n    if (!equalWidth && children) {\n      children.forEach((column) => this.addChildElement(column));\n    }\n  }\n}\nconst DocumentGridType = {\n  /**\n   * Specifies that no document grid shall be applied to the contents of the current section in the document.\n   */\n  DEFAULT: \"default\",\n  /**\n   * Specifies that the parent section shall have additional line pitch added to each line within it (as specified on the <docGrid> element (2.6.5)) in order to maintain the specified number of lines per page.\n   */\n  LINES: \"lines\",\n  /**\n   * Specifies that the parent section shall have both the additional line pitch and character pitch added to each line and character within it (as specified on the <docGrid> element (2.6.5)) in order to maintain a specific number of lines per page and characters per line.\n   *\n   * When this value is set, the input specified via the user interface may be allowed in exact number of line/character pitch units. */\n  LINES_AND_CHARS: \"linesAndChars\",\n  /**\n   * Specifies that the parent section shall have both the additional line pitch and character pitch added to each line and character within it (as specified on the <docGrid> element (2.6.5)) in order to maintain a specific number of lines per page and characters per line.\n   *\n   * When this value is set, the input specified via the user interface may be restricted to the number of lines per page and characters per line, with the consumer or producer translating this information based on the current font data to get the resulting line and character pitch values\n   */\n  SNAP_TO_CHARS: \"snapToChars\"\n};\nconst createDocumentGrid = ({ type: type2, linePitch, charSpace }) => new BuilderElement({\n  name: \"w:docGrid\",\n  attributes: {\n    type: { key: \"w:type\", value: type2 },\n    linePitch: { key: \"w:linePitch\", value: decimalNumber(linePitch) },\n    charSpace: { key: \"w:charSpace\", value: charSpace ? decimalNumber(charSpace) : void 0 }\n  }\n});\nconst HeaderFooterReferenceType = {\n  /** Specifies that this header or footer shall appear on every page in this section which is not overridden with a specific `even` or `first` page header/footer. In a section with all three types specified, this type shall be used on all odd numbered pages (counting from the `first` page in the section, not the section numbering). */\n  DEFAULT: \"default\",\n  /** Specifies that this header or footer shall appear on the first page in this section. The appearance of this header or footer is contingent on the setting of the `titlePg` element (2.10.6). */\n  FIRST: \"first\",\n  /** Specifies that this header or footer shall appear on all even numbered pages in this section (counting from the first page in the section, not the section numbering). The appearance of this header or footer is contingent on the setting of the `evenAndOddHeaders` element (2.10.1). */\n  EVEN: \"even\"\n};\nclass FooterReferenceAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      type: \"w:type\",\n      id: \"r:id\"\n    });\n  }\n}\nconst HeaderFooterType = {\n  HEADER: \"w:headerReference\",\n  FOOTER: \"w:footerReference\"\n};\nclass HeaderFooterReference extends XmlComponent {\n  constructor(type2, options) {\n    super(type2);\n    this.root.push(\n      new FooterReferenceAttributes({\n        type: options.type || HeaderFooterReferenceType.DEFAULT,\n        id: `rId${options.id}`\n      })\n    );\n  }\n}\nconst LineNumberRestartFormat = {\n  /**\n   * ## Restart Line Numbering on Each Page\n   *\n   * Specifies that line numbering for the parent section shall restart to the starting value whenever a new page is displayed.\n   */\n  NEW_PAGE: \"newPage\",\n  /**\n   * ## Restart Line Numbering for Each Section\n   *\n   * Specifies that line numbering for the parent section shall restart to the starting value whenever the parent begins.\n   */\n  NEW_SECTION: \"newSection\",\n  /**\n   * ## Continue Line Numbering From Previous Section\n   *\n   * Specifies that line numbering for the parent section shall continue from the line numbering from the end of the previous section, if any.\n   */\n  CONTINUOUS: \"continuous\"\n};\nconst createLineNumberType = ({ countBy, start, restart, distance }) => new BuilderElement({\n  name: \"w:lnNumType\",\n  attributes: {\n    countBy: { key: \"w:countBy\", value: countBy === void 0 ? void 0 : decimalNumber(countBy) },\n    start: { key: \"w:start\", value: start === void 0 ? void 0 : decimalNumber(start) },\n    restart: { key: \"w:restart\", value: restart },\n    distance: {\n      key: \"w:distance\",\n      value: distance === void 0 ? void 0 : twipsMeasureValue(distance)\n    }\n  }\n});\nconst PageBorderDisplay = {\n  ALL_PAGES: \"allPages\",\n  FIRST_PAGE: \"firstPage\",\n  NOT_FIRST_PAGE: \"notFirstPage\"\n};\nconst PageBorderOffsetFrom = {\n  PAGE: \"page\",\n  TEXT: \"text\"\n};\nconst PageBorderZOrder = {\n  BACK: \"back\",\n  FRONT: \"front\"\n};\nclass PageBordersAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      display: \"w:display\",\n      offsetFrom: \"w:offsetFrom\",\n      zOrder: \"w:zOrder\"\n    });\n  }\n}\nclass PageBorders extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:pgBorders\");\n    if (!options) {\n      return this;\n    }\n    if (options.pageBorders) {\n      this.root.push(\n        new PageBordersAttributes({\n          display: options.pageBorders.display,\n          offsetFrom: options.pageBorders.offsetFrom,\n          zOrder: options.pageBorders.zOrder\n        })\n      );\n    } else {\n      this.root.push(new PageBordersAttributes({}));\n    }\n    if (options.pageBorderTop) {\n      this.root.push(new BorderElement(\"w:top\", options.pageBorderTop));\n    }\n    if (options.pageBorderLeft) {\n      this.root.push(new BorderElement(\"w:left\", options.pageBorderLeft));\n    }\n    if (options.pageBorderBottom) {\n      this.root.push(new BorderElement(\"w:bottom\", options.pageBorderBottom));\n    }\n    if (options.pageBorderRight) {\n      this.root.push(new BorderElement(\"w:right\", options.pageBorderRight));\n    }\n  }\n}\nclass PageMargin extends XmlComponent {\n  constructor(top, right, bottom, left, header, footer, gutter) {\n    super(\"w:pgMar\");\n    this.root.push(\n      new NextAttributeComponent({\n        top: { key: \"w:top\", value: signedTwipsMeasureValue(top) },\n        right: { key: \"w:right\", value: twipsMeasureValue(right) },\n        bottom: { key: \"w:bottom\", value: signedTwipsMeasureValue(bottom) },\n        left: { key: \"w:left\", value: twipsMeasureValue(left) },\n        header: { key: \"w:header\", value: twipsMeasureValue(header) },\n        footer: { key: \"w:footer\", value: twipsMeasureValue(footer) },\n        gutter: { key: \"w:gutter\", value: twipsMeasureValue(gutter) }\n      })\n    );\n  }\n}\nconst PageNumberSeparator = {\n  HYPHEN: \"hyphen\",\n  PERIOD: \"period\",\n  COLON: \"colon\",\n  EM_DASH: \"emDash\",\n  EN_DASH: \"endash\"\n};\nclass PageNumberTypeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      start: \"w:start\",\n      formatType: \"w:fmt\",\n      separator: \"w:chapSep\"\n    });\n  }\n}\nclass PageNumberType extends XmlComponent {\n  constructor({ start, formatType, separator }) {\n    super(\"w:pgNumType\");\n    this.root.push(\n      new PageNumberTypeAttributes({\n        start: start === void 0 ? void 0 : decimalNumber(start),\n        formatType,\n        separator\n      })\n    );\n  }\n}\nconst PageOrientation = {\n  /**\n   * ## Portrait Mode\n   *\n   * Specifies that pages in this section shall be printed in portrait mode.\n   */\n  PORTRAIT: \"portrait\",\n  /**\n   * ## Landscape Mode\n   *\n   * Specifies that pages in this section shall be printed in landscape mode, which prints the page contents with a 90 degree rotation with respect to the normal page orientation.\n   */\n  LANDSCAPE: \"landscape\"\n};\nconst createPageSize = ({ width, height, orientation, code }) => {\n  const widthTwips = twipsMeasureValue(width);\n  const heightTwips = twipsMeasureValue(height);\n  return new BuilderElement({\n    name: \"w:pgSz\",\n    attributes: {\n      width: { key: \"w:w\", value: orientation === PageOrientation.LANDSCAPE ? heightTwips : widthTwips },\n      height: { key: \"w:h\", value: orientation === PageOrientation.LANDSCAPE ? widthTwips : heightTwips },\n      orientation: { key: \"w:orient\", value: orientation },\n      code: { key: \"w:code\", value: code }\n    }\n  });\n};\nconst PageTextDirectionType = {\n  LEFT_TO_RIGHT_TOP_TO_BOTTOM: \"lrTb\",\n  TOP_TO_BOTTOM_RIGHT_TO_LEFT: \"tbRl\"\n};\nclass PageTextDirectionAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass PageTextDirection extends XmlComponent {\n  constructor(value) {\n    super(\"w:textDirection\");\n    this.root.push(\n      new PageTextDirectionAttributes({\n        val: value\n      })\n    );\n  }\n}\nconst SectionType = {\n  NEXT_PAGE: \"nextPage\",\n  NEXT_COLUMN: \"nextColumn\",\n  CONTINUOUS: \"continuous\",\n  EVEN_PAGE: \"evenPage\",\n  ODD_PAGE: \"oddPage\"\n};\nclass SectionTypeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      val: \"w:val\"\n    });\n  }\n}\nclass Type extends XmlComponent {\n  constructor(value) {\n    super(\"w:type\");\n    this.root.push(new SectionTypeAttributes({ val: value }));\n  }\n}\nconst sectionMarginDefaults = {\n  TOP: 1440,\n  RIGHT: 1440,\n  BOTTOM: 1440,\n  LEFT: 1440,\n  HEADER: 708,\n  FOOTER: 708,\n  GUTTER: 0\n};\nconst sectionPageSizeDefaults = {\n  WIDTH: 11906,\n  HEIGHT: 16838,\n  ORIENTATION: PageOrientation.PORTRAIT\n};\nclass SectionProperties extends XmlComponent {\n  constructor({\n    page: {\n      size: {\n        width = sectionPageSizeDefaults.WIDTH,\n        height = sectionPageSizeDefaults.HEIGHT,\n        orientation = sectionPageSizeDefaults.ORIENTATION\n      } = {},\n      margin: {\n        top = sectionMarginDefaults.TOP,\n        right = sectionMarginDefaults.RIGHT,\n        bottom = sectionMarginDefaults.BOTTOM,\n        left = sectionMarginDefaults.LEFT,\n        header = sectionMarginDefaults.HEADER,\n        footer = sectionMarginDefaults.FOOTER,\n        gutter = sectionMarginDefaults.GUTTER\n      } = {},\n      pageNumbers = {},\n      borders,\n      textDirection\n    } = {},\n    grid: { linePitch = 360, charSpace, type: gridType } = {},\n    headerWrapperGroup = {},\n    footerWrapperGroup = {},\n    lineNumbers,\n    titlePage,\n    verticalAlign,\n    column,\n    type: type2\n  } = {}) {\n    super(\"w:sectPr\");\n    this.addHeaderFooterGroup(HeaderFooterType.HEADER, headerWrapperGroup);\n    this.addHeaderFooterGroup(HeaderFooterType.FOOTER, footerWrapperGroup);\n    if (type2) {\n      this.root.push(new Type(type2));\n    }\n    this.root.push(createPageSize({ width, height, orientation }));\n    this.root.push(new PageMargin(top, right, bottom, left, header, footer, gutter));\n    if (borders) {\n      this.root.push(new PageBorders(borders));\n    }\n    if (lineNumbers) {\n      this.root.push(createLineNumberType(lineNumbers));\n    }\n    this.root.push(new PageNumberType(pageNumbers));\n    if (column) {\n      this.root.push(new Columns(column));\n    }\n    if (verticalAlign) {\n      this.root.push(new VerticalAlignElement(verticalAlign));\n    }\n    if (titlePage !== void 0) {\n      this.root.push(new OnOffElement(\"w:titlePg\", titlePage));\n    }\n    if (textDirection) {\n      this.root.push(new PageTextDirection(textDirection));\n    }\n    this.root.push(createDocumentGrid({ linePitch, charSpace, type: gridType }));\n  }\n  addHeaderFooterGroup(type2, group) {\n    if (group.default) {\n      this.root.push(\n        new HeaderFooterReference(type2, {\n          type: HeaderFooterReferenceType.DEFAULT,\n          id: group.default.View.ReferenceId\n        })\n      );\n    }\n    if (group.first) {\n      this.root.push(\n        new HeaderFooterReference(type2, {\n          type: HeaderFooterReferenceType.FIRST,\n          id: group.first.View.ReferenceId\n        })\n      );\n    }\n    if (group.even) {\n      this.root.push(\n        new HeaderFooterReference(type2, {\n          type: HeaderFooterReferenceType.EVEN,\n          id: group.even.View.ReferenceId\n        })\n      );\n    }\n  }\n}\nclass Body extends XmlComponent {\n  constructor() {\n    super(\"w:body\");\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"sections\", []);\n  }\n  /**\n   * Adds new section properties.\n   * Note: Previous section is created in paragraph after the current element, and then new section will be added.\n   * The spec says:\n   *  - section element should be in the last paragraph of the section\n   *  - last section should be direct child of body\n   *\n   * @param options new section options\n   */\n  addSection(options) {\n    const currentSection = this.sections.pop();\n    this.root.push(this.createSectionParagraph(currentSection));\n    this.sections.push(new SectionProperties(options));\n  }\n  prepForXml(context) {\n    if (this.sections.length === 1) {\n      this.root.splice(0, 1);\n      this.root.push(this.sections.pop());\n    }\n    return super.prepForXml(context);\n  }\n  push(component) {\n    this.root.push(component);\n  }\n  createSectionParagraph(section) {\n    const paragraph = new Paragraph({});\n    const properties = new ParagraphProperties({});\n    properties.push(section);\n    paragraph.addChildElement(properties);\n    return paragraph;\n  }\n}\nclass Column extends XmlComponent {\n  constructor({ width, space }) {\n    super(\"w:col\");\n    this.root.push(\n      new NextAttributeComponent({\n        width: { key: \"w:w\", value: twipsMeasureValue(width) },\n        space: { key: \"w:space\", value: space === void 0 ? void 0 : twipsMeasureValue(space) }\n      })\n    );\n  }\n}\nconst DocumentAttributeNamespaces = {\n  wpc: \"http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas\",\n  mc: \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n  o: \"urn:schemas-microsoft-com:office:office\",\n  r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n  m: \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n  v: \"urn:schemas-microsoft-com:vml\",\n  wp14: \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n  wp: \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n  w10: \"urn:schemas-microsoft-com:office:word\",\n  w: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n  w14: \"http://schemas.microsoft.com/office/word/2010/wordml\",\n  w15: \"http://schemas.microsoft.com/office/word/2012/wordml\",\n  wpg: \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n  wpi: \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n  wne: \"http://schemas.microsoft.com/office/word/2006/wordml\",\n  wps: \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\",\n  cp: \"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\",\n  dc: \"http://purl.org/dc/elements/1.1/\",\n  dcterms: \"http://purl.org/dc/terms/\",\n  dcmitype: \"http://purl.org/dc/dcmitype/\",\n  xsi: \"http://www.w3.org/2001/XMLSchema-instance\",\n  cx: \"http://schemas.microsoft.com/office/drawing/2014/chartex\",\n  cx1: \"http://schemas.microsoft.com/office/drawing/2015/9/8/chartex\",\n  cx2: \"http://schemas.microsoft.com/office/drawing/2015/10/21/chartex\",\n  cx3: \"http://schemas.microsoft.com/office/drawing/2016/5/9/chartex\",\n  cx4: \"http://schemas.microsoft.com/office/drawing/2016/5/10/chartex\",\n  cx5: \"http://schemas.microsoft.com/office/drawing/2016/5/11/chartex\",\n  cx6: \"http://schemas.microsoft.com/office/drawing/2016/5/12/chartex\",\n  cx7: \"http://schemas.microsoft.com/office/drawing/2016/5/13/chartex\",\n  cx8: \"http://schemas.microsoft.com/office/drawing/2016/5/14/chartex\",\n  aink: \"http://schemas.microsoft.com/office/drawing/2016/ink\",\n  am3d: \"http://schemas.microsoft.com/office/drawing/2017/model3d\",\n  w16cex: \"http://schemas.microsoft.com/office/word/2018/wordml/cex\",\n  w16cid: \"http://schemas.microsoft.com/office/word/2016/wordml/cid\",\n  w16: \"http://schemas.microsoft.com/office/word/2018/wordml\",\n  w16sdtdh: \"http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash\",\n  w16se: \"http://schemas.microsoft.com/office/word/2015/wordml/symex\"\n};\nclass DocumentAttributes extends XmlAttributeComponent {\n  constructor(ns, Ignorable) {\n    super(__spreadValues({ Ignorable }, Object.fromEntries(ns.map((n) => [n, DocumentAttributeNamespaces[n]]))));\n    __publicField(this, \"xmlKeys\", __spreadValues({\n      Ignorable: \"mc:Ignorable\"\n    }, Object.fromEntries(Object.keys(DocumentAttributeNamespaces).map((key) => [key, `xmlns:${key}`]))));\n  }\n}\nclass DocumentBackgroundAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      color: \"w:color\",\n      themeColor: \"w:themeColor\",\n      themeShade: \"w:themeShade\",\n      themeTint: \"w:themeTint\"\n    });\n  }\n}\nclass DocumentBackground extends XmlComponent {\n  constructor(options) {\n    super(\"w:background\");\n    this.root.push(\n      new DocumentBackgroundAttributes({\n        color: options.color === void 0 ? void 0 : hexColorValue(options.color),\n        themeColor: options.themeColor,\n        themeShade: options.themeShade === void 0 ? void 0 : uCharHexNumber(options.themeShade),\n        themeTint: options.themeTint === void 0 ? void 0 : uCharHexNumber(options.themeTint)\n      })\n    );\n  }\n}\nclass Document extends XmlComponent {\n  constructor(options) {\n    super(\"w:document\");\n    __publicField(this, \"body\");\n    this.root.push(\n      new DocumentAttributes(\n        [\n          \"wpc\",\n          \"mc\",\n          \"o\",\n          \"r\",\n          \"m\",\n          \"v\",\n          \"wp14\",\n          \"wp\",\n          \"w10\",\n          \"w\",\n          \"w14\",\n          \"w15\",\n          \"wpg\",\n          \"wpi\",\n          \"wne\",\n          \"wps\",\n          \"cx\",\n          \"cx1\",\n          \"cx2\",\n          \"cx3\",\n          \"cx4\",\n          \"cx5\",\n          \"cx6\",\n          \"cx7\",\n          \"cx8\",\n          \"aink\",\n          \"am3d\",\n          \"w16cex\",\n          \"w16cid\",\n          \"w16\",\n          \"w16sdtdh\",\n          \"w16se\"\n        ],\n        \"w14 w15 wp14\"\n      )\n    );\n    this.body = new Body();\n    if (options.background) {\n      this.root.push(new DocumentBackground(options.background));\n    }\n    this.root.push(this.body);\n  }\n  add(item) {\n    this.body.push(item);\n    return this;\n  }\n  get Body() {\n    return this.body;\n  }\n}\nclass DocumentWrapper {\n  constructor(options) {\n    __publicField(this, \"document\");\n    __publicField(this, \"relationships\");\n    this.document = new Document(options);\n    this.relationships = new Relationships();\n  }\n  get View() {\n    return this.document;\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n}\nclass WordWrapAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass WordWrap extends XmlComponent {\n  constructor() {\n    super(\"w:wordWrap\");\n    this.root.push(new WordWrapAttributes({ val: 0 }));\n  }\n}\nconst DropCapType = {\n  NONE: \"none\",\n  DROP: \"drop\",\n  MARGIN: \"margin\"\n};\nconst FrameAnchorType = {\n  MARGIN: \"margin\",\n  PAGE: \"page\",\n  TEXT: \"text\"\n};\nconst FrameWrap = {\n  AROUND: \"around\",\n  AUTO: \"auto\",\n  NONE: \"none\",\n  NOT_BESIDE: \"notBeside\",\n  THROUGH: \"through\",\n  TIGHT: \"tight\"\n};\nconst createFrameProperties = (options) => {\n  var _a, _b;\n  return new BuilderElement({\n    name: \"w:framePr\",\n    attributes: {\n      anchorLock: {\n        key: \"w:anchorLock\",\n        value: options.anchorLock\n      },\n      dropCap: {\n        key: \"w:dropCap\",\n        value: options.dropCap\n      },\n      width: {\n        key: \"w:w\",\n        value: options.width\n      },\n      height: {\n        key: \"w:h\",\n        value: options.height\n      },\n      x: {\n        key: \"w:x\",\n        value: options.position ? options.position.x : void 0\n      },\n      y: {\n        key: \"w:y\",\n        value: options.position ? options.position.y : void 0\n      },\n      anchorHorizontal: {\n        key: \"w:hAnchor\",\n        value: options.anchor.horizontal\n      },\n      anchorVertical: {\n        key: \"w:vAnchor\",\n        value: options.anchor.vertical\n      },\n      spaceHorizontal: {\n        key: \"w:hSpace\",\n        value: (_a = options.space) == null ? void 0 : _a.horizontal\n      },\n      spaceVertical: {\n        key: \"w:vSpace\",\n        value: (_b = options.space) == null ? void 0 : _b.vertical\n      },\n      rule: {\n        key: \"w:hRule\",\n        value: options.rule\n      },\n      alignmentX: {\n        key: \"w:xAlign\",\n        value: options.alignment ? options.alignment.x : void 0\n      },\n      alignmentY: {\n        key: \"w:yAlign\",\n        value: options.alignment ? options.alignment.y : void 0\n      },\n      lines: {\n        key: \"w:lines\",\n        value: options.lines\n      },\n      wrap: {\n        key: \"w:wrap\",\n        value: options.wrap\n      }\n    }\n  });\n};\nclass ParagraphProperties extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    var _a, _b;\n    super(\"w:pPr\");\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"numberingReferences\", []);\n    if (!options) {\n      return this;\n    }\n    if (options.heading) {\n      this.push(new Style$1(options.heading));\n    }\n    if (options.bullet) {\n      this.push(new Style$1(\"ListParagraph\"));\n    }\n    if (options.numbering) {\n      if (!options.style && !options.heading) {\n        if (!options.numbering.custom) {\n          this.push(new Style$1(\"ListParagraph\"));\n        }\n      }\n    }\n    if (options.style) {\n      this.push(new Style$1(options.style));\n    }\n    if (options.keepNext !== void 0) {\n      this.push(new OnOffElement(\"w:keepNext\", options.keepNext));\n    }\n    if (options.keepLines !== void 0) {\n      this.push(new OnOffElement(\"w:keepLines\", options.keepLines));\n    }\n    if (options.pageBreakBefore) {\n      this.push(new PageBreakBefore());\n    }\n    if (options.frame) {\n      this.push(createFrameProperties(options.frame));\n    }\n    if (options.widowControl !== void 0) {\n      this.push(new OnOffElement(\"w:widowControl\", options.widowControl));\n    }\n    if (options.bullet) {\n      this.push(new NumberProperties(1, options.bullet.level));\n    }\n    if (options.numbering) {\n      this.numberingReferences.push({\n        reference: options.numbering.reference,\n        instance: (_a = options.numbering.instance) != null ? _a : 0\n      });\n      this.push(new NumberProperties(`${options.numbering.reference}-${(_b = options.numbering.instance) != null ? _b : 0}`, options.numbering.level));\n    } else if (options.numbering === false) {\n      this.push(new NumberProperties(0, 0));\n    }\n    if (options.border) {\n      this.push(new Border(options.border));\n    }\n    if (options.thematicBreak) {\n      this.push(new ThematicBreak());\n    }\n    if (options.shading) {\n      this.push(new Shading(options.shading));\n    }\n    if (options.wordWrap) {\n      this.push(new WordWrap());\n    }\n    if (options.overflowPunctuation) {\n      this.push(new OnOffElement(\"w:overflowPunct\", options.overflowPunctuation));\n    }\n    const tabDefinitions = [\n      ...options.rightTabStop !== void 0 ? [{ type: TabStopType.RIGHT, position: options.rightTabStop }] : [],\n      ...options.tabStops ? options.tabStops : [],\n      ...options.leftTabStop !== void 0 ? [{ type: TabStopType.LEFT, position: options.leftTabStop }] : []\n    ];\n    if (tabDefinitions.length > 0) {\n      this.push(new TabStop(tabDefinitions));\n    }\n    if (options.bidirectional !== void 0) {\n      this.push(new OnOffElement(\"w:bidi\", options.bidirectional));\n    }\n    if (options.spacing) {\n      this.push(new Spacing(options.spacing));\n    }\n    if (options.indent) {\n      this.push(new Indent(options.indent));\n    }\n    if (options.contextualSpacing !== void 0) {\n      this.push(new OnOffElement(\"w:contextualSpacing\", options.contextualSpacing));\n    }\n    if (options.alignment) {\n      this.push(new Alignment(options.alignment));\n    }\n    if (options.outlineLevel !== void 0) {\n      this.push(new OutlineLevel(options.outlineLevel));\n    }\n    if (options.suppressLineNumbers !== void 0) {\n      this.push(new OnOffElement(\"w:suppressLineNumbers\", options.suppressLineNumbers));\n    }\n    if (options.autoSpaceEastAsianText !== void 0) {\n      this.push(new OnOffElement(\"w:autoSpaceDN\", options.autoSpaceEastAsianText));\n    }\n    if (options.run) {\n      this.push(new RunProperties(options.run));\n    }\n  }\n  push(item) {\n    this.root.push(item);\n  }\n  prepForXml(context) {\n    if (context.viewWrapper instanceof DocumentWrapper) {\n      for (const reference of this.numberingReferences) {\n        context.file.Numbering.createConcreteNumberingInstance(reference.reference, reference.instance);\n      }\n    }\n    return super.prepForXml(context);\n  }\n}\nclass Paragraph extends FileChild {\n  constructor(options) {\n    super(\"w:p\");\n    __publicField(this, \"properties\");\n    if (typeof options === \"string\") {\n      this.properties = new ParagraphProperties({});\n      this.root.push(this.properties);\n      this.root.push(new TextRun(options));\n      return this;\n    }\n    this.properties = new ParagraphProperties(options);\n    this.root.push(this.properties);\n    if (options.text) {\n      this.root.push(new TextRun(options.text));\n    }\n    if (options.children) {\n      for (const child of options.children) {\n        if (child instanceof Bookmark) {\n          this.root.push(child.start);\n          for (const textRun of child.children) {\n            this.root.push(textRun);\n          }\n          this.root.push(child.end);\n          continue;\n        }\n        this.root.push(child);\n      }\n    }\n  }\n  prepForXml(context) {\n    for (const element of this.root) {\n      if (element instanceof ExternalHyperlink) {\n        const index = this.root.indexOf(element);\n        const concreteHyperlink = new ConcreteHyperlink(element.options.children, uniqueId());\n        context.viewWrapper.Relationships.createRelationship(\n          concreteHyperlink.linkId,\n          \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\",\n          element.options.link,\n          TargetModeType.EXTERNAL\n        );\n        this.root[index] = concreteHyperlink;\n      }\n    }\n    return super.prepForXml(context);\n  }\n  addRunToFront(run) {\n    this.root.splice(1, 0, run);\n    return this;\n  }\n}\nlet Math$1 = class Math2 extends XmlComponent {\n  constructor(options) {\n    super(\"m:oMath\");\n    for (const child of options.children) {\n      this.root.push(child);\n    }\n  }\n};\nclass MathText extends XmlComponent {\n  constructor(text) {\n    super(\"m:t\");\n    this.root.push(text);\n  }\n}\nclass MathRun extends XmlComponent {\n  constructor(text) {\n    super(\"m:r\");\n    this.root.push(new MathText(text));\n  }\n}\nclass MathDenominator extends XmlComponent {\n  constructor(children) {\n    super(\"m:den\");\n    for (const child of children) {\n      this.root.push(child);\n    }\n  }\n}\nclass MathNumerator extends XmlComponent {\n  constructor(children) {\n    super(\"m:num\");\n    for (const child of children) {\n      this.root.push(child);\n    }\n  }\n}\nclass MathFraction extends XmlComponent {\n  constructor(options) {\n    super(\"m:f\");\n    this.root.push(new MathNumerator(options.numerator));\n    this.root.push(new MathDenominator(options.denominator));\n  }\n}\nconst createMathAccentCharacter = ({ accent }) => new BuilderElement({\n  name: \"m:chr\",\n  attributes: {\n    accent: { key: \"m:val\", value: accent }\n  }\n});\nconst createMathBase = ({ children }) => new BuilderElement({\n  name: \"m:e\",\n  children\n});\nconst createMathLimitLocation = ({ value }) => new BuilderElement({\n  name: \"m:limLoc\",\n  attributes: {\n    value: { key: \"m:val\", value: value || \"undOvr\" }\n  }\n});\nconst createMathSubScriptHide = () => new BuilderElement({\n  name: \"m:subHide\",\n  attributes: {\n    hide: { key: \"m:val\", value: 1 }\n  }\n});\nconst createMathSuperScriptHide = () => new BuilderElement({\n  name: \"m:supHide\",\n  attributes: {\n    hide: { key: \"m:val\", value: 1 }\n  }\n});\nconst createMathNAryProperties = ({\n  accent,\n  hasSuperScript,\n  hasSubScript,\n  limitLocationVal\n}) => new BuilderElement({\n  name: \"m:naryPr\",\n  children: [\n    ...!!accent ? [createMathAccentCharacter({ accent })] : [],\n    createMathLimitLocation({ value: limitLocationVal }),\n    ...!hasSuperScript ? [createMathSuperScriptHide()] : [],\n    ...!hasSubScript ? [createMathSubScriptHide()] : []\n  ]\n});\nconst createMathSubScriptElement = ({ children }) => new BuilderElement({\n  name: \"m:sub\",\n  children\n});\nconst createMathSuperScriptElement = ({ children }) => new BuilderElement({\n  name: \"m:sup\",\n  children\n});\nclass MathSum extends XmlComponent {\n  constructor(options) {\n    super(\"m:nary\");\n    this.root.push(\n      createMathNAryProperties({\n        accent: \"\",\n        hasSuperScript: !!options.superScript,\n        hasSubScript: !!options.subScript\n      })\n    );\n    if (!!options.subScript) {\n      this.root.push(createMathSubScriptElement({ children: options.subScript }));\n    }\n    if (!!options.superScript) {\n      this.root.push(createMathSuperScriptElement({ children: options.superScript }));\n    }\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathIntegral extends XmlComponent {\n  constructor(options) {\n    super(\"m:nary\");\n    this.root.push(\n      createMathNAryProperties({\n        accent: \"\",\n        hasSuperScript: !!options.superScript,\n        hasSubScript: !!options.subScript,\n        limitLocationVal: \"subSup\"\n      })\n    );\n    if (!!options.subScript) {\n      this.root.push(createMathSubScriptElement({ children: options.subScript }));\n    }\n    if (!!options.superScript) {\n      this.root.push(createMathSuperScriptElement({ children: options.superScript }));\n    }\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathLimit extends XmlComponent {\n  constructor(children) {\n    super(\"m:lim\");\n    for (const child of children) {\n      this.root.push(child);\n    }\n  }\n}\nclass MathLimitUpper extends XmlComponent {\n  constructor(options) {\n    super(\"m:limUpp\");\n    this.root.push(createMathBase({ children: options.children }));\n    this.root.push(new MathLimit(options.limit));\n  }\n}\nclass MathLimitLower extends XmlComponent {\n  constructor(options) {\n    super(\"m:limLow\");\n    this.root.push(createMathBase({ children: options.children }));\n    this.root.push(new MathLimit(options.limit));\n  }\n}\nconst createMathSuperScriptProperties = () => new BuilderElement({\n  name: \"m:sSupPr\"\n});\nclass MathSuperScript extends XmlComponent {\n  constructor(options) {\n    super(\"m:sSup\");\n    this.root.push(createMathSuperScriptProperties());\n    this.root.push(createMathBase({ children: options.children }));\n    this.root.push(createMathSuperScriptElement({ children: options.superScript }));\n  }\n}\nconst createMathSubScriptProperties = () => new BuilderElement({\n  name: \"m:sSubPr\"\n});\nclass MathSubScript extends XmlComponent {\n  constructor(options) {\n    super(\"m:sSub\");\n    this.root.push(createMathSubScriptProperties());\n    this.root.push(createMathBase({ children: options.children }));\n    this.root.push(createMathSubScriptElement({ children: options.subScript }));\n  }\n}\nconst createMathSubSuperScriptProperties = () => new BuilderElement({\n  name: \"m:sSubSupPr\"\n});\nclass MathSubSuperScript extends XmlComponent {\n  constructor(options) {\n    super(\"m:sSubSup\");\n    this.root.push(createMathSubSuperScriptProperties());\n    this.root.push(createMathBase({ children: options.children }));\n    this.root.push(createMathSubScriptElement({ children: options.subScript }));\n    this.root.push(createMathSuperScriptElement({ children: options.superScript }));\n  }\n}\nconst createMathPreSubSuperScriptProperties = () => new BuilderElement({\n  name: \"m:sPrePr\"\n});\nclass MathPreSubSuperScript extends BuilderElement {\n  constructor({ children, subScript, superScript }) {\n    super({\n      name: \"m:sPre\",\n      children: [\n        createMathPreSubSuperScriptProperties(),\n        createMathBase({ children }),\n        createMathSubScriptElement({ children: subScript }),\n        createMathSuperScriptElement({ children: superScript })\n      ]\n    });\n  }\n}\nconst WORKAROUND4 = \"\";\nclass MathDegree extends XmlComponent {\n  constructor(children) {\n    super(\"m:deg\");\n    if (!!children) {\n      for (const child of children) {\n        this.root.push(child);\n      }\n    }\n  }\n}\nclass MathDegreeHideAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { hide: \"m:val\" });\n  }\n}\nclass MathDegreeHide extends XmlComponent {\n  constructor() {\n    super(\"m:degHide\");\n    this.root.push(new MathDegreeHideAttributes({ hide: 1 }));\n  }\n}\nclass MathRadicalProperties extends XmlComponent {\n  constructor(hasDegree) {\n    super(\"m:radPr\");\n    if (!hasDegree) {\n      this.root.push(new MathDegreeHide());\n    }\n  }\n}\nclass MathRadical extends XmlComponent {\n  constructor(options) {\n    super(\"m:rad\");\n    this.root.push(new MathRadicalProperties(!!options.degree));\n    this.root.push(new MathDegree(options.degree));\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathFunctionName extends XmlComponent {\n  constructor(children) {\n    super(\"m:fName\");\n    for (const child of children) {\n      this.root.push(child);\n    }\n  }\n}\nclass MathFunctionProperties extends XmlComponent {\n  constructor() {\n    super(\"m:funcPr\");\n  }\n}\nclass MathFunction extends XmlComponent {\n  constructor(options) {\n    super(\"m:func\");\n    this.root.push(new MathFunctionProperties());\n    this.root.push(new MathFunctionName(options.name));\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nconst createMathBeginningCharacter = ({ character }) => new BuilderElement({\n  name: \"m:begChr\",\n  attributes: {\n    character: { key: \"m:val\", value: character }\n  }\n});\nconst createMathEndingCharacter = ({ character }) => new BuilderElement({\n  name: \"m:endChr\",\n  attributes: {\n    character: { key: \"m:val\", value: character }\n  }\n});\nconst createMathBracketProperties = ({ characters }) => new BuilderElement({\n  name: \"m:dPr\",\n  children: !!characters ? [\n    createMathBeginningCharacter({ character: characters.beginningCharacter }),\n    createMathEndingCharacter({ character: characters.endingCharacter })\n  ] : []\n});\nclass MathRoundBrackets extends XmlComponent {\n  constructor(options) {\n    super(\"m:d\");\n    this.root.push(createMathBracketProperties({}));\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathSquareBrackets extends XmlComponent {\n  constructor(options) {\n    super(\"m:d\");\n    this.root.push(\n      createMathBracketProperties({\n        characters: {\n          beginningCharacter: \"[\",\n          endingCharacter: \"]\"\n        }\n      })\n    );\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathCurlyBrackets extends XmlComponent {\n  constructor(options) {\n    super(\"m:d\");\n    this.root.push(\n      createMathBracketProperties({\n        characters: {\n          beginningCharacter: \"{\",\n          endingCharacter: \"}\"\n        }\n      })\n    );\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass MathAngledBrackets extends XmlComponent {\n  constructor(options) {\n    super(\"m:d\");\n    this.root.push(\n      createMathBracketProperties({\n        characters: {\n          beginningCharacter: \"\",\n          endingCharacter: \"\"\n        }\n      })\n    );\n    this.root.push(createMathBase({ children: options.children }));\n  }\n}\nclass TableGrid extends XmlComponent {\n  constructor(widths) {\n    super(\"w:tblGrid\");\n    for (const width of widths) {\n      this.root.push(new GridCol(width));\n    }\n  }\n}\nclass GridCol extends XmlComponent {\n  constructor(width) {\n    super(\"w:gridCol\");\n    if (width !== void 0) {\n      this.root.push(\n        new NextAttributeComponent({\n          width: { key: \"w:w\", value: twipsMeasureValue(width) }\n        })\n      );\n    }\n  }\n}\nconst TableCellMarginElementType = {\n  TABLE: \"w:tblCellMar\",\n  TABLE_CELL: \"w:tcMar\"\n};\nclass TableCellMargin extends IgnoreIfEmptyXmlComponent {\n  constructor(type2, { marginUnitType = WidthType.DXA, top, left, bottom, right }) {\n    super(type2);\n    if (top !== void 0) {\n      this.root.push(new TableWidthElement(\"w:top\", { type: marginUnitType, size: top }));\n    }\n    if (left !== void 0) {\n      this.root.push(new TableWidthElement(\"w:left\", { type: marginUnitType, size: left }));\n    }\n    if (bottom !== void 0) {\n      this.root.push(new TableWidthElement(\"w:bottom\", { type: marginUnitType, size: bottom }));\n    }\n    if (right !== void 0) {\n      this.root.push(new TableWidthElement(\"w:right\", { type: marginUnitType, size: right }));\n    }\n  }\n}\nconst WidthType = {\n  /** Auto. */\n  AUTO: \"auto\",\n  /** Value is in twentieths of a point */\n  DXA: \"dxa\",\n  /** No (empty) value. */\n  NIL: \"nil\",\n  /** Value is in percentage. */\n  PERCENTAGE: \"pct\"\n};\nclass TableWidthElement extends XmlComponent {\n  constructor(name, { type: type2 = WidthType.AUTO, size }) {\n    super(name);\n    let tableWidthValue = size;\n    if (type2 === WidthType.PERCENTAGE && typeof size === \"number\") {\n      tableWidthValue = `${size}%`;\n    }\n    this.root.push(\n      new NextAttributeComponent({\n        type: { key: \"w:type\", value: type2 },\n        size: { key: \"w:w\", value: measurementOrPercentValue(tableWidthValue) }\n      })\n    );\n  }\n}\nclass TableCellBorders extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:tcBorders\");\n    if (options.top) {\n      this.root.push(new BorderElement(\"w:top\", options.top));\n    }\n    if (options.start) {\n      this.root.push(new BorderElement(\"w:start\", options.start));\n    }\n    if (options.left) {\n      this.root.push(new BorderElement(\"w:left\", options.left));\n    }\n    if (options.bottom) {\n      this.root.push(new BorderElement(\"w:bottom\", options.bottom));\n    }\n    if (options.end) {\n      this.root.push(new BorderElement(\"w:end\", options.end));\n    }\n    if (options.right) {\n      this.root.push(new BorderElement(\"w:right\", options.right));\n    }\n  }\n}\nclass GridSpanAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass GridSpan extends XmlComponent {\n  constructor(value) {\n    super(\"w:gridSpan\");\n    this.root.push(\n      new GridSpanAttributes({\n        val: decimalNumber(value)\n      })\n    );\n  }\n}\nconst VerticalMergeType = {\n  /**\n   * Cell that is merged with upper one.\n   */\n  CONTINUE: \"continue\",\n  /**\n   * Cell that is starting the vertical merge.\n   */\n  RESTART: \"restart\"\n};\nclass VerticalMergeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass VerticalMerge extends XmlComponent {\n  constructor(value) {\n    super(\"w:vMerge\");\n    this.root.push(\n      new VerticalMergeAttributes({\n        val: value\n      })\n    );\n  }\n}\nconst TextDirection = {\n  BOTTOM_TO_TOP_LEFT_TO_RIGHT: \"btLr\",\n  LEFT_TO_RIGHT_TOP_TO_BOTTOM: \"lrTb\",\n  TOP_TO_BOTTOM_RIGHT_TO_LEFT: \"tbRl\"\n};\nclass TDirectionAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass TDirection extends XmlComponent {\n  constructor(value) {\n    super(\"w:textDirection\");\n    this.root.push(\n      new TDirectionAttributes({\n        val: value\n      })\n    );\n  }\n}\nclass TableCellProperties extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:tcPr\");\n    if (options.width) {\n      this.root.push(new TableWidthElement(\"w:tcW\", options.width));\n    }\n    if (options.columnSpan) {\n      this.root.push(new GridSpan(options.columnSpan));\n    }\n    if (options.verticalMerge) {\n      this.root.push(new VerticalMerge(options.verticalMerge));\n    } else if (options.rowSpan && options.rowSpan > 1) {\n      this.root.push(new VerticalMerge(VerticalMergeType.RESTART));\n    }\n    if (options.borders) {\n      this.root.push(new TableCellBorders(options.borders));\n    }\n    if (options.shading) {\n      this.root.push(new Shading(options.shading));\n    }\n    if (options.margins) {\n      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE_CELL, options.margins));\n    }\n    if (options.textDirection) {\n      this.root.push(new TDirection(options.textDirection));\n    }\n    if (options.verticalAlign) {\n      this.root.push(new VerticalAlignElement(options.verticalAlign));\n    }\n  }\n}\nclass TableCell extends XmlComponent {\n  constructor(options) {\n    super(\"w:tc\");\n    this.options = options;\n    this.root.push(new TableCellProperties(options));\n    for (const child of options.children) {\n      this.root.push(child);\n    }\n  }\n  prepForXml(context) {\n    if (!(this.root[this.root.length - 1] instanceof Paragraph)) {\n      this.root.push(new Paragraph({}));\n    }\n    return super.prepForXml(context);\n  }\n}\nconst NONE_BORDER = {\n  style: BorderStyle.NONE,\n  size: 0,\n  color: \"auto\"\n};\nconst DEFAULT_BORDER = {\n  style: BorderStyle.SINGLE,\n  size: 4,\n  color: \"auto\"\n};\nclass TableBorders extends XmlComponent {\n  constructor(options) {\n    super(\"w:tblBorders\");\n    if (options.top) {\n      this.root.push(new BorderElement(\"w:top\", options.top));\n    } else {\n      this.root.push(new BorderElement(\"w:top\", DEFAULT_BORDER));\n    }\n    if (options.left) {\n      this.root.push(new BorderElement(\"w:left\", options.left));\n    } else {\n      this.root.push(new BorderElement(\"w:left\", DEFAULT_BORDER));\n    }\n    if (options.bottom) {\n      this.root.push(new BorderElement(\"w:bottom\", options.bottom));\n    } else {\n      this.root.push(new BorderElement(\"w:bottom\", DEFAULT_BORDER));\n    }\n    if (options.right) {\n      this.root.push(new BorderElement(\"w:right\", options.right));\n    } else {\n      this.root.push(new BorderElement(\"w:right\", DEFAULT_BORDER));\n    }\n    if (options.insideHorizontal) {\n      this.root.push(new BorderElement(\"w:insideH\", options.insideHorizontal));\n    } else {\n      this.root.push(new BorderElement(\"w:insideH\", DEFAULT_BORDER));\n    }\n    if (options.insideVertical) {\n      this.root.push(new BorderElement(\"w:insideV\", options.insideVertical));\n    } else {\n      this.root.push(new BorderElement(\"w:insideV\", DEFAULT_BORDER));\n    }\n  }\n}\n__publicField(TableBorders, \"NONE\", {\n  top: NONE_BORDER,\n  bottom: NONE_BORDER,\n  left: NONE_BORDER,\n  right: NONE_BORDER,\n  insideHorizontal: NONE_BORDER,\n  insideVertical: NONE_BORDER\n});\nconst TableAnchorType = {\n  MARGIN: \"margin\",\n  PAGE: \"page\",\n  TEXT: \"text\"\n};\nconst RelativeHorizontalPosition = {\n  CENTER: \"center\",\n  INSIDE: \"inside\",\n  LEFT: \"left\",\n  OUTSIDE: \"outside\",\n  RIGHT: \"right\"\n};\nconst RelativeVerticalPosition = {\n  CENTER: \"center\",\n  INSIDE: \"inside\",\n  BOTTOM: \"bottom\",\n  OUTSIDE: \"outside\",\n  INLINE: \"inline\",\n  TOP: \"top\"\n};\nconst OverlapType = {\n  NEVER: \"never\",\n  OVERLAP: \"overlap\"\n};\nclass TableFloatProperties extends XmlComponent {\n  constructor({\n    horizontalAnchor,\n    verticalAnchor,\n    absoluteHorizontalPosition,\n    relativeHorizontalPosition,\n    absoluteVerticalPosition,\n    relativeVerticalPosition,\n    bottomFromText,\n    topFromText,\n    leftFromText,\n    rightFromText,\n    overlap\n  }) {\n    super(\"w:tblpPr\");\n    this.root.push(\n      new NextAttributeComponent({\n        leftFromText: {\n          key: \"w:leftFromText\",\n          value: leftFromText === void 0 ? void 0 : twipsMeasureValue(leftFromText)\n        },\n        rightFromText: {\n          key: \"w:rightFromText\",\n          value: rightFromText === void 0 ? void 0 : twipsMeasureValue(rightFromText)\n        },\n        topFromText: {\n          key: \"w:topFromText\",\n          value: topFromText === void 0 ? void 0 : twipsMeasureValue(topFromText)\n        },\n        bottomFromText: {\n          key: \"w:bottomFromText\",\n          value: bottomFromText === void 0 ? void 0 : twipsMeasureValue(bottomFromText)\n        },\n        absoluteHorizontalPosition: {\n          key: \"w:tblpX\",\n          value: absoluteHorizontalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteHorizontalPosition)\n        },\n        absoluteVerticalPosition: {\n          key: \"w:tblpY\",\n          value: absoluteVerticalPosition === void 0 ? void 0 : signedTwipsMeasureValue(absoluteVerticalPosition)\n        },\n        horizontalAnchor: {\n          key: \"w:horzAnchor\",\n          value: horizontalAnchor === void 0 ? void 0 : horizontalAnchor\n        },\n        relativeHorizontalPosition: {\n          key: \"w:tblpXSpec\",\n          value: relativeHorizontalPosition\n        },\n        relativeVerticalPosition: {\n          key: \"w:tblpYSpec\",\n          value: relativeVerticalPosition\n        },\n        verticalAnchor: {\n          key: \"w:vertAnchor\",\n          value: verticalAnchor\n        }\n      })\n    );\n    if (overlap) {\n      this.root.push(new StringEnumValueElement(\"w:tblOverlap\", overlap));\n    }\n  }\n}\nconst TableLayoutType = {\n  AUTOFIT: \"autofit\",\n  FIXED: \"fixed\"\n};\nclass TableLayoutAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { type: \"w:type\" });\n  }\n}\nclass TableLayout extends XmlComponent {\n  constructor(type2) {\n    super(\"w:tblLayout\");\n    this.root.push(new TableLayoutAttributes({ type: type2 }));\n  }\n}\nconst CellSpacingType = {\n  /** Value is in twentieths of a point */\n  DXA: \"dxa\"\n};\nclass TableCellSpacingElement extends XmlComponent {\n  constructor({ type: type2 = CellSpacingType.DXA, value }) {\n    super(\"w:tblCellSpacing\");\n    this.root.push(\n      new NextAttributeComponent({\n        type: { key: \"w:type\", value: type2 },\n        value: { key: \"w:w\", value: measurementOrPercentValue(value) }\n      })\n    );\n  }\n}\nclass TableProperties extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:tblPr\");\n    if (options.style) {\n      this.root.push(new StringValueElement(\"w:tblStyle\", options.style));\n    }\n    if (options.float) {\n      this.root.push(new TableFloatProperties(options.float));\n    }\n    if (options.visuallyRightToLeft !== void 0) {\n      this.root.push(new OnOffElement(\"w:bidiVisual\", options.visuallyRightToLeft));\n    }\n    if (options.width) {\n      this.root.push(new TableWidthElement(\"w:tblW\", options.width));\n    }\n    if (options.alignment) {\n      this.root.push(new Alignment(options.alignment));\n    }\n    if (options.indent) {\n      this.root.push(new TableWidthElement(\"w:tblInd\", options.indent));\n    }\n    if (options.borders) {\n      this.root.push(new TableBorders(options.borders));\n    }\n    if (options.shading) {\n      this.root.push(new Shading(options.shading));\n    }\n    if (options.layout) {\n      this.root.push(new TableLayout(options.layout));\n    }\n    if (options.cellMargin) {\n      this.root.push(new TableCellMargin(TableCellMarginElementType.TABLE, options.cellMargin));\n    }\n    if (options.cellSpacing) {\n      this.root.push(new TableCellSpacingElement(options.cellSpacing));\n    }\n  }\n}\nclass Table extends FileChild {\n  constructor({\n    rows,\n    width,\n    // eslint-disable-next-line functional/immutable-data\n    columnWidths = Array(Math.max(...rows.map((row) => row.CellCount))).fill(100),\n    margins,\n    indent,\n    float,\n    layout,\n    style,\n    borders,\n    alignment,\n    visuallyRightToLeft,\n    cellSpacing\n  }) {\n    super(\"w:tbl\");\n    this.root.push(\n      new TableProperties({\n        borders: borders != null ? borders : {},\n        width: width != null ? width : { size: 100 },\n        indent,\n        float,\n        layout,\n        style,\n        alignment,\n        cellMargin: margins,\n        visuallyRightToLeft,\n        cellSpacing\n      })\n    );\n    this.root.push(new TableGrid(columnWidths));\n    for (const row of rows) {\n      this.root.push(row);\n    }\n    rows.forEach((row, rowIndex) => {\n      if (rowIndex === rows.length - 1) {\n        return;\n      }\n      let columnIndex = 0;\n      row.cells.forEach((cell) => {\n        if (cell.options.rowSpan && cell.options.rowSpan > 1) {\n          const continueCell = new TableCell({\n            // the inserted CONTINUE cell has rowSpan, and will be handled when process the next row\n            rowSpan: cell.options.rowSpan - 1,\n            columnSpan: cell.options.columnSpan,\n            borders: cell.options.borders,\n            children: [],\n            verticalMerge: VerticalMergeType.CONTINUE\n          });\n          rows[rowIndex + 1].addCellToColumnIndex(continueCell, columnIndex);\n        }\n        columnIndex += cell.options.columnSpan || 1;\n      });\n    });\n  }\n}\nconst HeightRule = {\n  /** Height is determined based on the content, so value is ignored. */\n  AUTO: \"auto\",\n  /** At least the value specified */\n  ATLEAST: \"atLeast\",\n  /** Exactly the value specified */\n  EXACT: \"exact\"\n};\nclass TableRowHeightAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { value: \"w:val\", rule: \"w:hRule\" });\n  }\n}\nclass TableRowHeight extends XmlComponent {\n  constructor(value, rule) {\n    super(\"w:trHeight\");\n    this.root.push(\n      new TableRowHeightAttributes({\n        value: twipsMeasureValue(value),\n        rule\n      })\n    );\n  }\n}\nclass TableRowProperties extends IgnoreIfEmptyXmlComponent {\n  constructor(options) {\n    super(\"w:trPr\");\n    if (options.cantSplit !== void 0) {\n      this.root.push(new OnOffElement(\"w:cantSplit\", options.cantSplit));\n    }\n    if (options.tableHeader !== void 0) {\n      this.root.push(new OnOffElement(\"w:tblHeader\", options.tableHeader));\n    }\n    if (options.height) {\n      this.root.push(new TableRowHeight(options.height.value, options.height.rule));\n    }\n    if (options.cellSpacing) {\n      this.root.push(new TableCellSpacingElement(options.cellSpacing));\n    }\n  }\n}\nclass TableRow extends XmlComponent {\n  constructor(options) {\n    super(\"w:tr\");\n    this.options = options;\n    this.root.push(new TableRowProperties(options));\n    for (const child of options.children) {\n      this.root.push(child);\n    }\n  }\n  get CellCount() {\n    return this.options.children.length;\n  }\n  get cells() {\n    return this.root.filter((xmlComponent) => xmlComponent instanceof TableCell);\n  }\n  addCellToIndex(cell, index) {\n    this.root.splice(index + 1, 0, cell);\n  }\n  addCellToColumnIndex(cell, columnIndex) {\n    const rootIndex = this.columnIndexToRootIndex(columnIndex, true);\n    this.addCellToIndex(cell, rootIndex - 1);\n  }\n  rootIndexToColumnIndex(rootIndex) {\n    if (rootIndex < 1 || rootIndex >= this.root.length) {\n      throw new Error(`cell 'rootIndex' should between 1 to ${this.root.length - 1}`);\n    }\n    let colIdx = 0;\n    for (let rootIdx = 1; rootIdx < rootIndex; rootIdx++) {\n      const cell = this.root[rootIdx];\n      colIdx += cell.options.columnSpan || 1;\n    }\n    return colIdx;\n  }\n  columnIndexToRootIndex(columnIndex, allowEndNewCell = false) {\n    if (columnIndex < 0) {\n      throw new Error(`cell 'columnIndex' should not less than zero`);\n    }\n    let colIdx = 0;\n    let rootIdx = 1;\n    while (colIdx <= columnIndex) {\n      if (rootIdx >= this.root.length) {\n        if (allowEndNewCell) {\n          return this.root.length;\n        } else {\n          throw new Error(`cell 'columnIndex' should not great than ${colIdx - 1}`);\n        }\n      }\n      const cell = this.root[rootIdx];\n      rootIdx += 1;\n      colIdx += cell && cell.options.columnSpan || 1;\n    }\n    return rootIdx - 1;\n  }\n}\nclass AppPropertiesAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns\",\n      vt: \"xmlns:vt\"\n    });\n  }\n}\nclass AppProperties extends XmlComponent {\n  constructor() {\n    super(\"Properties\");\n    this.root.push(\n      new AppPropertiesAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\",\n        vt: \"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\"\n      })\n    );\n  }\n}\nclass ContentTypeAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns\"\n    });\n  }\n}\nclass DefaultAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      contentType: \"ContentType\",\n      extension: \"Extension\"\n    });\n  }\n}\nclass Default extends XmlComponent {\n  constructor(contentType, extension) {\n    super(\"Default\");\n    this.root.push(\n      new DefaultAttributes({\n        contentType,\n        extension\n      })\n    );\n  }\n}\nclass OverrideAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      contentType: \"ContentType\",\n      partName: \"PartName\"\n    });\n  }\n}\nclass Override extends XmlComponent {\n  constructor(contentType, partName) {\n    super(\"Override\");\n    this.root.push(\n      new OverrideAttributes({\n        contentType,\n        partName\n      })\n    );\n  }\n}\nclass ContentTypes extends XmlComponent {\n  constructor() {\n    super(\"Types\");\n    this.root.push(\n      new ContentTypeAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/package/2006/content-types\"\n      })\n    );\n    this.root.push(new Default(\"image/png\", \"png\"));\n    this.root.push(new Default(\"image/jpeg\", \"jpeg\"));\n    this.root.push(new Default(\"image/jpeg\", \"jpg\"));\n    this.root.push(new Default(\"image/bmp\", \"bmp\"));\n    this.root.push(new Default(\"image/gif\", \"gif\"));\n    this.root.push(new Default(\"image/svg+xml\", \"svg\"));\n    this.root.push(new Default(\"application/vnd.openxmlformats-package.relationships+xml\", \"rels\"));\n    this.root.push(new Default(\"application/xml\", \"xml\"));\n    this.root.push(new Default(\"application/vnd.openxmlformats-officedocument.obfuscatedFont\", \"odttf\"));\n    this.root.push(\n      new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\", \"/word/document.xml\")\n    );\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\", \"/word/styles.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-package.core-properties+xml\", \"/docProps/core.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.custom-properties+xml\", \"/docProps/custom.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.extended-properties+xml\", \"/docProps/app.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml\", \"/word/numbering.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\", \"/word/footnotes.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\", \"/word/settings.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\", \"/word/comments.xml\"));\n    this.root.push(new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml\", \"/word/fontTable.xml\"));\n  }\n  addFooter(index) {\n    this.root.push(\n      new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\", `/word/footer${index}.xml`)\n    );\n  }\n  addHeader(index) {\n    this.root.push(\n      new Override(\"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\", `/word/header${index}.xml`)\n    );\n  }\n}\nclass CoreProperties extends XmlComponent {\n  constructor(options) {\n    super(\"cp:coreProperties\");\n    this.root.push(new DocumentAttributes([\"cp\", \"dc\", \"dcterms\", \"dcmitype\", \"xsi\"]));\n    if (options.title) {\n      this.root.push(new StringContainer(\"dc:title\", options.title));\n    }\n    if (options.subject) {\n      this.root.push(new StringContainer(\"dc:subject\", options.subject));\n    }\n    if (options.creator) {\n      this.root.push(new StringContainer(\"dc:creator\", options.creator));\n    }\n    if (options.keywords) {\n      this.root.push(new StringContainer(\"cp:keywords\", options.keywords));\n    }\n    if (options.description) {\n      this.root.push(new StringContainer(\"dc:description\", options.description));\n    }\n    if (options.lastModifiedBy) {\n      this.root.push(new StringContainer(\"cp:lastModifiedBy\", options.lastModifiedBy));\n    }\n    if (options.revision) {\n      this.root.push(new StringContainer(\"cp:revision\", String(options.revision)));\n    }\n    this.root.push(new TimestampElement(\"dcterms:created\"));\n    this.root.push(new TimestampElement(\"dcterms:modified\"));\n  }\n}\nclass TimestampElementProperties extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { type: \"xsi:type\" });\n  }\n}\nclass TimestampElement extends XmlComponent {\n  constructor(name) {\n    super(name);\n    this.root.push(\n      new TimestampElementProperties({\n        type: \"dcterms:W3CDTF\"\n      })\n    );\n    this.root.push(dateTimeValue(/* @__PURE__ */ new Date()));\n  }\n}\nclass CustomPropertiesAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      xmlns: \"xmlns\",\n      vt: \"xmlns:vt\"\n    });\n  }\n}\nclass CustomPropertyAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      fmtid: \"fmtid\",\n      pid: \"pid\",\n      name: \"name\"\n    });\n  }\n}\nclass CustomProperty extends XmlComponent {\n  constructor(id, properties) {\n    super(\"property\");\n    this.root.push(\n      new CustomPropertyAttributes({\n        fmtid: \"{D5CDD505-2E9C-101B-9397-08002B2CF9AE}\",\n        pid: id.toString(),\n        name: properties.name\n      })\n    );\n    this.root.push(new CustomPropertyValue(properties.value));\n  }\n}\nclass CustomPropertyValue extends XmlComponent {\n  constructor(value) {\n    super(\"vt:lpwstr\");\n    this.root.push(value);\n  }\n}\nclass CustomProperties extends XmlComponent {\n  constructor(properties) {\n    super(\"Properties\");\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"nextId\");\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"properties\", []);\n    this.root.push(\n      new CustomPropertiesAttributes({\n        xmlns: \"http://schemas.openxmlformats.org/officeDocument/2006/custom-properties\",\n        vt: \"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\"\n      })\n    );\n    this.nextId = 2;\n    for (const property of properties) {\n      this.addCustomProperty(property);\n    }\n  }\n  prepForXml(context) {\n    this.properties.forEach((x) => this.root.push(x));\n    return super.prepForXml(context);\n  }\n  addCustomProperty(property) {\n    this.properties.push(new CustomProperty(this.nextId++, property));\n  }\n}\nconst CharacterSet = {\n  ANSI: \"00\",\n  DEFAULT: \"01\",\n  SYMBOL: \"02\",\n  MAC: \"4D\",\n  JIS: \"80\",\n  HANGUL: \"81\",\n  JOHAB: \"82\",\n  GB_2312: \"86\",\n  CHINESEBIG5: \"88\",\n  GREEK: \"A1\",\n  TURKISH: \"A2\",\n  VIETNAMESE: \"A3\",\n  HEBREW: \"B1\",\n  ARABIC: \"B2\",\n  BALTIC: \"BA\",\n  RUSSIAN: \"CC\",\n  THAI: \"DE\",\n  EASTEUROPE: \"EE\",\n  OEM: \"FF\"\n};\nconst createFontRelationship = ({ id, fontKey, subsetted }, name) => new BuilderElement({\n  name,\n  attributes: __spreadValues({\n    id: { key: \"r:id\", value: id }\n  }, fontKey ? { fontKey: { key: \"w:fontKey\", value: `{${fontKey}}` } } : {}),\n  children: [...subsetted ? [new OnOffElement(\"w:subsetted\", subsetted)] : []]\n});\nconst createFont = ({\n  name,\n  altName,\n  panose1,\n  charset,\n  family,\n  notTrueType,\n  pitch,\n  sig,\n  embedRegular,\n  embedBold,\n  embedItalic,\n  embedBoldItalic\n}) => (\n  // http://www.datypic.com/sc/ooxml/e-w_font-1.html\n  new BuilderElement({\n    name: \"w:font\",\n    attributes: {\n      name: { key: \"w:name\", value: name }\n    },\n    children: [\n      // http://www.datypic.com/sc/ooxml/e-w_altName-1.html\n      ...altName ? [createStringElement(\"w:altName\", altName)] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_panose1-1.html\n      ...panose1 ? [createStringElement(\"w:panose1\", panose1)] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_charset-1.html\n      ...charset ? [createStringElement(\"w:charset\", charset)] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_family-1.html\n      ...[createStringElement(\"w:family\", family)],\n      // http://www.datypic.com/sc/ooxml/e-w_notTrueType-1.html\n      ...notTrueType ? [new OnOffElement(\"w:notTrueType\", notTrueType)] : [],\n      ...[createStringElement(\"w:pitch\", pitch)],\n      // http://www.datypic.com/sc/ooxml/e-w_sig-1.html\n      ...sig ? [\n        new BuilderElement({\n          name: \"w:sig\",\n          attributes: {\n            usb0: { key: \"w:usb0\", value: sig.usb0 },\n            usb1: { key: \"w:usb1\", value: sig.usb1 },\n            usb2: { key: \"w:usb2\", value: sig.usb2 },\n            usb3: { key: \"w:usb3\", value: sig.usb3 },\n            csb0: { key: \"w:csb0\", value: sig.csb0 },\n            csb1: { key: \"w:csb1\", value: sig.csb1 }\n          }\n        })\n      ] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_embedRegular-1.html\n      ...embedRegular ? [createFontRelationship(embedRegular, \"w:embedRegular\")] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_embedBold-1.html\n      ...embedBold ? [createFontRelationship(embedBold, \"w:embedBold\")] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_embedItalic-1.html\n      ...embedItalic ? [createFontRelationship(embedItalic, \"w:embedItalic\")] : [],\n      // http://www.datypic.com/sc/ooxml/e-w_embedBoldItalic-1.html\n      ...embedBoldItalic ? [createFontRelationship(embedBoldItalic, \"w:embedBoldItalic\")] : []\n    ]\n  })\n);\nconst createRegularFont = ({\n  name,\n  index,\n  fontKey,\n  characterSet\n}) => createFont({\n  name,\n  sig: {\n    usb0: \"E0002AFF\",\n    usb1: \"C000247B\",\n    usb2: \"00000009\",\n    usb3: \"00000000\",\n    csb0: \"000001FF\",\n    csb1: \"00000000\"\n  },\n  charset: characterSet,\n  family: \"auto\",\n  pitch: \"variable\",\n  embedRegular: {\n    fontKey,\n    id: `rId${index}`\n  }\n});\nconst createFontTable = (fonts) => (\n  // https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_Font_topic_ID0ERNCU.html\n  // http://www.datypic.com/sc/ooxml/e-w_fonts.html\n  new BuilderElement({\n    name: \"w:fonts\",\n    attributes: {\n      mc: { key: \"xmlns:mc\", value: \"http://schemas.openxmlformats.org/markup-compatibility/2006\" },\n      r: { key: \"xmlns:r\", value: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" },\n      w: { key: \"xmlns:w\", value: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\" },\n      w14: { key: \"xmlns:w14\", value: \"http://schemas.microsoft.com/office/word/2010/wordml\" },\n      w15: { key: \"xmlns:w15\", value: \"http://schemas.microsoft.com/office/word/2012/wordml\" },\n      w16cex: { key: \"xmlns:w16cex\", value: \"http://schemas.microsoft.com/office/word/2018/wordml/cex\" },\n      w16cid: { key: \"xmlns:w16cid\", value: \"http://schemas.microsoft.com/office/word/2016/wordml/cid\" },\n      w16: { key: \"xmlns:w16\", value: \"http://schemas.microsoft.com/office/word/2018/wordml\" },\n      w16sdtdh: { key: \"xmlns:w16sdtdh\", value: \"http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash\" },\n      w16se: { key: \"xmlns:w16se\", value: \"http://schemas.microsoft.com/office/word/2015/wordml/symex\" },\n      Ignorable: { key: \"mc:Ignorable\", value: \"w14 w15 w16se w16cid w16 w16cex w16sdtdh\" }\n    },\n    children: fonts.map(\n      (font, i) => createRegularFont({\n        name: font.name,\n        index: i + 1,\n        fontKey: font.fontKey\n      })\n    )\n  })\n);\nclass FontWrapper {\n  constructor(options) {\n    __publicField(this, \"fontTable\");\n    __publicField(this, \"relationships\");\n    __publicField(this, \"fontOptionsWithKey\", []);\n    this.options = options;\n    this.fontOptionsWithKey = options.map((o) => __spreadProps(__spreadValues({}, o), { fontKey: uniqueUuid() }));\n    this.fontTable = createFontTable(this.fontOptionsWithKey);\n    this.relationships = new Relationships();\n    for (let i = 0; i < options.length; i++) {\n      this.relationships.createRelationship(\n        i + 1,\n        \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/font\",\n        `fonts/${options[i].name}.odttf`\n      );\n    }\n  }\n  get View() {\n    return this.fontTable;\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n}\nclass FooterAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      wpc: \"xmlns:wpc\",\n      mc: \"xmlns:mc\",\n      o: \"xmlns:o\",\n      r: \"xmlns:r\",\n      m: \"xmlns:m\",\n      v: \"xmlns:v\",\n      wp14: \"xmlns:wp14\",\n      wp: \"xmlns:wp\",\n      w10: \"xmlns:w10\",\n      w: \"xmlns:w\",\n      w14: \"xmlns:w14\",\n      w15: \"xmlns:w15\",\n      wpg: \"xmlns:wpg\",\n      wpi: \"xmlns:wpi\",\n      wne: \"xmlns:wne\",\n      wps: \"xmlns:wps\",\n      cp: \"xmlns:cp\",\n      dc: \"xmlns:dc\",\n      dcterms: \"xmlns:dcterms\",\n      dcmitype: \"xmlns:dcmitype\",\n      xsi: \"xmlns:xsi\",\n      type: \"xsi:type\"\n    });\n  }\n}\nlet Footer$1 = class Footer extends InitializableXmlComponent {\n  constructor(referenceNumber, initContent) {\n    super(\"w:ftr\", initContent);\n    __publicField(this, \"refId\");\n    this.refId = referenceNumber;\n    if (!initContent) {\n      this.root.push(\n        new FooterAttributes({\n          wpc: \"http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas\",\n          mc: \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n          o: \"urn:schemas-microsoft-com:office:office\",\n          r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n          m: \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n          v: \"urn:schemas-microsoft-com:vml\",\n          wp14: \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n          wp: \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n          w10: \"urn:schemas-microsoft-com:office:word\",\n          w: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n          w14: \"http://schemas.microsoft.com/office/word/2010/wordml\",\n          w15: \"http://schemas.microsoft.com/office/word/2012/wordml\",\n          wpg: \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n          wpi: \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n          wne: \"http://schemas.microsoft.com/office/word/2006/wordml\",\n          wps: \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\"\n        })\n      );\n    }\n  }\n  get ReferenceId() {\n    return this.refId;\n  }\n  add(item) {\n    this.root.push(item);\n  }\n};\nclass FooterWrapper {\n  constructor(media, referenceId, initContent) {\n    __publicField(this, \"footer\");\n    __publicField(this, \"relationships\");\n    this.media = media;\n    this.footer = new Footer$1(referenceId, initContent);\n    this.relationships = new Relationships();\n  }\n  add(item) {\n    this.footer.add(item);\n  }\n  addChildElement(childElement) {\n    this.footer.addChildElement(childElement);\n  }\n  get View() {\n    return this.footer;\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n  get Media() {\n    return this.media;\n  }\n}\nclass FootnoteAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      type: \"w:type\",\n      id: \"w:id\"\n    });\n  }\n}\nclass FootnoteRef extends XmlComponent {\n  constructor() {\n    super(\"w:footnoteRef\");\n  }\n}\nclass FootnoteRefRun extends Run {\n  constructor() {\n    super({\n      style: \"FootnoteReference\"\n    });\n    this.root.push(new FootnoteRef());\n  }\n}\nconst FootnoteType = {\n  SEPERATOR: \"separator\",\n  CONTINUATION_SEPERATOR: \"continuationSeparator\"\n};\nclass Footnote extends XmlComponent {\n  constructor(options) {\n    super(\"w:footnote\");\n    this.root.push(\n      new FootnoteAttributes({\n        type: options.type,\n        id: options.id\n      })\n    );\n    for (let i = 0; i < options.children.length; i++) {\n      const child = options.children[i];\n      if (i === 0) {\n        child.addRunToFront(new FootnoteRefRun());\n      }\n      this.root.push(child);\n    }\n  }\n}\nclass ContinuationSeperator extends XmlComponent {\n  constructor() {\n    super(\"w:continuationSeparator\");\n  }\n}\nclass ContinuationSeperatorRun extends Run {\n  constructor() {\n    super({});\n    this.root.push(new ContinuationSeperator());\n  }\n}\nclass Seperator extends XmlComponent {\n  constructor() {\n    super(\"w:separator\");\n  }\n}\nclass SeperatorRun extends Run {\n  constructor() {\n    super({});\n    this.root.push(new Seperator());\n  }\n}\nclass FootnotesAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      wpc: \"xmlns:wpc\",\n      mc: \"xmlns:mc\",\n      o: \"xmlns:o\",\n      r: \"xmlns:r\",\n      m: \"xmlns:m\",\n      v: \"xmlns:v\",\n      wp14: \"xmlns:wp14\",\n      wp: \"xmlns:wp\",\n      w10: \"xmlns:w10\",\n      w: \"xmlns:w\",\n      w14: \"xmlns:w14\",\n      w15: \"xmlns:w15\",\n      wpg: \"xmlns:wpg\",\n      wpi: \"xmlns:wpi\",\n      wne: \"xmlns:wne\",\n      wps: \"xmlns:wps\",\n      Ignorable: \"mc:Ignorable\"\n    });\n  }\n}\nclass FootNotes extends XmlComponent {\n  constructor() {\n    super(\"w:footnotes\");\n    this.root.push(\n      new FootnotesAttributes({\n        wpc: \"http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas\",\n        mc: \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n        o: \"urn:schemas-microsoft-com:office:office\",\n        r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n        m: \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n        v: \"urn:schemas-microsoft-com:vml\",\n        wp14: \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n        wp: \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n        w10: \"urn:schemas-microsoft-com:office:word\",\n        w: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n        w14: \"http://schemas.microsoft.com/office/word/2010/wordml\",\n        w15: \"http://schemas.microsoft.com/office/word/2012/wordml\",\n        wpg: \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n        wpi: \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n        wne: \"http://schemas.microsoft.com/office/word/2006/wordml\",\n        wps: \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\",\n        Ignorable: \"w14 w15 wp14\"\n      })\n    );\n    const begin = new Footnote({\n      id: -1,\n      type: FootnoteType.SEPERATOR,\n      children: [\n        new Paragraph({\n          spacing: {\n            after: 0,\n            line: 240,\n            lineRule: LineRuleType.AUTO\n          },\n          children: [new SeperatorRun()]\n        })\n      ]\n    });\n    this.root.push(begin);\n    const spacing = new Footnote({\n      id: 0,\n      type: FootnoteType.CONTINUATION_SEPERATOR,\n      children: [\n        new Paragraph({\n          spacing: {\n            after: 0,\n            line: 240,\n            lineRule: LineRuleType.AUTO\n          },\n          children: [new ContinuationSeperatorRun()]\n        })\n      ]\n    });\n    this.root.push(spacing);\n  }\n  createFootNote(id, paragraph) {\n    const footnote = new Footnote({\n      id,\n      children: paragraph\n    });\n    this.root.push(footnote);\n  }\n}\nclass FootnotesWrapper {\n  constructor() {\n    __publicField(this, \"footnotess\");\n    __publicField(this, \"relationships\");\n    this.footnotess = new FootNotes();\n    this.relationships = new Relationships();\n  }\n  get View() {\n    return this.footnotess;\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n}\nclass HeaderAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      wpc: \"xmlns:wpc\",\n      mc: \"xmlns:mc\",\n      o: \"xmlns:o\",\n      r: \"xmlns:r\",\n      m: \"xmlns:m\",\n      v: \"xmlns:v\",\n      wp14: \"xmlns:wp14\",\n      wp: \"xmlns:wp\",\n      w10: \"xmlns:w10\",\n      w: \"xmlns:w\",\n      w14: \"xmlns:w14\",\n      w15: \"xmlns:w15\",\n      wpg: \"xmlns:wpg\",\n      wpi: \"xmlns:wpi\",\n      wne: \"xmlns:wne\",\n      wps: \"xmlns:wps\",\n      cp: \"xmlns:cp\",\n      dc: \"xmlns:dc\",\n      dcterms: \"xmlns:dcterms\",\n      dcmitype: \"xmlns:dcmitype\",\n      xsi: \"xmlns:xsi\",\n      type: \"xsi:type\",\n      cx: \"xmlns:cx\",\n      cx1: \"xmlns:cx1\",\n      cx2: \"xmlns:cx2\",\n      cx3: \"xmlns:cx3\",\n      cx4: \"xmlns:cx4\",\n      cx5: \"xmlns:cx5\",\n      cx6: \"xmlns:cx6\",\n      cx7: \"xmlns:cx7\",\n      cx8: \"xmlns:cx8\",\n      w16cid: \"xmlns:w16cid\",\n      w16se: \"xmlns:w16se\"\n    });\n  }\n}\nlet Header$1 = class Header extends InitializableXmlComponent {\n  constructor(referenceNumber, initContent) {\n    super(\"w:hdr\", initContent);\n    __publicField(this, \"refId\");\n    this.refId = referenceNumber;\n    if (!initContent) {\n      this.root.push(\n        new HeaderAttributes({\n          wpc: \"http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas\",\n          mc: \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n          o: \"urn:schemas-microsoft-com:office:office\",\n          r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n          m: \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n          v: \"urn:schemas-microsoft-com:vml\",\n          wp14: \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n          wp: \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n          w10: \"urn:schemas-microsoft-com:office:word\",\n          w: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n          w14: \"http://schemas.microsoft.com/office/word/2010/wordml\",\n          w15: \"http://schemas.microsoft.com/office/word/2012/wordml\",\n          wpg: \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n          wpi: \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n          wne: \"http://schemas.microsoft.com/office/word/2006/wordml\",\n          wps: \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\",\n          cx: \"http://schemas.microsoft.com/office/drawing/2014/chartex\",\n          cx1: \"http://schemas.microsoft.com/office/drawing/2015/9/8/chartex\",\n          cx2: \"http://schemas.microsoft.com/office/drawing/2015/10/21/chartex\",\n          cx3: \"http://schemas.microsoft.com/office/drawing/2016/5/9/chartex\",\n          cx4: \"http://schemas.microsoft.com/office/drawing/2016/5/10/chartex\",\n          cx5: \"http://schemas.microsoft.com/office/drawing/2016/5/11/chartex\",\n          cx6: \"http://schemas.microsoft.com/office/drawing/2016/5/12/chartex\",\n          cx7: \"http://schemas.microsoft.com/office/drawing/2016/5/13/chartex\",\n          cx8: \"http://schemas.microsoft.com/office/drawing/2016/5/14/chartex\",\n          w16cid: \"http://schemas.microsoft.com/office/word/2016/wordml/cid\",\n          w16se: \"http://schemas.microsoft.com/office/word/2015/wordml/symex\"\n        })\n      );\n    }\n  }\n  get ReferenceId() {\n    return this.refId;\n  }\n  add(item) {\n    this.root.push(item);\n  }\n};\nclass HeaderWrapper {\n  constructor(media, referenceId, initContent) {\n    __publicField(this, \"header\");\n    __publicField(this, \"relationships\");\n    this.media = media;\n    this.header = new Header$1(referenceId, initContent);\n    this.relationships = new Relationships();\n  }\n  add(item) {\n    this.header.add(item);\n    return this;\n  }\n  addChildElement(childElement) {\n    this.header.addChildElement(childElement);\n  }\n  get View() {\n    return this.header;\n  }\n  get Relationships() {\n    return this.relationships;\n  }\n  get Media() {\n    return this.media;\n  }\n}\nclass Media {\n  constructor() {\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"map\");\n    this.map = /* @__PURE__ */ new Map();\n  }\n  addImage(key, mediaData) {\n    this.map.set(key, mediaData);\n  }\n  get Array() {\n    return Array.from(this.map.values());\n  }\n}\nconst WORKAROUND2 = \"\";\nconst LevelFormat = {\n  DECIMAL: \"decimal\",\n  UPPER_ROMAN: \"upperRoman\",\n  LOWER_ROMAN: \"lowerRoman\",\n  UPPER_LETTER: \"upperLetter\",\n  LOWER_LETTER: \"lowerLetter\",\n  ORDINAL: \"ordinal\",\n  CARDINAL_TEXT: \"cardinalText\",\n  ORDINAL_TEXT: \"ordinalText\",\n  HEX: \"hex\",\n  CHICAGO: \"chicago\",\n  IDEOGRAPH__DIGITAL: \"ideographDigital\",\n  JAPANESE_COUNTING: \"japaneseCounting\",\n  AIUEO: \"aiueo\",\n  IROHA: \"iroha\",\n  DECIMAL_FULL_WIDTH: \"decimalFullWidth\",\n  DECIMAL_HALF_WIDTH: \"decimalHalfWidth\",\n  JAPANESE_LEGAL: \"japaneseLegal\",\n  JAPANESE_DIGITAL_TEN_THOUSAND: \"japaneseDigitalTenThousand\",\n  DECIMAL_ENCLOSED_CIRCLE: \"decimalEnclosedCircle\",\n  DECIMAL_FULL_WIDTH2: \"decimalFullWidth2\",\n  AIUEO_FULL_WIDTH: \"aiueoFullWidth\",\n  IROHA_FULL_WIDTH: \"irohaFullWidth\",\n  DECIMAL_ZERO: \"decimalZero\",\n  BULLET: \"bullet\",\n  GANADA: \"ganada\",\n  CHOSUNG: \"chosung\",\n  DECIMAL_ENCLOSED_FULLSTOP: \"decimalEnclosedFullstop\",\n  DECIMAL_ENCLOSED_PARENTHESES: \"decimalEnclosedParen\",\n  DECIMAL_ENCLOSED_CIRCLE_CHINESE: \"decimalEnclosedCircleChinese\",\n  IDEOGRAPH_ENCLOSED_CIRCLE: \"ideographEnclosedCircle\",\n  IDEOGRAPH_TRADITIONAL: \"ideographTraditional\",\n  IDEOGRAPH_ZODIAC: \"ideographZodiac\",\n  IDEOGRAPH_ZODIAC_TRADITIONAL: \"ideographZodiacTraditional\",\n  TAIWANESE_COUNTING: \"taiwaneseCounting\",\n  IDEOGRAPH_LEGAL_TRADITIONAL: \"ideographLegalTraditional\",\n  TAIWANESE_COUNTING_THOUSAND: \"taiwaneseCountingThousand\",\n  TAIWANESE_DIGITAL: \"taiwaneseDigital\",\n  CHINESE_COUNTING: \"chineseCounting\",\n  CHINESE_LEGAL_SIMPLIFIED: \"chineseLegalSimplified\",\n  CHINESE_COUNTING_THOUSAND: \"chineseCountingThousand\",\n  KOREAN_DIGITAL: \"koreanDigital\",\n  KOREAN_COUNTING: \"koreanCounting\",\n  KOREAN_LEGAL: \"koreanLegal\",\n  KOREAN_DIGITAL2: \"koreanDigital2\",\n  VIETNAMESE_COUNTING: \"vietnameseCounting\",\n  RUSSIAN_LOWER: \"russianLower\",\n  RUSSIAN_UPPER: \"russianUpper\",\n  NONE: \"none\",\n  NUMBER_IN_DASH: \"numberInDash\",\n  HEBREW1: \"hebrew1\",\n  HEBREW2: \"hebrew2\",\n  ARABIC_ALPHA: \"arabicAlpha\",\n  ARABIC_ABJAD: \"arabicAbjad\",\n  HINDI_VOWELS: \"hindiVowels\",\n  HINDI_CONSONANTS: \"hindiConsonants\",\n  HINDI_NUMBERS: \"hindiNumbers\",\n  HINDI_COUNTING: \"hindiCounting\",\n  THAI_LETTERS: \"thaiLetters\",\n  THAI_NUMBERS: \"thaiNumbers\",\n  THAI_COUNTING: \"thaiCounting\",\n  BAHT_TEXT: \"bahtText\",\n  DOLLAR_TEXT: \"dollarText\",\n  CUSTOM: \"custom\"\n};\nclass LevelAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      ilvl: \"w:ilvl\",\n      tentative: \"w15:tentative\"\n    });\n  }\n}\nclass NumberFormat extends XmlComponent {\n  constructor(value) {\n    super(\"w:numFmt\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nclass LevelText extends XmlComponent {\n  constructor(value) {\n    super(\"w:lvlText\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nclass LevelJc extends XmlComponent {\n  constructor(value) {\n    super(\"w:lvlJc\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nconst LevelSuffix = {\n  NOTHING: \"nothing\",\n  SPACE: \"space\",\n  TAB: \"tab\"\n};\nclass Suffix extends XmlComponent {\n  constructor(value) {\n    super(\"w:suff\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nclass IsLegalNumberingStyle extends XmlComponent {\n  constructor() {\n    super(\"w:isLgl\");\n  }\n}\nclass LevelBase extends XmlComponent {\n  constructor({\n    level,\n    format,\n    text,\n    alignment = AlignmentType.START,\n    start = 1,\n    style,\n    suffix,\n    isLegalNumberingStyle\n  }) {\n    super(\"w:lvl\");\n    __publicField(this, \"paragraphProperties\");\n    __publicField(this, \"runProperties\");\n    this.root.push(new NumberValueElement(\"w:start\", decimalNumber(start)));\n    if (format) {\n      this.root.push(new NumberFormat(format));\n    }\n    if (suffix) {\n      this.root.push(new Suffix(suffix));\n    }\n    if (isLegalNumberingStyle) {\n      this.root.push(new IsLegalNumberingStyle());\n    }\n    if (text) {\n      this.root.push(new LevelText(text));\n    }\n    this.root.push(new LevelJc(alignment));\n    this.paragraphProperties = new ParagraphProperties(style && style.paragraph);\n    this.runProperties = new RunProperties(style && style.run);\n    this.root.push(this.paragraphProperties);\n    this.root.push(this.runProperties);\n    if (level > 9) {\n      throw new Error(\n        \"Level cannot be greater than 9. Read more here: https://answers.microsoft.com/en-us/msoffice/forum/all/does-word-support-more-than-9-list-levels/d130fdcd-1781-446d-8c84-c6c79124e4d7\"\n      );\n    }\n    this.root.push(\n      new LevelAttributes({\n        ilvl: decimalNumber(level),\n        tentative: 1\n      })\n    );\n  }\n}\nclass Level extends LevelBase {\n  // This is the level that sits under abstractNum. We make a\n  // handful of properties required\n}\nclass LevelForOverride extends LevelBase {\n}\nclass MultiLevelType extends XmlComponent {\n  constructor(value) {\n    super(\"w:multiLevelType\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nclass AbstractNumberingAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      abstractNumId: \"w:abstractNumId\",\n      restartNumberingAfterBreak: \"w15:restartNumberingAfterBreak\"\n    });\n  }\n}\nclass AbstractNumbering extends XmlComponent {\n  constructor(id, levelOptions) {\n    super(\"w:abstractNum\");\n    __publicField(this, \"id\");\n    this.root.push(\n      new AbstractNumberingAttributes({\n        abstractNumId: decimalNumber(id),\n        restartNumberingAfterBreak: 0\n      })\n    );\n    this.root.push(new MultiLevelType(\"hybridMultilevel\"));\n    this.id = id;\n    for (const option of levelOptions) {\n      this.root.push(new Level(option));\n    }\n  }\n}\nclass AbstractNumId extends XmlComponent {\n  constructor(value) {\n    super(\"w:abstractNumId\");\n    this.root.push(\n      new Attributes({\n        val: value\n      })\n    );\n  }\n}\nclass NumAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { numId: \"w:numId\" });\n  }\n}\nclass ConcreteNumbering extends XmlComponent {\n  constructor(options) {\n    super(\"w:num\");\n    __publicField(this, \"numId\");\n    __publicField(this, \"reference\");\n    __publicField(this, \"instance\");\n    this.numId = options.numId;\n    this.reference = options.reference;\n    this.instance = options.instance;\n    this.root.push(\n      new NumAttributes({\n        numId: decimalNumber(options.numId)\n      })\n    );\n    this.root.push(new AbstractNumId(decimalNumber(options.abstractNumId)));\n    if (options.overrideLevels && options.overrideLevels.length) {\n      for (const level of options.overrideLevels) {\n        this.root.push(new LevelOverride(level.num, level.start));\n      }\n    }\n  }\n}\nclass LevelOverrideAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { ilvl: \"w:ilvl\" });\n  }\n}\nclass LevelOverride extends XmlComponent {\n  constructor(levelNum, start) {\n    super(\"w:lvlOverride\");\n    this.root.push(new LevelOverrideAttributes({ ilvl: levelNum }));\n    if (start !== void 0) {\n      this.root.push(new StartOverride(start));\n    }\n  }\n}\nclass StartOverrideAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass StartOverride extends XmlComponent {\n  constructor(start) {\n    super(\"w:startOverride\");\n    this.root.push(new StartOverrideAttributes({ val: start }));\n  }\n}\nclass Numbering extends XmlComponent {\n  constructor(options) {\n    super(\"w:numbering\");\n    __publicField(this, \"abstractNumberingMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"concreteNumberingMap\", /* @__PURE__ */ new Map());\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    __publicField(this, \"referenceConfigMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"abstractNumUniqueNumericId\", abstractNumUniqueNumericIdGen());\n    __publicField(this, \"concreteNumUniqueNumericId\", concreteNumUniqueNumericIdGen());\n    this.root.push(\n      new DocumentAttributes(\n        [\"wpc\", \"mc\", \"o\", \"r\", \"m\", \"v\", \"wp14\", \"wp\", \"w10\", \"w\", \"w14\", \"w15\", \"wpg\", \"wpi\", \"wne\", \"wps\"],\n        \"w14 w15 wp14\"\n      )\n    );\n    const abstractNumbering = new AbstractNumbering(this.abstractNumUniqueNumericId(), [\n      {\n        level: 0,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: convertInchesToTwip(0.5), hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 1,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: convertInchesToTwip(1), hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 2,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 2160, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 3,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 2880, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 4,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 3600, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 5,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 4320, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 6,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 5040, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 7,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 5760, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      },\n      {\n        level: 8,\n        format: LevelFormat.BULLET,\n        text: \"\",\n        alignment: AlignmentType.LEFT,\n        style: {\n          paragraph: {\n            indent: { left: 6480, hanging: convertInchesToTwip(0.25) }\n          }\n        }\n      }\n    ]);\n    this.concreteNumberingMap.set(\n      \"default-bullet-numbering\",\n      new ConcreteNumbering({\n        numId: 1,\n        abstractNumId: abstractNumbering.id,\n        reference: \"default-bullet-numbering\",\n        instance: 0,\n        overrideLevels: [\n          {\n            num: 0,\n            start: 1\n          }\n        ]\n      })\n    );\n    this.abstractNumberingMap.set(\"default-bullet-numbering\", abstractNumbering);\n    for (const con of options.config) {\n      this.abstractNumberingMap.set(con.reference, new AbstractNumbering(this.abstractNumUniqueNumericId(), con.levels));\n      this.referenceConfigMap.set(con.reference, con.levels);\n    }\n  }\n  prepForXml(context) {\n    for (const numbering of this.abstractNumberingMap.values()) {\n      this.root.push(numbering);\n    }\n    for (const numbering of this.concreteNumberingMap.values()) {\n      this.root.push(numbering);\n    }\n    return super.prepForXml(context);\n  }\n  createConcreteNumberingInstance(reference, instance) {\n    const abstractNumbering = this.abstractNumberingMap.get(reference);\n    if (!abstractNumbering) {\n      return;\n    }\n    const fullReference = `${reference}-${instance}`;\n    if (this.concreteNumberingMap.has(fullReference)) {\n      return;\n    }\n    const referenceConfigLevels = this.referenceConfigMap.get(reference);\n    const firstLevelStartNumber = referenceConfigLevels && referenceConfigLevels[0].start;\n    const concreteNumberingSettings = {\n      numId: this.concreteNumUniqueNumericId(),\n      abstractNumId: abstractNumbering.id,\n      reference,\n      instance,\n      overrideLevels: [\n        firstLevelStartNumber && Number.isInteger(firstLevelStartNumber) ? {\n          num: 0,\n          start: firstLevelStartNumber\n        } : {\n          num: 0,\n          start: 1\n        }\n      ]\n    };\n    this.concreteNumberingMap.set(fullReference, new ConcreteNumbering(concreteNumberingSettings));\n  }\n  get ConcreteNumbering() {\n    return Array.from(this.concreteNumberingMap.values());\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get ReferenceConfig() {\n    return Array.from(this.referenceConfigMap.values());\n  }\n}\nclass CompatibilitySettingAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      version: \"w:val\",\n      name: \"w:name\",\n      uri: \"w:uri\"\n    });\n  }\n}\nclass CompatibilitySetting extends XmlComponent {\n  constructor(version) {\n    super(\"w:compatSetting\");\n    this.root.push(\n      new CompatibilitySettingAttributes({\n        version,\n        uri: \"http://schemas.microsoft.com/office/word\",\n        name: \"compatibilityMode\"\n      })\n    );\n  }\n}\nclass Compatibility extends XmlComponent {\n  constructor(options) {\n    super(\"w:compat\");\n    if (options.version) {\n      this.root.push(new CompatibilitySetting(options.version));\n    }\n    if (options.useSingleBorderforContiguousCells) {\n      this.root.push(new OnOffElement(\"w:useSingleBorderforContiguousCells\", options.useSingleBorderforContiguousCells));\n    }\n    if (options.wordPerfectJustification) {\n      this.root.push(new OnOffElement(\"w:wpJustification\", options.wordPerfectJustification));\n    }\n    if (options.noTabStopForHangingIndent) {\n      this.root.push(new OnOffElement(\"w:noTabHangInd\", options.noTabStopForHangingIndent));\n    }\n    if (options.noLeading) {\n      this.root.push(new OnOffElement(\"w:noLeading\", options.noLeading));\n    }\n    if (options.spaceForUnderline) {\n      this.root.push(new OnOffElement(\"w:spaceForUL\", options.spaceForUnderline));\n    }\n    if (options.noColumnBalance) {\n      this.root.push(new OnOffElement(\"w:noColumnBalance\", options.noColumnBalance));\n    }\n    if (options.balanceSingleByteDoubleByteWidth) {\n      this.root.push(new OnOffElement(\"w:balanceSingleByteDoubleByteWidth\", options.balanceSingleByteDoubleByteWidth));\n    }\n    if (options.noExtraLineSpacing) {\n      this.root.push(new OnOffElement(\"w:noExtraLineSpacing\", options.noExtraLineSpacing));\n    }\n    if (options.doNotLeaveBackslashAlone) {\n      this.root.push(new OnOffElement(\"w:doNotLeaveBackslashAlone\", options.doNotLeaveBackslashAlone));\n    }\n    if (options.underlineTrailingSpaces) {\n      this.root.push(new OnOffElement(\"w:ulTrailSpace\", options.underlineTrailingSpaces));\n    }\n    if (options.doNotExpandShiftReturn) {\n      this.root.push(new OnOffElement(\"w:doNotExpandShiftReturn\", options.doNotExpandShiftReturn));\n    }\n    if (options.spacingInWholePoints) {\n      this.root.push(new OnOffElement(\"w:spacingInWholePoints\", options.spacingInWholePoints));\n    }\n    if (options.lineWrapLikeWord6) {\n      this.root.push(new OnOffElement(\"w:lineWrapLikeWord6\", options.lineWrapLikeWord6));\n    }\n    if (options.printBodyTextBeforeHeader) {\n      this.root.push(new OnOffElement(\"w:printBodyTextBeforeHeader\", options.printBodyTextBeforeHeader));\n    }\n    if (options.printColorsBlack) {\n      this.root.push(new OnOffElement(\"w:printColBlack\", options.printColorsBlack));\n    }\n    if (options.spaceWidth) {\n      this.root.push(new OnOffElement(\"w:wpSpaceWidth\", options.spaceWidth));\n    }\n    if (options.showBreaksInFrames) {\n      this.root.push(new OnOffElement(\"w:showBreaksInFrames\", options.showBreaksInFrames));\n    }\n    if (options.subFontBySize) {\n      this.root.push(new OnOffElement(\"w:subFontBySize\", options.subFontBySize));\n    }\n    if (options.suppressBottomSpacing) {\n      this.root.push(new OnOffElement(\"w:suppressBottomSpacing\", options.suppressBottomSpacing));\n    }\n    if (options.suppressTopSpacing) {\n      this.root.push(new OnOffElement(\"w:suppressTopSpacing\", options.suppressTopSpacing));\n    }\n    if (options.suppressSpacingAtTopOfPage) {\n      this.root.push(new OnOffElement(\"w:suppressSpacingAtTopOfPage\", options.suppressSpacingAtTopOfPage));\n    }\n    if (options.suppressTopSpacingWP) {\n      this.root.push(new OnOffElement(\"w:suppressTopSpacingWP\", options.suppressTopSpacingWP));\n    }\n    if (options.suppressSpBfAfterPgBrk) {\n      this.root.push(new OnOffElement(\"w:suppressSpBfAfterPgBrk\", options.suppressSpBfAfterPgBrk));\n    }\n    if (options.swapBordersFacingPages) {\n      this.root.push(new OnOffElement(\"w:swapBordersFacingPages\", options.swapBordersFacingPages));\n    }\n    if (options.convertMailMergeEsc) {\n      this.root.push(new OnOffElement(\"w:convMailMergeEsc\", options.convertMailMergeEsc));\n    }\n    if (options.truncateFontHeightsLikeWP6) {\n      this.root.push(new OnOffElement(\"w:truncateFontHeightsLikeWP6\", options.truncateFontHeightsLikeWP6));\n    }\n    if (options.macWordSmallCaps) {\n      this.root.push(new OnOffElement(\"w:mwSmallCaps\", options.macWordSmallCaps));\n    }\n    if (options.usePrinterMetrics) {\n      this.root.push(new OnOffElement(\"w:usePrinterMetrics\", options.usePrinterMetrics));\n    }\n    if (options.doNotSuppressParagraphBorders) {\n      this.root.push(new OnOffElement(\"w:doNotSuppressParagraphBorders\", options.doNotSuppressParagraphBorders));\n    }\n    if (options.wrapTrailSpaces) {\n      this.root.push(new OnOffElement(\"w:wrapTrailSpaces\", options.wrapTrailSpaces));\n    }\n    if (options.footnoteLayoutLikeWW8) {\n      this.root.push(new OnOffElement(\"w:footnoteLayoutLikeWW8\", options.footnoteLayoutLikeWW8));\n    }\n    if (options.shapeLayoutLikeWW8) {\n      this.root.push(new OnOffElement(\"w:shapeLayoutLikeWW8\", options.shapeLayoutLikeWW8));\n    }\n    if (options.alignTablesRowByRow) {\n      this.root.push(new OnOffElement(\"w:alignTablesRowByRow\", options.alignTablesRowByRow));\n    }\n    if (options.forgetLastTabAlignment) {\n      this.root.push(new OnOffElement(\"w:forgetLastTabAlignment\", options.forgetLastTabAlignment));\n    }\n    if (options.adjustLineHeightInTable) {\n      this.root.push(new OnOffElement(\"w:adjustLineHeightInTable\", options.adjustLineHeightInTable));\n    }\n    if (options.autoSpaceLikeWord95) {\n      this.root.push(new OnOffElement(\"w:autoSpaceLikeWord95\", options.autoSpaceLikeWord95));\n    }\n    if (options.noSpaceRaiseLower) {\n      this.root.push(new OnOffElement(\"w:noSpaceRaiseLower\", options.noSpaceRaiseLower));\n    }\n    if (options.doNotUseHTMLParagraphAutoSpacing) {\n      this.root.push(new OnOffElement(\"w:doNotUseHTMLParagraphAutoSpacing\", options.doNotUseHTMLParagraphAutoSpacing));\n    }\n    if (options.layoutRawTableWidth) {\n      this.root.push(new OnOffElement(\"w:layoutRawTableWidth\", options.layoutRawTableWidth));\n    }\n    if (options.layoutTableRowsApart) {\n      this.root.push(new OnOffElement(\"w:layoutTableRowsApart\", options.layoutTableRowsApart));\n    }\n    if (options.useWord97LineBreakRules) {\n      this.root.push(new OnOffElement(\"w:useWord97LineBreakRules\", options.useWord97LineBreakRules));\n    }\n    if (options.doNotBreakWrappedTables) {\n      this.root.push(new OnOffElement(\"w:doNotBreakWrappedTables\", options.doNotBreakWrappedTables));\n    }\n    if (options.doNotSnapToGridInCell) {\n      this.root.push(new OnOffElement(\"w:doNotSnapToGridInCell\", options.doNotSnapToGridInCell));\n    }\n    if (options.selectFieldWithFirstOrLastCharacter) {\n      this.root.push(new OnOffElement(\"w:selectFldWithFirstOrLastChar\", options.selectFieldWithFirstOrLastCharacter));\n    }\n    if (options.applyBreakingRules) {\n      this.root.push(new OnOffElement(\"w:applyBreakingRules\", options.applyBreakingRules));\n    }\n    if (options.doNotWrapTextWithPunctuation) {\n      this.root.push(new OnOffElement(\"w:doNotWrapTextWithPunct\", options.doNotWrapTextWithPunctuation));\n    }\n    if (options.doNotUseEastAsianBreakRules) {\n      this.root.push(new OnOffElement(\"w:doNotUseEastAsianBreakRules\", options.doNotUseEastAsianBreakRules));\n    }\n    if (options.useWord2002TableStyleRules) {\n      this.root.push(new OnOffElement(\"w:useWord2002TableStyleRules\", options.useWord2002TableStyleRules));\n    }\n    if (options.growAutofit) {\n      this.root.push(new OnOffElement(\"w:growAutofit\", options.growAutofit));\n    }\n    if (options.useFELayout) {\n      this.root.push(new OnOffElement(\"w:useFELayout\", options.useFELayout));\n    }\n    if (options.useNormalStyleForList) {\n      this.root.push(new OnOffElement(\"w:useNormalStyleForList\", options.useNormalStyleForList));\n    }\n    if (options.doNotUseIndentAsNumberingTabStop) {\n      this.root.push(new OnOffElement(\"w:doNotUseIndentAsNumberingTabStop\", options.doNotUseIndentAsNumberingTabStop));\n    }\n    if (options.useAlternateEastAsianLineBreakRules) {\n      this.root.push(new OnOffElement(\"w:useAltKinsokuLineBreakRules\", options.useAlternateEastAsianLineBreakRules));\n    }\n    if (options.allowSpaceOfSameStyleInTable) {\n      this.root.push(new OnOffElement(\"w:allowSpaceOfSameStyleInTable\", options.allowSpaceOfSameStyleInTable));\n    }\n    if (options.doNotSuppressIndentation) {\n      this.root.push(new OnOffElement(\"w:doNotSuppressIndentation\", options.doNotSuppressIndentation));\n    }\n    if (options.doNotAutofitConstrainedTables) {\n      this.root.push(new OnOffElement(\"w:doNotAutofitConstrainedTables\", options.doNotAutofitConstrainedTables));\n    }\n    if (options.autofitToFirstFixedWidthCell) {\n      this.root.push(new OnOffElement(\"w:autofitToFirstFixedWidthCell\", options.autofitToFirstFixedWidthCell));\n    }\n    if (options.underlineTabInNumberingList) {\n      this.root.push(new OnOffElement(\"w:underlineTabInNumList\", options.underlineTabInNumberingList));\n    }\n    if (options.displayHangulFixedWidth) {\n      this.root.push(new OnOffElement(\"w:displayHangulFixedWidth\", options.displayHangulFixedWidth));\n    }\n    if (options.splitPgBreakAndParaMark) {\n      this.root.push(new OnOffElement(\"w:splitPgBreakAndParaMark\", options.splitPgBreakAndParaMark));\n    }\n    if (options.doNotVerticallyAlignCellWithSp) {\n      this.root.push(new OnOffElement(\"w:doNotVertAlignCellWithSp\", options.doNotVerticallyAlignCellWithSp));\n    }\n    if (options.doNotBreakConstrainedForcedTable) {\n      this.root.push(new OnOffElement(\"w:doNotBreakConstrainedForcedTable\", options.doNotBreakConstrainedForcedTable));\n    }\n    if (options.ignoreVerticalAlignmentInTextboxes) {\n      this.root.push(new OnOffElement(\"w:doNotVertAlignInTxbx\", options.ignoreVerticalAlignmentInTextboxes));\n    }\n    if (options.useAnsiKerningPairs) {\n      this.root.push(new OnOffElement(\"w:useAnsiKerningPairs\", options.useAnsiKerningPairs));\n    }\n    if (options.cachedColumnBalance) {\n      this.root.push(new OnOffElement(\"w:cachedColBalance\", options.cachedColumnBalance));\n    }\n  }\n}\nclass SettingsAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      wpc: \"xmlns:wpc\",\n      mc: \"xmlns:mc\",\n      o: \"xmlns:o\",\n      r: \"xmlns:r\",\n      m: \"xmlns:m\",\n      v: \"xmlns:v\",\n      wp14: \"xmlns:wp14\",\n      wp: \"xmlns:wp\",\n      w10: \"xmlns:w10\",\n      w: \"xmlns:w\",\n      w14: \"xmlns:w14\",\n      w15: \"xmlns:w15\",\n      wpg: \"xmlns:wpg\",\n      wpi: \"xmlns:wpi\",\n      wne: \"xmlns:wne\",\n      wps: \"xmlns:wps\",\n      Ignorable: \"mc:Ignorable\"\n    });\n  }\n}\nclass Settings extends XmlComponent {\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    super(\"w:settings\");\n    this.root.push(\n      new SettingsAttributes({\n        wpc: \"http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas\",\n        mc: \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n        o: \"urn:schemas-microsoft-com:office:office\",\n        r: \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n        m: \"http://schemas.openxmlformats.org/officeDocument/2006/math\",\n        v: \"urn:schemas-microsoft-com:vml\",\n        wp14: \"http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing\",\n        wp: \"http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing\",\n        w10: \"urn:schemas-microsoft-com:office:word\",\n        w: \"http://schemas.openxmlformats.org/wordprocessingml/2006/main\",\n        w14: \"http://schemas.microsoft.com/office/word/2010/wordml\",\n        w15: \"http://schemas.microsoft.com/office/word/2012/wordml\",\n        wpg: \"http://schemas.microsoft.com/office/word/2010/wordprocessingGroup\",\n        wpi: \"http://schemas.microsoft.com/office/word/2010/wordprocessingInk\",\n        wne: \"http://schemas.microsoft.com/office/word/2006/wordml\",\n        wps: \"http://schemas.microsoft.com/office/word/2010/wordprocessingShape\",\n        Ignorable: \"w14 w15 wp14\"\n      })\n    );\n    this.root.push(new OnOffElement(\"w:displayBackgroundShape\", true));\n    if (options.trackRevisions !== void 0) {\n      this.root.push(new OnOffElement(\"w:trackRevisions\", options.trackRevisions));\n    }\n    if (options.evenAndOddHeaders !== void 0) {\n      this.root.push(new OnOffElement(\"w:evenAndOddHeaders\", options.evenAndOddHeaders));\n    }\n    if (options.updateFields !== void 0) {\n      this.root.push(new OnOffElement(\"w:updateFields\", options.updateFields));\n    }\n    if (options.defaultTabStop !== void 0) {\n      this.root.push(new NumberValueElement(\"w:defaultTabStop\", options.defaultTabStop));\n    }\n    if (((_a = options.hyphenation) == null ? void 0 : _a.autoHyphenation) !== void 0) {\n      this.root.push(new OnOffElement(\"w:autoHyphenation\", options.hyphenation.autoHyphenation));\n    }\n    if (((_b = options.hyphenation) == null ? void 0 : _b.hyphenationZone) !== void 0) {\n      this.root.push(new NumberValueElement(\"w:hyphenationZone\", options.hyphenation.hyphenationZone));\n    }\n    if (((_c = options.hyphenation) == null ? void 0 : _c.consecutiveHyphenLimit) !== void 0) {\n      this.root.push(new NumberValueElement(\"w:consecutiveHyphenLimit\", options.hyphenation.consecutiveHyphenLimit));\n    }\n    if (((_d = options.hyphenation) == null ? void 0 : _d.doNotHyphenateCaps) !== void 0) {\n      this.root.push(new OnOffElement(\"w:doNotHyphenateCaps\", options.hyphenation.doNotHyphenateCaps));\n    }\n    this.root.push(\n      new Compatibility(__spreadProps(__spreadValues({}, (_e = options.compatibility) != null ? _e : {}), {\n        version: (_h = (_g = (_f = options.compatibility) == null ? void 0 : _f.version) != null ? _g : options.compatibilityModeVersion) != null ? _h : 15\n      }))\n    );\n  }\n}\nclass ComponentAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", { val: \"w:val\" });\n  }\n}\nclass Name extends XmlComponent {\n  constructor(value) {\n    super(\"w:name\");\n    this.root.push(new ComponentAttributes({ val: value }));\n  }\n}\nclass UiPriority extends XmlComponent {\n  constructor(value) {\n    super(\"w:uiPriority\");\n    this.root.push(new ComponentAttributes({ val: decimalNumber(value) }));\n  }\n}\nclass StyleAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      type: \"w:type\",\n      styleId: \"w:styleId\",\n      default: \"w:default\",\n      customStyle: \"w:customStyle\"\n    });\n  }\n}\nclass Style2 extends XmlComponent {\n  constructor(attributes, options) {\n    super(\"w:style\");\n    this.root.push(new StyleAttributes(attributes));\n    if (options.name) {\n      this.root.push(new Name(options.name));\n    }\n    if (options.basedOn) {\n      this.root.push(new StringValueElement(\"w:basedOn\", options.basedOn));\n    }\n    if (options.next) {\n      this.root.push(new StringValueElement(\"w:next\", options.next));\n    }\n    if (options.link) {\n      this.root.push(new StringValueElement(\"w:link\", options.link));\n    }\n    if (options.uiPriority !== void 0) {\n      this.root.push(new UiPriority(options.uiPriority));\n    }\n    if (options.semiHidden !== void 0) {\n      this.root.push(new OnOffElement(\"w:semiHidden\", options.semiHidden));\n    }\n    if (options.unhideWhenUsed !== void 0) {\n      this.root.push(new OnOffElement(\"w:unhideWhenUsed\", options.unhideWhenUsed));\n    }\n    if (options.quickFormat !== void 0) {\n      this.root.push(new OnOffElement(\"w:qFormat\", options.quickFormat));\n    }\n  }\n}\nclass StyleForParagraph extends Style2 {\n  constructor(options) {\n    super({ type: \"paragraph\", styleId: options.id }, options);\n    __publicField(this, \"paragraphProperties\");\n    __publicField(this, \"runProperties\");\n    this.paragraphProperties = new ParagraphProperties(options.paragraph);\n    this.runProperties = new RunProperties(options.run);\n    this.root.push(this.paragraphProperties);\n    this.root.push(this.runProperties);\n  }\n}\nclass StyleForCharacter extends Style2 {\n  constructor(options) {\n    super(\n      { type: \"character\", styleId: options.id },\n      __spreadValues({\n        uiPriority: 99,\n        unhideWhenUsed: true\n      }, options)\n    );\n    __publicField(this, \"runProperties\");\n    this.runProperties = new RunProperties(options.run);\n    this.root.push(this.runProperties);\n  }\n}\nclass HeadingStyle extends StyleForParagraph {\n  constructor(options) {\n    super(__spreadValues({\n      basedOn: \"Normal\",\n      next: \"Normal\",\n      quickFormat: true\n    }, options));\n  }\n}\nclass TitleStyle extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Title\",\n      name: \"Title\"\n    }, options));\n  }\n}\nclass Heading1Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading1\",\n      name: \"Heading 1\"\n    }, options));\n  }\n}\nclass Heading2Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading2\",\n      name: \"Heading 2\"\n    }, options));\n  }\n}\nclass Heading3Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading3\",\n      name: \"Heading 3\"\n    }, options));\n  }\n}\nclass Heading4Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading4\",\n      name: \"Heading 4\"\n    }, options));\n  }\n}\nclass Heading5Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading5\",\n      name: \"Heading 5\"\n    }, options));\n  }\n}\nclass Heading6Style extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Heading6\",\n      name: \"Heading 6\"\n    }, options));\n  }\n}\nclass StrongStyle extends HeadingStyle {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Strong\",\n      name: \"Strong\"\n    }, options));\n  }\n}\nclass ListParagraph extends StyleForParagraph {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"ListParagraph\",\n      name: \"List Paragraph\",\n      basedOn: \"Normal\",\n      quickFormat: true\n    }, options));\n  }\n}\nclass FootnoteText extends StyleForParagraph {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"FootnoteText\",\n      name: \"footnote text\",\n      link: \"FootnoteTextChar\",\n      basedOn: \"Normal\",\n      uiPriority: 99,\n      semiHidden: true,\n      unhideWhenUsed: true,\n      paragraph: {\n        spacing: {\n          after: 0,\n          line: 240,\n          lineRule: LineRuleType.AUTO\n        }\n      },\n      run: {\n        size: 20\n      }\n    }, options));\n  }\n}\nclass FootnoteReferenceStyle extends StyleForCharacter {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"FootnoteReference\",\n      name: \"footnote reference\",\n      basedOn: \"DefaultParagraphFont\",\n      semiHidden: true,\n      run: {\n        superScript: true\n      }\n    }, options));\n  }\n}\nclass FootnoteTextChar extends StyleForCharacter {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"FootnoteTextChar\",\n      name: \"Footnote Text Char\",\n      basedOn: \"DefaultParagraphFont\",\n      link: \"FootnoteText\",\n      semiHidden: true,\n      run: {\n        size: 20\n      }\n    }, options));\n  }\n}\nclass HyperlinkStyle extends StyleForCharacter {\n  constructor(options) {\n    super(__spreadValues({\n      id: \"Hyperlink\",\n      name: \"Hyperlink\",\n      basedOn: \"DefaultParagraphFont\",\n      run: {\n        color: \"0563C1\",\n        underline: {\n          type: UnderlineType.SINGLE\n        }\n      }\n    }, options));\n  }\n}\nclass Styles extends XmlComponent {\n  constructor(options) {\n    super(\"w:styles\");\n    if (options.initialStyles) {\n      this.root.push(options.initialStyles);\n    }\n    if (options.importedStyles) {\n      for (const style of options.importedStyles) {\n        this.root.push(style);\n      }\n    }\n    if (options.paragraphStyles) {\n      for (const style of options.paragraphStyles) {\n        this.root.push(new StyleForParagraph(style));\n      }\n    }\n    if (options.characterStyles) {\n      for (const style of options.characterStyles) {\n        this.root.push(new StyleForCharacter(style));\n      }\n    }\n  }\n}\nclass ParagraphPropertiesDefaults extends XmlComponent {\n  constructor(options) {\n    super(\"w:pPrDefault\");\n    this.root.push(new ParagraphProperties(options));\n  }\n}\nclass RunPropertiesDefaults extends XmlComponent {\n  constructor(options) {\n    super(\"w:rPrDefault\");\n    this.root.push(new RunProperties(options));\n  }\n}\nclass DocumentDefaults extends XmlComponent {\n  constructor(options) {\n    super(\"w:docDefaults\");\n    __publicField(this, \"runPropertiesDefaults\");\n    __publicField(this, \"paragraphPropertiesDefaults\");\n    this.runPropertiesDefaults = new RunPropertiesDefaults(options.run);\n    this.paragraphPropertiesDefaults = new ParagraphPropertiesDefaults(options.paragraph);\n    this.root.push(this.runPropertiesDefaults);\n    this.root.push(this.paragraphPropertiesDefaults);\n  }\n}\nclass ExternalStylesFactory {\n  /**\n   * Creates new Style based on the given styles.\n   * Parses the styles and convert them to XmlComponent.\n   * Example content from styles.xml:\n   * <?xml version=\"1.0\">\n   * <w:styles xmlns:mc=\"some schema\" ...>\n   *\n   *   <w:style w:type=\"paragraph\" w:styleId=\"Heading1\">\n   *           <w:name w:val=\"heading 1\"/>\n   *           .....\n   *   </w:style>\n   *\n   *   <w:style w:type=\"paragraph\" w:styleId=\"Heading2\">\n   *           <w:name w:val=\"heading 2\"/>\n   *           .....\n   *   </w:style>\n   *\n   *   <w:docDefaults>Or any other element will be parsed to</w:docDefaults>\n   *\n   * </w:styles>\n   *\n   * @param externalStyles context from styles.xml\n   */\n  newInstance(xmlData) {\n    const xmlObj = libExports.xml2js(xmlData, { compact: false });\n    let stylesXmlElement;\n    for (const xmlElm of xmlObj.elements || []) {\n      if (xmlElm.name === \"w:styles\") {\n        stylesXmlElement = xmlElm;\n      }\n    }\n    if (stylesXmlElement === void 0) {\n      throw new Error(\"can not find styles element\");\n    }\n    const stylesElements = stylesXmlElement.elements || [];\n    const importedStyle = new Styles({\n      initialStyles: new ImportedRootElementAttributes(stylesXmlElement.attributes),\n      importedStyles: stylesElements.map((childElm) => convertToXmlComponent(childElm))\n    });\n    return importedStyle;\n  }\n}\nclass DefaultStylesFactory {\n  newInstance(options = {}) {\n    var _a;\n    const documentAttributes = new DocumentAttributes([\"mc\", \"r\", \"w\", \"w14\", \"w15\"], \"w14 w15\");\n    return {\n      initialStyles: documentAttributes,\n      importedStyles: [\n        new DocumentDefaults((_a = options.document) != null ? _a : {}),\n        new TitleStyle(__spreadValues({\n          run: {\n            size: 56\n          }\n        }, options.title)),\n        new Heading1Style(__spreadValues({\n          run: {\n            color: \"2E74B5\",\n            size: 32\n          }\n        }, options.heading1)),\n        new Heading2Style(__spreadValues({\n          run: {\n            color: \"2E74B5\",\n            size: 26\n          }\n        }, options.heading2)),\n        new Heading3Style(__spreadValues({\n          run: {\n            color: \"1F4D78\",\n            size: 24\n          }\n        }, options.heading3)),\n        new Heading4Style(__spreadValues({\n          run: {\n            color: \"2E74B5\",\n            italics: true\n          }\n        }, options.heading4)),\n        new Heading5Style(__spreadValues({\n          run: {\n            color: \"2E74B5\"\n          }\n        }, options.heading5)),\n        new Heading6Style(__spreadValues({\n          run: {\n            color: \"1F4D78\"\n          }\n        }, options.heading6)),\n        new StrongStyle(__spreadValues({\n          run: {\n            bold: true\n          }\n        }, options.strong)),\n        new ListParagraph(options.listParagraph || {}),\n        new HyperlinkStyle(options.hyperlink || {}),\n        new FootnoteReferenceStyle(options.footnoteReference || {}),\n        new FootnoteText(options.footnoteText || {}),\n        new FootnoteTextChar(options.footnoteTextChar || {})\n      ]\n    };\n  }\n}\nclass File {\n  constructor(options) {\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"currentRelationshipId\", 1);\n    __publicField(this, \"documentWrapper\");\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"headers\", []);\n    // eslint-disable-next-line functional/prefer-readonly-type\n    __publicField(this, \"footers\", []);\n    __publicField(this, \"coreProperties\");\n    __publicField(this, \"numbering\");\n    __publicField(this, \"media\");\n    __publicField(this, \"fileRelationships\");\n    __publicField(this, \"footnotesWrapper\");\n    __publicField(this, \"settings\");\n    __publicField(this, \"contentTypes\");\n    __publicField(this, \"customProperties\");\n    __publicField(this, \"appProperties\");\n    __publicField(this, \"styles\");\n    __publicField(this, \"comments\");\n    __publicField(this, \"fontWrapper\");\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n    this.coreProperties = new CoreProperties(__spreadProps(__spreadValues({}, options), {\n      creator: (_a = options.creator) != null ? _a : \"Un-named\",\n      revision: (_b = options.revision) != null ? _b : 1,\n      lastModifiedBy: (_c = options.lastModifiedBy) != null ? _c : \"Un-named\"\n    }));\n    this.numbering = new Numbering(options.numbering ? options.numbering : { config: [] });\n    this.comments = new Comments((_d = options.comments) != null ? _d : { children: [] });\n    this.fileRelationships = new Relationships();\n    this.customProperties = new CustomProperties((_e = options.customProperties) != null ? _e : []);\n    this.appProperties = new AppProperties();\n    this.footnotesWrapper = new FootnotesWrapper();\n    this.contentTypes = new ContentTypes();\n    this.documentWrapper = new DocumentWrapper({ background: options.background });\n    this.settings = new Settings({\n      compatibilityModeVersion: options.compatabilityModeVersion,\n      compatibility: options.compatibility,\n      evenAndOddHeaders: options.evenAndOddHeaderAndFooters ? true : false,\n      trackRevisions: (_f = options.features) == null ? void 0 : _f.trackRevisions,\n      updateFields: (_g = options.features) == null ? void 0 : _g.updateFields,\n      defaultTabStop: options.defaultTabStop,\n      hyphenation: {\n        autoHyphenation: (_h = options.hyphenation) == null ? void 0 : _h.autoHyphenation,\n        hyphenationZone: (_i = options.hyphenation) == null ? void 0 : _i.hyphenationZone,\n        consecutiveHyphenLimit: (_j = options.hyphenation) == null ? void 0 : _j.consecutiveHyphenLimit,\n        doNotHyphenateCaps: (_k = options.hyphenation) == null ? void 0 : _k.doNotHyphenateCaps\n      }\n    });\n    this.media = new Media();\n    if (options.externalStyles !== void 0) {\n      const stylesFactory = new ExternalStylesFactory();\n      this.styles = stylesFactory.newInstance(options.externalStyles);\n    } else if (options.styles) {\n      const stylesFactory = new DefaultStylesFactory();\n      const defaultStyles = stylesFactory.newInstance(options.styles.default);\n      this.styles = new Styles(__spreadValues(__spreadValues({}, defaultStyles), options.styles));\n    } else {\n      const stylesFactory = new DefaultStylesFactory();\n      this.styles = new Styles(stylesFactory.newInstance());\n    }\n    this.addDefaultRelationships();\n    for (const section of options.sections) {\n      this.addSection(section);\n    }\n    if (options.footnotes) {\n      for (const key in options.footnotes) {\n        this.footnotesWrapper.View.createFootNote(parseFloat(key), options.footnotes[key].children);\n      }\n    }\n    this.fontWrapper = new FontWrapper((_l = options.fonts) != null ? _l : []);\n  }\n  addSection({ headers = {}, footers = {}, children, properties }) {\n    this.documentWrapper.View.Body.addSection(__spreadProps(__spreadValues({}, properties), {\n      headerWrapperGroup: {\n        default: headers.default ? this.createHeader(headers.default) : void 0,\n        first: headers.first ? this.createHeader(headers.first) : void 0,\n        even: headers.even ? this.createHeader(headers.even) : void 0\n      },\n      footerWrapperGroup: {\n        default: footers.default ? this.createFooter(footers.default) : void 0,\n        first: footers.first ? this.createFooter(footers.first) : void 0,\n        even: footers.even ? this.createFooter(footers.even) : void 0\n      }\n    }));\n    for (const child of children) {\n      this.documentWrapper.View.add(child);\n    }\n  }\n  createHeader(header) {\n    const wrapper = new HeaderWrapper(this.media, this.currentRelationshipId++);\n    for (const child of header.options.children) {\n      wrapper.add(child);\n    }\n    this.addHeaderToDocument(wrapper);\n    return wrapper;\n  }\n  createFooter(footer) {\n    const wrapper = new FooterWrapper(this.media, this.currentRelationshipId++);\n    for (const child of footer.options.children) {\n      wrapper.add(child);\n    }\n    this.addFooterToDocument(wrapper);\n    return wrapper;\n  }\n  addHeaderToDocument(header, type2 = HeaderFooterReferenceType.DEFAULT) {\n    this.headers.push({ header, type: type2 });\n    this.documentWrapper.Relationships.createRelationship(\n      header.View.ReferenceId,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/header\",\n      `header${this.headers.length}.xml`\n    );\n    this.contentTypes.addHeader(this.headers.length);\n  }\n  addFooterToDocument(footer, type2 = HeaderFooterReferenceType.DEFAULT) {\n    this.footers.push({ footer, type: type2 });\n    this.documentWrapper.Relationships.createRelationship(\n      footer.View.ReferenceId,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer\",\n      `footer${this.footers.length}.xml`\n    );\n    this.contentTypes.addFooter(this.footers.length);\n  }\n  addDefaultRelationships() {\n    this.fileRelationships.createRelationship(\n      1,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\",\n      \"word/document.xml\"\n    );\n    this.fileRelationships.createRelationship(\n      2,\n      \"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\",\n      \"docProps/core.xml\"\n    );\n    this.fileRelationships.createRelationship(\n      3,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\",\n      \"docProps/app.xml\"\n    );\n    this.fileRelationships.createRelationship(\n      4,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties\",\n      \"docProps/custom.xml\"\n    );\n    this.documentWrapper.Relationships.createRelationship(\n      // eslint-disable-next-line functional/immutable-data\n      this.currentRelationshipId++,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\",\n      \"styles.xml\"\n    );\n    this.documentWrapper.Relationships.createRelationship(\n      // eslint-disable-next-line functional/immutable-data\n      this.currentRelationshipId++,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering\",\n      \"numbering.xml\"\n    );\n    this.documentWrapper.Relationships.createRelationship(\n      // eslint-disable-next-line functional/immutable-data\n      this.currentRelationshipId++,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes\",\n      \"footnotes.xml\"\n    );\n    this.documentWrapper.Relationships.createRelationship(\n      // eslint-disable-next-line functional/immutable-data\n      this.currentRelationshipId++,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings\",\n      \"settings.xml\"\n    );\n    this.documentWrapper.Relationships.createRelationship(\n      // eslint-disable-next-line functional/immutable-data\n      this.currentRelationshipId++,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments\",\n      \"comments.xml\"\n    );\n  }\n  get Document() {\n    return this.documentWrapper;\n  }\n  get Styles() {\n    return this.styles;\n  }\n  get CoreProperties() {\n    return this.coreProperties;\n  }\n  get Numbering() {\n    return this.numbering;\n  }\n  get Media() {\n    return this.media;\n  }\n  get FileRelationships() {\n    return this.fileRelationships;\n  }\n  get Headers() {\n    return this.headers.map((item) => item.header);\n  }\n  get Footers() {\n    return this.footers.map((item) => item.footer);\n  }\n  get ContentTypes() {\n    return this.contentTypes;\n  }\n  get CustomProperties() {\n    return this.customProperties;\n  }\n  get AppProperties() {\n    return this.appProperties;\n  }\n  get FootNotes() {\n    return this.footnotesWrapper;\n  }\n  get Settings() {\n    return this.settings;\n  }\n  get Comments() {\n    return this.comments;\n  }\n  get FontTable() {\n    return this.fontWrapper;\n  }\n}\nclass FieldInstruction extends XmlComponent {\n  constructor(properties = {}) {\n    super(\"w:instrText\");\n    __publicField(this, \"properties\");\n    this.properties = properties;\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    let instruction = \"TOC\";\n    if (this.properties.captionLabel) {\n      instruction = `${instruction} \\\\a \"${this.properties.captionLabel}\"`;\n    }\n    if (this.properties.entriesFromBookmark) {\n      instruction = `${instruction} \\\\b \"${this.properties.entriesFromBookmark}\"`;\n    }\n    if (this.properties.captionLabelIncludingNumbers) {\n      instruction = `${instruction} \\\\c \"${this.properties.captionLabelIncludingNumbers}\"`;\n    }\n    if (this.properties.sequenceAndPageNumbersSeparator) {\n      instruction = `${instruction} \\\\d \"${this.properties.sequenceAndPageNumbersSeparator}\"`;\n    }\n    if (this.properties.tcFieldIdentifier) {\n      instruction = `${instruction} \\\\f \"${this.properties.tcFieldIdentifier}\"`;\n    }\n    if (this.properties.hyperlink) {\n      instruction = `${instruction} \\\\h`;\n    }\n    if (this.properties.tcFieldLevelRange) {\n      instruction = `${instruction} \\\\l \"${this.properties.tcFieldLevelRange}\"`;\n    }\n    if (this.properties.pageNumbersEntryLevelsRange) {\n      instruction = `${instruction} \\\\n \"${this.properties.pageNumbersEntryLevelsRange}\"`;\n    }\n    if (this.properties.headingStyleRange) {\n      instruction = `${instruction} \\\\o \"${this.properties.headingStyleRange}\"`;\n    }\n    if (this.properties.entryAndPageNumberSeparator) {\n      instruction = `${instruction} \\\\p \"${this.properties.entryAndPageNumberSeparator}\"`;\n    }\n    if (this.properties.seqFieldIdentifierForPrefix) {\n      instruction = `${instruction} \\\\s \"${this.properties.seqFieldIdentifierForPrefix}\"`;\n    }\n    if (this.properties.stylesWithLevels && this.properties.stylesWithLevels.length) {\n      const styles = this.properties.stylesWithLevels.map((sl) => `${sl.styleName},${sl.level}`).join(\",\");\n      instruction = `${instruction} \\\\t \"${styles}\"`;\n    }\n    if (this.properties.useAppliedParagraphOutlineLevel) {\n      instruction = `${instruction} \\\\u`;\n    }\n    if (this.properties.preserveTabInEntries) {\n      instruction = `${instruction} \\\\w`;\n    }\n    if (this.properties.preserveNewLineInEntries) {\n      instruction = `${instruction} \\\\x`;\n    }\n    if (this.properties.hideTabAndPageNumbersInWebView) {\n      instruction = `${instruction} \\\\z`;\n    }\n    this.root.push(instruction);\n  }\n}\nclass StructuredDocumentTagContent extends XmlComponent {\n  constructor() {\n    super(\"w:sdtContent\");\n  }\n}\nclass StructuredDocumentTagProperties extends XmlComponent {\n  constructor(alias) {\n    super(\"w:sdtPr\");\n    if (alias) {\n      this.root.push(new StringValueElement(\"w:alias\", alias));\n    }\n  }\n}\nclass TableOfContents extends FileChild {\n  constructor(alias = \"Table of Contents\", properties) {\n    super(\"w:sdt\");\n    this.root.push(new StructuredDocumentTagProperties(alias));\n    const content = new StructuredDocumentTagContent();\n    const beginParagraph = new Paragraph({\n      children: [\n        new Run({\n          children: [new Begin(true), new FieldInstruction(properties), new Separate()]\n        })\n      ]\n    });\n    content.addChildElement(beginParagraph);\n    const endParagraph = new Paragraph({\n      children: [\n        new Run({\n          children: [new End()]\n        })\n      ]\n    });\n    content.addChildElement(endParagraph);\n    this.root.push(content);\n  }\n}\nclass StyleLevel {\n  constructor(styleName, level) {\n    __publicField(this, \"styleName\");\n    __publicField(this, \"level\");\n    this.styleName = styleName;\n    this.level = level;\n  }\n}\nclass Header2 {\n  constructor(options = { children: [] }) {\n    __publicField(this, \"options\");\n    this.options = options;\n  }\n}\nclass Footer2 {\n  constructor(options = { children: [] }) {\n    __publicField(this, \"options\");\n    this.options = options;\n  }\n}\nclass FootNoteReferenceRunAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      id: \"w:id\"\n    });\n  }\n}\nclass FootnoteReference extends XmlComponent {\n  constructor(id) {\n    super(\"w:footnoteReference\");\n    this.root.push(\n      new FootNoteReferenceRunAttributes({\n        id\n      })\n    );\n  }\n}\nclass FootnoteReferenceRun extends Run {\n  constructor(id) {\n    super({ style: \"FootnoteReference\" });\n    this.root.push(new FootnoteReference(id));\n  }\n}\nclass InsertedTextRun extends XmlComponent {\n  constructor(options) {\n    super(\"w:ins\");\n    this.root.push(\n      new ChangeAttributes({\n        id: options.id,\n        author: options.author,\n        date: options.date\n      })\n    );\n    this.addChildElement(new TextRun(options));\n  }\n}\nclass DeletedPage extends XmlComponent {\n  constructor() {\n    super(\"w:delInstrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"PAGE\");\n  }\n}\nclass DeletedNumberOfPages extends XmlComponent {\n  constructor() {\n    super(\"w:delInstrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"NUMPAGES\");\n  }\n}\nclass DeletedNumberOfPagesSection extends XmlComponent {\n  constructor() {\n    super(\"w:delInstrText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(\"SECTIONPAGES\");\n  }\n}\nclass DeletedText extends XmlComponent {\n  constructor(text) {\n    super(\"w:delText\");\n    this.root.push(new TextAttributes({ space: SpaceType.PRESERVE }));\n    this.root.push(text);\n  }\n}\nclass DeletedTextRun extends XmlComponent {\n  constructor(options) {\n    super(\"w:del\");\n    __publicField(this, \"deletedTextRunWrapper\");\n    this.root.push(\n      new ChangeAttributes({\n        id: options.id,\n        author: options.author,\n        date: options.date\n      })\n    );\n    this.deletedTextRunWrapper = new DeletedTextRunWrapper(options);\n    this.addChildElement(this.deletedTextRunWrapper);\n  }\n}\nclass DeletedTextRunWrapper extends XmlComponent {\n  constructor(options) {\n    super(\"w:r\");\n    this.root.push(new RunProperties(options));\n    if (options.children) {\n      for (const child of options.children) {\n        if (typeof child === \"string\") {\n          switch (child) {\n            case PageNumber.CURRENT:\n              this.root.push(new Begin());\n              this.root.push(new DeletedPage());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            case PageNumber.TOTAL_PAGES:\n              this.root.push(new Begin());\n              this.root.push(new DeletedNumberOfPages());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            case PageNumber.TOTAL_PAGES_IN_SECTION:\n              this.root.push(new Begin());\n              this.root.push(new DeletedNumberOfPagesSection());\n              this.root.push(new Separate());\n              this.root.push(new End());\n              break;\n            default:\n              this.root.push(new DeletedText(child));\n              break;\n          }\n          continue;\n        }\n        this.root.push(child);\n      }\n    } else if (options.text) {\n      this.root.push(new DeletedText(options.text));\n    }\n    if (options.break) {\n      for (let i = 0; i < options.break; i++) {\n        this.root.splice(1, 0, new Break$1());\n      }\n    }\n  }\n}\nclass CheckboxSymbolAttributes extends XmlAttributeComponent {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"xmlKeys\", {\n      val: \"w14:val\",\n      symbolfont: \"w14:font\"\n    });\n  }\n}\nclass CheckBoxSymbolElement extends XmlComponent {\n  constructor(name, val, font) {\n    super(name);\n    if (font) {\n      this.root.push(new CheckboxSymbolAttributes({ val: shortHexNumber(val), symbolfont: font }));\n    } else {\n      this.root.push(new CheckboxSymbolAttributes({ val }));\n    }\n  }\n}\nclass CheckBoxUtil extends XmlComponent {\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    super(\"w14:checkbox\");\n    __publicField(this, \"DEFAULT_UNCHECKED_SYMBOL\", \"2610\");\n    __publicField(this, \"DEFAULT_CHECKED_SYMBOL\", \"2612\");\n    __publicField(this, \"DEFAULT_FONT\", \"MS Gothic\");\n    const value = (options == null ? void 0 : options.checked) ? \"1\" : \"0\";\n    let symbol;\n    let font;\n    this.root.push(new CheckBoxSymbolElement(\"w14:checked\", value));\n    symbol = ((_a = options == null ? void 0 : options.checkedState) == null ? void 0 : _a.value) ? (_b = options == null ? void 0 : options.checkedState) == null ? void 0 : _b.value : this.DEFAULT_CHECKED_SYMBOL;\n    font = ((_c = options == null ? void 0 : options.checkedState) == null ? void 0 : _c.font) ? (_d = options == null ? void 0 : options.checkedState) == null ? void 0 : _d.font : this.DEFAULT_FONT;\n    this.root.push(new CheckBoxSymbolElement(\"w14:checkedState\", symbol, font));\n    symbol = ((_e = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _e.value) ? (_f = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _f.value : this.DEFAULT_UNCHECKED_SYMBOL;\n    font = ((_g = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _g.font) ? (_h = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _h.font : this.DEFAULT_FONT;\n    this.root.push(new CheckBoxSymbolElement(\"w14:uncheckedState\", symbol, font));\n  }\n}\nclass CheckBox extends XmlComponent {\n  constructor(options) {\n    var _a, _b, _c, _d;\n    super(\"w:sdt\");\n    // default values per Microsoft\n    __publicField(this, \"DEFAULT_UNCHECKED_SYMBOL\", \"2610\");\n    __publicField(this, \"DEFAULT_CHECKED_SYMBOL\", \"2612\");\n    __publicField(this, \"DEFAULT_FONT\", \"MS Gothic\");\n    const properties = new StructuredDocumentTagProperties(options == null ? void 0 : options.alias);\n    properties.addChildElement(new CheckBoxUtil(options));\n    this.root.push(properties);\n    const content = new StructuredDocumentTagContent();\n    const checkedFont = (_a = options == null ? void 0 : options.checkedState) == null ? void 0 : _a.font;\n    const checkedText = (_b = options == null ? void 0 : options.checkedState) == null ? void 0 : _b.value;\n    const uncheckedFont = (_c = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _c.font;\n    const uncheckedText = (_d = options == null ? void 0 : options.uncheckedState) == null ? void 0 : _d.value;\n    let symbolFont;\n    let char;\n    if (options == null ? void 0 : options.checked) {\n      symbolFont = checkedFont ? checkedFont : this.DEFAULT_FONT;\n      char = checkedText ? checkedText : this.DEFAULT_CHECKED_SYMBOL;\n    } else {\n      symbolFont = uncheckedFont ? uncheckedFont : this.DEFAULT_FONT;\n      char = uncheckedText ? uncheckedText : this.DEFAULT_UNCHECKED_SYMBOL;\n    }\n    const initialRenderedChar = new SymbolRun({\n      char,\n      symbolfont: symbolFont\n    });\n    content.addChildElement(initialRenderedChar);\n    this.root.push(content);\n  }\n}\nconst createPictElement = ({ shape }) => new BuilderElement({\n  name: \"w:pict\",\n  children: [shape]\n});\nconst createTextboxContent = ({ children = [] }) => new BuilderElement({\n  name: \"w:txbxContent\",\n  children\n});\nconst createVmlTextbox = ({ style, children, inset }) => new BuilderElement({\n  name: \"v:textbox\",\n  attributes: {\n    style: {\n      key: \"style\",\n      value: style\n    },\n    insetMode: {\n      key: \"insetmode\",\n      value: inset ? \"custom\" : \"auto\"\n    },\n    inset: {\n      key: \"inset\",\n      value: inset ? `${inset.left}, ${inset.top}, ${inset.right}, ${inset.bottom}` : void 0\n    }\n  },\n  children: [createTextboxContent({ children })]\n});\nconst SHAPE_TYPE = \"#_x0000_t202\";\nconst styleToKeyMap = {\n  flip: \"flip\",\n  height: \"height\",\n  left: \"left\",\n  marginBottom: \"margin-bottom\",\n  marginLeft: \"margin-left\",\n  marginRight: \"margin-right\",\n  marginTop: \"margin-top\",\n  positionHorizontal: \"mso-position-horizontal\",\n  positionHorizontalRelative: \"mso-position-horizontal-relative\",\n  positionVertical: \"mso-position-vertical\",\n  positionVerticalRelative: \"mso-position-vertical-relative\",\n  wrapDistanceBottom: \"mso-wrap-distance-bottom\",\n  wrapDistanceLeft: \"mso-wrap-distance-left\",\n  wrapDistanceRight: \"mso-wrap-distance-right\",\n  wrapDistanceTop: \"mso-wrap-distance-top\",\n  wrapEdited: \"mso-wrap-edited\",\n  wrapStyle: \"mso-wrap-style\",\n  position: \"position\",\n  rotation: \"rotation\",\n  top: \"top\",\n  visibility: \"visibility\",\n  width: \"width\",\n  zIndex: \"z-index\"\n};\nconst formatShapeStyle = (style) => style ? Object.entries(style).map(([key, value]) => `${styleToKeyMap[key]}:${value}`).join(\";\") : void 0;\nconst createShape = ({ id, children, type: type2 = SHAPE_TYPE, style }) => new BuilderElement({\n  name: \"v:shape\",\n  attributes: {\n    id: {\n      key: \"id\",\n      value: id\n    },\n    type: {\n      key: \"type\",\n      value: type2\n    },\n    style: {\n      key: \"style\",\n      value: formatShapeStyle(style)\n    }\n  },\n  children: [createVmlTextbox({ style: \"mso-fit-shape-to-text:t;\", children })]\n});\nclass Textbox extends FileChild {\n  constructor(_a) {\n    var _b = _a, { style, children } = _b, rest = __objRest(_b, [\"style\", \"children\"]);\n    super(\"w:p\");\n    this.root.push(new ParagraphProperties(rest));\n    this.root.push(\n      createPictElement({\n        shape: createShape({\n          children,\n          id: uniqueId(),\n          style\n        })\n      })\n    );\n  }\n}\nvar streamBrowserifyExports = requireStreamBrowserify();\nfunction commonjsRequire(path) {\n  throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar jszip_min = { exports: {} };\nvar hasRequiredJszip_min;\nfunction requireJszip_min() {\n  if (hasRequiredJszip_min) return jszip_min.exports;\n  hasRequiredJszip_min = 1;\n  (function(module, exports) {\n    !function(e) {\n      module.exports = e();\n    }(function() {\n      return function s(a, o, h) {\n        function u(r, e2) {\n          if (!o[r]) {\n            if (!a[r]) {\n              var t = \"function\" == typeof commonjsRequire && commonjsRequire;\n              if (!e2 && t) return t(r, true);\n              if (l) return l(r, true);\n              var n = new Error(\"Cannot find module '\" + r + \"'\");\n              throw n.code = \"MODULE_NOT_FOUND\", n;\n            }\n            var i = o[r] = { exports: {} };\n            a[r][0].call(i.exports, function(e3) {\n              var t2 = a[r][1][e3];\n              return u(t2 || e3);\n            }, i, i.exports, s, a, o, h);\n          }\n          return o[r].exports;\n        }\n        for (var l = \"function\" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++) u(h[e]);\n        return u;\n      }({ 1: [function(e, t, r) {\n        var d = e(\"./utils\"), c = e(\"./support\"), p = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        r.encode = function(e2) {\n          for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = \"string\" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));\n          return h.join(\"\");\n        }, r.decode = function(e2) {\n          var t2, r2, n, i, s, a, o = 0, h = 0, u = \"data:\";\n          if (e2.substr(0, u.length) === u) throw new Error(\"Invalid base64 input, it looks like a data url.\");\n          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, \"\")).length / 4;\n          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error(\"Invalid base64 input, bad content length.\");\n          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);\n          return l;\n        };\n      }, { \"./support\": 30, \"./utils\": 32 }], 2: [function(e, t, r) {\n        var n = e(\"./external\"), i = e(\"./stream/DataWorker\"), s = e(\"./stream/Crc32Probe\"), a = e(\"./stream/DataLengthProbe\");\n        function o(e2, t2, r2, n2, i2) {\n          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;\n        }\n        o.prototype = { getContentWorker: function() {\n          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")), t2 = this;\n          return e2.on(\"end\", function() {\n            if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error(\"Bug : uncompressed data size mismatch\");\n          }), e2;\n        }, getCompressedWorker: function() {\n          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\", this.compressedSize).withStreamInfo(\"uncompressedSize\", this.uncompressedSize).withStreamInfo(\"crc32\", this.crc32).withStreamInfo(\"compression\", this.compression);\n        } }, o.createWorkerFrom = function(e2, t2, r2) {\n          return e2.pipe(new s()).pipe(new a(\"uncompressedSize\")).pipe(t2.compressWorker(r2)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\", t2);\n        }, t.exports = o;\n      }, { \"./external\": 6, \"./stream/Crc32Probe\": 25, \"./stream/DataLengthProbe\": 26, \"./stream/DataWorker\": 27 }], 3: [function(e, t, r) {\n        var n = e(\"./stream/GenericWorker\");\n        r.STORE = { magic: \"\\0\\0\", compressWorker: function() {\n          return new n(\"STORE compression\");\n        }, uncompressWorker: function() {\n          return new n(\"STORE decompression\");\n        } }, r.DEFLATE = e(\"./flate\");\n      }, { \"./flate\": 7, \"./stream/GenericWorker\": 28 }], 4: [function(e, t, r) {\n        var n = e(\"./utils\");\n        var o = function() {\n          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {\n            e2 = r2;\n            for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;\n            t2[r2] = e2;\n          }\n          return t2;\n        }();\n        t.exports = function(e2, t2) {\n          return void 0 !== e2 && e2.length ? \"string\" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {\n            var i = o, s = n2 + r2;\n            e3 ^= -1;\n            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];\n            return -1 ^ e3;\n          }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {\n            var i = o, s = n2 + r2;\n            e3 ^= -1;\n            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];\n            return -1 ^ e3;\n          }(0 | t2, e2, e2.length, 0) : 0;\n        };\n      }, { \"./utils\": 32 }], 5: [function(e, t, r) {\n        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;\n      }, {}], 6: [function(e, t, r) {\n        var n = null;\n        n = \"undefined\" != typeof Promise ? Promise : e(\"lie\"), t.exports = { Promise: n };\n      }, { lie: 37 }], 7: [function(e, t, r) {\n        var n = \"undefined\" != typeof Uint8Array && \"undefined\" != typeof Uint16Array && \"undefined\" != typeof Uint32Array, i = e(\"pako\"), s = e(\"./utils\"), a = e(\"./stream/GenericWorker\"), o = n ? \"uint8array\" : \"array\";\n        function h(e2, t2) {\n          a.call(this, \"FlateWorker/\" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};\n        }\n        r.magic = \"\\b\\0\", s.inherits(h, a), h.prototype.processChunk = function(e2) {\n          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);\n        }, h.prototype.flush = function() {\n          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);\n        }, h.prototype.cleanUp = function() {\n          a.prototype.cleanUp.call(this), this._pako = null;\n        }, h.prototype._createPako = function() {\n          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });\n          var t2 = this;\n          this._pako.onData = function(e2) {\n            t2.push({ data: e2, meta: t2.meta });\n          };\n        }, r.compressWorker = function(e2) {\n          return new h(\"Deflate\", e2);\n        }, r.uncompressWorker = function() {\n          return new h(\"Inflate\", {});\n        };\n      }, { \"./stream/GenericWorker\": 28, \"./utils\": 32, pako: 38 }], 8: [function(e, t, r) {\n        function A(e2, t2) {\n          var r2, n2 = \"\";\n          for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;\n          return n2;\n        }\n        function n(e2, t2, r2, n2, i2, s2) {\n          var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo(\"string\", s2(h.name)), c = I.transformTo(\"string\", O.utf8encode(h.name)), d = h.comment, p = I.transformTo(\"string\", s2(d)), m = I.transformTo(\"string\", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = \"\", v = \"\", y = \"\", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };\n          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);\n          var S = 0;\n          t2 && (S |= 8), l || !_ && !g || (S |= 2048);\n          var z = 0, C = 0;\n          w && (z |= 16), \"UNIX\" === i2 ? (C = 798, z |= function(e3, t3) {\n            var r3 = e3;\n            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;\n          }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {\n            return 63 & (e3 || 0);\n          }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += \"up\" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += \"uc\" + A(y.length, 2) + y);\n          var E = \"\";\n          return E += \"\\n\\0\", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + \"\\0\\0\\0\\0\" + A(z, 4) + A(n2, 4) + f + b + p };\n        }\n        var I = e(\"../utils\"), i = e(\"../stream/GenericWorker\"), O = e(\"../utf8\"), B = e(\"../crc32\"), R = e(\"../signature\");\n        function s(e2, t2, r2, n2) {\n          i.call(this, \"ZipFileWorker\"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];\n        }\n        I.inherits(s, i), s.prototype.push = function(e2) {\n          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;\n          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));\n        }, s.prototype.openedSource = function(e2) {\n          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;\n          var t2 = this.streamFiles && !e2.file.dir;\n          if (t2) {\n            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n            this.push({ data: r2.fileRecord, meta: { percent: 0 } });\n          } else this.accumulate = true;\n        }, s.prototype.closedSource = function(e2) {\n          this.accumulate = false;\n          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n          if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: function(e3) {\n            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);\n          }(e2), meta: { percent: 100 } });\n          else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());\n          this.currentFile = null;\n        }, s.prototype.flush = function() {\n          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });\n          var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {\n            var s2 = I.transformTo(\"string\", i2(n3));\n            return R.CENTRAL_DIRECTORY_END + \"\\0\\0\\0\\0\" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;\n          }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);\n          this.push({ data: n2, meta: { percent: 100 } });\n        }, s.prototype.prepareNextSource = function() {\n          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();\n        }, s.prototype.registerPrevious = function(e2) {\n          this._sources.push(e2);\n          var t2 = this;\n          return e2.on(\"data\", function(e3) {\n            t2.processChunk(e3);\n          }), e2.on(\"end\", function() {\n            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();\n          }), e2.on(\"error\", function(e3) {\n            t2.error(e3);\n          }), this;\n        }, s.prototype.resume = function() {\n          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));\n        }, s.prototype.error = function(e2) {\n          var t2 = this._sources;\n          if (!i.prototype.error.call(this, e2)) return false;\n          for (var r2 = 0; r2 < t2.length; r2++) try {\n            t2[r2].error(e2);\n          } catch (e3) {\n          }\n          return true;\n        }, s.prototype.lock = function() {\n          i.prototype.lock.call(this);\n          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();\n        }, t.exports = s;\n      }, { \"../crc32\": 4, \"../signature\": 23, \"../stream/GenericWorker\": 28, \"../utf8\": 31, \"../utils\": 32 }], 9: [function(e, t, r) {\n        var u = e(\"../compressions\"), n = e(\"./ZipFileWorker\");\n        r.generateWorker = function(e2, a, t2) {\n          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;\n          try {\n            e2.forEach(function(e3, t3) {\n              h++;\n              var r2 = function(e4, t4) {\n                var r3 = e4 || t4, n3 = u[r3];\n                if (!n3) throw new Error(r3 + \" is not a valid compression method !\");\n                return n3;\n              }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;\n              t3._compressWorker(r2, n2).withStreamInfo(\"file\", { name: e3, dir: i, date: s, comment: t3.comment || \"\", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);\n            }), o.entriesCount = h;\n          } catch (e3) {\n            o.error(e3);\n          }\n          return o;\n        };\n      }, { \"../compressions\": 3, \"./ZipFileWorker\": 8 }], 10: [function(e, t, r) {\n        function n() {\n          if (!(this instanceof n)) return new n();\n          if (arguments.length) throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = \"\", this.clone = function() {\n            var e2 = new n();\n            for (var t2 in this) \"function\" != typeof this[t2] && (e2[t2] = this[t2]);\n            return e2;\n          };\n        }\n        (n.prototype = e(\"./object\")).loadAsync = e(\"./load\"), n.support = e(\"./support\"), n.defaults = e(\"./defaults\"), n.version = \"3.10.1\", n.loadAsync = function(e2, t2) {\n          return new n().loadAsync(e2, t2);\n        }, n.external = e(\"./external\"), t.exports = n;\n      }, { \"./defaults\": 5, \"./external\": 6, \"./load\": 11, \"./object\": 15, \"./support\": 30 }], 11: [function(e, t, r) {\n        var u = e(\"./utils\"), i = e(\"./external\"), n = e(\"./utf8\"), s = e(\"./zipEntries\"), a = e(\"./stream/Crc32Probe\"), l = e(\"./nodejsUtils\");\n        function f(n2) {\n          return new i.Promise(function(e2, t2) {\n            var r2 = n2.decompressed.getContentWorker().pipe(new a());\n            r2.on(\"error\", function(e3) {\n              t2(e3);\n            }).on(\"end\", function() {\n              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error(\"Corrupted zip : CRC32 mismatch\")) : e2();\n            }).resume();\n          });\n        }\n        t.exports = function(e2, o) {\n          var h = this;\n          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")) : u.prepareContent(\"the loaded zip file\", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {\n            var t2 = new s(o);\n            return t2.load(e3), t2;\n          }).then(function(e3) {\n            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;\n            if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));\n            return i.Promise.all(t2);\n          }).then(function(e3) {\n            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {\n              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);\n              h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);\n            }\n            return t2.zipComment.length && (h.comment = t2.zipComment), h;\n          });\n        };\n      }, { \"./external\": 6, \"./nodejsUtils\": 14, \"./stream/Crc32Probe\": 25, \"./utf8\": 31, \"./utils\": 32, \"./zipEntries\": 33 }], 12: [function(e, t, r) {\n        var n = e(\"../utils\"), i = e(\"../stream/GenericWorker\");\n        function s(e2, t2) {\n          i.call(this, \"Nodejs stream input adapter for \" + e2), this._upstreamEnded = false, this._bindStream(t2);\n        }\n        n.inherits(s, i), s.prototype._bindStream = function(e2) {\n          var t2 = this;\n          (this._stream = e2).pause(), e2.on(\"data\", function(e3) {\n            t2.push({ data: e3, meta: { percent: 0 } });\n          }).on(\"error\", function(e3) {\n            t2.isPaused ? this.generatedError = e3 : t2.error(e3);\n          }).on(\"end\", function() {\n            t2.isPaused ? t2._upstreamEnded = true : t2.end();\n          });\n        }, s.prototype.pause = function() {\n          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);\n        }, s.prototype.resume = function() {\n          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);\n        }, t.exports = s;\n      }, { \"../stream/GenericWorker\": 28, \"../utils\": 32 }], 13: [function(e, t, r) {\n        var i = e(\"readable-stream\").Readable;\n        function n(e2, t2, r2) {\n          i.call(this, t2), this._helper = e2;\n          var n2 = this;\n          e2.on(\"data\", function(e3, t3) {\n            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);\n          }).on(\"error\", function(e3) {\n            n2.emit(\"error\", e3);\n          }).on(\"end\", function() {\n            n2.push(null);\n          });\n        }\n        e(\"../utils\").inherits(n, i), n.prototype._read = function() {\n          this._helper.resume();\n        }, t.exports = n;\n      }, { \"../utils\": 32, \"readable-stream\": 16 }], 14: [function(e, t, r) {\n        t.exports = { isNode: \"undefined\" != typeof Buffer, newBufferFrom: function(e2, t2) {\n          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);\n          if (\"number\" == typeof e2) throw new Error('The \"data\" argument must not be a number');\n          return new Buffer(e2, t2);\n        }, allocBuffer: function(e2) {\n          if (Buffer.alloc) return Buffer.alloc(e2);\n          var t2 = new Buffer(e2);\n          return t2.fill(0), t2;\n        }, isBuffer: function(e2) {\n          return Buffer.isBuffer(e2);\n        }, isStream: function(e2) {\n          return e2 && \"function\" == typeof e2.on && \"function\" == typeof e2.pause && \"function\" == typeof e2.resume;\n        } };\n      }, {}], 15: [function(e, t, r) {\n        function s(e2, t2, r2) {\n          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);\n          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), \"string\" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);\n          var a2 = \"string\" === i2 && false === s2.binary && false === s2.base64;\n          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = \"\", s2.compression = \"STORE\", i2 = \"string\");\n          var o2 = null;\n          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);\n          var h2 = new d(e2, o2, s2);\n          this.files[e2] = h2;\n        }\n        var i = e(\"./utf8\"), u = e(\"./utils\"), l = e(\"./stream/GenericWorker\"), a = e(\"./stream/StreamHelper\"), f = e(\"./defaults\"), c = e(\"./compressedObject\"), d = e(\"./zipObject\"), o = e(\"./generate\"), p = e(\"./nodejsUtils\"), m = e(\"./nodejs/NodejsStreamInputAdapter\"), _ = function(e2) {\n          \"/\" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));\n          var t2 = e2.lastIndexOf(\"/\");\n          return 0 < t2 ? e2.substring(0, t2) : \"\";\n        }, g = function(e2) {\n          return \"/\" !== e2.slice(-1) && (e2 += \"/\"), e2;\n        }, b = function(e2, t2) {\n          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];\n        };\n        function h(e2) {\n          return \"[object RegExp]\" === Object.prototype.toString.call(e2);\n        }\n        var n = { load: function() {\n          throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n        }, forEach: function(e2) {\n          var t2, r2, n2;\n          for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);\n        }, filter: function(r2) {\n          var n2 = [];\n          return this.forEach(function(e2, t2) {\n            r2(e2, t2) && n2.push(t2);\n          }), n2;\n        }, file: function(e2, t2, r2) {\n          if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;\n          if (h(e2)) {\n            var n2 = e2;\n            return this.filter(function(e3, t3) {\n              return !t3.dir && n2.test(e3);\n            });\n          }\n          var i2 = this.files[this.root + e2];\n          return i2 && !i2.dir ? i2 : null;\n        }, folder: function(r2) {\n          if (!r2) return this;\n          if (h(r2)) return this.filter(function(e3, t3) {\n            return t3.dir && r2.test(e3);\n          });\n          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();\n          return n2.root = t2.name, n2;\n        }, remove: function(r2) {\n          r2 = this.root + r2;\n          var e2 = this.files[r2];\n          if (e2 || (\"/\" !== r2.slice(-1) && (r2 += \"/\"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];\n          else for (var t2 = this.filter(function(e3, t3) {\n            return t3.name.slice(0, r2.length) === r2;\n          }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];\n          return this;\n        }, generate: function() {\n          throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n        }, generateInternalStream: function(e2) {\n          var t2, r2 = {};\n          try {\n            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: \"STORE\", compressionOptions: null, type: \"\", platform: \"DOS\", comment: null, mimeType: \"application/zip\", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), \"binarystring\" === r2.type && (r2.type = \"string\"), !r2.type) throw new Error(\"No output type specified.\");\n            u.checkSupport(r2.type), \"darwin\" !== r2.platform && \"freebsd\" !== r2.platform && \"linux\" !== r2.platform && \"sunos\" !== r2.platform || (r2.platform = \"UNIX\"), \"win32\" === r2.platform && (r2.platform = \"DOS\");\n            var n2 = r2.comment || this.comment || \"\";\n            t2 = o.generateWorker(this, r2, n2);\n          } catch (e3) {\n            (t2 = new l(\"error\")).error(e3);\n          }\n          return new a(t2, r2.type || \"string\", r2.mimeType);\n        }, generateAsync: function(e2, t2) {\n          return this.generateInternalStream(e2).accumulate(t2);\n        }, generateNodeStream: function(e2, t2) {\n          return (e2 = e2 || {}).type || (e2.type = \"nodebuffer\"), this.generateInternalStream(e2).toNodejsStream(t2);\n        } };\n        t.exports = n;\n      }, { \"./compressedObject\": 2, \"./defaults\": 5, \"./generate\": 9, \"./nodejs/NodejsStreamInputAdapter\": 12, \"./nodejsUtils\": 14, \"./stream/GenericWorker\": 28, \"./stream/StreamHelper\": 29, \"./utf8\": 31, \"./utils\": 32, \"./zipObject\": 35 }], 16: [function(e, t, r) {\n        t.exports = e(\"stream\");\n      }, { stream: void 0 }], 17: [function(e, t, r) {\n        var n = e(\"./DataReader\");\n        function i(e2) {\n          n.call(this, e2);\n          for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];\n        }\n        e(\"../utils\").inherits(i, n), i.prototype.byteAt = function(e2) {\n          return this.data[this.zero + e2];\n        }, i.prototype.lastIndexOfSignature = function(e2) {\n          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;\n          return -1;\n        }, i.prototype.readAndCheckSignature = function(e2) {\n          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);\n          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];\n        }, i.prototype.readData = function(e2) {\n          if (this.checkOffset(e2), 0 === e2) return [];\n          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);\n          return this.index += e2, t2;\n        }, t.exports = i;\n      }, { \"../utils\": 32, \"./DataReader\": 18 }], 18: [function(e, t, r) {\n        var n = e(\"../utils\");\n        function i(e2) {\n          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;\n        }\n        i.prototype = { checkOffset: function(e2) {\n          this.checkIndex(this.index + e2);\n        }, checkIndex: function(e2) {\n          if (this.length < this.zero + e2 || e2 < 0) throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + e2 + \"). Corrupted zip ?\");\n        }, setIndex: function(e2) {\n          this.checkIndex(e2), this.index = e2;\n        }, skip: function(e2) {\n          this.setIndex(this.index + e2);\n        }, byteAt: function() {\n        }, readInt: function(e2) {\n          var t2, r2 = 0;\n          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);\n          return this.index += e2, r2;\n        }, readString: function(e2) {\n          return n.transformTo(\"string\", this.readData(e2));\n        }, readData: function() {\n        }, lastIndexOfSignature: function() {\n        }, readAndCheckSignature: function() {\n        }, readDate: function() {\n          var e2 = this.readInt(4);\n          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));\n        } }, t.exports = i;\n      }, { \"../utils\": 32 }], 19: [function(e, t, r) {\n        var n = e(\"./Uint8ArrayReader\");\n        function i(e2) {\n          n.call(this, e2);\n        }\n        e(\"../utils\").inherits(i, n), i.prototype.readData = function(e2) {\n          this.checkOffset(e2);\n          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);\n          return this.index += e2, t2;\n        }, t.exports = i;\n      }, { \"../utils\": 32, \"./Uint8ArrayReader\": 21 }], 20: [function(e, t, r) {\n        var n = e(\"./DataReader\");\n        function i(e2) {\n          n.call(this, e2);\n        }\n        e(\"../utils\").inherits(i, n), i.prototype.byteAt = function(e2) {\n          return this.data.charCodeAt(this.zero + e2);\n        }, i.prototype.lastIndexOfSignature = function(e2) {\n          return this.data.lastIndexOf(e2) - this.zero;\n        }, i.prototype.readAndCheckSignature = function(e2) {\n          return e2 === this.readData(4);\n        }, i.prototype.readData = function(e2) {\n          this.checkOffset(e2);\n          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);\n          return this.index += e2, t2;\n        }, t.exports = i;\n      }, { \"../utils\": 32, \"./DataReader\": 18 }], 21: [function(e, t, r) {\n        var n = e(\"./ArrayReader\");\n        function i(e2) {\n          n.call(this, e2);\n        }\n        e(\"../utils\").inherits(i, n), i.prototype.readData = function(e2) {\n          if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);\n          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);\n          return this.index += e2, t2;\n        }, t.exports = i;\n      }, { \"../utils\": 32, \"./ArrayReader\": 17 }], 22: [function(e, t, r) {\n        var n = e(\"../utils\"), i = e(\"../support\"), s = e(\"./ArrayReader\"), a = e(\"./StringReader\"), o = e(\"./NodeBufferReader\"), h = e(\"./Uint8ArrayReader\");\n        t.exports = function(e2) {\n          var t2 = n.getTypeOf(e2);\n          return n.checkSupport(t2), \"string\" !== t2 || i.uint8array ? \"nodebuffer\" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo(\"uint8array\", e2)) : new s(n.transformTo(\"array\", e2)) : new a(e2);\n        };\n      }, { \"../support\": 30, \"../utils\": 32, \"./ArrayReader\": 17, \"./NodeBufferReader\": 19, \"./StringReader\": 20, \"./Uint8ArrayReader\": 21 }], 23: [function(e, t, r) {\n        r.LOCAL_FILE_HEADER = \"PK\u0003\u0004\", r.CENTRAL_FILE_HEADER = \"PK\u0001\u0002\", r.CENTRAL_DIRECTORY_END = \"PK\u0005\u0006\", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\u0006\\x07\", r.ZIP64_CENTRAL_DIRECTORY_END = \"PK\u0006\u0006\", r.DATA_DESCRIPTOR = \"PK\\x07\\b\";\n      }, {}], 24: [function(e, t, r) {\n        var n = e(\"./GenericWorker\"), i = e(\"../utils\");\n        function s(e2) {\n          n.call(this, \"ConvertWorker to \" + e2), this.destType = e2;\n        }\n        i.inherits(s, n), s.prototype.processChunk = function(e2) {\n          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });\n        }, t.exports = s;\n      }, { \"../utils\": 32, \"./GenericWorker\": 28 }], 25: [function(e, t, r) {\n        var n = e(\"./GenericWorker\"), i = e(\"../crc32\");\n        function s() {\n          n.call(this, \"Crc32Probe\"), this.withStreamInfo(\"crc32\", 0);\n        }\n        e(\"../utils\").inherits(s, n), s.prototype.processChunk = function(e2) {\n          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);\n        }, t.exports = s;\n      }, { \"../crc32\": 4, \"../utils\": 32, \"./GenericWorker\": 28 }], 26: [function(e, t, r) {\n        var n = e(\"../utils\"), i = e(\"./GenericWorker\");\n        function s(e2) {\n          i.call(this, \"DataLengthProbe for \" + e2), this.propName = e2, this.withStreamInfo(e2, 0);\n        }\n        n.inherits(s, i), s.prototype.processChunk = function(e2) {\n          if (e2) {\n            var t2 = this.streamInfo[this.propName] || 0;\n            this.streamInfo[this.propName] = t2 + e2.data.length;\n          }\n          i.prototype.processChunk.call(this, e2);\n        }, t.exports = s;\n      }, { \"../utils\": 32, \"./GenericWorker\": 28 }], 27: [function(e, t, r) {\n        var n = e(\"../utils\"), i = e(\"./GenericWorker\");\n        function s(e2) {\n          i.call(this, \"DataWorker\");\n          var t2 = this;\n          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = \"\", this._tickScheduled = false, e2.then(function(e3) {\n            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();\n          }, function(e3) {\n            t2.error(e3);\n          });\n        }\n        n.inherits(s, i), s.prototype.cleanUp = function() {\n          i.prototype.cleanUp.call(this), this.data = null;\n        }, s.prototype.resume = function() {\n          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);\n        }, s.prototype._tickAndRepeat = function() {\n          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));\n        }, s.prototype._tick = function() {\n          if (this.isPaused || this.isFinished) return false;\n          var e2 = null, t2 = Math.min(this.max, this.index + 16384);\n          if (this.index >= this.max) return this.end();\n          switch (this.type) {\n            case \"string\":\n              e2 = this.data.substring(this.index, t2);\n              break;\n            case \"uint8array\":\n              e2 = this.data.subarray(this.index, t2);\n              break;\n            case \"array\":\n            case \"nodebuffer\":\n              e2 = this.data.slice(this.index, t2);\n          }\n          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });\n        }, t.exports = s;\n      }, { \"../utils\": 32, \"./GenericWorker\": 28 }], 28: [function(e, t, r) {\n        function n(e2) {\n          this.name = e2 || \"default\", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;\n        }\n        n.prototype = { push: function(e2) {\n          this.emit(\"data\", e2);\n        }, end: function() {\n          if (this.isFinished) return false;\n          this.flush();\n          try {\n            this.emit(\"end\"), this.cleanUp(), this.isFinished = true;\n          } catch (e2) {\n            this.emit(\"error\", e2);\n          }\n          return true;\n        }, error: function(e2) {\n          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit(\"error\", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);\n        }, on: function(e2, t2) {\n          return this._listeners[e2].push(t2), this;\n        }, cleanUp: function() {\n          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];\n        }, emit: function(e2, t2) {\n          if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);\n        }, pipe: function(e2) {\n          return e2.registerPrevious(this);\n        }, registerPrevious: function(e2) {\n          if (this.isLocked) throw new Error(\"The stream '\" + this + \"' has already been used.\");\n          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;\n          var t2 = this;\n          return e2.on(\"data\", function(e3) {\n            t2.processChunk(e3);\n          }), e2.on(\"end\", function() {\n            t2.end();\n          }), e2.on(\"error\", function(e3) {\n            t2.error(e3);\n          }), this;\n        }, pause: function() {\n          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);\n        }, resume: function() {\n          if (!this.isPaused || this.isFinished) return false;\n          var e2 = this.isPaused = false;\n          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;\n        }, flush: function() {\n        }, processChunk: function(e2) {\n          this.push(e2);\n        }, withStreamInfo: function(e2, t2) {\n          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;\n        }, mergeStreamInfo: function() {\n          for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);\n        }, lock: function() {\n          if (this.isLocked) throw new Error(\"The stream '\" + this + \"' has already been used.\");\n          this.isLocked = true, this.previous && this.previous.lock();\n        }, toString: function() {\n          var e2 = \"Worker \" + this.name;\n          return this.previous ? this.previous + \" -> \" + e2 : e2;\n        } }, t.exports = n;\n      }, {}], 29: [function(e, t, r) {\n        var h = e(\"../utils\"), i = e(\"./ConvertWorker\"), s = e(\"./GenericWorker\"), u = e(\"../base64\"), n = e(\"../support\"), a = e(\"../external\"), o = null;\n        if (n.nodestream) try {\n          o = e(\"../nodejs/NodejsStreamOutputAdapter\");\n        } catch (e2) {\n        }\n        function l(e2, o2) {\n          return new a.Promise(function(t2, r2) {\n            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;\n            e2.on(\"data\", function(e3, t3) {\n              n2.push(e3), o2 && o2(t3);\n            }).on(\"error\", function(e3) {\n              n2 = [], r2(e3);\n            }).on(\"end\", function() {\n              try {\n                var e3 = function(e4, t3, r3) {\n                  switch (e4) {\n                    case \"blob\":\n                      return h.newBlob(h.transformTo(\"arraybuffer\", t3), r3);\n                    case \"base64\":\n                      return u.encode(t3);\n                    default:\n                      return h.transformTo(e4, t3);\n                  }\n                }(s2, function(e4, t3) {\n                  var r3, n3 = 0, i3 = null, s3 = 0;\n                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;\n                  switch (e4) {\n                    case \"string\":\n                      return t3.join(\"\");\n                    case \"array\":\n                      return Array.prototype.concat.apply([], t3);\n                    case \"uint8array\":\n                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;\n                      return i3;\n                    case \"nodebuffer\":\n                      return Buffer.concat(t3);\n                    default:\n                      throw new Error(\"concat : unsupported type '\" + e4 + \"'\");\n                  }\n                }(i2, n2), a2);\n                t2(e3);\n              } catch (e4) {\n                r2(e4);\n              }\n              n2 = [];\n            }).resume();\n          });\n        }\n        function f(e2, t2, r2) {\n          var n2 = t2;\n          switch (t2) {\n            case \"blob\":\n            case \"arraybuffer\":\n              n2 = \"uint8array\";\n              break;\n            case \"base64\":\n              n2 = \"string\";\n          }\n          try {\n            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();\n          } catch (e3) {\n            this._worker = new s(\"error\"), this._worker.error(e3);\n          }\n        }\n        f.prototype = { accumulate: function(e2) {\n          return l(this, e2);\n        }, on: function(e2, t2) {\n          var r2 = this;\n          return \"data\" === e2 ? this._worker.on(e2, function(e3) {\n            t2.call(r2, e3.data, e3.meta);\n          }) : this._worker.on(e2, function() {\n            h.delay(t2, arguments, r2);\n          }), this;\n        }, resume: function() {\n          return h.delay(this._worker.resume, [], this._worker), this;\n        }, pause: function() {\n          return this._worker.pause(), this;\n        }, toNodejsStream: function(e2) {\n          if (h.checkSupport(\"nodestream\"), \"nodebuffer\" !== this._outputType) throw new Error(this._outputType + \" is not supported by this method\");\n          return new o(this, { objectMode: \"nodebuffer\" !== this._outputType }, e2);\n        } }, t.exports = f;\n      }, { \"../base64\": 1, \"../external\": 6, \"../nodejs/NodejsStreamOutputAdapter\": 13, \"../support\": 30, \"../utils\": 32, \"./ConvertWorker\": 24, \"./GenericWorker\": 28 }], 30: [function(e, t, r) {\n        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = \"undefined\" != typeof ArrayBuffer && \"undefined\" != typeof Uint8Array, r.nodebuffer = \"undefined\" != typeof Buffer, r.uint8array = \"undefined\" != typeof Uint8Array, \"undefined\" == typeof ArrayBuffer) r.blob = false;\n        else {\n          var n = new ArrayBuffer(0);\n          try {\n            r.blob = 0 === new Blob([n], { type: \"application/zip\" }).size;\n          } catch (e2) {\n            try {\n              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();\n              i.append(n), r.blob = 0 === i.getBlob(\"application/zip\").size;\n            } catch (e3) {\n              r.blob = false;\n            }\n          }\n        }\n        try {\n          r.nodestream = !!e(\"readable-stream\").Readable;\n        } catch (e2) {\n          r.nodestream = false;\n        }\n      }, { \"readable-stream\": 16 }], 31: [function(e, t, s) {\n        for (var o = e(\"./utils\"), h = e(\"./support\"), r = e(\"./nodejsUtils\"), n = e(\"./stream/GenericWorker\"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;\n        u[254] = u[254] = 1;\n        function a() {\n          n.call(this, \"utf-8 decode\"), this.leftOver = null;\n        }\n        function l() {\n          n.call(this, \"utf-8 encode\");\n        }\n        s.utf8encode = function(e2) {\n          return h.nodebuffer ? r.newBufferFrom(e2, \"utf-8\") : function(e3) {\n            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;\n            for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;\n            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);\n            return t2;\n          }(e2);\n        }, s.utf8decode = function(e2) {\n          return h.nodebuffer ? o.transformTo(\"nodebuffer\", e2).toString(\"utf-8\") : function(e3) {\n            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);\n            for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;\n            else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;\n            else {\n              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;\n              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);\n            }\n            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);\n          }(e2 = o.transformTo(h.uint8array ? \"uint8array\" : \"array\", e2));\n        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {\n          var t2 = o.transformTo(h.uint8array ? \"uint8array\" : \"array\", e2.data);\n          if (this.leftOver && this.leftOver.length) {\n            if (h.uint8array) {\n              var r2 = t2;\n              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);\n            } else t2 = this.leftOver.concat(t2);\n            this.leftOver = null;\n          }\n          var n2 = function(e3, t3) {\n            var r3;\n            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;\n            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;\n          }(t2), i2 = t2;\n          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });\n        }, a.prototype.flush = function() {\n          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);\n        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {\n          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });\n        }, s.Utf8EncodeWorker = l;\n      }, { \"./nodejsUtils\": 14, \"./stream/GenericWorker\": 28, \"./support\": 30, \"./utils\": 32 }], 32: [function(e, t, a) {\n        var o = e(\"./support\"), h = e(\"./base64\"), r = e(\"./nodejsUtils\"), u = e(\"./external\");\n        function n(e2) {\n          return e2;\n        }\n        function l(e2, t2) {\n          for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);\n          return t2;\n        }\n        e(\"setimmediate\"), a.newBlob = function(t2, r2) {\n          a.checkSupport(\"blob\");\n          try {\n            return new Blob([t2], { type: r2 });\n          } catch (e2) {\n            try {\n              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();\n              return n2.append(t2), n2.getBlob(r2);\n            } catch (e3) {\n              throw new Error(\"Bug : can't construct the Blob.\");\n            }\n          }\n        };\n        var i = { stringifyByChunk: function(e2, t2, r2) {\n          var n2 = [], i2 = 0, s2 = e2.length;\n          if (s2 <= r2) return String.fromCharCode.apply(null, e2);\n          for (; i2 < s2; ) \"array\" === t2 || \"nodebuffer\" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;\n          return n2.join(\"\");\n        }, stringifyByChar: function(e2) {\n          for (var t2 = \"\", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);\n          return t2;\n        }, applyCanBeUsed: { uint8array: function() {\n          try {\n            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;\n          } catch (e2) {\n            return false;\n          }\n        }(), nodebuffer: function() {\n          try {\n            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;\n          } catch (e2) {\n            return false;\n          }\n        }() } };\n        function s(e2) {\n          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;\n          if (\"uint8array\" === r2 ? n2 = i.applyCanBeUsed.uint8array : \"nodebuffer\" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {\n            return i.stringifyByChunk(e2, r2, t2);\n          } catch (e3) {\n            t2 = Math.floor(t2 / 2);\n          }\n          return i.stringifyByChar(e2);\n        }\n        function f(e2, t2) {\n          for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];\n          return t2;\n        }\n        a.applyFromCharCode = s;\n        var c = {};\n        c.string = { string: n, array: function(e2) {\n          return l(e2, new Array(e2.length));\n        }, arraybuffer: function(e2) {\n          return c.string.uint8array(e2).buffer;\n        }, uint8array: function(e2) {\n          return l(e2, new Uint8Array(e2.length));\n        }, nodebuffer: function(e2) {\n          return l(e2, r.allocBuffer(e2.length));\n        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {\n          return new Uint8Array(e2).buffer;\n        }, uint8array: function(e2) {\n          return new Uint8Array(e2);\n        }, nodebuffer: function(e2) {\n          return r.newBufferFrom(e2);\n        } }, c.arraybuffer = { string: function(e2) {\n          return s(new Uint8Array(e2));\n        }, array: function(e2) {\n          return f(new Uint8Array(e2), new Array(e2.byteLength));\n        }, arraybuffer: n, uint8array: function(e2) {\n          return new Uint8Array(e2);\n        }, nodebuffer: function(e2) {\n          return r.newBufferFrom(new Uint8Array(e2));\n        } }, c.uint8array = { string: s, array: function(e2) {\n          return f(e2, new Array(e2.length));\n        }, arraybuffer: function(e2) {\n          return e2.buffer;\n        }, uint8array: n, nodebuffer: function(e2) {\n          return r.newBufferFrom(e2);\n        } }, c.nodebuffer = { string: s, array: function(e2) {\n          return f(e2, new Array(e2.length));\n        }, arraybuffer: function(e2) {\n          return c.nodebuffer.uint8array(e2).buffer;\n        }, uint8array: function(e2) {\n          return f(e2, new Uint8Array(e2.length));\n        }, nodebuffer: n }, a.transformTo = function(e2, t2) {\n          if (t2 = t2 || \"\", !e2) return t2;\n          a.checkSupport(e2);\n          var r2 = a.getTypeOf(t2);\n          return c[r2][e2](t2);\n        }, a.resolve = function(e2) {\n          for (var t2 = e2.split(\"/\"), r2 = [], n2 = 0; n2 < t2.length; n2++) {\n            var i2 = t2[n2];\n            \".\" === i2 || \"\" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (\"..\" === i2 ? r2.pop() : r2.push(i2));\n          }\n          return r2.join(\"/\");\n        }, a.getTypeOf = function(e2) {\n          return \"string\" == typeof e2 ? \"string\" : \"[object Array]\" === Object.prototype.toString.call(e2) ? \"array\" : o.nodebuffer && r.isBuffer(e2) ? \"nodebuffer\" : o.uint8array && e2 instanceof Uint8Array ? \"uint8array\" : o.arraybuffer && e2 instanceof ArrayBuffer ? \"arraybuffer\" : void 0;\n        }, a.checkSupport = function(e2) {\n          if (!o[e2.toLowerCase()]) throw new Error(e2 + \" is not supported by this platform\");\n        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {\n          var t2, r2, n2 = \"\";\n          for (r2 = 0; r2 < (e2 || \"\").length; r2++) n2 += \"\\\\x\" + ((t2 = e2.charCodeAt(r2)) < 16 ? \"0\" : \"\") + t2.toString(16).toUpperCase();\n          return n2;\n        }, a.delay = function(e2, t2, r2) {\n          setImmediate(function() {\n            e2.apply(r2 || null, t2 || []);\n          });\n        }, a.inherits = function(e2, t2) {\n          function r2() {\n          }\n          r2.prototype = t2.prototype, e2.prototype = new r2();\n        }, a.extend = function() {\n          var e2, t2, r2 = {};\n          for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);\n          return r2;\n        }, a.prepareContent = function(r2, e2, n2, i2, s2) {\n          return u.Promise.resolve(e2).then(function(n3) {\n            return o.blob && (n3 instanceof Blob || -1 !== [\"[object File]\", \"[object Blob]\"].indexOf(Object.prototype.toString.call(n3))) && \"undefined\" != typeof FileReader ? new u.Promise(function(t2, r3) {\n              var e3 = new FileReader();\n              e3.onload = function(e4) {\n                t2(e4.target.result);\n              }, e3.onerror = function(e4) {\n                r3(e4.target.error);\n              }, e3.readAsArrayBuffer(n3);\n            }) : n3;\n          }).then(function(e3) {\n            var t2 = a.getTypeOf(e3);\n            return t2 ? (\"arraybuffer\" === t2 ? e3 = a.transformTo(\"uint8array\", e3) : \"string\" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {\n              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));\n            }(e3))), e3) : u.Promise.reject(new Error(\"Can't read the data of '\" + r2 + \"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"));\n          });\n        };\n      }, { \"./base64\": 1, \"./external\": 6, \"./nodejsUtils\": 14, \"./support\": 30, setimmediate: 54 }], 33: [function(e, t, r) {\n        var n = e(\"./reader/readerFor\"), i = e(\"./utils\"), s = e(\"./signature\"), a = e(\"./zipEntry\"), o = e(\"./support\");\n        function h(e2) {\n          this.files = [], this.loadOptions = e2;\n        }\n        h.prototype = { checkSignature: function(e2) {\n          if (!this.reader.readAndCheckSignature(e2)) {\n            this.reader.index -= 4;\n            var t2 = this.reader.readString(4);\n            throw new Error(\"Corrupted zip or bug: unexpected signature (\" + i.pretty(t2) + \", expected \" + i.pretty(e2) + \")\");\n          }\n        }, isSignature: function(e2, t2) {\n          var r2 = this.reader.index;\n          this.reader.setIndex(e2);\n          var n2 = this.reader.readString(4) === t2;\n          return this.reader.setIndex(r2), n2;\n        }, readBlockEndOfCentral: function() {\n          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);\n          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? \"uint8array\" : \"array\", r2 = i.transformTo(t2, e2);\n          this.zipComment = this.loadOptions.decodeFileName(r2);\n        }, readBlockZip64EndOfCentral: function() {\n          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};\n          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };\n        }, readBlockZip64EndOfCentralLocator: function() {\n          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error(\"Multi-volumes zip are not supported\");\n        }, readLocalFiles: function() {\n          var e2, t2;\n          for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();\n        }, readCentralDir: function() {\n          var e2;\n          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);\n          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n        }, readEndOfCentral: function() {\n          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);\n          if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html\") : new Error(\"Corrupted zip: can't find end of central directory\");\n          this.reader.setIndex(e2);\n          var t2 = e2;\n          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {\n            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();\n          }\n          var r2 = this.centralDirOffset + this.centralDirSize;\n          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);\n          var n2 = t2 - r2;\n          if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);\n          else if (n2 < 0) throw new Error(\"Corrupted zip: missing \" + Math.abs(n2) + \" bytes.\");\n        }, prepareReader: function(e2) {\n          this.reader = n(e2);\n        }, load: function(e2) {\n          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();\n        } }, t.exports = h;\n      }, { \"./reader/readerFor\": 22, \"./signature\": 23, \"./support\": 30, \"./utils\": 32, \"./zipEntry\": 34 }], 34: [function(e, t, r) {\n        var n = e(\"./reader/readerFor\"), s = e(\"./utils\"), i = e(\"./compressedObject\"), a = e(\"./crc32\"), o = e(\"./utf8\"), h = e(\"./compressions\"), u = e(\"./support\");\n        function l(e2, t2) {\n          this.options = e2, this.loadOptions = t2;\n        }\n        l.prototype = { isEncrypted: function() {\n          return 1 == (1 & this.bitFlag);\n        }, useUTF8: function() {\n          return 2048 == (2048 & this.bitFlag);\n        }, readLocalPart: function(e2) {\n          var t2, r2;\n          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");\n          if (null === (t2 = function(e3) {\n            for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3) return h[t3];\n            return null;\n          }(this.compressionMethod))) throw new Error(\"Corrupted zip : compression \" + s.pretty(this.compressionMethod) + \" unknown (inner file : \" + s.transformTo(\"string\", this.fileName) + \")\");\n          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));\n        }, readCentralPart: function(e2) {\n          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);\n          var t2 = e2.readInt(2);\n          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error(\"Encrypted zip are not supported\");\n          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);\n        }, processAttributes: function() {\n          this.unixPermissions = null, this.dosPermissions = null;\n          var e2 = this.versionMadeBy >> 8;\n          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || \"/\" !== this.fileNameStr.slice(-1) || (this.dir = true);\n        }, parseZIP64ExtraField: function() {\n          if (this.extraFields[1]) {\n            var e2 = n(this.extraFields[1].value);\n            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));\n          }\n        }, readExtraFields: function(e2) {\n          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;\n          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };\n          e2.setIndex(i2);\n        }, handleUTF8: function() {\n          var e2 = u.uint8array ? \"uint8array\" : \"array\";\n          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);\n          else {\n            var t2 = this.findExtraFieldUnicodePath();\n            if (null !== t2) this.fileNameStr = t2;\n            else {\n              var r2 = s.transformTo(e2, this.fileName);\n              this.fileNameStr = this.loadOptions.decodeFileName(r2);\n            }\n            var n2 = this.findExtraFieldUnicodeComment();\n            if (null !== n2) this.fileCommentStr = n2;\n            else {\n              var i2 = s.transformTo(e2, this.fileComment);\n              this.fileCommentStr = this.loadOptions.decodeFileName(i2);\n            }\n          }\n        }, findExtraFieldUnicodePath: function() {\n          var e2 = this.extraFields[28789];\n          if (e2) {\n            var t2 = n(e2.value);\n            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));\n          }\n          return null;\n        }, findExtraFieldUnicodeComment: function() {\n          var e2 = this.extraFields[25461];\n          if (e2) {\n            var t2 = n(e2.value);\n            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));\n          }\n          return null;\n        } }, t.exports = l;\n      }, { \"./compressedObject\": 2, \"./compressions\": 3, \"./crc32\": 4, \"./reader/readerFor\": 22, \"./support\": 30, \"./utf8\": 31, \"./utils\": 32 }], 35: [function(e, t, r) {\n        function n(e2, t2, r2) {\n          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };\n        }\n        var s = e(\"./stream/StreamHelper\"), i = e(\"./stream/DataWorker\"), a = e(\"./utf8\"), o = e(\"./compressedObject\"), h = e(\"./stream/GenericWorker\");\n        n.prototype = { internalStream: function(e2) {\n          var t2 = null, r2 = \"string\";\n          try {\n            if (!e2) throw new Error(\"No output type specified.\");\n            var n2 = \"string\" === (r2 = e2.toLowerCase()) || \"text\" === r2;\n            \"binarystring\" !== r2 && \"text\" !== r2 || (r2 = \"string\"), t2 = this._decompressWorker();\n            var i2 = !this._dataBinary;\n            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));\n          } catch (e3) {\n            (t2 = new h(\"error\")).error(e3);\n          }\n          return new s(t2, r2, \"\");\n        }, async: function(e2, t2) {\n          return this.internalStream(e2).accumulate(t2);\n        }, nodeStream: function(e2, t2) {\n          return this.internalStream(e2 || \"nodebuffer\").toNodejsStream(t2);\n        }, _compressWorker: function(e2, t2) {\n          if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();\n          var r2 = this._decompressWorker();\n          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);\n        }, _decompressWorker: function() {\n          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);\n        } };\n        for (var u = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"], l = function() {\n          throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n        }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;\n        t.exports = n;\n      }, { \"./compressedObject\": 2, \"./stream/DataWorker\": 27, \"./stream/GenericWorker\": 28, \"./stream/StreamHelper\": 29, \"./utf8\": 31 }], 36: [function(e, l, t) {\n        (function(t2) {\n          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;\n          if (e2) {\n            var i = 0, s = new e2(u), a = t2.document.createTextNode(\"\");\n            s.observe(a, { characterData: true }), r = function() {\n              a.data = i = ++i % 2;\n            };\n          } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = \"document\" in t2 && \"onreadystatechange\" in t2.document.createElement(\"script\") ? function() {\n            var e3 = t2.document.createElement(\"script\");\n            e3.onreadystatechange = function() {\n              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;\n            }, t2.document.documentElement.appendChild(e3);\n          } : function() {\n            setTimeout(u, 0);\n          };\n          else {\n            var o = new t2.MessageChannel();\n            o.port1.onmessage = u, r = function() {\n              o.port2.postMessage(0);\n            };\n          }\n          var h = [];\n          function u() {\n            var e3, t3;\n            n = true;\n            for (var r2 = h.length; r2; ) {\n              for (t3 = h, h = [], e3 = -1; ++e3 < r2; ) t3[e3]();\n              r2 = h.length;\n            }\n            n = false;\n          }\n          l.exports = function(e3) {\n            1 !== h.push(e3) || n || r();\n          };\n        }).call(this, \"undefined\" != typeof commonjsGlobal ? commonjsGlobal : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n      }, {}], 37: [function(e, t, r) {\n        var i = e(\"immediate\");\n        function u() {\n        }\n        var l = {}, s = [\"REJECTED\"], a = [\"FULFILLED\"], n = [\"PENDING\"];\n        function o(e2) {\n          if (\"function\" != typeof e2) throw new TypeError(\"resolver must be a function\");\n          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);\n        }\n        function h(e2, t2, r2) {\n          this.promise = e2, \"function\" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), \"function\" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);\n        }\n        function f(t2, r2, n2) {\n          i(function() {\n            var e2;\n            try {\n              e2 = r2(n2);\n            } catch (e3) {\n              return l.reject(t2, e3);\n            }\n            e2 === t2 ? l.reject(t2, new TypeError(\"Cannot resolve promise with itself\")) : l.resolve(t2, e2);\n          });\n        }\n        function c(e2) {\n          var t2 = e2 && e2.then;\n          if (e2 && (\"object\" == typeof e2 || \"function\" == typeof e2) && \"function\" == typeof t2) return function() {\n            t2.apply(e2, arguments);\n          };\n        }\n        function d(t2, e2) {\n          var r2 = false;\n          function n2(e3) {\n            r2 || (r2 = true, l.reject(t2, e3));\n          }\n          function i2(e3) {\n            r2 || (r2 = true, l.resolve(t2, e3));\n          }\n          var s2 = p(function() {\n            e2(i2, n2);\n          });\n          \"error\" === s2.status && n2(s2.value);\n        }\n        function p(e2, t2) {\n          var r2 = {};\n          try {\n            r2.value = e2(t2), r2.status = \"success\";\n          } catch (e3) {\n            r2.status = \"error\", r2.value = e3;\n          }\n          return r2;\n        }\n        (t.exports = o).prototype.finally = function(t2) {\n          if (\"function\" != typeof t2) return this;\n          var r2 = this.constructor;\n          return this.then(function(e2) {\n            return r2.resolve(t2()).then(function() {\n              return e2;\n            });\n          }, function(e2) {\n            return r2.resolve(t2()).then(function() {\n              throw e2;\n            });\n          });\n        }, o.prototype.catch = function(e2) {\n          return this.then(null, e2);\n        }, o.prototype.then = function(e2, t2) {\n          if (\"function\" != typeof e2 && this.state === a || \"function\" != typeof t2 && this.state === s) return this;\n          var r2 = new this.constructor(u);\n          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));\n          return r2;\n        }, h.prototype.callFulfilled = function(e2) {\n          l.resolve(this.promise, e2);\n        }, h.prototype.otherCallFulfilled = function(e2) {\n          f(this.promise, this.onFulfilled, e2);\n        }, h.prototype.callRejected = function(e2) {\n          l.reject(this.promise, e2);\n        }, h.prototype.otherCallRejected = function(e2) {\n          f(this.promise, this.onRejected, e2);\n        }, l.resolve = function(e2, t2) {\n          var r2 = p(c, t2);\n          if (\"error\" === r2.status) return l.reject(e2, r2.value);\n          var n2 = r2.value;\n          if (n2) d(e2, n2);\n          else {\n            e2.state = a, e2.outcome = t2;\n            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);\n          }\n          return e2;\n        }, l.reject = function(e2, t2) {\n          e2.state = s, e2.outcome = t2;\n          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);\n          return e2;\n        }, o.resolve = function(e2) {\n          if (e2 instanceof this) return e2;\n          return l.resolve(new this(u), e2);\n        }, o.reject = function(e2) {\n          var t2 = new this(u);\n          return l.reject(t2, e2);\n        }, o.all = function(e2) {\n          var r2 = this;\n          if (\"[object Array]\" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError(\"must be an array\"));\n          var n2 = e2.length, i2 = false;\n          if (!n2) return this.resolve([]);\n          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);\n          for (; ++t2 < n2; ) h2(e2[t2], t2);\n          return o2;\n          function h2(e3, t3) {\n            r2.resolve(e3).then(function(e4) {\n              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));\n            }, function(e4) {\n              i2 || (i2 = true, l.reject(o2, e4));\n            });\n          }\n        }, o.race = function(e2) {\n          var t2 = this;\n          if (\"[object Array]\" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError(\"must be an array\"));\n          var r2 = e2.length, n2 = false;\n          if (!r2) return this.resolve([]);\n          var i2 = -1, s2 = new this(u);\n          for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {\n            n2 || (n2 = true, l.resolve(s2, e3));\n          }, function(e3) {\n            n2 || (n2 = true, l.reject(s2, e3));\n          });\n          var a2;\n          return s2;\n        };\n      }, { immediate: 36 }], 38: [function(e, t, r) {\n        var n = {};\n        (0, e(\"./lib/utils/common\").assign)(n, e(\"./lib/deflate\"), e(\"./lib/inflate\"), e(\"./lib/zlib/constants\")), t.exports = n;\n      }, { \"./lib/deflate\": 39, \"./lib/inflate\": 40, \"./lib/utils/common\": 41, \"./lib/zlib/constants\": 44 }], 39: [function(e, t, r) {\n        var a = e(\"./zlib/deflate\"), o = e(\"./utils/common\"), h = e(\"./utils/strings\"), i = e(\"./zlib/messages\"), s = e(\"./zlib/zstream\"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;\n        function p(e2) {\n          if (!(this instanceof p)) return new p(e2);\n          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: \"\" }, e2 || {});\n          var t2 = this.options;\n          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = \"\", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;\n          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);\n          if (r2 !== l) throw new Error(i[r2]);\n          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {\n            var n2;\n            if (n2 = \"string\" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : \"[object ArrayBuffer]\" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);\n            this._dict_set = true;\n          }\n        }\n        function n(e2, t2) {\n          var r2 = new p(t2);\n          if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];\n          return r2.result;\n        }\n        p.prototype.push = function(e2, t2) {\n          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;\n          if (this.ended) return false;\n          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, \"string\" == typeof e2 ? i2.input = h.string2buf(e2) : \"[object ArrayBuffer]\" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;\n          do {\n            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);\n            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || (\"string\" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));\n          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);\n          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));\n        }, p.prototype.onData = function(e2) {\n          this.chunks.push(e2);\n        }, p.prototype.onEnd = function(e2) {\n          e2 === l && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;\n        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {\n          return (t2 = t2 || {}).raw = true, n(e2, t2);\n        }, r.gzip = function(e2, t2) {\n          return (t2 = t2 || {}).gzip = true, n(e2, t2);\n        };\n      }, { \"./utils/common\": 41, \"./utils/strings\": 42, \"./zlib/deflate\": 46, \"./zlib/messages\": 51, \"./zlib/zstream\": 53 }], 40: [function(e, t, r) {\n        var c = e(\"./zlib/inflate\"), d = e(\"./utils/common\"), p = e(\"./utils/strings\"), m = e(\"./zlib/constants\"), n = e(\"./zlib/messages\"), i = e(\"./zlib/zstream\"), s = e(\"./zlib/gzheader\"), _ = Object.prototype.toString;\n        function a(e2) {\n          if (!(this instanceof a)) return new a(e2);\n          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: \"\" }, e2 || {});\n          var t2 = this.options;\n          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = \"\", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;\n          var r2 = c.inflateInit2(this.strm, t2.windowBits);\n          if (r2 !== m.Z_OK) throw new Error(n[r2]);\n          this.header = new s(), c.inflateGetHeader(this.strm, this.header);\n        }\n        function o(e2, t2) {\n          var r2 = new a(t2);\n          if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];\n          return r2.result;\n        }\n        a.prototype.push = function(e2, t2) {\n          var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;\n          if (this.ended) return false;\n          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, \"string\" == typeof e2 ? h.input = p.binstring2buf(e2) : \"[object ArrayBuffer]\" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;\n          do {\n            if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = \"string\" == typeof l ? p.string2buf(l) : \"[object ArrayBuffer]\" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);\n            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || (\"string\" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);\n          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);\n          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));\n        }, a.prototype.onData = function(e2) {\n          this.chunks.push(e2);\n        }, a.prototype.onEnd = function(e2) {\n          e2 === m.Z_OK && (\"string\" === this.options.to ? this.result = this.chunks.join(\"\") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;\n        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {\n          return (t2 = t2 || {}).raw = true, o(e2, t2);\n        }, r.ungzip = o;\n      }, { \"./utils/common\": 41, \"./utils/strings\": 42, \"./zlib/constants\": 44, \"./zlib/gzheader\": 47, \"./zlib/inflate\": 49, \"./zlib/messages\": 51, \"./zlib/zstream\": 53 }], 41: [function(e, t, r) {\n        var n = \"undefined\" != typeof Uint8Array && \"undefined\" != typeof Uint16Array && \"undefined\" != typeof Int32Array;\n        r.assign = function(e2) {\n          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {\n            var r2 = t2.shift();\n            if (r2) {\n              if (\"object\" != typeof r2) throw new TypeError(r2 + \"must be non-object\");\n              for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);\n            }\n          }\n          return e2;\n        }, r.shrinkBuf = function(e2, t2) {\n          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);\n        };\n        var i = { arraySet: function(e2, t2, r2, n2, i2) {\n          if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);\n          else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];\n        }, flattenChunks: function(e2) {\n          var t2, r2, n2, i2, s2, a;\n          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;\n          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;\n          return a;\n        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {\n          for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];\n        }, flattenChunks: function(e2) {\n          return [].concat.apply([], e2);\n        } };\n        r.setTyped = function(e2) {\n          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));\n        }, r.setTyped(n);\n      }, {}], 42: [function(e, t, r) {\n        var h = e(\"./common\"), i = true, s = true;\n        try {\n          String.fromCharCode.apply(null, [0]);\n        } catch (e2) {\n          i = false;\n        }\n        try {\n          String.fromCharCode.apply(null, new Uint8Array(1));\n        } catch (e2) {\n          s = false;\n        }\n        for (var u = new h.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;\n        function l(e2, t2) {\n          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));\n          for (var r2 = \"\", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);\n          return r2;\n        }\n        u[254] = u[254] = 1, r.string2buf = function(e2) {\n          var t2, r2, n2, i2, s2, a = e2.length, o = 0;\n          for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;\n          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);\n          return t2;\n        }, r.buf2binstring = function(e2) {\n          return l(e2, e2.length);\n        }, r.binstring2buf = function(e2) {\n          for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);\n          return t2;\n        }, r.buf2string = function(e2, t2) {\n          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);\n          for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;\n          else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;\n          else {\n            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;\n            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);\n          }\n          return l(o, n2);\n        }, r.utf8border = function(e2, t2) {\n          var r2;\n          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;\n          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;\n        };\n      }, { \"./common\": 41 }], 43: [function(e, t, r) {\n        t.exports = function(e2, t2, r2, n) {\n          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {\n            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;\n            i %= 65521, s %= 65521;\n          }\n          return i | s << 16 | 0;\n        };\n      }, {}], 44: [function(e, t, r) {\n        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };\n      }, {}], 45: [function(e, t, r) {\n        var o = function() {\n          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {\n            e2 = r2;\n            for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;\n            t2[r2] = e2;\n          }\n          return t2;\n        }();\n        t.exports = function(e2, t2, r2, n) {\n          var i = o, s = n + r2;\n          e2 ^= -1;\n          for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];\n          return -1 ^ e2;\n        };\n      }, {}], 46: [function(e, t, r) {\n        var h, c = e(\"../utils/common\"), u = e(\"./trees\"), d = e(\"./adler32\"), p = e(\"./crc32\"), n = e(\"./messages\"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;\n        function R(e2, t2) {\n          return e2.msg = n[t2], t2;\n        }\n        function T(e2) {\n          return (e2 << 1) - (4 < e2 ? 9 : 0);\n        }\n        function D(e2) {\n          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;\n        }\n        function F(e2) {\n          var t2 = e2.state, r2 = t2.pending;\n          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));\n        }\n        function N(e2, t2) {\n          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);\n        }\n        function U(e2, t2) {\n          e2.pending_buf[e2.pending++] = t2;\n        }\n        function P(e2, t2) {\n          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;\n        }\n        function L(e2, t2) {\n          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];\n          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);\n          do {\n            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {\n              s2 += 2, r2++;\n              do {\n              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);\n              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {\n                if (e2.match_start = t2, o2 <= (a2 = n2)) break;\n                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];\n              }\n            }\n          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);\n          return a2 <= e2.lookahead ? a2 : e2.lookahead;\n        }\n        function j(e2) {\n          var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;\n          do {\n            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {\n              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;\n              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;\n              i2 += f2;\n            }\n            if (0 === e2.strm.avail_in) break;\n            if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;\n          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);\n        }\n        function Z(e2, t2) {\n          for (var r2, n2; ; ) {\n            if (e2.lookahead < z) {\n              if (j(e2), e2.lookahead < z && t2 === l) return A;\n              if (0 === e2.lookahead) break;\n            }\n            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {\n              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;\n              e2.strstart++;\n            } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;\n            else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;\n            if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;\n          }\n          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;\n        }\n        function W(e2, t2) {\n          for (var r2, n2, i2; ; ) {\n            if (e2.lookahead < z) {\n              if (j(e2), e2.lookahead < z && t2 === l) return A;\n              if (0 === e2.lookahead) break;\n            }\n            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {\n              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;\n              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;\n            } else if (e2.match_available) {\n              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;\n            } else e2.match_available = 1, e2.strstart++, e2.lookahead--;\n          }\n          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;\n        }\n        function M(e2, t2, r2, n2, i2) {\n          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;\n        }\n        function H() {\n          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;\n        }\n        function G(e2) {\n          var t2;\n          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);\n        }\n        function K(e2) {\n          var t2 = G(e2);\n          return t2 === m && function(e3) {\n            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;\n          }(e2.state), t2;\n        }\n        function Y(e2, t2, r2, n2, i2, s2) {\n          if (!e2) return _;\n          var a2 = 1;\n          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _);\n          8 === n2 && (n2 = 9);\n          var o2 = new H();\n          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);\n        }\n        h = [new M(0, 0, 0, 0, function(e2, t2) {\n          var r2 = 65535;\n          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {\n            if (e2.lookahead <= 1) {\n              if (j(e2), 0 === e2.lookahead && t2 === l) return A;\n              if (0 === e2.lookahead) break;\n            }\n            e2.strstart += e2.lookahead, e2.lookahead = 0;\n            var n2 = e2.block_start + r2;\n            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;\n            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;\n          }\n          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);\n        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {\n          return Y(e2, t2, v, 15, 8, 0);\n        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {\n          return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;\n        }, r.deflate = function(e2, t2) {\n          var r2, n2, i2, s2;\n          if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _) : _;\n          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _);\n          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);\n          else {\n            var a2 = v + (n2.w_bits - 8 << 4) << 8;\n            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;\n          }\n          if (69 === n2.status) if (n2.gzhead.extra) {\n            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;\n            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);\n          } else n2.status = 73;\n          if (73 === n2.status) if (n2.gzhead.name) {\n            i2 = n2.pending;\n            do {\n              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {\n                s2 = 1;\n                break;\n              }\n              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);\n            } while (0 !== s2);\n            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);\n          } else n2.status = 91;\n          if (91 === n2.status) if (n2.gzhead.comment) {\n            i2 = n2.pending;\n            do {\n              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {\n                s2 = 1;\n                break;\n              }\n              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);\n            } while (0 !== s2);\n            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);\n          } else n2.status = 103;\n          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {\n            if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;\n          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);\n          if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);\n          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {\n            var o2 = 2 === n2.strategy ? function(e3, t3) {\n              for (var r3; ; ) {\n                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {\n                  if (t3 === l) return A;\n                  break;\n                }\n                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;\n              }\n              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;\n            }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {\n              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {\n                if (e3.lookahead <= S) {\n                  if (j(e3), e3.lookahead <= S && t3 === l) return A;\n                  if (0 === e3.lookahead) break;\n                }\n                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {\n                  s3 = e3.strstart + S;\n                  do {\n                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);\n                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);\n                }\n                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;\n              }\n              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;\n            }(n2, t2) : h[n2.level].func(n2, t2);\n            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;\n            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;\n          }\n          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);\n        }, r.deflateEnd = function(e2) {\n          var t2;\n          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;\n        }, r.deflateSetDictionary = function(e2, t2) {\n          var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;\n          if (!e2 || !e2.state) return _;\n          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;\n          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {\n            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;\n            r2.strstart = n2, r2.lookahead = x - 1, j(r2);\n          }\n          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;\n        }, r.deflateInfo = \"pako deflate (from Nodeca project)\";\n      }, { \"../utils/common\": 41, \"./adler32\": 43, \"./crc32\": 45, \"./messages\": 51, \"./trees\": 52 }], 47: [function(e, t, r) {\n        t.exports = function() {\n          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = \"\", this.comment = \"\", this.hcrc = 0, this.done = false;\n        };\n      }, {}], 48: [function(e, t, r) {\n        t.exports = function(e2, t2) {\n          var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;\n          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;\n          e: do {\n            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];\n            t: for (; ; ) {\n              if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;\n              else {\n                if (!(16 & y)) {\n                  if (0 == (64 & y)) {\n                    v = m[(65535 & v) + (d & (1 << y) - 1)];\n                    continue t;\n                  }\n                  if (32 & y) {\n                    r2.mode = 12;\n                    break e;\n                  }\n                  e2.msg = \"invalid literal/length code\", r2.mode = 30;\n                  break e;\n                }\n                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];\n                r: for (; ; ) {\n                  if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {\n                    if (0 == (64 & y)) {\n                      v = _[(65535 & v) + (d & (1 << y) - 1)];\n                      continue r;\n                    }\n                    e2.msg = \"invalid distance code\", r2.mode = 30;\n                    break e;\n                  }\n                  if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {\n                    e2.msg = \"invalid distance too far back\", r2.mode = 30;\n                    break e;\n                  }\n                  if (d >>>= y, p -= y, (y = s - a) < k) {\n                    if (l < (y = k - y) && r2.sane) {\n                      e2.msg = \"invalid distance too far back\", r2.mode = 30;\n                      break e;\n                    }\n                    if (S = c, (x = 0) === f) {\n                      if (x += u - y, y < w) {\n                        for (w -= y; C[s++] = c[x++], --y; ) ;\n                        x = s - k, S = C;\n                      }\n                    } else if (f < y) {\n                      if (x += u + f - y, (y -= f) < w) {\n                        for (w -= y; C[s++] = c[x++], --y; ) ;\n                        if (x = 0, f < w) {\n                          for (w -= y = f; C[s++] = c[x++], --y; ) ;\n                          x = s - k, S = C;\n                        }\n                      }\n                    } else if (x += f - y, y < w) {\n                      for (w -= y; C[s++] = c[x++], --y; ) ;\n                      x = s - k, S = C;\n                    }\n                    for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;\n                    w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));\n                  } else {\n                    for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;\n                    w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));\n                  }\n                  break;\n                }\n              }\n              break;\n            }\n          } while (n < i && s < o);\n          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;\n        };\n      }, {}], 49: [function(e, t, r) {\n        var I = e(\"../utils/common\"), O = e(\"./adler32\"), B = e(\"./crc32\"), R = e(\"./inffast\"), T = e(\"./inftrees\"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;\n        function L(e2) {\n          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);\n        }\n        function s() {\n          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;\n        }\n        function a(e2) {\n          var t2;\n          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = \"\", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;\n        }\n        function o(e2) {\n          var t2;\n          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;\n        }\n        function h(e2, t2) {\n          var r2, n2;\n          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;\n        }\n        function u(e2, t2) {\n          var r2, n2;\n          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;\n        }\n        var l, f, c = true;\n        function j(e2) {\n          if (c) {\n            var t2;\n            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;\n            for (; t2 < 256; ) e2.lens[t2++] = 9;\n            for (; t2 < 280; ) e2.lens[t2++] = 7;\n            for (; t2 < 288; ) e2.lens[t2++] = 8;\n            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;\n            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;\n          }\n          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;\n        }\n        function Z(e2, t2, r2, n2) {\n          var i2, s2 = e2.state;\n          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;\n        }\n        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {\n          return u(e2, 15);\n        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {\n          var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;\n          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;\n          e: for (; ; ) switch (r2.mode) {\n            case P:\n              if (0 === r2.wrap) {\n                r2.mode = 13;\n                break;\n              }\n              for (; l2 < 16; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if (2 & r2.wrap && 35615 === u2) {\n                E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;\n                break;\n              }\n              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {\n                e2.msg = \"incorrect header check\", r2.mode = 30;\n                break;\n              }\n              if (8 != (15 & u2)) {\n                e2.msg = \"unknown compression method\", r2.mode = 30;\n                break;\n              }\n              if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;\n              else if (k > r2.wbits) {\n                e2.msg = \"invalid window size\", r2.mode = 30;\n                break;\n              }\n              r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;\n              break;\n            case 2:\n              for (; l2 < 16; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if (r2.flags = u2, 8 != (255 & r2.flags)) {\n                e2.msg = \"unknown compression method\", r2.mode = 30;\n                break;\n              }\n              if (57344 & r2.flags) {\n                e2.msg = \"unknown header flags set\", r2.mode = 30;\n                break;\n              }\n              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;\n            case 3:\n              for (; l2 < 32; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;\n            case 4:\n              for (; l2 < 16; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;\n            case 5:\n              if (1024 & r2.flags) {\n                for (; l2 < 16; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;\n              } else r2.head && (r2.head.extra = null);\n              r2.mode = 6;\n            case 6:\n              if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;\n              r2.length = 0, r2.mode = 7;\n            case 7:\n              if (2048 & r2.flags) {\n                if (0 === o2) break e;\n                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;\n                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;\n              } else r2.head && (r2.head.name = null);\n              r2.length = 0, r2.mode = 8;\n            case 8:\n              if (4096 & r2.flags) {\n                if (0 === o2) break e;\n                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;\n                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;\n              } else r2.head && (r2.head.comment = null);\n              r2.mode = 9;\n            case 9:\n              if (512 & r2.flags) {\n                for (; l2 < 16; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                if (u2 !== (65535 & r2.check)) {\n                  e2.msg = \"header crc mismatch\", r2.mode = 30;\n                  break;\n                }\n                l2 = u2 = 0;\n              }\n              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;\n              break;\n            case 10:\n              for (; l2 < 32; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;\n            case 11:\n              if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;\n              e2.adler = r2.check = 1, r2.mode = 12;\n            case 12:\n              if (5 === t2 || 6 === t2) break e;\n            case 13:\n              if (r2.last) {\n                u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;\n                break;\n              }\n              for (; l2 < 3; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {\n                case 0:\n                  r2.mode = 14;\n                  break;\n                case 1:\n                  if (j(r2), r2.mode = 20, 6 !== t2) break;\n                  u2 >>>= 2, l2 -= 2;\n                  break e;\n                case 2:\n                  r2.mode = 17;\n                  break;\n                case 3:\n                  e2.msg = \"invalid block type\", r2.mode = 30;\n              }\n              u2 >>>= 2, l2 -= 2;\n              break;\n            case 14:\n              for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {\n                e2.msg = \"invalid stored block lengths\", r2.mode = 30;\n                break;\n              }\n              if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;\n            case 15:\n              r2.mode = 16;\n            case 16:\n              if (d = r2.length) {\n                if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d) break e;\n                I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;\n                break;\n              }\n              r2.mode = 12;\n              break;\n            case 17:\n              for (; l2 < 14; ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {\n                e2.msg = \"too many length or distance symbols\", r2.mode = 30;\n                break;\n              }\n              r2.have = 0, r2.mode = 18;\n            case 18:\n              for (; r2.have < r2.ncode; ) {\n                for (; l2 < 3; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;\n              }\n              for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;\n              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {\n                e2.msg = \"invalid code lengths set\", r2.mode = 30;\n                break;\n              }\n              r2.have = 0, r2.mode = 19;\n            case 19:\n              for (; r2.have < r2.nlen + r2.ndist; ) {\n                for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;\n                else {\n                  if (16 === b) {\n                    for (z = _ + 2; l2 < z; ) {\n                      if (0 === o2) break e;\n                      o2--, u2 += n2[s2++] << l2, l2 += 8;\n                    }\n                    if (u2 >>>= _, l2 -= _, 0 === r2.have) {\n                      e2.msg = \"invalid bit length repeat\", r2.mode = 30;\n                      break;\n                    }\n                    k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;\n                  } else if (17 === b) {\n                    for (z = _ + 3; l2 < z; ) {\n                      if (0 === o2) break e;\n                      o2--, u2 += n2[s2++] << l2, l2 += 8;\n                    }\n                    l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;\n                  } else {\n                    for (z = _ + 7; l2 < z; ) {\n                      if (0 === o2) break e;\n                      o2--, u2 += n2[s2++] << l2, l2 += 8;\n                    }\n                    l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;\n                  }\n                  if (r2.have + d > r2.nlen + r2.ndist) {\n                    e2.msg = \"invalid bit length repeat\", r2.mode = 30;\n                    break;\n                  }\n                  for (; d--; ) r2.lens[r2.have++] = k;\n                }\n              }\n              if (30 === r2.mode) break;\n              if (0 === r2.lens[256]) {\n                e2.msg = \"invalid code -- missing end-of-block\", r2.mode = 30;\n                break;\n              }\n              if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {\n                e2.msg = \"invalid literal/lengths set\", r2.mode = 30;\n                break;\n              }\n              if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {\n                e2.msg = \"invalid distances set\", r2.mode = 30;\n                break;\n              }\n              if (r2.mode = 20, 6 === t2) break e;\n            case 20:\n              r2.mode = 21;\n            case 21:\n              if (6 <= o2 && 258 <= h2) {\n                e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);\n                break;\n              }\n              for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if (g && 0 == (240 & g)) {\n                for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                u2 >>>= v, l2 -= v, r2.back += v;\n              }\n              if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {\n                r2.mode = 26;\n                break;\n              }\n              if (32 & g) {\n                r2.back = -1, r2.mode = 12;\n                break;\n              }\n              if (64 & g) {\n                e2.msg = \"invalid literal/length code\", r2.mode = 30;\n                break;\n              }\n              r2.extra = 15 & g, r2.mode = 22;\n            case 22:\n              if (r2.extra) {\n                for (z = r2.extra; l2 < z; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;\n              }\n              r2.was = r2.length, r2.mode = 23;\n            case 23:\n              for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {\n                if (0 === o2) break e;\n                o2--, u2 += n2[s2++] << l2, l2 += 8;\n              }\n              if (0 == (240 & g)) {\n                for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                u2 >>>= v, l2 -= v, r2.back += v;\n              }\n              if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {\n                e2.msg = \"invalid distance code\", r2.mode = 30;\n                break;\n              }\n              r2.offset = b, r2.extra = 15 & g, r2.mode = 24;\n            case 24:\n              if (r2.extra) {\n                for (z = r2.extra; l2 < z; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;\n              }\n              if (r2.offset > r2.dmax) {\n                e2.msg = \"invalid distance too far back\", r2.mode = 30;\n                break;\n              }\n              r2.mode = 25;\n            case 25:\n              if (0 === h2) break e;\n              if (d = c2 - h2, r2.offset > d) {\n                if ((d = r2.offset - d) > r2.whave && r2.sane) {\n                  e2.msg = \"invalid distance too far back\", r2.mode = 30;\n                  break;\n                }\n                p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;\n              } else m = i2, p = a2 - r2.offset, d = r2.length;\n              for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;\n              0 === r2.length && (r2.mode = 21);\n              break;\n            case 26:\n              if (0 === h2) break e;\n              i2[a2++] = r2.length, h2--, r2.mode = 21;\n              break;\n            case 27:\n              if (r2.wrap) {\n                for (; l2 < 32; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 |= n2[s2++] << l2, l2 += 8;\n                }\n                if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {\n                  e2.msg = \"incorrect data check\", r2.mode = 30;\n                  break;\n                }\n                l2 = u2 = 0;\n              }\n              r2.mode = 28;\n            case 28:\n              if (r2.wrap && r2.flags) {\n                for (; l2 < 32; ) {\n                  if (0 === o2) break e;\n                  o2--, u2 += n2[s2++] << l2, l2 += 8;\n                }\n                if (u2 !== (4294967295 & r2.total)) {\n                  e2.msg = \"incorrect length check\", r2.mode = 30;\n                  break;\n                }\n                l2 = u2 = 0;\n              }\n              r2.mode = 29;\n            case 29:\n              x = 1;\n              break e;\n            case 30:\n              x = -3;\n              break e;\n            case 31:\n              return -4;\n            case 32:\n            default:\n              return U;\n          }\n          return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);\n        }, r.inflateEnd = function(e2) {\n          if (!e2 || !e2.state) return U;\n          var t2 = e2.state;\n          return t2.window && (t2.window = null), e2.state = null, N;\n        }, r.inflateGetHeader = function(e2, t2) {\n          var r2;\n          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;\n        }, r.inflateSetDictionary = function(e2, t2) {\n          var r2, n2 = t2.length;\n          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;\n        }, r.inflateInfo = \"pako inflate (from Nodeca project)\";\n      }, { \"../utils/common\": 41, \"./adler32\": 43, \"./crc32\": 45, \"./inffast\": 48, \"./inftrees\": 50 }], 50: [function(e, t, r) {\n        var D = e(\"../utils/common\"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];\n        t.exports = function(e2, t2, r2, n, i, s, a, o) {\n          var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;\n          for (b = 0; b <= 15; b++) O[b] = 0;\n          for (v = 0; v < n; v++) O[t2[r2 + v]]++;\n          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;\n          if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;\n          for (y = 1; y < w && 0 === O[y]; y++) ;\n          for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;\n          if (0 < z && (0 === e2 || 1 !== w)) return -1;\n          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];\n          for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);\n          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;\n          for (; ; ) {\n            for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;\n            for (h = 1 << b - 1; E & h; ) h >>= 1;\n            if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {\n              if (b === w) break;\n              b = t2[r2 + a[v]];\n            }\n            if (k < b && (E & f) !== l) {\n              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;\n              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;\n              i[l = E & f] = k << 24 | x << 16 | c - s | 0;\n            }\n          }\n          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;\n        };\n      }, { \"../utils/common\": 41 }], 51: [function(e, t, r) {\n        t.exports = { 2: \"need dictionary\", 1: \"stream end\", 0: \"\", \"-1\": \"file error\", \"-2\": \"stream error\", \"-3\": \"data error\", \"-4\": \"insufficient memory\", \"-5\": \"buffer error\", \"-6\": \"incompatible version\" };\n      }, {}], 52: [function(e, t, r) {\n        var i = e(\"../utils/common\"), o = 0, h = 1;\n        function n(e2) {\n          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;\n        }\n        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));\n        n(z);\n        var C = new Array(2 * f);\n        n(C);\n        var E = new Array(512);\n        n(E);\n        var A = new Array(256);\n        n(A);\n        var I = new Array(a);\n        n(I);\n        var O, B, R, T = new Array(f);\n        function D(e2, t2, r2, n2, i2) {\n          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;\n        }\n        function F(e2, t2) {\n          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;\n        }\n        function N(e2) {\n          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];\n        }\n        function U(e2, t2) {\n          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;\n        }\n        function P(e2, t2, r2) {\n          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);\n        }\n        function L(e2, t2, r2) {\n          P(e2, r2[2 * t2], r2[2 * t2 + 1]);\n        }\n        function j(e2, t2) {\n          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;\n          return r2 >>> 1;\n        }\n        function Z(e2, t2, r2) {\n          var n2, i2, s2 = new Array(g + 1), a2 = 0;\n          for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;\n          for (i2 = 0; i2 <= t2; i2++) {\n            var o2 = e2[2 * i2 + 1];\n            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));\n          }\n        }\n        function W(e2) {\n          var t2;\n          for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;\n          for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;\n          for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;\n          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;\n        }\n        function M(e2) {\n          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;\n        }\n        function H(e2, t2, r2, n2) {\n          var i2 = 2 * t2, s2 = 2 * r2;\n          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];\n        }\n        function G(e2, t2, r2) {\n          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;\n          e2.heap[r2] = n2;\n        }\n        function K(e2, t2, r2) {\n          var n2, i2, s2, a2, o2 = 0;\n          if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;\n          L(e2, m, t2);\n        }\n        function Y(e2, t2) {\n          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;\n          for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;\n          for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);\n          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);\n          for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;\n          e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {\n            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;\n            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;\n            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));\n            if (0 !== m2) {\n              do {\n                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;\n                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;\n              } while (0 < m2);\n              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);\n            }\n          }(e2, t2), Z(s2, u2, e2.bl_count);\n        }\n        function X(e2, t2, r2) {\n          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;\n          for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));\n        }\n        function V(e2, t2, r2) {\n          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;\n          for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {\n            if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;\n            else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));\n            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);\n          }\n        }\n        n(T);\n        var q = false;\n        function J(e2, t2, r2, n2) {\n          P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {\n            M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;\n          }(e2, t2, r2);\n        }\n        r._tr_init = function(e2) {\n          q || (function() {\n            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);\n            for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;\n            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;\n            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;\n            for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;\n            for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;\n            for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;\n            for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;\n            for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;\n            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);\n            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);\n          }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);\n        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {\n          var i2, s2, a2 = 0;\n          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {\n            var t3, r3 = 4093624447;\n            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;\n            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h;\n            for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h;\n            return o;\n          }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {\n            var t3;\n            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;\n            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;\n          }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {\n            var i3;\n            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);\n            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);\n          }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);\n        }, r._tr_tally = function(e2, t2, r2) {\n          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;\n        }, r._tr_align = function(e2) {\n          P(e2, 2, 3), L(e2, m, z), function(e3) {\n            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);\n          }(e2);\n        };\n      }, { \"../utils/common\": 41 }], 53: [function(e, t, r) {\n        t.exports = function() {\n          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = \"\", this.state = null, this.data_type = 2, this.adler = 0;\n        };\n      }, {}], 54: [function(e, t, r) {\n        (function(e2) {\n          !function(r2, n) {\n            if (!r2.setImmediate) {\n              var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);\n              e3 = e3 && e3.setTimeout ? e3 : r2, i = \"[object process]\" === {}.toString.call(r2.process) ? function(e4) {\n                process$1.nextTick(function() {\n                  c(e4);\n                });\n              } : function() {\n                if (r2.postMessage && !r2.importScripts) {\n                  var e4 = true, t3 = r2.onmessage;\n                  return r2.onmessage = function() {\n                    e4 = false;\n                  }, r2.postMessage(\"\", \"*\"), r2.onmessage = t3, e4;\n                }\n              }() ? (a = \"setImmediate$\" + Math.random() + \"$\", r2.addEventListener ? r2.addEventListener(\"message\", d, false) : r2.attachEvent(\"onmessage\", d), function(e4) {\n                r2.postMessage(a + e4, \"*\");\n              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {\n                c(e4.data);\n              }, function(e4) {\n                t2.port2.postMessage(e4);\n              }) : l && \"onreadystatechange\" in l.createElement(\"script\") ? (s = l.documentElement, function(e4) {\n                var t3 = l.createElement(\"script\");\n                t3.onreadystatechange = function() {\n                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;\n                }, s.appendChild(t3);\n              }) : function(e4) {\n                setTimeout(c, 0, e4);\n              }, e3.setImmediate = function(e4) {\n                \"function\" != typeof e4 && (e4 = new Function(\"\" + e4));\n                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];\n                var n2 = { callback: e4, args: t3 };\n                return h[o] = n2, i(o), o++;\n              }, e3.clearImmediate = f;\n            }\n            function f(e4) {\n              delete h[e4];\n            }\n            function c(e4) {\n              if (u) setTimeout(c, 0, e4);\n              else {\n                var t3 = h[e4];\n                if (t3) {\n                  u = true;\n                  try {\n                    !function(e5) {\n                      var t4 = e5.callback, r3 = e5.args;\n                      switch (r3.length) {\n                        case 0:\n                          t4();\n                          break;\n                        case 1:\n                          t4(r3[0]);\n                          break;\n                        case 2:\n                          t4(r3[0], r3[1]);\n                          break;\n                        case 3:\n                          t4(r3[0], r3[1], r3[2]);\n                          break;\n                        default:\n                          t4.apply(n, r3);\n                      }\n                    }(t3);\n                  } finally {\n                    f(e4), u = false;\n                  }\n                }\n              }\n            }\n            function d(e4) {\n              e4.source === r2 && \"string\" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));\n            }\n          }(\"undefined\" == typeof self ? void 0 === e2 ? this : e2 : self);\n        }).call(this, \"undefined\" != typeof commonjsGlobal ? commonjsGlobal : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : {});\n      }, {}] }, {}, [10])(10);\n    });\n  })(jszip_min);\n  return jszip_min.exports;\n}\nvar jszip_minExports = requireJszip_min();\nconst JSZip = /* @__PURE__ */ getDefaultExportFromCjs$1(jszip_minExports);\nvar xml$1 = { exports: {} };\nvar escapeForXML_1;\nvar hasRequiredEscapeForXML;\nfunction requireEscapeForXML() {\n  if (hasRequiredEscapeForXML) return escapeForXML_1;\n  hasRequiredEscapeForXML = 1;\n  var XML_CHARACTER_MAP = {\n    \"&\": \"&amp;\",\n    '\"': \"&quot;\",\n    \"'\": \"&apos;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\"\n  };\n  function escapeForXML(string) {\n    return string && string.replace ? string.replace(/([&\"<>'])/g, function(str, item) {\n      return XML_CHARACTER_MAP[item];\n    }) : string;\n  }\n  escapeForXML_1 = escapeForXML;\n  return escapeForXML_1;\n}\nvar hasRequiredXml;\nfunction requireXml() {\n  if (hasRequiredXml) return xml$1.exports;\n  hasRequiredXml = 1;\n  var escapeForXML = requireEscapeForXML();\n  var Stream = requireStreamBrowserify().Stream;\n  var DEFAULT_INDENT = \"    \";\n  function xml2(input, options) {\n    if (typeof options !== \"object\") {\n      options = {\n        indent: options\n      };\n    }\n    var stream = options.stream ? new Stream() : null, output = \"\", interrupted = false, indent = !options.indent ? \"\" : options.indent === true ? DEFAULT_INDENT : options.indent, instant = true;\n    function delay(func) {\n      if (!instant) {\n        func();\n      } else {\n        process$1.nextTick(func);\n      }\n    }\n    function append(interrupt, out) {\n      if (out !== void 0) {\n        output += out;\n      }\n      if (interrupt && !interrupted) {\n        stream = stream || new Stream();\n        interrupted = true;\n      }\n      if (interrupt && interrupted) {\n        var data = output;\n        delay(function() {\n          stream.emit(\"data\", data);\n        });\n        output = \"\";\n      }\n    }\n    function add(value, last) {\n      format(append, resolve(value, indent, indent ? 1 : 0), last);\n    }\n    function end() {\n      if (stream) {\n        var data = output;\n        delay(function() {\n          stream.emit(\"data\", data);\n          stream.emit(\"end\");\n          stream.readable = false;\n          stream.emit(\"close\");\n        });\n      }\n    }\n    function addXmlDeclaration(declaration) {\n      var encoding = declaration.encoding || \"UTF-8\", attr = { version: \"1.0\", encoding };\n      if (declaration.standalone) {\n        attr.standalone = declaration.standalone;\n      }\n      add({ \"?xml\": { _attr: attr } });\n      output = output.replace(\"/>\", \"?>\");\n    }\n    delay(function() {\n      instant = false;\n    });\n    if (options.declaration) {\n      addXmlDeclaration(options.declaration);\n    }\n    if (input && input.forEach) {\n      input.forEach(function(value, i) {\n        var last;\n        if (i + 1 === input.length)\n          last = end;\n        add(value, last);\n      });\n    } else {\n      add(input, end);\n    }\n    if (stream) {\n      stream.readable = true;\n      return stream;\n    }\n    return output;\n  }\n  function element() {\n    var input = Array.prototype.slice.call(arguments), self2 = {\n      _elem: resolve(input)\n    };\n    self2.push = function(input2) {\n      if (!this.append) {\n        throw new Error(\"not assigned to a parent!\");\n      }\n      var that = this;\n      var indent = this._elem.indent;\n      format(\n        this.append,\n        resolve(\n          input2,\n          indent,\n          this._elem.icount + (indent ? 1 : 0)\n        ),\n        function() {\n          that.append(true);\n        }\n      );\n    };\n    self2.close = function(input2) {\n      if (input2 !== void 0) {\n        this.push(input2);\n      }\n      if (this.end) {\n        this.end();\n      }\n    };\n    return self2;\n  }\n  function create_indent(character, count) {\n    return new Array(count || 0).join(character || \"\");\n  }\n  function resolve(data, indent, indent_count) {\n    indent_count = indent_count || 0;\n    var indent_spaces = create_indent(indent, indent_count);\n    var name;\n    var values = data;\n    var interrupt = false;\n    if (typeof data === \"object\") {\n      var keys = Object.keys(data);\n      name = keys[0];\n      values = data[name];\n      if (values && values._elem) {\n        values._elem.name = name;\n        values._elem.icount = indent_count;\n        values._elem.indent = indent;\n        values._elem.indents = indent_spaces;\n        values._elem.interrupt = values;\n        return values._elem;\n      }\n    }\n    var attributes = [], content = [];\n    var isStringContent;\n    function get_attributes(obj) {\n      var keys2 = Object.keys(obj);\n      keys2.forEach(function(key) {\n        attributes.push(attribute(key, obj[key]));\n      });\n    }\n    switch (typeof values) {\n      case \"object\":\n        if (values === null) break;\n        if (values._attr) {\n          get_attributes(values._attr);\n        }\n        if (values._cdata) {\n          content.push(\n            (\"<![CDATA[\" + values._cdata).replace(/\\]\\]>/g, \"]]]]><![CDATA[>\") + \"]]>\"\n          );\n        }\n        if (values.forEach) {\n          isStringContent = false;\n          content.push(\"\");\n          values.forEach(function(value) {\n            if (typeof value == \"object\") {\n              var _name = Object.keys(value)[0];\n              if (_name == \"_attr\") {\n                get_attributes(value._attr);\n              } else {\n                content.push(resolve(\n                  value,\n                  indent,\n                  indent_count + 1\n                ));\n              }\n            } else {\n              content.pop();\n              isStringContent = true;\n              content.push(escapeForXML(value));\n            }\n          });\n          if (!isStringContent) {\n            content.push(\"\");\n          }\n        }\n        break;\n      default:\n        content.push(escapeForXML(values));\n    }\n    return {\n      name,\n      interrupt,\n      attributes,\n      content,\n      icount: indent_count,\n      indents: indent_spaces,\n      indent\n    };\n  }\n  function format(append, elem, end) {\n    if (typeof elem != \"object\") {\n      return append(false, elem);\n    }\n    var len = elem.interrupt ? 1 : elem.content.length;\n    function proceed() {\n      while (elem.content.length) {\n        var value = elem.content.shift();\n        if (value === void 0) continue;\n        if (interrupt(value)) return;\n        format(append, value);\n      }\n      append(false, (len > 1 ? elem.indents : \"\") + (elem.name ? \"</\" + elem.name + \">\" : \"\") + (elem.indent && !end ? \"\\n\" : \"\"));\n      if (end) {\n        end();\n      }\n    }\n    function interrupt(value) {\n      if (value.interrupt) {\n        value.interrupt.append = append;\n        value.interrupt.end = proceed;\n        value.interrupt = false;\n        append(true);\n        return true;\n      }\n      return false;\n    }\n    append(false, elem.indents + (elem.name ? \"<\" + elem.name : \"\") + (elem.attributes.length ? \" \" + elem.attributes.join(\" \") : \"\") + (len ? elem.name ? \">\" : \"\" : elem.name ? \"/>\" : \"\") + (elem.indent && len > 1 ? \"\\n\" : \"\"));\n    if (!len) {\n      return append(false, elem.indent ? \"\\n\" : \"\");\n    }\n    if (!interrupt(elem)) {\n      proceed();\n    }\n  }\n  function attribute(key, value) {\n    return key + '=\"' + escapeForXML(value) + '\"';\n  }\n  xml$1.exports = xml2;\n  xml$1.exports.element = xml$1.exports.Element = element;\n  return xml$1.exports;\n}\nvar xmlExports = requireXml();\nconst xml = /* @__PURE__ */ getDefaultExportFromCjs$1(xmlExports);\nconst obfuscatedStartOffset = 0;\nconst obfuscatedEndOffset = 32;\nconst guidSize = 32;\nconst obfuscate = (buf, fontKey) => {\n  const guid = fontKey.replace(/-/g, \"\");\n  if (guid.length !== guidSize) {\n    throw new Error(`Error: Cannot extract GUID from font filename: ${fontKey}`);\n  }\n  const hexStrings = guid.replace(/(..)/g, \"$1 \").trim().split(\" \");\n  const hexNumbers = hexStrings.map((hexString) => parseInt(hexString, 16));\n  hexNumbers.reverse();\n  const bytesToObfuscate = buf.slice(obfuscatedStartOffset, obfuscatedEndOffset);\n  const obfuscatedBytes = bytesToObfuscate.map((byte, i) => byte ^ hexNumbers[i % hexNumbers.length]);\n  const out = new Uint8Array(obfuscatedStartOffset + obfuscatedBytes.length + Math.max(0, buf.length - obfuscatedEndOffset));\n  out.set(buf.slice(0, obfuscatedStartOffset));\n  out.set(obfuscatedBytes, obfuscatedStartOffset);\n  out.set(buf.slice(obfuscatedEndOffset), obfuscatedStartOffset + obfuscatedBytes.length);\n  return out;\n};\nclass Formatter {\n  format(input, context = { stack: [] }) {\n    const output = input.prepForXml(context);\n    if (output) {\n      return output;\n    } else {\n      throw Error(\"XMLComponent did not format correctly\");\n    }\n  }\n}\nclass ImageReplacer {\n  replace(xmlData, mediaData, offset) {\n    let currentXmlData = xmlData;\n    mediaData.forEach((image, i) => {\n      currentXmlData = currentXmlData.replace(new RegExp(`{${image.fileName}}`, \"g\"), (offset + i).toString());\n    });\n    return currentXmlData;\n  }\n  getMediaData(xmlData, media) {\n    return media.Array.filter((image) => xmlData.search(`{${image.fileName}}`) > 0);\n  }\n}\nclass NumberingReplacer {\n  replace(xmlData, concreteNumberings) {\n    let currentXmlData = xmlData;\n    for (const concreteNumbering of concreteNumberings) {\n      currentXmlData = currentXmlData.replace(\n        new RegExp(`{${concreteNumbering.reference}-${concreteNumbering.instance}}`, \"g\"),\n        concreteNumbering.numId.toString()\n      );\n    }\n    return currentXmlData;\n  }\n}\nclass Compiler {\n  constructor() {\n    __publicField(this, \"formatter\");\n    __publicField(this, \"imageReplacer\");\n    __publicField(this, \"numberingReplacer\");\n    this.formatter = new Formatter();\n    this.imageReplacer = new ImageReplacer();\n    this.numberingReplacer = new NumberingReplacer();\n  }\n  compile(file, prettifyXml, overrides = []) {\n    const zip = new JSZip();\n    const xmlifiedFileMapping = this.xmlifyFile(file, prettifyXml);\n    const map = new Map(Object.entries(xmlifiedFileMapping));\n    for (const [, obj] of map) {\n      if (Array.isArray(obj)) {\n        for (const subFile of obj) {\n          zip.file(subFile.path, subFile.data);\n        }\n      } else {\n        zip.file(obj.path, obj.data);\n      }\n    }\n    for (const subFile of overrides) {\n      zip.file(subFile.path, subFile.data);\n    }\n    for (const data of file.Media.Array) {\n      if (data.type !== \"svg\") {\n        zip.file(`word/media/${data.fileName}`, data.data);\n      } else {\n        zip.file(`word/media/${data.fileName}`, data.data);\n        zip.file(`word/media/${data.fallback.fileName}`, data.fallback.data);\n      }\n    }\n    for (const { data: buffer2, name, fontKey } of file.FontTable.fontOptionsWithKey) {\n      const [nameWithoutExtension] = name.split(\".\");\n      zip.file(`word/fonts/${nameWithoutExtension}.odttf`, obfuscate(buffer2, fontKey));\n    }\n    return zip;\n  }\n  xmlifyFile(file, prettify) {\n    const documentRelationshipCount = file.Document.Relationships.RelationshipCount + 1;\n    const documentXmlData = xml(\n      this.formatter.format(file.Document.View, {\n        viewWrapper: file.Document,\n        file,\n        stack: []\n      }),\n      {\n        indent: prettify,\n        declaration: {\n          standalone: \"yes\",\n          encoding: \"UTF-8\"\n        }\n      }\n    );\n    const commentRelationshipCount = file.Comments.Relationships.RelationshipCount + 1;\n    const commentXmlData = xml(\n      this.formatter.format(file.Comments, {\n        viewWrapper: {\n          View: file.Comments,\n          Relationships: file.Comments.Relationships\n        },\n        file,\n        stack: []\n      }),\n      {\n        indent: prettify,\n        declaration: {\n          standalone: \"yes\",\n          encoding: \"UTF-8\"\n        }\n      }\n    );\n    const documentMediaDatas = this.imageReplacer.getMediaData(documentXmlData, file.Media);\n    const commentMediaDatas = this.imageReplacer.getMediaData(commentXmlData, file.Media);\n    return {\n      Relationships: {\n        data: (() => {\n          documentMediaDatas.forEach((mediaData, i) => {\n            file.Document.Relationships.createRelationship(\n              documentRelationshipCount + i,\n              \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\",\n              `media/${mediaData.fileName}`\n            );\n          });\n          file.Document.Relationships.createRelationship(\n            file.Document.Relationships.RelationshipCount + 1,\n            \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable\",\n            \"fontTable.xml\"\n          );\n          return xml(\n            this.formatter.format(file.Document.Relationships, {\n              viewWrapper: file.Document,\n              file,\n              stack: []\n            }),\n            {\n              indent: prettify,\n              declaration: {\n                encoding: \"UTF-8\"\n              }\n            }\n          );\n        })(),\n        path: \"word/_rels/document.xml.rels\"\n      },\n      Document: {\n        data: (() => {\n          const xmlData = this.imageReplacer.replace(documentXmlData, documentMediaDatas, documentRelationshipCount);\n          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);\n          return referenedXmlData;\n        })(),\n        path: \"word/document.xml\"\n      },\n      Styles: {\n        data: (() => {\n          const xmlStyles = xml(\n            this.formatter.format(file.Styles, {\n              viewWrapper: file.Document,\n              file,\n              stack: []\n            }),\n            {\n              indent: prettify,\n              declaration: {\n                standalone: \"yes\",\n                encoding: \"UTF-8\"\n              }\n            }\n          );\n          const referencedXmlStyles = this.numberingReplacer.replace(xmlStyles, file.Numbering.ConcreteNumbering);\n          return referencedXmlStyles;\n        })(),\n        path: \"word/styles.xml\"\n      },\n      Properties: {\n        data: xml(\n          this.formatter.format(file.CoreProperties, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"docProps/core.xml\"\n      },\n      Numbering: {\n        data: xml(\n          this.formatter.format(file.Numbering, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"word/numbering.xml\"\n      },\n      FileRelationships: {\n        data: xml(\n          this.formatter.format(file.FileRelationships, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"_rels/.rels\"\n      },\n      HeaderRelationships: file.Headers.map((headerWrapper, index) => {\n        const xmlData = xml(\n          this.formatter.format(headerWrapper.View, {\n            viewWrapper: headerWrapper,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        );\n        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);\n        mediaDatas.forEach((mediaData, i) => {\n          headerWrapper.Relationships.createRelationship(\n            i,\n            \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\",\n            `media/${mediaData.fileName}`\n          );\n        });\n        return {\n          data: xml(\n            this.formatter.format(headerWrapper.Relationships, {\n              viewWrapper: headerWrapper,\n              file,\n              stack: []\n            }),\n            {\n              indent: prettify,\n              declaration: {\n                encoding: \"UTF-8\"\n              }\n            }\n          ),\n          path: `word/_rels/header${index + 1}.xml.rels`\n        };\n      }),\n      FooterRelationships: file.Footers.map((footerWrapper, index) => {\n        const xmlData = xml(\n          this.formatter.format(footerWrapper.View, {\n            viewWrapper: footerWrapper,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        );\n        const mediaDatas = this.imageReplacer.getMediaData(xmlData, file.Media);\n        mediaDatas.forEach((mediaData, i) => {\n          footerWrapper.Relationships.createRelationship(\n            i,\n            \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\",\n            `media/${mediaData.fileName}`\n          );\n        });\n        return {\n          data: xml(\n            this.formatter.format(footerWrapper.Relationships, {\n              viewWrapper: footerWrapper,\n              file,\n              stack: []\n            }),\n            {\n              indent: prettify,\n              declaration: {\n                encoding: \"UTF-8\"\n              }\n            }\n          ),\n          path: `word/_rels/footer${index + 1}.xml.rels`\n        };\n      }),\n      Headers: file.Headers.map((headerWrapper, index) => {\n        const tempXmlData = xml(\n          this.formatter.format(headerWrapper.View, {\n            viewWrapper: headerWrapper,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        );\n        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);\n        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);\n        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);\n        return {\n          data: referenedXmlData,\n          path: `word/header${index + 1}.xml`\n        };\n      }),\n      Footers: file.Footers.map((footerWrapper, index) => {\n        const tempXmlData = xml(\n          this.formatter.format(footerWrapper.View, {\n            viewWrapper: footerWrapper,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        );\n        const mediaDatas = this.imageReplacer.getMediaData(tempXmlData, file.Media);\n        const xmlData = this.imageReplacer.replace(tempXmlData, mediaDatas, 0);\n        const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);\n        return {\n          data: referenedXmlData,\n          path: `word/footer${index + 1}.xml`\n        };\n      }),\n      ContentTypes: {\n        data: xml(\n          this.formatter.format(file.ContentTypes, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"[Content_Types].xml\"\n      },\n      CustomProperties: {\n        data: xml(\n          this.formatter.format(file.CustomProperties, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"docProps/custom.xml\"\n      },\n      AppProperties: {\n        data: xml(\n          this.formatter.format(file.AppProperties, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"docProps/app.xml\"\n      },\n      FootNotes: {\n        data: xml(\n          this.formatter.format(file.FootNotes.View, {\n            viewWrapper: file.FootNotes,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"word/footnotes.xml\"\n      },\n      FootNotesRelationships: {\n        data: xml(\n          this.formatter.format(file.FootNotes.Relationships, {\n            viewWrapper: file.FootNotes,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"word/_rels/footnotes.xml.rels\"\n      },\n      Settings: {\n        data: xml(\n          this.formatter.format(file.Settings, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"word/settings.xml\"\n      },\n      Comments: {\n        data: (() => {\n          const xmlData = this.imageReplacer.replace(commentXmlData, commentMediaDatas, commentRelationshipCount);\n          const referenedXmlData = this.numberingReplacer.replace(xmlData, file.Numbering.ConcreteNumbering);\n          return referenedXmlData;\n        })(),\n        path: \"word/comments.xml\"\n      },\n      CommentsRelationships: {\n        data: (() => {\n          commentMediaDatas.forEach((mediaData, i) => {\n            file.Comments.Relationships.createRelationship(\n              commentRelationshipCount + i,\n              \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\",\n              `media/${mediaData.fileName}`\n            );\n          });\n          return xml(\n            this.formatter.format(file.Comments.Relationships, {\n              viewWrapper: {\n                View: file.Comments,\n                Relationships: file.Comments.Relationships\n              },\n              file,\n              stack: []\n            }),\n            {\n              indent: prettify,\n              declaration: {\n                encoding: \"UTF-8\"\n              }\n            }\n          );\n        })(),\n        path: \"word/_rels/comments.xml.rels\"\n      },\n      FontTable: {\n        data: xml(\n          this.formatter.format(file.FontTable.View, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              standalone: \"yes\",\n              encoding: \"UTF-8\"\n            }\n          }\n        ),\n        path: \"word/fontTable.xml\"\n      },\n      FontTableRelationships: {\n        data: (() => xml(\n          this.formatter.format(file.FontTable.Relationships, {\n            viewWrapper: file.Document,\n            file,\n            stack: []\n          }),\n          {\n            indent: prettify,\n            declaration: {\n              encoding: \"UTF-8\"\n            }\n          }\n        ))(),\n        path: \"word/_rels/fontTable.xml.rels\"\n      }\n    };\n  }\n}\nconst PrettifyType = {\n  NONE: \"\",\n  WITH_2_BLANKS: \"  \",\n  WITH_4_BLANKS: \"    \",\n  WITH_TAB: \"\t\"\n};\nconst convertPrettifyType = (prettify) => prettify === true ? PrettifyType.WITH_2_BLANKS : prettify === false ? void 0 : prettify;\nconst _Packer = class _Packer {\n  // eslint-disable-next-line require-await\n  static pack(_0, _12, _2) {\n    return __async(this, arguments, function* (file, type2, prettify, overrides = []) {\n      const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);\n      return zip.generateAsync({\n        type: type2,\n        mimeType: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n        compression: \"DEFLATE\"\n      });\n    });\n  }\n  static toString(file, prettify, overrides = []) {\n    return _Packer.pack(file, \"string\", prettify, overrides);\n  }\n  static toBuffer(file, prettify, overrides = []) {\n    return _Packer.pack(file, \"nodebuffer\", prettify, overrides);\n  }\n  static toBase64String(file, prettify, overrides = []) {\n    return _Packer.pack(file, \"base64\", prettify, overrides);\n  }\n  static toBlob(file, prettify, overrides = []) {\n    return _Packer.pack(file, \"blob\", prettify, overrides);\n  }\n  static toArrayBuffer(file, prettify, overrides = []) {\n    return _Packer.pack(file, \"arraybuffer\", prettify, overrides);\n  }\n  static toStream(file, prettify, overrides = []) {\n    const stream = new streamBrowserifyExports.Stream();\n    const zip = this.compiler.compile(file, convertPrettifyType(prettify), overrides);\n    zip.generateAsync({\n      type: \"nodebuffer\",\n      mimeType: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n      compression: \"DEFLATE\"\n    }).then((z) => {\n      stream.emit(\"data\", z);\n      stream.emit(\"end\");\n    });\n    return stream;\n  }\n};\n__publicField(_Packer, \"compiler\", new Compiler());\nlet Packer = _Packer;\nconst formatter$1 = new Formatter();\nconst toJson = (xmlData) => {\n  const xmlObj = libExports.xml2js(xmlData, { compact: false, captureSpacesBetweenElements: true });\n  return xmlObj;\n};\nconst createTextElementContents = (text) => {\n  var _a;\n  const textJson = toJson(xml(formatter$1.format(new Text({ text }))));\n  return (_a = textJson.elements[0].elements) != null ? _a : [];\n};\nconst patchSpaceAttribute = (element) => __spreadProps(__spreadValues({}, element), {\n  attributes: {\n    \"xml:space\": \"preserve\"\n  }\n});\nconst getFirstLevelElements = (relationships, id) => {\n  var _a, _b;\n  return (_b = (_a = relationships.elements) == null ? void 0 : _a.filter((e) => e.name === id)[0].elements) != null ? _b : [];\n};\nconst appendContentType = (element, contentType, extension) => {\n  const relationshipElements = getFirstLevelElements(element, \"Types\");\n  const exist = relationshipElements.some(\n    (el) => {\n      var _a, _b;\n      return el.type === \"element\" && el.name === \"Default\" && ((_a = el == null ? void 0 : el.attributes) == null ? void 0 : _a.ContentType) === contentType && ((_b = el == null ? void 0 : el.attributes) == null ? void 0 : _b.Extension) === extension;\n    }\n  );\n  if (exist) {\n    return;\n  }\n  relationshipElements.push({\n    attributes: {\n      ContentType: contentType,\n      Extension: extension\n    },\n    name: \"Default\",\n    type: \"element\"\n  });\n};\nconst getIdFromRelationshipId = (relationshipId) => {\n  const output = parseInt(relationshipId.substring(3), 10);\n  return isNaN(output) ? 0 : output;\n};\nconst getNextRelationshipIndex = (relationships) => {\n  const relationshipElements = getFirstLevelElements(relationships, \"Relationships\");\n  return relationshipElements.map((e) => {\n    var _a, _b, _c;\n    return getIdFromRelationshipId((_c = (_b = (_a = e.attributes) == null ? void 0 : _a.Id) == null ? void 0 : _b.toString()) != null ? _c : \"\");\n  }).reduce((acc, curr) => Math.max(acc, curr), 0) + 1;\n};\nconst appendRelationship = (relationships, id, type2, target, targetMode) => {\n  const relationshipElements = getFirstLevelElements(relationships, \"Relationships\");\n  relationshipElements.push({\n    attributes: {\n      Id: `rId${id}`,\n      Type: type2,\n      Target: target,\n      TargetMode: targetMode\n    },\n    name: \"Relationship\",\n    type: \"element\"\n  });\n  return relationshipElements;\n};\nconst findRunElementIndexWithToken = (paragraphElement, token) => {\n  var _a, _b, _c, _d;\n  for (let i = 0; i < ((_a = paragraphElement.elements) != null ? _a : []).length; i++) {\n    const element = paragraphElement.elements[i];\n    if (element.type === \"element\" && element.name === \"w:r\") {\n      const textElement = ((_b = element.elements) != null ? _b : []).filter((e) => e.type === \"element\" && e.name === \"w:t\");\n      for (const text of textElement) {\n        if (!((_c = text.elements) == null ? void 0 : _c[0])) {\n          continue;\n        }\n        if ((_d = text.elements[0].text) == null ? void 0 : _d.includes(token)) {\n          return i;\n        }\n      }\n    }\n  }\n  throw new Error(\"Token not found\");\n};\nconst splitRunElement = (runElement, token) => {\n  var _a, _b;\n  let splitIndex = 0;\n  const splitElements = (_b = (_a = runElement.elements) == null ? void 0 : _a.map((e, i) => {\n    var _a2, _b2, _c;\n    if (e.type === \"element\" && e.name === \"w:t\") {\n      const text = (_c = (_b2 = (_a2 = e.elements) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.text) != null ? _c : \"\";\n      const splitText = text.split(token);\n      const newElements = splitText.map((t) => __spreadProps(__spreadValues(__spreadValues({}, e), patchSpaceAttribute(e)), {\n        elements: createTextElementContents(t)\n      }));\n      splitIndex = i;\n      return newElements;\n    } else {\n      return e;\n    }\n  }).flat()) != null ? _b : [];\n  const leftRunElement = __spreadProps(__spreadValues({}, JSON.parse(JSON.stringify(runElement))), {\n    elements: splitElements.slice(0, splitIndex + 1)\n  });\n  const rightRunElement = __spreadProps(__spreadValues({}, JSON.parse(JSON.stringify(runElement))), {\n    elements: splitElements.slice(splitIndex + 1)\n  });\n  return { left: leftRunElement, right: rightRunElement };\n};\nconst ReplaceMode = {\n  START: 0,\n  MIDDLE: 1,\n  END: 2\n};\nconst replaceTokenInParagraphElement = ({\n  paragraphElement,\n  renderedParagraph,\n  originalText,\n  replacementText\n}) => {\n  const startIndex = renderedParagraph.text.indexOf(originalText);\n  const endIndex = startIndex + originalText.length - 1;\n  let replaceMode = ReplaceMode.START;\n  for (const run of renderedParagraph.runs) {\n    for (const { text, index, start, end } of run.parts) {\n      switch (replaceMode) {\n        case ReplaceMode.START:\n          if (startIndex >= start) {\n            const offsetStartIndex = startIndex - start;\n            const offsetEndIndex = Math.min(endIndex, end) - start;\n            const partToReplace = run.text.substring(offsetStartIndex, offsetEndIndex + 1);\n            if (partToReplace === \"\") {\n              continue;\n            }\n            const firstPart = text.replace(partToReplace, replacementText);\n            patchTextElement(paragraphElement.elements[run.index].elements[index], firstPart);\n            replaceMode = ReplaceMode.MIDDLE;\n            continue;\n          }\n          break;\n        case ReplaceMode.MIDDLE:\n          if (endIndex <= end) {\n            const lastPart = text.substring(endIndex - start + 1);\n            patchTextElement(paragraphElement.elements[run.index].elements[index], lastPart);\n            const currentElement = paragraphElement.elements[run.index].elements[index];\n            paragraphElement.elements[run.index].elements[index] = patchSpaceAttribute(currentElement);\n            replaceMode = ReplaceMode.END;\n          } else {\n            patchTextElement(paragraphElement.elements[run.index].elements[index], \"\");\n          }\n          break;\n      }\n    }\n  }\n  return paragraphElement;\n};\nconst patchTextElement = (element, text) => {\n  element.elements = createTextElementContents(text);\n  return element;\n};\nconst renderParagraphNode = (node) => {\n  if (node.element.name !== \"w:p\") {\n    throw new Error(`Invalid node type: ${node.element.name}`);\n  }\n  if (!node.element.elements) {\n    return {\n      text: \"\",\n      runs: [],\n      index: -1,\n      pathToParagraph: []\n    };\n  }\n  let currentRunStringLength = 0;\n  const runs = node.element.elements.map((element, i) => ({ element, i })).filter(({ element }) => element.name === \"w:r\").map(({ element, i }) => {\n    const renderedRunNode = renderRunNode(element, i, currentRunStringLength);\n    currentRunStringLength += renderedRunNode.text.length;\n    return renderedRunNode;\n  }).filter((e) => !!e);\n  const text = runs.reduce((acc, curr) => acc + curr.text, \"\");\n  return {\n    text,\n    runs,\n    index: node.index,\n    pathToParagraph: buildNodePath(node)\n  };\n};\nconst renderRunNode = (node, index, currentRunStringIndex) => {\n  if (!node.elements) {\n    return {\n      text: \"\",\n      parts: [],\n      index: -1,\n      start: currentRunStringIndex,\n      end: currentRunStringIndex\n    };\n  }\n  let currentTextStringIndex = currentRunStringIndex;\n  const parts = node.elements.map(\n    (element, i) => {\n      var _a, _b;\n      return element.name === \"w:t\" && element.elements && element.elements.length > 0 ? {\n        text: (_b = (_a = element.elements[0].text) == null ? void 0 : _a.toString()) != null ? _b : \"\",\n        index: i,\n        start: currentTextStringIndex,\n        end: (() => {\n          var _a2, _b2;\n          currentTextStringIndex += ((_b2 = (_a2 = element.elements[0].text) == null ? void 0 : _a2.toString()) != null ? _b2 : \"\").length - 1;\n          return currentTextStringIndex;\n        })()\n      } : void 0;\n    }\n  ).filter((e) => !!e).map((e) => e);\n  const text = parts.reduce((acc, curr) => acc + curr.text, \"\");\n  return {\n    text,\n    parts,\n    index,\n    start: currentRunStringIndex,\n    end: currentTextStringIndex\n  };\n};\nconst buildNodePath = (node) => node.parent ? [...buildNodePath(node.parent), node.index] : [node.index];\nconst elementsToWrapper = (wrapper) => {\n  var _a, _b;\n  return (_b = (_a = wrapper.element.elements) == null ? void 0 : _a.map((e, i) => ({\n    element: e,\n    index: i,\n    parent: wrapper\n  }))) != null ? _b : [];\n};\nconst traverse = (node) => {\n  let renderedParagraphs = [];\n  const queue2 = [\n    ...elementsToWrapper({\n      element: node,\n      index: 0,\n      parent: void 0\n    })\n  ];\n  let currentNode;\n  while (queue2.length > 0) {\n    currentNode = queue2.shift();\n    if (currentNode.element.name === \"w:p\") {\n      renderedParagraphs = [...renderedParagraphs, renderParagraphNode(currentNode)];\n    }\n    queue2.push(...elementsToWrapper(currentNode));\n  }\n  return renderedParagraphs;\n};\nconst findLocationOfText = (node, text) => traverse(node).filter((p) => p.text.includes(text));\nconst formatter = new Formatter();\nconst SPLIT_TOKEN = \"\";\nconst replacer = ({\n  json,\n  patch,\n  patchText,\n  context,\n  keepOriginalStyles = true\n}) => {\n  const renderedParagraphs = findLocationOfText(json, patchText);\n  if (renderedParagraphs.length === 0) {\n    return { element: json, didFindOccurrence: false };\n  }\n  for (const renderedParagraph of renderedParagraphs) {\n    const textJson = patch.children.map((c) => toJson(xml(formatter.format(c, context)))).map((c) => c.elements[0]);\n    switch (patch.type) {\n      case PatchType.DOCUMENT: {\n        const parentElement = goToParentElementFromPath(json, renderedParagraph.pathToParagraph);\n        const elementIndex = getLastElementIndexFromPath(renderedParagraph.pathToParagraph);\n        parentElement.elements.splice(elementIndex, 1, ...textJson);\n        break;\n      }\n      case PatchType.PARAGRAPH:\n      default: {\n        const paragraphElement = goToElementFromPath(json, renderedParagraph.pathToParagraph);\n        replaceTokenInParagraphElement({\n          paragraphElement,\n          renderedParagraph,\n          originalText: patchText,\n          replacementText: SPLIT_TOKEN\n        });\n        const index = findRunElementIndexWithToken(paragraphElement, SPLIT_TOKEN);\n        const runElementToBeReplaced = paragraphElement.elements[index];\n        const { left, right } = splitRunElement(runElementToBeReplaced, SPLIT_TOKEN);\n        let newRunElements = textJson;\n        let patchedRightElement = right;\n        if (keepOriginalStyles) {\n          const runElementNonTextualElements = runElementToBeReplaced.elements.filter(\n            (e) => e.type === \"element\" && e.name === \"w:rPr\"\n          );\n          newRunElements = textJson.map((e) => {\n            var _a;\n            return __spreadProps(__spreadValues({}, e), {\n              elements: [...runElementNonTextualElements, ...(_a = e.elements) != null ? _a : []]\n            });\n          });\n          patchedRightElement = __spreadProps(__spreadValues({}, right), {\n            elements: [...runElementNonTextualElements, ...right.elements]\n          });\n        }\n        paragraphElement.elements.splice(index, 1, left, ...newRunElements, patchedRightElement);\n        break;\n      }\n    }\n  }\n  return { element: json, didFindOccurrence: true };\n};\nconst goToElementFromPath = (json, path) => {\n  let element = json;\n  for (let i = 1; i < path.length; i++) {\n    const index = path[i];\n    const nextElements = element.elements;\n    element = nextElements[index];\n  }\n  return element;\n};\nconst goToParentElementFromPath = (json, path) => goToElementFromPath(json, path.slice(0, path.length - 1));\nconst getLastElementIndexFromPath = (path) => path[path.length - 1];\nconst PatchType = {\n  DOCUMENT: \"file\",\n  PARAGRAPH: \"paragraph\"\n};\nconst imageReplacer = new ImageReplacer();\nconst UTF16LE = new Uint8Array([255, 254]);\nconst UTF16BE = new Uint8Array([254, 255]);\nconst compareByteArrays = (a, b) => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst patchDocument = (_0) => __async(void 0, [_0], function* ({\n  outputType,\n  data,\n  patches,\n  keepOriginalStyles,\n  placeholderDelimiters = { start: \"{{\", end: \"}}\" },\n  /**\n   * Search for occurrences over patched document\n   */\n  recursive = true\n}) {\n  var _a, _b, _c;\n  const zipContent = data instanceof JSZip ? data : yield JSZip.loadAsync(data);\n  const contexts = /* @__PURE__ */ new Map();\n  const file = {\n    Media: new Media()\n  };\n  const map = /* @__PURE__ */ new Map();\n  const imageRelationshipAdditions = [];\n  const hyperlinkRelationshipAdditions = [];\n  let hasMedia = false;\n  const binaryContentMap = /* @__PURE__ */ new Map();\n  for (const [key, value] of Object.entries(zipContent.files)) {\n    const binaryValue = yield value.async(\"uint8array\");\n    const startBytes = binaryValue.slice(0, 2);\n    if (compareByteArrays(startBytes, UTF16LE) || compareByteArrays(startBytes, UTF16BE)) {\n      binaryContentMap.set(key, binaryValue);\n      continue;\n    }\n    if (!key.endsWith(\".xml\") && !key.endsWith(\".rels\")) {\n      binaryContentMap.set(key, binaryValue);\n      continue;\n    }\n    const json = toJson(yield value.async(\"text\"));\n    if (key === \"word/document.xml\") {\n      const document2 = (_a = json.elements) == null ? void 0 : _a.find((i) => i.name === \"w:document\");\n      if (document2 && document2.attributes) {\n        for (const ns of [\"mc\", \"wp\", \"r\", \"w15\", \"m\"]) {\n          document2.attributes[`xmlns:${ns}`] = DocumentAttributeNamespaces[ns];\n        }\n        document2.attributes[\"mc:Ignorable\"] = `${document2.attributes[\"mc:Ignorable\"] || \"\"} w15`.trim();\n      }\n    }\n    if (key.startsWith(\"word/\") && !key.endsWith(\".xml.rels\")) {\n      const context = {\n        file,\n        viewWrapper: {\n          Relationships: {\n            createRelationship: (linkId, _, target, __) => {\n              hyperlinkRelationshipAdditions.push({\n                key,\n                hyperlink: {\n                  id: linkId,\n                  link: target\n                }\n              });\n            }\n          }\n        },\n        stack: []\n      };\n      contexts.set(key, context);\n      if (!(placeholderDelimiters == null ? void 0 : placeholderDelimiters.start.trim()) || !(placeholderDelimiters == null ? void 0 : placeholderDelimiters.end.trim())) {\n        throw new Error(\"Both start and end delimiters must be non-empty strings.\");\n      }\n      const { start, end } = placeholderDelimiters;\n      for (const [patchKey, patchValue] of Object.entries(patches)) {\n        const patchText = `${start}${patchKey}${end}`;\n        while (true) {\n          const { didFindOccurrence } = replacer({\n            json,\n            patch: __spreadProps(__spreadValues({}, patchValue), {\n              children: patchValue.children.map((element) => {\n                if (element instanceof ExternalHyperlink) {\n                  const concreteHyperlink = new ConcreteHyperlink(element.options.children, uniqueId());\n                  hyperlinkRelationshipAdditions.push({\n                    key,\n                    hyperlink: {\n                      id: concreteHyperlink.linkId,\n                      link: element.options.link\n                    }\n                  });\n                  return concreteHyperlink;\n                } else {\n                  return element;\n                }\n              })\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            }),\n            patchText,\n            context,\n            keepOriginalStyles\n          });\n          if (!recursive || !didFindOccurrence) {\n            break;\n          }\n        }\n      }\n      const mediaDatas = imageReplacer.getMediaData(JSON.stringify(json), context.file.Media);\n      if (mediaDatas.length > 0) {\n        hasMedia = true;\n        imageRelationshipAdditions.push({\n          key,\n          mediaDatas\n        });\n      }\n    }\n    map.set(key, json);\n  }\n  for (const { key, mediaDatas } of imageRelationshipAdditions) {\n    const relationshipKey = `word/_rels/${key.split(\"/\").pop()}.rels`;\n    const relationshipsJson = (_b = map.get(relationshipKey)) != null ? _b : createRelationshipFile();\n    map.set(relationshipKey, relationshipsJson);\n    const index = getNextRelationshipIndex(relationshipsJson);\n    const newJson = imageReplacer.replace(JSON.stringify(map.get(key)), mediaDatas, index);\n    map.set(key, JSON.parse(newJson));\n    for (let i = 0; i < mediaDatas.length; i++) {\n      const { fileName } = mediaDatas[i];\n      appendRelationship(\n        relationshipsJson,\n        index + i,\n        \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\",\n        `media/${fileName}`\n      );\n    }\n  }\n  for (const { key, hyperlink } of hyperlinkRelationshipAdditions) {\n    const relationshipKey = `word/_rels/${key.split(\"/\").pop()}.rels`;\n    const relationshipsJson = (_c = map.get(relationshipKey)) != null ? _c : createRelationshipFile();\n    map.set(relationshipKey, relationshipsJson);\n    appendRelationship(\n      relationshipsJson,\n      hyperlink.id,\n      \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\",\n      hyperlink.link,\n      TargetModeType.EXTERNAL\n    );\n  }\n  if (hasMedia) {\n    const contentTypesJson = map.get(\"[Content_Types].xml\");\n    if (!contentTypesJson) {\n      throw new Error(\"Could not find content types file\");\n    }\n    appendContentType(contentTypesJson, \"image/png\", \"png\");\n    appendContentType(contentTypesJson, \"image/jpeg\", \"jpeg\");\n    appendContentType(contentTypesJson, \"image/jpeg\", \"jpg\");\n    appendContentType(contentTypesJson, \"image/bmp\", \"bmp\");\n    appendContentType(contentTypesJson, \"image/gif\", \"gif\");\n    appendContentType(contentTypesJson, \"image/svg+xml\", \"svg\");\n  }\n  const zip = new JSZip();\n  for (const [key, value] of map) {\n    const output = toXml(value);\n    zip.file(key, output);\n  }\n  for (const [key, value] of binaryContentMap) {\n    zip.file(key, value);\n  }\n  for (const { data: stream, fileName } of file.Media.Array) {\n    zip.file(`word/media/${fileName}`, stream);\n  }\n  return zip.generateAsync({\n    type: outputType,\n    mimeType: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    compression: \"DEFLATE\"\n  });\n});\nconst toXml = (jsonObj) => {\n  const output = libExports.js2xml(jsonObj, {\n    attributeValueFn: (str) => String(str).replace(/&(?!amp;|lt;|gt;|quot;|apos;)/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\")\n    // cspell:words apos\n  });\n  return output;\n};\nconst createRelationshipFile = () => ({\n  declaration: {\n    attributes: {\n      version: \"1.0\",\n      encoding: \"UTF-8\",\n      standalone: \"yes\"\n    }\n  },\n  elements: [\n    {\n      type: \"element\",\n      name: \"Relationships\",\n      attributes: {\n        xmlns: \"http://schemas.openxmlformats.org/package/2006/relationships\"\n      },\n      elements: []\n    }\n  ]\n});\nconst patchDetector = (_0) => __async(void 0, [_0], function* ({ data }) {\n  const zipContent = data instanceof JSZip ? data : yield JSZip.loadAsync(data);\n  const patches = /* @__PURE__ */ new Set();\n  for (const [key, value] of Object.entries(zipContent.files)) {\n    if (!key.endsWith(\".xml\") && !key.endsWith(\".rels\")) {\n      continue;\n    }\n    if (key.startsWith(\"word/\") && !key.endsWith(\".xml.rels\")) {\n      const json = toJson(yield value.async(\"text\"));\n      traverse(json).forEach((p) => findPatchKeys(p.text).forEach((patch) => patches.add(patch)));\n    }\n  }\n  return Array.from(patches);\n});\nconst findPatchKeys = (text) => {\n  var _a;\n  const pattern = new RegExp(\"(?<=\\\\{\\\\{).+?(?=\\\\}\\\\})\", \"gs\");\n  return (_a = text.match(pattern)) != null ? _a : [];\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kb2N4L2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTyxzQ0FBc0MsWUFBWSxvQ0FBb0MsVUFBVSxjQUFjLEtBQUs7QUFDL0ssYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxFQUFFO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsVUFBVTtBQUMzQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxpRkFBaUYsc0NBQXNDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsTUFBTTtBQUNOLG9EQUFvRDtBQUNwRCxNQUFNO0FBQ04sMERBQTBEO0FBQzFELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkUsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksZUFBZSxZQUFZO0FBQ3hELGlCQUFpQixLQUFLO0FBQ3RCO0FBQ0EsaUJBQWlCLDRCQUE0QiwyQkFBMkIsWUFBWTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxlQUFlLFlBQVk7QUFDeEQsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQSxpQkFBaUIsa0NBQWtDLDJCQUEyQixZQUFZO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZEQUE2RDtBQUNyRyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQTZEO0FBQ3JHLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG1CQUFtQixNQUFNLDBCQUEwQixNQUFNLDRCQUE0QixNQUFNO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1CQUFtQjtBQUN4RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0Isc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixvQ0FBb0Msc0JBQXNCLHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxJQUFJO0FBQzdELDBDQUEwQyxJQUFJLGNBQWMsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZSxFQUFFLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUNBQXVDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQSxNQUFNO0FBQ04sMENBQTBDLDhEQUE4RDtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUUsNkVBQTZFO0FBQ2pHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCLElBQUksc0NBQXNDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QixTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQTBDO0FBQzVFLHdDQUF3QyxzQ0FBc0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUF1RDtBQUN4RjtBQUNBO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTixrQ0FBa0MsMkVBQTJFO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTSxHQUFHLGFBQWE7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVCxXQUFXLGdDQUFnQyxHQUFHLHNCQUFzQjtBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkUsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLE9BQU8sVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3RUFBd0U7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBbUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQWdEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEVBQUUsSUFBSTtBQUM5QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBOEM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZFQUE2RTtBQUM5RixpQkFBaUIsdUVBQXVFO0FBQ3hGLG9CQUFvQiwrQkFBK0I7QUFDbkQsc0JBQXNCO0FBQ3RCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxpQkFBaUIscURBQXFEO0FBQ3RFLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0EsZUFBZSwrRUFBK0U7QUFDOUYsYUFBYSx5RUFBeUU7QUFDdEYsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ04saURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1EQUFtRDtBQUNsRSxpQkFBaUIsaURBQWlEO0FBQ2xFLGtCQUFrQix5REFBeUQ7QUFDM0UsZ0JBQWdCLCtDQUErQztBQUMvRCxrQkFBa0IsbURBQW1EO0FBQ3JFLGtCQUFrQixtREFBbUQ7QUFDckUsa0JBQWtCO0FBQ2xCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlGQUF5RjtBQUN4RyxnQkFBZ0IseUZBQXlGO0FBQ3pHLHFCQUFxQixxQ0FBcUM7QUFDMUQsY0FBYztBQUNkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQUk7QUFDWixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWLFlBQVksNkNBQTZDLElBQUk7QUFDN0QsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNDQUFzQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlELGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLLDBGQUEwRixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLDRCQUE0QixHQUFHLG1EQUFtRDtBQUMxSCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlEQUF5RDtBQUN2RztBQUNBLDZDQUE2Qyx1REFBdUQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLENBQUM7QUFDRCwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RCw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRTtBQUNBO0FBQ0Esb0RBQW9ELCtCQUErQjtBQUNuRjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRTtBQUNBO0FBQ0Esb0RBQW9ELCtCQUErQjtBQUNuRjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsZ0RBQWdELDZCQUE2QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsZ0RBQWdELDZCQUE2QjtBQUM3RSxrREFBa0QsK0JBQStCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DLHFDQUFxQyxxQkFBcUI7QUFDMUQsdUNBQXVDLHVCQUF1QjtBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNELHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0UsZ0NBQWdDLHVDQUF1QztBQUN2RTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDZCQUE2QjtBQUM3QjtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBMEQ7QUFDakY7QUFDQTtBQUNBLHNEQUFzRCxpQ0FBaUM7QUFDdkY7QUFDQTtBQUNBLHVEQUF1RCxrQ0FBa0M7QUFDekY7QUFDQTtBQUNBLHlEQUF5RCxvQ0FBb0M7QUFDN0Y7QUFDQTtBQUNBLHdEQUF3RCxtQ0FBbUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0I7QUFDaEIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHFCQUFxQjtBQUNuRjtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0VBQXNFLFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQStHLE1BQU07QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0csTUFBTTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQ0FBcUM7QUFDdEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBLFVBQVU7QUFDVixHQUFHLGNBQWMsV0FBVywyQkFBMkIsRUFBRSxTQUFTLE1BQU0sSUFBSTtBQUM1RTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQsb0JBQW9CLGdDQUFnQztBQUNwRCxvQkFBb0IsZ0NBQWdDO0FBQ3BELG9CQUFvQixnQ0FBZ0M7QUFDcEQsb0JBQW9CLGdDQUFnQztBQUNwRCxvQkFBb0I7QUFDcEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVGQUF1RjtBQUNuRyxXQUFXLDhGQUE4RjtBQUN6RyxXQUFXLHVGQUF1RjtBQUNsRyxhQUFhLGlGQUFpRjtBQUM5RixhQUFhLGlGQUFpRjtBQUM5RixnQkFBZ0Isd0ZBQXdGO0FBQ3hHLGdCQUFnQix3RkFBd0Y7QUFDeEcsYUFBYSxpRkFBaUY7QUFDOUYsa0JBQWtCLGtHQUFrRztBQUNwSCxlQUFlLHlGQUF5RjtBQUN4RyxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsUUFBUSx1QkFBdUI7QUFDL0c7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0JBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVUsR0FBRyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0RBQWdEO0FBQ3ZHO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscURBQXFEO0FBQ3JELGtEQUFrRDtBQUNsRCxrRUFBa0U7QUFDbEUsbURBQW1EO0FBQ25ELDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2RUFBNkUsWUFBWTtBQUN6RiwwRUFBMEUsY0FBYztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLGNBQWMsd0JBQXdCO0FBQ2pFLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxPQUFPLDZCQUE2QjtBQUN4RTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsT0FBTyxvQ0FBb0M7QUFDL0U7QUFDQTtBQUNBLHVCQUF1QixhQUFhLE9BQU8sNkNBQTZDO0FBQ3hGO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxPQUFPLGdEQUFnRDtBQUMzRjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsT0FBTyxrQ0FBa0M7QUFDN0U7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxPQUFPLGtDQUFrQztBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsT0FBTyw0Q0FBNEM7QUFDdkY7QUFDQTtBQUNBLHVCQUF1QixhQUFhLE9BQU8sa0NBQWtDO0FBQzdFO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxPQUFPLDRDQUE0QztBQUN2RjtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsT0FBTyw0Q0FBNEM7QUFDdkY7QUFDQTtBQUNBLHFFQUFxRSxhQUFhLEdBQUcsU0FBUztBQUM5Rix1QkFBdUIsYUFBYSxPQUFPLE9BQU87QUFDbEQ7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRDQUE0QztBQUNoRyxNQUFNO0FBQ04sb0RBQW9ELEtBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUNELDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixXQUFXLElBQUksVUFBVSxJQUFJLFlBQVksSUFBSSxhQUFhO0FBQ2xGO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxVQUFVO0FBQzlDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG1CQUFtQixHQUFHLE1BQU0sVUFBVTtBQUNqSSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdDQUFnQyxnQ0FBZ0MsYUFBYTtBQUM3RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixjQUFjO0FBQ25HO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7QUFDQTtBQUNBLGtIQUFrSCxlQUFlO0FBQ2pJO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBLE9BQU8sSUFBSSxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVCxPQUFPLElBQUksdUdBQXVHO0FBQ2xIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVztBQUNYLE9BQU8sSUFBSSw0Q0FBNEM7QUFDdkQ7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTyxJQUFJLGVBQWU7QUFDMUI7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBLDhFQUE4RTtBQUM5RSxPQUFPLElBQUksU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsaURBQWlELGlEQUFpRDtBQUNsRztBQUNBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEM7QUFDQSxPQUFPLElBQUksdURBQXVEO0FBQ2xFO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSwyWEFBMlg7QUFDM1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxrTkFBa047QUFDbE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsdUJBQXVCLHNGQUFzRjtBQUMzTyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCLGNBQWM7QUFDbkUsWUFBWTtBQUNaLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsV0FBVyxjQUFjLGdCQUFnQjtBQUN6QyxnQ0FBZ0MsNkJBQTZCLGNBQWMsR0FBRywyQkFBMkI7QUFDekc7QUFDQSxTQUFTO0FBQ1QsbURBQW1ELDZCQUE2QixrQkFBa0IsbUNBQW1DLGdCQUFnQjtBQUNySjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsc0JBQXNCLGtCQUFrQixnQkFBZ0I7QUFDeEQsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRCxTQUFTO0FBQ1QsT0FBTyxJQUFJLGlHQUFpRztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUdBQXlHO0FBQ3hILGtFQUFrRSw4SEFBOEg7QUFDaE0sYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSw0Q0FBNEM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLElBQUksaUZBQWlGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUksb0hBQW9IO0FBQzdKO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0EsV0FBVztBQUNYLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSw0Q0FBNEMsNk9BQTZPO0FBQ3pSO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPLElBQUksa0hBQWtIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixjQUFjO0FBQ3RELFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsT0FBTyxJQUFJLCtDQUErQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sSUFBSSx1Q0FBdUM7QUFDbEQsc0JBQXNCLDhCQUE4QixNQUFNO0FBQzFELGNBQWMsTUFBTSxTQUFTLE1BQU0sa0NBQWtDLE1BQU07QUFDM0U7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQixTQUFTO0FBQ1QsY0FBYyxNQUFNLGVBQWUsTUFBTTtBQUN6Qyx1QkFBdUIsTUFBTTtBQUM3QjtBQUNBLFNBQVM7QUFDVCxpQkFBaUIsTUFBTTtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxtSEFBbUgsOEJBQThCO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXLGdCQUFnQjtBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLElBQUkseUtBQXlLO0FBQ3BOO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxPQUFPLElBQUksb09BQW9PO0FBQy9PO0FBQ0EsT0FBTyxJQUFJLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvSUFBb0ksUUFBUTtBQUM1STtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLElBQUksb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFNBQVM7QUFDVCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPLElBQUksZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxJQUFJLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sSUFBSSxvQ0FBb0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLElBQUkscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUksaUlBQWlJO0FBQzVJO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBNEQ7QUFDbEYsU0FBUztBQUNULE9BQU8sSUFBSSx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sSUFBSSxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxJQUFJLHVDQUF1QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCLHVEQUF1RDtBQUN2SCxTQUFTO0FBQ1QsT0FBTyxJQUFJLHVDQUF1QztBQUNsRDtBQUNBLDJEQUEyRCx1REFBdUQsNEZBQTRGLDhCQUE4QjtBQUM1TztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Qsb0RBQW9ELGlDQUFpQztBQUNyRixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0IsK0NBQStDO0FBQzlFLFdBQVc7QUFDWCxPQUFPLElBQUksNkpBQTZKO0FBQ3hLLDBMQUEwTCxNQUFNO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7QUFDcEUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU8sSUFBSSx1QkFBdUI7QUFDbEMsMklBQTJJLFNBQVM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQyxzRkFBc0YsU0FBUztBQUMvRjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixrQ0FBa0M7QUFDeEg7QUFDQSxXQUFXO0FBQ1gsb01BQW9NLHVDQUF1QztBQUMzTyxTQUFTO0FBQ1QsZ0VBQWdFLDZDQUE2QztBQUM3RyxTQUFTO0FBQ1Qsc0JBQXNCLDRDQUE0QztBQUNsRSxTQUFTO0FBQ1QsT0FBTyxJQUFJLG1GQUFtRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQSxTQUFTO0FBQ1Qsb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZJQUE2SSxRQUFRO0FBQ3JKO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBLE9BQU8sSUFBSSx3RkFBd0Y7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxRUFBcUUsUUFBUSw0SEFBNEg7QUFDek0sU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQyxTQUFTO0FBQ1Q7QUFDQSw0REFBNEQsMERBQTBELGdCQUFnQixtQkFBbUI7QUFDeko7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFdBQVc7QUFDWCxPQUFPLElBQUksK0ZBQStGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseURBQXlELEdBQUcsbUJBQW1CLHlGQUF5RjtBQUN4SztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU8sSUFBSSxvSUFBb0k7QUFDL0k7QUFDQSxpUEFBaVA7QUFDalA7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTLGNBQWM7QUFDaEM7QUFDQSxPQUFPLElBQUksNkhBQTZIO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEMsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1KQUFtSjtBQUM1SixPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUksZUFBZTtBQUMxQjtBQUNBO0FBQ0EsT0FBTyxJQUFJLGdHQUFnRztBQUMzRztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUZBQXlGLFVBQVU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsK0JBQStCO0FBQy9CLFNBQVM7QUFDVCwrQkFBK0I7QUFDL0I7QUFDQSxPQUFPLElBQUksZ0hBQWdIO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5Q0FBeUMsVUFBVTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsK0JBQStCO0FBQy9CLFNBQVM7QUFDVCxPQUFPLElBQUksK0pBQStKO0FBQzFLO0FBQ0E7QUFDQSxrRUFBa0UsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekMsU0FBUztBQUNUO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQsb0VBQW9FLFNBQVM7QUFDN0U7QUFDQSxXQUFXLFFBQVE7QUFDbkIsMkJBQTJCLFNBQVM7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsdUVBQXVFLFNBQVM7QUFDaEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvRkFBb0Ysa0NBQWtDO0FBQ3RIO0FBQ0E7QUFDQSxPQUFPLElBQUksZ0JBQWdCO0FBQzNCO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkYsZ0RBQWdELHdDQUF3QztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYLHNCQUFzQjtBQUN0QixPQUFPLElBQUk7QUFDWDtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLGdFQUFnRTtBQUN2TixpQ0FBaUMsZ0VBQWdFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLGdrQkFBZ2tCLHVOQUF1TjtBQUN2eEIsWUFBWTtBQUNaO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyTkFBMk47QUFDalE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0TEFBNEwsb09BQW9PO0FBQ2hhO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMlBBQTJQO0FBQzdSO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlZQUFpWSxtQkFBbUI7QUFDcFosZ0VBQWdFLGdLQUFnSztBQUNoTztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTyxJQUFJLHdGQUF3RjtBQUNuRztBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBLG9CQUFvQjtBQUNwQixvQ0FBb0MsaUVBQWlFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RSxtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3Qix3REFBd0QsU0FBUyxXQUFXLFNBQVM7QUFDckYsa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhHQUE4RztBQUMxSTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpSEFBaUg7QUFDN0k7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekMsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQsdUJBQXVCLHVHQUF1RztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsbUJBQW1CO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUdBQXVHO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1IQUFtSDtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUdBQXlHO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9IQUFvSDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU8sSUFBSSwwRkFBMEY7QUFDckc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0Isc0JBQXNCLE9BQU87QUFDN0IsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0MsNENBQTRDLFNBQVM7QUFDckQ7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxzQkFBc0IsT0FBTztBQUM3QjtBQUNBLG1CQUFtQjtBQUNuQixvSkFBb0osaUVBQWlFO0FBQ3JOLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0NBQXNDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSx1QkFBdUI7QUFDbEMsc0JBQXNCO0FBQ3RCLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2Q0FBNkM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxxSUFBcUk7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb1VBQW9VO0FBQzVXO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEUsaUJBQWlCLGlCQUFpQjtBQUNsQyx3REFBd0QsU0FBUztBQUNqRSx3QkFBd0IsK1ZBQStWO0FBQ3ZYO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQyw2RUFBNkUsUUFBUTtBQUNyRjtBQUNBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLGdCQUFnQjtBQUNoQiw0QkFBNEIsVUFBVSxpQ0FBaUMsVUFBVTtBQUNqRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsVUFBVTtBQUMvRjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsVUFBVTtBQUNqRSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZLCtCQUErQixpQkFBaUI7QUFDMUYsOENBQThDLFNBQVMsK0JBQStCLGlCQUFpQjtBQUN2RywyQkFBMkIsUUFBUSxvQ0FBb0MscUJBQXFCO0FBQzVGLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixXQUFXO0FBQ3BDLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixXQUFXO0FBQzlCLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0lBQWtJLDRDQUE0QztBQUM5SztBQUNBLFdBQVc7QUFDWDtBQUNBLGlGQUFpRixTQUFTO0FBQzFGO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTyxJQUFJLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx1RUFBdUUsZ0JBQWdCO0FBQ3ZGLDJCQUEyQjtBQUMzQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVMsbUpBQW1KO0FBQzVKLE9BQU8sSUFBSSxHQUFHLElBQUk7QUFDbEIsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsUUFBUTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUUsZ0JBQWdCO0FBQzdFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsRUFBRSxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxRQUFRO0FBQ1IsK0JBQStCLGNBQWM7QUFDN0MsK0JBQStCLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9EQUFvRDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixHQUFHO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlFQUFpRTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCx3REFBd0Q7QUFDeEQ7QUFDQSxHQUFHO0FBQ0gseURBQXlEO0FBQ3pEO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZLGFBQWEsU0FBUyxvQ0FBb0MsWUFBWTtBQUM5STtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCwrREFBK0Q7QUFDL0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUsV0FBVyxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDO0FBQ0Esa0RBQWtELDRDQUE0QztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsNkJBQTZCLE1BQU0sRUFBRSxTQUFTLEVBQUUsSUFBSTtBQUNwRDtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQywwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEMsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDREQUE0RCxJQUFJLElBQUksTUFBTSxNQUFNLFdBQVcsc0JBQXNCLHNCQUFzQix3QkFBd0Isd0JBQXdCO0FBQ3ZMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsVUFBVSxHQUFHO0FBQ3JEO0FBQ0E7QUFnU0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2RvY3gvZGlzdC9pbmRleC5tanM/YzEzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIF9fYXN5bmMgPSAoX190aGlzLCBfX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdmFyIGZ1bGZpbGxlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdGVwID0gKHgpID0+IHguZG9uZSA/IHJlc29sdmUoeC52YWx1ZSkgOiBQcm9taXNlLnJlc29sdmUoeC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkoX190aGlzLCBfX2FyZ3VtZW50cykpLm5leHQoKSk7XG4gIH0pO1xufTtcbmNsYXNzIEJhc2VYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihyb290S2V5KSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJvb3RLZXlcIik7XG4gICAgdGhpcy5yb290S2V5ID0gcm9vdEtleTtcbiAgfVxufVxuY29uc3QgRU1QVFlfT0JKRUNUID0gT2JqZWN0LnNlYWwoe30pO1xuY2xhc3MgWG1sQ29tcG9uZW50IGV4dGVuZHMgQmFzZVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJvb3RLZXkpIHtcbiAgICBzdXBlcihyb290S2V5KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb290XCIpO1xuICAgIHRoaXMucm9vdCA9IG5ldyBBcnJheSgpO1xuICB9XG4gIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgZm9ybWF0dGVyIHRvIGdldCB0aGUgWE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LlxuICAvLyBJdCBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgZm9yIGFsbCBjaGlsZCBjb21wb25lbnRzLlxuICAvLyBJdCBpcyBhIHNlcmlhbGl6ZXIgdG8gYmUgdXNlZCBpbiB0aGUgeG1sIGxpYnJhcnkuXG4gIC8vIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3htbFxuICAvLyBDaGlsZCBjb21wb25lbnRzIGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjdXN0b21pemUgdGhlIFhNTCByZXByZXNlbnRhdGlvbiwgb3IgZXhlY3V0ZSBzaWRlIGVmZmVjdHMuXG4gIHByZXBGb3JYbWwoY29udGV4dCkge1xuICAgIHZhciBfYTtcbiAgICBjb250ZXh0LnN0YWNrLnB1c2godGhpcyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnJvb3QubWFwKChjb21wKSA9PiB7XG4gICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIEJhc2VYbWxDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXAucHJlcEZvclhtbChjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wO1xuICAgIH0pLmZpbHRlcigoY29tcCkgPT4gY29tcCAhPT0gdm9pZCAwKTtcbiAgICBjb250ZXh0LnN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5yb290S2V5XTogY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICgoX2EgPSBjaGlsZHJlblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLl9hdHRyKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW4gOiBFTVBUWV9PQkpFQ1RcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseSBieSB0aGUgbGlicmFyeS4gSXQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gICAqL1xuICBhZGRDaGlsZEVsZW1lbnQoY2hpbGQpIHtcbiAgICB0aGlzLnJvb3QucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIElnbm9yZUlmRW1wdHlYbWxDb21wb25lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBwcmVwRm9yWG1sKGNvbnRleHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wcmVwRm9yWG1sKGNvbnRleHQpO1xuICAgIGlmIChyZXN1bHQgJiYgKHR5cGVvZiByZXN1bHRbdGhpcy5yb290S2V5XSAhPT0gXCJvYmplY3RcIiB8fCBPYmplY3Qua2V5cyhyZXN1bHRbdGhpcy5yb290S2V5XSkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgWG1sQXR0cmlidXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICBzdXBlcihcIl9hdHRyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIpO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gIH1cbiAgcHJlcEZvclhtbChfKSB7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnJvb3QpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbmV3S2V5ID0gdGhpcy54bWxLZXlzICYmIHRoaXMueG1sS2V5c1trZXldIHx8IGtleTtcbiAgICAgICAgYXR0cnNbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IF9hdHRyOiBhdHRycyB9O1xuICB9XG59XG5jbGFzcyBOZXh0QXR0cmlidXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICBzdXBlcihcIl9hdHRyXCIpO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gIH1cbiAgcHJlcEZvclhtbChfKSB7XG4gICAgY29uc3QgYXR0cnMgPSBPYmplY3QudmFsdWVzKHRoaXMucm9vdCkuZmlsdGVyKCh7IHZhbHVlIH0pID0+IHZhbHVlICE9PSB2b2lkIDApLnJlZHVjZSgoYWNjLCB7IGtleSwgdmFsdWUgfSkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYWNjKSwgeyBba2V5XTogdmFsdWUgfSksIHt9KTtcbiAgICByZXR1cm4geyBfYXR0cjogYXR0cnMgfTtcbiAgfVxufVxuY2xhc3MgQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgdmFsOiBcInc6dmFsXCIsXG4gICAgICBjb2xvcjogXCJ3OmNvbG9yXCIsXG4gICAgICBmaWxsOiBcInc6ZmlsbFwiLFxuICAgICAgc3BhY2U6IFwidzpzcGFjZVwiLFxuICAgICAgc3o6IFwidzpzelwiLFxuICAgICAgdHlwZTogXCJ3OnR5cGVcIixcbiAgICAgIHJzaWRSOiBcInc6cnNpZFJcIixcbiAgICAgIHJzaWRSUHI6IFwidzpyc2lkUlByXCIsXG4gICAgICByc2lkU2VjdDogXCJ3OnJzaWRTZWN0XCIsXG4gICAgICB3OiBcInc6d1wiLFxuICAgICAgaDogXCJ3OmhcIixcbiAgICAgIHRvcDogXCJ3OnRvcFwiLFxuICAgICAgcmlnaHQ6IFwidzpyaWdodFwiLFxuICAgICAgYm90dG9tOiBcInc6Ym90dG9tXCIsXG4gICAgICBsZWZ0OiBcInc6bGVmdFwiLFxuICAgICAgaGVhZGVyOiBcInc6aGVhZGVyXCIsXG4gICAgICBmb290ZXI6IFwidzpmb290ZXJcIixcbiAgICAgIGd1dHRlcjogXCJ3Omd1dHRlclwiLFxuICAgICAgbGluZVBpdGNoOiBcInc6bGluZVBpdGNoXCIsXG4gICAgICBwb3M6IFwidzpwb3NcIlxuICAgIH0pO1xuICB9XG59XG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMSh4KSB7XG4gIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgXCJkZWZhdWx0XCIpID8geFtcImRlZmF1bHRcIl0gOiB4O1xufVxudmFyIHNheCA9IHt9O1xudmFyIGV2ZW50cyA9IHsgZXhwb3J0czoge30gfTtcbnZhciBoYXNSZXF1aXJlZEV2ZW50cztcbmZ1bmN0aW9uIHJlcXVpcmVFdmVudHMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEV2ZW50cykgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEV2ZW50cyA9IDE7XG4gIHZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgPyBSZWZsZWN0IDogbnVsbDtcbiAgdmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09IFwiZnVuY3Rpb25cIiA/IFIuYXBwbHkgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkyKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH07XG4gIHZhciBSZWZsZWN0T3duS2V5cztcbiAgaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXM7XG4gIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXMyKHRhcmdldCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzMih0YXJnZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgfVxuICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4yKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG4gIH1cbiAgZXZlbnRzLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gIGV2ZW50cy5leHBvcnRzLm9uY2UgPSBvbmNlO1xuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB2b2lkIDA7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdm9pZCAwO1xuICB2YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuICBmdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIiB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgXCIuXCIpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xuICBFdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ldmVudHMgPT09IHZvaWQgMCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHZvaWQgMDtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gXCJudW1iZXJcIiB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArIFwiLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gICAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZTIpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB2YXIgZG9FcnJvciA9IHR5cGUyID09PSBcImVycm9yXCI7XG4gICAgdmFyIGV2ZW50czIgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50czIgIT09IHZvaWQgMClcbiAgICAgIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50czIuZXJyb3IgPT09IHZvaWQgMDtcbiAgICBlbHNlIGlmICghZG9FcnJvcilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZG9FcnJvcikge1xuICAgICAgdmFyIGVyO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgICAgZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7XG4gICAgICB9XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiVW5oYW5kbGVkIGVycm9yLlwiICsgKGVyID8gXCIgKFwiICsgZXIubWVzc2FnZSArIFwiKVwiIDogXCJcIikpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHMyW3R5cGUyXTtcbiAgICBpZiAoaGFuZGxlciA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUyLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgIHZhciBtO1xuICAgIHZhciBldmVudHMyO1xuICAgIHZhciBleGlzdGluZztcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBldmVudHMyID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKGV2ZW50czIgPT09IHZvaWQgMCkge1xuICAgICAgZXZlbnRzMiA9IHRhcmdldC5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV2ZW50czIubmV3TGlzdGVuZXIgIT09IHZvaWQgMCkge1xuICAgICAgICB0YXJnZXQuZW1pdChcbiAgICAgICAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgICAgICAgdHlwZTIsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyXG4gICAgICAgICk7XG4gICAgICAgIGV2ZW50czIgPSB0YXJnZXQuX2V2ZW50cztcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzMlt0eXBlMl07XG4gICAgfVxuICAgIGlmIChleGlzdGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBleGlzdGluZyA9IGV2ZW50czJbdHlwZTJdID0gbGlzdGVuZXI7XG4gICAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBleGlzdGluZyA9IGV2ZW50czJbdHlwZTJdID0gcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKFwiUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiBcIiArIGV4aXN0aW5nLmxlbmd0aCArIFwiIFwiICsgU3RyaW5nKHR5cGUyKSArIFwiIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXRcIik7XG4gICAgICAgIHcubmFtZSA9IFwiTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nXCI7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTI7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZTIsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlMiwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUyLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZTIsIGxpc3RlbmVyLCB0cnVlKTtcbiAgfTtcbiAgZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gICAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUyLCBsaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZTIgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB2b2lkIDAsIHRhcmdldCwgdHlwZTogdHlwZTIsIGxpc3RlbmVyIH07XG4gICAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlMik7XG4gICAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIHN0YXRlMi53cmFwRm4gPSB3cmFwcGVkO1xuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UyKHR5cGUyLCBsaXN0ZW5lcikge1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIHRoaXMub24odHlwZTIsIF9vbmNlV3JhcCh0aGlzLCB0eXBlMiwgbGlzdGVuZXIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlMiwgbGlzdGVuZXIpIHtcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlMiwgX29uY2VXcmFwKHRoaXMsIHR5cGUyLCBsaXN0ZW5lcikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZTIsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3QsIGV2ZW50czIsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGV2ZW50czIgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50czIgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGxpc3QgPSBldmVudHMyW3R5cGUyXTtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50czJbdHlwZTJdO1xuICAgICAgICBpZiAoZXZlbnRzMi5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlMiwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwb3NpdGlvbiA9IC0xO1xuICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgZXZlbnRzMlt0eXBlMl0gPSBsaXN0WzBdO1xuICAgICAgaWYgKGV2ZW50czIucmVtb3ZlTGlzdGVuZXIgIT09IHZvaWQgMClcbiAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIiwgdHlwZTIsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlMikge1xuICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50czIsIGk7XG4gICAgZXZlbnRzMiA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzMiA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGV2ZW50czIucmVtb3ZlTGlzdGVuZXIgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRzMlt0eXBlMl0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRlbGV0ZSBldmVudHMyW3R5cGUyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMyKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSBcInJlbW92ZUxpc3RlbmVyXCIpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKTtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxpc3RlbmVycyA9IGV2ZW50czJbdHlwZTJdO1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZTIsIGxpc3RlbmVycyk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHZvaWQgMCkge1xuICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZTIsIGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZTIsIHVud3JhcCkge1xuICAgIHZhciBldmVudHMyID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKGV2ZW50czIgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBbXTtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50czJbdHlwZTJdO1xuICAgIGlmIChldmxpc3RlbmVyID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG4gICAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUyKSB7XG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZTIsIHRydWUpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlMikge1xuICAgIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUyLCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZTIpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlMik7XG4gICAgfVxuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuICBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUyKSB7XG4gICAgdmFyIGV2ZW50czIgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50czIgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHMyW3R5cGUyXTtcbiAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG4gIH07XG4gIGZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICBjb3B5W2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICAgIGxpc3QucG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgaWYgKG5hbWUgIT09IFwiZXJyb3JcIikge1xuICAgICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIFwiZXJyb3JcIiwgaGFuZGxlciwgZmxhZ3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gICAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcihhcmcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudHMuZXhwb3J0cztcbn1cbnZhciBpbmhlcml0c19icm93c2VyID0geyBleHBvcnRzOiB7fSB9O1xudmFyIGhhc1JlcXVpcmVkSW5oZXJpdHNfYnJvd3NlcjtcbmZ1bmN0aW9uIHJlcXVpcmVJbmhlcml0c19icm93c2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRJbmhlcml0c19icm93c2VyKSByZXR1cm4gaW5oZXJpdHNfYnJvd3Nlci5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEluaGVyaXRzX2Jyb3dzZXIgPSAxO1xuICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGluaGVyaXRzX2Jyb3dzZXIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGluaGVyaXRzX2Jyb3dzZXIuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBpbmhlcml0c19icm93c2VyLmV4cG9ydHM7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh4KSB7XG4gIHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgXCJkZWZhdWx0XCIpID8geFtcImRlZmF1bHRcIl0gOiB4O1xufVxudmFyIGJyb3dzZXIkMSA9IHsgZXhwb3J0czoge30gfTtcbnZhciBwcm9jZXNzID0gYnJvd3NlciQxLmV4cG9ydHMgPSB7fTtcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG59XG4oZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgfVxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICB9XG59KSgpO1xuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9XG4gIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gIH1cbiAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgfVxuICB9XG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkcmFpbmluZyA9IGZhbHNlO1xuICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVJbmRleCA9IC0xO1xuICB9XG4gIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICBkcmFpblF1ZXVlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgZHJhaW5pbmcgPSB0cnVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcXVldWVJbmRleCA9IC0xO1xuICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgfVxuICBjdXJyZW50UXVldWUgPSBudWxsO1xuICBkcmFpbmluZyA9IGZhbHNlO1xuICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24oZnVuKSB7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgdGhpcy5mdW4gPSBmdW47XG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gXCJicm93c2VyXCI7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gXCJcIjtcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIFtdO1xufTtcbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG59O1xucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiL1wiO1xufTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbihkaXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIGJyb3dzZXJFeHBvcnRzID0gYnJvd3NlciQxLmV4cG9ydHM7XG5jb25zdCBwcm9jZXNzJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYnJvd3NlckV4cG9ydHMpO1xudmFyIHN0cmVhbUJyb3dzZXI7XG52YXIgaGFzUmVxdWlyZWRTdHJlYW1Ccm93c2VyO1xuZnVuY3Rpb24gcmVxdWlyZVN0cmVhbUJyb3dzZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFN0cmVhbUJyb3dzZXIpIHJldHVybiBzdHJlYW1Ccm93c2VyO1xuICBoYXNSZXF1aXJlZFN0cmVhbUJyb3dzZXIgPSAxO1xuICBzdHJlYW1Ccm93c2VyID0gcmVxdWlyZUV2ZW50cygpLkV2ZW50RW1pdHRlcjtcbiAgcmV0dXJuIHN0cmVhbUJyb3dzZXI7XG59XG52YXIgYnVmZmVyID0ge307XG52YXIgYmFzZTY0SnMgPSB7fTtcbnZhciBoYXNSZXF1aXJlZEJhc2U2NEpzO1xuZnVuY3Rpb24gcmVxdWlyZUJhc2U2NEpzKCkge1xuICBpZiAoaGFzUmVxdWlyZWRCYXNlNjRKcykgcmV0dXJuIGJhc2U2NEpzO1xuICBoYXNSZXF1aXJlZEJhc2U2NEpzID0gMTtcbiAgYmFzZTY0SnMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGg7XG4gIGJhc2U2NEpzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXk7XG4gIGJhc2U2NEpzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5O1xuICB2YXIgbG9va3VwID0gW107XG4gIHZhciByZXZMb29rdXAgPSBbXTtcbiAgdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSA6IEFycmF5O1xuICB2YXIgY29kZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG4gIHJldkxvb2t1cFtcIi1cIi5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICByZXZMb29rdXBbXCJfXCIuY2hhckNvZGVBdCgwKV0gPSA2MztcbiAgZnVuY3Rpb24gZ2V0TGVucyhiNjQpIHtcbiAgICB2YXIgbGVuMiA9IGI2NC5sZW5ndGg7XG4gICAgaWYgKGxlbjIgJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICB9XG4gICAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoXCI9XCIpO1xuICAgIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuMjtcbiAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlbjIgPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcbiAgICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dO1xuICB9XG4gIGZ1bmN0aW9uIGJ5dGVMZW5ndGgoYjY0KSB7XG4gICAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCk7XG4gICAgdmFyIHZhbGlkTGVuID0gbGVuc1swXTtcbiAgICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXTtcbiAgICByZXR1cm4gKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuO1xuICB9XG4gIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICAgIHJldHVybiAodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQgLSBwbGFjZUhvbGRlcnNMZW47XG4gIH1cbiAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgbGVucyA9IGdldExlbnMoYjY0KTtcbiAgICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdO1xuICAgIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuICAgIHZhciBjdXJCeXRlID0gMDtcbiAgICB2YXIgbGVuMiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAgPyB2YWxpZExlbiAtIDQgOiB2YWxpZExlbjtcbiAgICB2YXIgaTI7XG4gICAgZm9yIChpMiA9IDA7IGkyIDwgbGVuMjsgaTIgKz0gNCkge1xuICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTggfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAyKV0gPDwgNiB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDMpXTtcbiAgICAgIGFycltjdXJCeXRlKytdID0gdG1wID4+IDE2ICYgMjU1O1xuICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICAgIH1cbiAgICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIpXSA8PCAyIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyICsgMSldID4+IDQ7XG4gICAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDI1NTtcbiAgICB9XG4gICAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgICAgdG1wID0gcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkyKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaTIgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpMiArIDIpXSA+PiAyO1xuICAgICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgPj4gOCAmIDI1NTtcbiAgICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMjU1O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChudW0pIHtcbiAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDYzXSArIGxvb2t1cFtudW0gPj4gMTIgJiA2M10gKyBsb29rdXBbbnVtID4+IDYgJiA2M10gKyBsb29rdXBbbnVtICYgNjNdO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgaTIgPSBzdGFydDsgaTIgPCBlbmQ7IGkyICs9IDMpIHtcbiAgICAgIHRtcCA9ICh1aW50OFtpMl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAodWludDhbaTIgKyAxXSA8PCA4ICYgNjUyODApICsgKHVpbnQ4W2kyICsgMl0gJiAyNTUpO1xuICAgICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSh1aW50OCkge1xuICAgIHZhciB0bXA7XG4gICAgdmFyIGxlbjIgPSB1aW50OC5sZW5ndGg7XG4gICAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4yICUgMztcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MztcbiAgICBmb3IgKHZhciBpMiA9IDAsIGxlbjIyID0gbGVuMiAtIGV4dHJhQnl0ZXM7IGkyIDwgbGVuMjI7IGkyICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpMiwgaTIgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIyID8gbGVuMjIgOiBpMiArIG1heENodW5rTGVuZ3RoKSk7XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICB0bXAgPSB1aW50OFtsZW4yIC0gMV07XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBsb29rdXBbdG1wID4+IDJdICsgbG9va3VwW3RtcCA8PCA0ICYgNjNdICsgXCI9PVwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgICAgdG1wID0gKHVpbnQ4W2xlbjIgLSAyXSA8PCA4KSArIHVpbnQ4W2xlbjIgLSAxXTtcbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICsgbG9va3VwW3RtcCA+PiA0ICYgNjNdICsgbG9va3VwW3RtcCA8PCAyICYgNjNdICsgXCI9XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICB9XG4gIHJldHVybiBiYXNlNjRKcztcbn1cbnZhciBpZWVlNzU0ID0ge307XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xudmFyIGhhc1JlcXVpcmVkSWVlZTc1NDtcbmZ1bmN0aW9uIHJlcXVpcmVJZWVlNzU0KCkge1xuICBpZiAoaGFzUmVxdWlyZWRJZWVlNzU0KSByZXR1cm4gaWVlZTc1NDtcbiAgaGFzUmVxdWlyZWRJZWVlNzU0ID0gMTtcbiAgaWVlZTc1NC5yZWFkID0gZnVuY3Rpb24oYnVmZmVyMiwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgICB2YXIgZSwgbTtcbiAgICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMTtcbiAgICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gICAgdmFyIG5CaXRzID0gLTc7XG4gICAgdmFyIGkgPSBpc0xFID8gbkJ5dGVzIC0gMSA6IDA7XG4gICAgdmFyIGQgPSBpc0xFID8gLTEgOiAxO1xuICAgIHZhciBzID0gYnVmZmVyMltvZmZzZXQgKyBpXTtcbiAgICBpICs9IGQ7XG4gICAgZSA9IHMgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgICBzID4+PSAtbkJpdHM7XG4gICAgbkJpdHMgKz0gZUxlbjtcbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcjJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge1xuICAgIH1cbiAgICBtID0gZSAmICgxIDw8IC1uQml0cykgLSAxO1xuICAgIGUgPj49IC1uQml0cztcbiAgICBuQml0cyArPSBtTGVuO1xuICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyMltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7XG4gICAgfVxuICAgIGlmIChlID09PSAwKSB7XG4gICAgICBlID0gMSAtIGVCaWFzO1xuICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgICAgcmV0dXJuIG0gPyBOYU4gOiAocyA/IC0xIDogMSkgKiBJbmZpbml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlIC0gZUJpYXM7XG4gICAgfVxuICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xuICB9O1xuICBpZWVlNzU0LndyaXRlID0gZnVuY3Rpb24oYnVmZmVyMiwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gICAgdmFyIGUsIG0sIGM7XG4gICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gICAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICAgIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwO1xuICAgIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxO1xuICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICAgIGUtLTtcbiAgICAgICAgYyAqPSAyO1xuICAgICAgfVxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgICBlKys7XG4gICAgICAgIGMgLz0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgICBtID0gMDtcbiAgICAgICAgZSA9IGVNYXg7XG4gICAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgICAgZSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcjJbb2Zmc2V0ICsgaV0gPSBtICYgMjU1LCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHtcbiAgICB9XG4gICAgZSA9IGUgPDwgbUxlbiB8IG07XG4gICAgZUxlbiArPSBtTGVuO1xuICAgIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyMltvZmZzZXQgKyBpXSA9IGUgJiAyNTUsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge1xuICAgIH1cbiAgICBidWZmZXIyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xuICB9O1xuICByZXR1cm4gaWVlZTc1NDtcbn1cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xudmFyIGhhc1JlcXVpcmVkQnVmZmVyO1xuZnVuY3Rpb24gcmVxdWlyZUJ1ZmZlcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkQnVmZmVyKSByZXR1cm4gYnVmZmVyO1xuICBoYXNSZXF1aXJlZEJ1ZmZlciA9IDE7XG4gIChmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIGJhc2U2NCA9IHJlcXVpcmVCYXNlNjRKcygpO1xuICAgIHZhciBpZWVlNzU0MiA9IHJlcXVpcmVJZWVlNzU0KCk7XG4gICAgdmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbFtcImZvclwiXSA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sW1wiZm9yXCJdKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIikgOiBudWxsO1xuICAgIGV4cG9ydHMuQnVmZmVyID0gQnVmZmVyMjtcbiAgICBleHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuICAgIGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcbiAgICB2YXIgS19NQVhfTEVOR1RIID0gMjE0NzQ4MzY0NztcbiAgICBleHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEg7XG4gICAgQnVmZmVyMi5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKTtcbiAgICBpZiAoIUJ1ZmZlcjIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiA0MjtcbiAgICAgICAgfSB9O1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pO1xuICAgICAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMi5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIUJ1ZmZlcjIuaXNCdWZmZXIodGhpcykpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyMi5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIUJ1ZmZlcjIuaXNCdWZmZXIodGhpcykpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKTtcbiAgICAgIH1cbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMi5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gQnVmZmVyMihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBCdWZmZXIyLnBvb2xTaXplID0gODE5MjtcbiAgICBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIHZhbHVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8IHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fCB2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkge1xuICAgICAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoYikgcmV0dXJuIGI7XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIyLmZyb20oXG4gICAgICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxcbiAgICAgICAgICBlbmNvZGluZ09yT2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIiArIHR5cGVvZiB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgQnVmZmVyMi5mcm9tID0gZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMi5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyMiwgVWludDhBcnJheSk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0U2l6ZShzaXplKSB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpO1xuICAgICAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgICBhc3NlcnRTaXplKHNpemUpO1xuICAgICAgaWYgKHNpemUgPD0gMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGwgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSBcInN0cmluZ1wiID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpO1xuICAgIH1cbiAgICBCdWZmZXIyLmFsbG9jID0gZnVuY3Rpb24oc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICBhc3NlcnRTaXplKHNpemUpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG4gICAgfVxuICAgIEJ1ZmZlcjIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfTtcbiAgICBCdWZmZXIyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBlbmNvZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gXCJzdHJpbmdcIiB8fCBlbmNvZGluZyA9PT0gXCJcIikge1xuICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiO1xuICAgICAgfVxuICAgICAgaWYgKCFCdWZmZXIyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMDtcbiAgICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKTtcbiAgICAgIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG4gICAgICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAgICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwO1xuICAgICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21BcnJheVZpZXcoYXJyYXlWaWV3KSB7XG4gICAgICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KTtcbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7XG4gICAgICB9XG4gICAgICB2YXIgYnVmO1xuICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHZvaWQgMCAmJiBsZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyMi5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbU9iamVjdChvYmopIHtcbiAgICAgIGlmIChCdWZmZXIyLmlzQnVmZmVyKG9iaikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgICAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbik7XG4gICAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICBvYmouY29weShidWYsIDAsIDAsIGxlbik7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9XG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmoudHlwZSA9PT0gXCJCdWZmZXJcIiAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrZWQobGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIiArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyBcIiBieXRlc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW5ndGggfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTbG93QnVmZmVyKGxlbmd0aCkge1xuICAgICAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyMi5hbGxvYygrbGVuZ3RoKTtcbiAgICB9XG4gICAgQnVmZmVyMi5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgICAgIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiYgYiAhPT0gQnVmZmVyMi5wcm90b3R5cGU7XG4gICAgfTtcbiAgICBCdWZmZXIyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyMi5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpO1xuICAgICAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgICBpZiAoIUJ1ZmZlcjIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlcjIuaXNCdWZmZXIoYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhID09PSBiKSByZXR1cm4gMDtcbiAgICAgIHZhciB4ID0gYS5sZW5ndGg7XG4gICAgICB2YXIgeSA9IGIubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICB4ID0gYVtpXTtcbiAgICAgICAgICB5ID0gYltpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gICAgICBpZiAoeSA8IHgpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBCdWZmZXIyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlcjIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KGxpc3QsIGxlbmd0aCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIyLmFsbG9jKDApO1xuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBidWZmZXIyID0gQnVmZmVyMi5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIEJ1ZmZlcjIuZnJvbShidWYpLmNvcHkoYnVmZmVyMiwgcG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgICAgIGJ1ZmZlcjIsXG4gICAgICAgICAgICAgIGJ1ZixcbiAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghQnVmZmVyMi5pc0J1ZmZlcihidWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmLmNvcHkoYnVmZmVyMiwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIyO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoQnVmZmVyMi5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIG11c3RNYXRjaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZTtcbiAgICAgIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVuICogMjtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gbGVuID4+PiAxO1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNvZGluZyA9IChcIlwiICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgQnVmZmVyMi5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDAgfHwgc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA8PSAwKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgICAgZW5kID4+Pj0gMDtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IFwidXRmOFwiO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICBjYXNlIFwidXRmOFwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgZW5jb2RpbmcpO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEJ1ZmZlcjIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWU7XG4gICAgZnVuY3Rpb24gc3dhcChiLCBuLCBtKSB7XG4gICAgICB2YXIgaSA9IGJbbl07XG4gICAgICBiW25dID0gYlttXTtcbiAgICAgIGJbbV0gPSBpO1xuICAgIH1cbiAgICBCdWZmZXIyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYoKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyKCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0KCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICAgICAgc3dhcCh0aGlzLCBpLCBpICsgNyk7XG4gICAgICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KTtcbiAgICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgICAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlcjIucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7XG4gICAgICBpZiAoIUJ1ZmZlcjIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICAgICAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICB2YXIgbWF4MiA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVM7XG4gICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKFwiaGV4XCIsIDAsIG1heDIpLnJlcGxhY2UoLyguezJ9KS9nLCBcIiQxIFwiKS50cmltKCk7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgyKSBzdHIgKz0gXCIgLi4uIFwiO1xuICAgICAgcmV0dXJuIFwiPEJ1ZmZlciBcIiArIHN0ciArIFwiPlwiO1xuICAgIH07XG4gICAgaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgICAgIEJ1ZmZlcjIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyMi5wcm90b3R5cGUuaW5zcGVjdDtcbiAgICB9XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgICAgIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGFyZ2V0ID0gQnVmZmVyMi5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKCFCdWZmZXIyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHRhcmdldFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNTdGFydCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXNTdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpc0VuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgIGVuZCA+Pj49IDA7XG4gICAgICB0aGlzU3RhcnQgPj4+PSAwO1xuICAgICAgdGhpc0VuZCA+Pj49IDA7XG4gICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMDtcbiAgICAgIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydDtcbiAgICAgIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gICAgICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG4gICAgICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gICAgICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICAgICAgeCA9IHRoaXNDb3B5W2ldO1xuICAgICAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgICAgIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlcjIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAgICAgaWYgKGJ1ZmZlcjIubGVuZ3RoID09PSAwKSByZXR1cm4gLTE7XG4gICAgICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0O1xuICAgICAgICBieXRlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgYnl0ZU9mZnNldCA9IDIxNDc0ODM2NDc7XG4gICAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMjE0NzQ4MzY0OCkge1xuICAgICAgICBieXRlT2Zmc2V0ID0gLTIxNDc0ODM2NDg7XG4gICAgICB9XG4gICAgICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQ7XG4gICAgICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiBidWZmZXIyLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gICAgICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGlyKSByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlcjIubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAgICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIGVsc2UgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsID0gQnVmZmVyMi5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKEJ1ZmZlcjIuaXNCdWZmZXIodmFsKSkge1xuICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlcjIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFsID0gdmFsICYgMjU1O1xuICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyMiwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyMiwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgICAgIHZhciBpbmRleFNpemUgPSAxO1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aDtcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IFwidWNzMlwiIHx8IGVuY29kaW5nID09PSBcInVjcy0yXCIgfHwgZW5jb2RpbmcgPT09IFwidXRmMTZsZVwiIHx8IGVuY29kaW5nID09PSBcInV0Zi0xNmxlXCIpIHtcbiAgICAgICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgICAgICBhcnJMZW5ndGggLz0gMjtcbiAgICAgICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlYWQoYnVmLCBpMikge1xuICAgICAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1ZltpMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaTIgKiBpbmRleFNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleDtcbiAgICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBCdWZmZXIyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGV4V3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcbiAgICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgICAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICAgICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpO1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXRmOFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdWNzMldyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuICAgIEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkge1xuICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiO1xuICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB2b2lkIDAgJiYgdHlwZW9mIG9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgICAgICBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBcInV0ZjhcIjtcbiAgICAgIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLThcIjpcbiAgICAgICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIGVuY29kaW5nKTtcbiAgICAgICAgICAgIGVuY29kaW5nID0gKFwiXCIgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJCdWZmZXJcIixcbiAgICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzZTY0U2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG4gICAgICB2YXIgcmVzID0gW107XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IG51bGw7XG4gICAgICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gZmlyc3RCeXRlID4gMjM5ID8gNCA6IGZpcnN0Qnl0ZSA+IDIyMyA/IDMgOiBmaXJzdEJ5dGUgPiAxOTEgPyAyIDogMTtcbiAgICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDMxKSA8PCA2IHwgc2Vjb25kQnl0ZSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl07XG4gICAgICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDE5MikgPT09IDEyOCAmJiAodGhpcmRCeXRlICYgMTkyKSA9PT0gMTI4KSB7XG4gICAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAxNSkgPDwgMTIgfCAoc2Vjb25kQnl0ZSAmIDYzKSA8PCA2IHwgdGhpcmRCeXRlICYgNjM7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAyMDQ3ICYmICh0ZW1wQ29kZVBvaW50IDwgNTUyOTYgfHwgdGVtcENvZGVQb2ludCA+IDU3MzQzKSkge1xuICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMTkyKSA9PT0gMTI4ICYmICh0aGlyZEJ5dGUgJiAxOTIpID09PSAxMjggJiYgKGZvdXJ0aEJ5dGUgJiAxOTIpID09PSAxMjgpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDE1KSA8PCAxOCB8IChzZWNvbmRCeXRlICYgNjMpIDw8IDEyIHwgKHRoaXJkQnl0ZSAmIDYzKSA8PCA2IHwgZm91cnRoQnl0ZSAmIDYzO1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gNjU1MzUgJiYgdGVtcENvZGVQb2ludCA8IDExMTQxMTIpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMztcbiAgICAgICAgICBieXRlc1BlclNlcXVlbmNlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiA2NTUzNSkge1xuICAgICAgICAgIGNvZGVQb2ludCAtPSA2NTUzNjtcbiAgICAgICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KTtcbiAgICAgICAgICBjb2RlUG9pbnQgPSA1NjMyMCB8IGNvZGVQb2ludCAmIDEwMjM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgaSArPSBieXRlc1BlclNlcXVlbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xuICAgIH1cbiAgICB2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSA0MDk2O1xuICAgIGZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheShjb2RlUG9pbnRzKSB7XG4gICAgICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgICAgIFN0cmluZyxcbiAgICAgICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMTI3KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhdGluMVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHJldCA9IFwiXCI7XG4gICAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhleFNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG4gICAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICAgICAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcbiAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjE2bGVTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgICBzdGFydCA9IH5+c3RhcnQ7XG4gICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IGxlbiA6IH5+ZW5kO1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCArPSBsZW47XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICAgICAgc3RhcnQgPSBsZW47XG4gICAgICB9XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuO1xuICAgICAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgICAgIGVuZCA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG4gICAgICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlcjIucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBuZXdCdWY7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja09mZnNldChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtcbiAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZFVpbnRMRSA9IEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFKG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgICAgIHZhciBtdWwgPSAxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgyICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkVWludEJFID0gQnVmZmVyMi5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUob2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aDJdO1xuICAgICAgdmFyIG11bCA9IDE7XG4gICAgICB3aGlsZSAoYnl0ZUxlbmd0aDIgPiAwICYmIChtdWwgKj0gMjU2KSkge1xuICAgICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGgyXSAqIG11bDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkVWludDggPSBCdWZmZXIyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpc1tvZmZzZXRdO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZFVpbnQxNkxFID0gQnVmZmVyMi5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMV07XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPSBCdWZmZXIyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gKHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpICsgdGhpc1tvZmZzZXQgKyAzXSAqIDE2Nzc3MjE2O1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZFVpbnQzMkJFID0gQnVmZmVyMi5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSAqIDE2Nzc3MjE2ICsgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdKTtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF07XG4gICAgICB2YXIgbXVsID0gMTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gICAgICB9XG4gICAgICBtdWwgKj0gMTI4O1xuICAgICAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgYnl0ZUxlbmd0aDIgPSBieXRlTGVuZ3RoMiA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciBpID0gYnl0ZUxlbmd0aDI7XG4gICAgICB2YXIgbXVsID0gMTtcbiAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV07XG4gICAgICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAyNTYpKSB7XG4gICAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWw7XG4gICAgICB9XG4gICAgICBtdWwgKj0gMTI4O1xuICAgICAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgICBpZiAoISh0aGlzW29mZnNldF0gJiAxMjgpKSByZXR1cm4gdGhpc1tvZmZzZXRdO1xuICAgICAgcmV0dXJuICgyNTUgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG4gICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgdGhpc1tvZmZzZXRdIDw8IDg7XG4gICAgICByZXR1cm4gdmFsICYgMzI3NjggPyB2YWwgfCA0Mjk0OTAxNzYwIDogdmFsO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2IHwgdGhpc1tvZmZzZXQgKyAzXSA8PCAyNDtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpc1tvZmZzZXRdIDw8IDI0IHwgdGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM107XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGllZWU3NTQyLnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGllZWU3NTQyLnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGllZWU3NTQyLnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gaWVlZTc1NDIucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0ludChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4MiwgbWluMikge1xuICAgICAgaWYgKCFCdWZmZXIyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgICAgaWYgKHZhbHVlID4gbWF4MiB8fCB2YWx1ZSA8IG1pbjIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9IEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGJ5dGVMZW5ndGgyID0gYnl0ZUxlbmd0aDIgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoMikgLSAxO1xuICAgICAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbWF4Qnl0ZXMsIDApO1xuICAgICAgfVxuICAgICAgdmFyIG11bCA9IDE7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMjU1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgyO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUud3JpdGVVaW50QkUgPSBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgyLCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBieXRlTGVuZ3RoMiA9IGJ5dGVMZW5ndGgyID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIpIC0gMTtcbiAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIG1heEJ5dGVzLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gYnl0ZUxlbmd0aDIgLSAxO1xuICAgICAgdmFyIG11bCA9IDE7XG4gICAgICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAyNTU7XG4gICAgICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAyNTYpKSB7XG4gICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDI1NTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoMjtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlVWludDggPSBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAyNTUsIDApO1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPSBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCA2NTUzNSwgMCk7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9IEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDY1NTM1LCAwKTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMjU1O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID0gQnVmZmVyMi5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID0gQnVmZmVyMi5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgNDI5NDk2NzI5NSwgMCk7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTtcbiAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBtdWwgPSAxO1xuICAgICAgdmFyIHN1YiA9IDA7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoMiAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgICAgICBzdWIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoMiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aDIgLSAxKTtcbiAgICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aDIsIGxpbWl0IC0gMSwgLWxpbWl0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gYnl0ZUxlbmd0aDIgLSAxO1xuICAgICAgdmFyIG11bCA9IDE7XG4gICAgICB2YXIgc3ViID0gMDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDI1NikpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgICAgICBzdWIgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwgPj4gMCkgLSBzdWIgJiAyNTU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDI7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMTI3LCAtMTI4KTtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMjU1ICsgdmFsdWUgKyAxO1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAyNTU7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAzMjc2NywgLTMyNzY4KTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMzI3NjcsIC0zMjc2OCk7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDI1NTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH07XG4gICAgQnVmZmVyMi5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMDtcbiAgICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KTtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMjU1O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9O1xuICAgIEJ1ZmZlcjIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDA7XG4gICAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAyMTQ3NDgzNjQ3LCAtMjE0NzQ4MzY0OCk7XG4gICAgICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDQyOTQ5NjcyOTUgKyB2YWx1ZSArIDE7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gMjQ7XG4gICAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWUgPj4+IDE2O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlICYgMjU1O1xuICAgICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heDIsIG1pbjIpIHtcbiAgICAgIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgICAgIH1cbiAgICAgIGllZWU3NTQyLndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgQnVmZmVyMi5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZURvdWJsZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwO1xuICAgICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4KTtcbiAgICAgIH1cbiAgICAgIGllZWU3NTQyLndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgODtcbiAgICB9XG4gICAgQnVmZmVyMi5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICAgIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIUJ1ZmZlcjIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtcbiAgICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgICAgIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICAgICAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0O1xuICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgICAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICAgICAgdGFyZ2V0U3RhcnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfTtcbiAgICBCdWZmZXIyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlcjIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIgKyBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gXCJ1dGY4XCIgJiYgY29kZSA8IDEyOCB8fCBlbmNvZGluZyA9PT0gXCJsYXRpbjFcIikge1xuICAgICAgICAgICAgdmFsID0gY29kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB2YWwgPSB2YWwgJiAyNTU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gICAgICBlbmQgPSBlbmQgPT09IHZvaWQgMCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwO1xuICAgICAgaWYgKCF2YWwpIHZhbCA9IDA7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICB0aGlzW2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYnl0ZXMgPSBCdWZmZXIyLmlzQnVmZmVyKHZhbCkgPyB2YWwgOiBCdWZmZXIyLmZyb20odmFsLCBlbmNvZGluZyk7XG4gICAgICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICsgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZztcbiAgICBmdW5jdGlvbiBiYXNlNjRjbGVhbihzdHIpIHtcbiAgICAgIHN0ciA9IHN0ci5zcGxpdChcIj1cIilbMF07XG4gICAgICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsIFwiXCIpO1xuICAgICAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gXCJcIjtcbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBzdHIgPSBzdHIgKyBcIj1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHtcbiAgICAgIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHk7XG4gICAgICB2YXIgY29kZVBvaW50O1xuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG4gICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiA1NTI5NSAmJiBjb2RlUG9pbnQgPCA1NzM0NCkge1xuICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDU2MzE5KSB7XG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDU2MzIwKSB7XG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gNTUyOTYgPDwgMTAgfCBjb2RlUG9pbnQgLSA1NjMyMCkgKyA2NTUzNjtcbiAgICAgICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICB9XG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMTI4KSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrO1xuICAgICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAyMDQ4KSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrO1xuICAgICAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgICAgICBjb2RlUG9pbnQgPj4gNiB8IDE5MixcbiAgICAgICAgICAgIGNvZGVQb2ludCAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCA2NTUzNikge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVhaztcbiAgICAgICAgICBieXRlcy5wdXNoKFxuICAgICAgICAgICAgY29kZVBvaW50ID4+IDEyIHwgMjI0LFxuICAgICAgICAgICAgY29kZVBvaW50ID4+IDYgJiA2MyB8IDEyOCxcbiAgICAgICAgICAgIGNvZGVQb2ludCAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAxMTE0MTEyKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgICAgICBjb2RlUG9pbnQgPj4gMTggfCAyNDAsXG4gICAgICAgICAgICBjb2RlUG9pbnQgPj4gMTIgJiA2MyB8IDEyOCxcbiAgICAgICAgICAgIGNvZGVQb2ludCA+PiA2ICYgNjMgfCAxMjgsXG4gICAgICAgICAgICBjb2RlUG9pbnQgJiA2MyB8IDEyOFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2lpVG9CeXRlcyhzdHIpIHtcbiAgICAgIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlQXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzKHN0ciwgdW5pdHMpIHtcbiAgICAgIHZhciBjLCBoaSwgbG87XG4gICAgICB2YXIgYnl0ZUFycmF5ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGkgPSBjID4+IDg7XG4gICAgICAgIGxvID0gYyAlIDI1NjtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgICAgICBieXRlQXJyYXkucHVzaChoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICAgICAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNJbnN0YW5jZShvYmosIHR5cGUyKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZTIgfHwgb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZTIubmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbnVtYmVySXNOYU4ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9PSBvYmo7XG4gICAgfVxuICAgIHZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIHZhciBpMTYgPSBpICogMTY7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH0oKTtcbiAgfSkoYnVmZmVyKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbnZhciB1dGlsID0ge307XG52YXIgdHlwZXMgPSB7fTtcbnZhciBzaGFtcyQxO1xudmFyIGhhc1JlcXVpcmVkU2hhbXMkMTtcbmZ1bmN0aW9uIHJlcXVpcmVTaGFtcyQxKCkge1xuICBpZiAoaGFzUmVxdWlyZWRTaGFtcyQxKSByZXR1cm4gc2hhbXMkMTtcbiAgaGFzUmVxdWlyZWRTaGFtcyQxID0gMTtcbiAgc2hhbXMkMSA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMyKCkge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgc3ltID0gU3ltYm9sKFwidGVzdFwiKTtcbiAgICB2YXIgc3ltT2JqID0gT2JqZWN0KHN5bSk7XG4gICAgaWYgKHR5cGVvZiBzeW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSBcIltvYmplY3QgU3ltYm9sXVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gXCJbb2JqZWN0IFN5bWJvbF1cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3ltVmFsID0gNDI7XG4gICAgb2JqW3N5bV0gPSBzeW1WYWw7XG4gICAgZm9yICh2YXIgXyBpbiBvYmopIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgPT09IFwiZnVuY3Rpb25cIiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcbiAgICBpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSAoXG4gICAgICAgIC8qKiBAdHlwZSB7UHJvcGVydHlEZXNjcmlwdG9yfSAqL1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKVxuICAgICAgKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHJldHVybiBzaGFtcyQxO1xufVxudmFyIHNoYW1zO1xudmFyIGhhc1JlcXVpcmVkU2hhbXM7XG5mdW5jdGlvbiByZXF1aXJlU2hhbXMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFNoYW1zKSByZXR1cm4gc2hhbXM7XG4gIGhhc1JlcXVpcmVkU2hhbXMgPSAxO1xuICB2YXIgaGFzU3ltYm9sczIgPSByZXF1aXJlU2hhbXMkMSgpO1xuICBzaGFtcyA9IGZ1bmN0aW9uIGhhc1RvU3RyaW5nVGFnU2hhbXMoKSB7XG4gICAgcmV0dXJuIGhhc1N5bWJvbHMyKCkgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG4gIH07XG4gIHJldHVybiBzaGFtcztcbn1cbnZhciBlc09iamVjdEF0b21zO1xudmFyIGhhc1JlcXVpcmVkRXNPYmplY3RBdG9tcztcbmZ1bmN0aW9uIHJlcXVpcmVFc09iamVjdEF0b21zKCkge1xuICBpZiAoaGFzUmVxdWlyZWRFc09iamVjdEF0b21zKSByZXR1cm4gZXNPYmplY3RBdG9tcztcbiAgaGFzUmVxdWlyZWRFc09iamVjdEF0b21zID0gMTtcbiAgZXNPYmplY3RBdG9tcyA9IE9iamVjdDtcbiAgcmV0dXJuIGVzT2JqZWN0QXRvbXM7XG59XG52YXIgZXNFcnJvcnM7XG52YXIgaGFzUmVxdWlyZWRFc0Vycm9ycztcbmZ1bmN0aW9uIHJlcXVpcmVFc0Vycm9ycygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRXNFcnJvcnMpIHJldHVybiBlc0Vycm9ycztcbiAgaGFzUmVxdWlyZWRFc0Vycm9ycyA9IDE7XG4gIGVzRXJyb3JzID0gRXJyb3I7XG4gIHJldHVybiBlc0Vycm9ycztcbn1cbnZhciBfZXZhbDtcbnZhciBoYXNSZXF1aXJlZF9ldmFsO1xuZnVuY3Rpb24gcmVxdWlyZV9ldmFsKCkge1xuICBpZiAoaGFzUmVxdWlyZWRfZXZhbCkgcmV0dXJuIF9ldmFsO1xuICBoYXNSZXF1aXJlZF9ldmFsID0gMTtcbiAgX2V2YWwgPSBFdmFsRXJyb3I7XG4gIHJldHVybiBfZXZhbDtcbn1cbnZhciByYW5nZTtcbnZhciBoYXNSZXF1aXJlZFJhbmdlO1xuZnVuY3Rpb24gcmVxdWlyZVJhbmdlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRSYW5nZSkgcmV0dXJuIHJhbmdlO1xuICBoYXNSZXF1aXJlZFJhbmdlID0gMTtcbiAgcmFuZ2UgPSBSYW5nZUVycm9yO1xuICByZXR1cm4gcmFuZ2U7XG59XG52YXIgcmVmO1xudmFyIGhhc1JlcXVpcmVkUmVmO1xuZnVuY3Rpb24gcmVxdWlyZVJlZigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUmVmKSByZXR1cm4gcmVmO1xuICBoYXNSZXF1aXJlZFJlZiA9IDE7XG4gIHJlZiA9IFJlZmVyZW5jZUVycm9yO1xuICByZXR1cm4gcmVmO1xufVxudmFyIHN5bnRheDtcbnZhciBoYXNSZXF1aXJlZFN5bnRheDtcbmZ1bmN0aW9uIHJlcXVpcmVTeW50YXgoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFN5bnRheCkgcmV0dXJuIHN5bnRheDtcbiAgaGFzUmVxdWlyZWRTeW50YXggPSAxO1xuICBzeW50YXggPSBTeW50YXhFcnJvcjtcbiAgcmV0dXJuIHN5bnRheDtcbn1cbnZhciB0eXBlO1xudmFyIGhhc1JlcXVpcmVkVHlwZTtcbmZ1bmN0aW9uIHJlcXVpcmVUeXBlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRUeXBlKSByZXR1cm4gdHlwZTtcbiAgaGFzUmVxdWlyZWRUeXBlID0gMTtcbiAgdHlwZSA9IFR5cGVFcnJvcjtcbiAgcmV0dXJuIHR5cGU7XG59XG52YXIgdXJpO1xudmFyIGhhc1JlcXVpcmVkVXJpO1xuZnVuY3Rpb24gcmVxdWlyZVVyaSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkVXJpKSByZXR1cm4gdXJpO1xuICBoYXNSZXF1aXJlZFVyaSA9IDE7XG4gIHVyaSA9IFVSSUVycm9yO1xuICByZXR1cm4gdXJpO1xufVxudmFyIGFicztcbnZhciBoYXNSZXF1aXJlZEFicztcbmZ1bmN0aW9uIHJlcXVpcmVBYnMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEFicykgcmV0dXJuIGFicztcbiAgaGFzUmVxdWlyZWRBYnMgPSAxO1xuICBhYnMgPSBNYXRoLmFicztcbiAgcmV0dXJuIGFicztcbn1cbnZhciBmbG9vcjtcbnZhciBoYXNSZXF1aXJlZEZsb29yO1xuZnVuY3Rpb24gcmVxdWlyZUZsb29yKCkge1xuICBpZiAoaGFzUmVxdWlyZWRGbG9vcikgcmV0dXJuIGZsb29yO1xuICBoYXNSZXF1aXJlZEZsb29yID0gMTtcbiAgZmxvb3IgPSBNYXRoLmZsb29yO1xuICByZXR1cm4gZmxvb3I7XG59XG52YXIgbWF4O1xudmFyIGhhc1JlcXVpcmVkTWF4O1xuZnVuY3Rpb24gcmVxdWlyZU1heCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTWF4KSByZXR1cm4gbWF4O1xuICBoYXNSZXF1aXJlZE1heCA9IDE7XG4gIG1heCA9IE1hdGgubWF4O1xuICByZXR1cm4gbWF4O1xufVxudmFyIG1pbjtcbnZhciBoYXNSZXF1aXJlZE1pbjtcbmZ1bmN0aW9uIHJlcXVpcmVNaW4oKSB7XG4gIGlmIChoYXNSZXF1aXJlZE1pbikgcmV0dXJuIG1pbjtcbiAgaGFzUmVxdWlyZWRNaW4gPSAxO1xuICBtaW4gPSBNYXRoLm1pbjtcbiAgcmV0dXJuIG1pbjtcbn1cbnZhciBwb3c7XG52YXIgaGFzUmVxdWlyZWRQb3c7XG5mdW5jdGlvbiByZXF1aXJlUG93KCkge1xuICBpZiAoaGFzUmVxdWlyZWRQb3cpIHJldHVybiBwb3c7XG4gIGhhc1JlcXVpcmVkUG93ID0gMTtcbiAgcG93ID0gTWF0aC5wb3c7XG4gIHJldHVybiBwb3c7XG59XG52YXIgcm91bmQ7XG52YXIgaGFzUmVxdWlyZWRSb3VuZDtcbmZ1bmN0aW9uIHJlcXVpcmVSb3VuZCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUm91bmQpIHJldHVybiByb3VuZDtcbiAgaGFzUmVxdWlyZWRSb3VuZCA9IDE7XG4gIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kO1xufVxudmFyIF9pc05hTjtcbnZhciBoYXNSZXF1aXJlZF9pc05hTjtcbmZ1bmN0aW9uIHJlcXVpcmVfaXNOYU4oKSB7XG4gIGlmIChoYXNSZXF1aXJlZF9pc05hTikgcmV0dXJuIF9pc05hTjtcbiAgaGFzUmVxdWlyZWRfaXNOYU4gPSAxO1xuICBfaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gaXNOYU4yKGEpIHtcbiAgICByZXR1cm4gYSAhPT0gYTtcbiAgfTtcbiAgcmV0dXJuIF9pc05hTjtcbn1cbnZhciBzaWduO1xudmFyIGhhc1JlcXVpcmVkU2lnbjtcbmZ1bmN0aW9uIHJlcXVpcmVTaWduKCkge1xuICBpZiAoaGFzUmVxdWlyZWRTaWduKSByZXR1cm4gc2lnbjtcbiAgaGFzUmVxdWlyZWRTaWduID0gMTtcbiAgdmFyICRpc05hTiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlX2lzTmFOKCk7XG4gIHNpZ24gPSBmdW5jdGlvbiBzaWduMihudW1iZXIpIHtcbiAgICBpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyIDwgMCA/IC0xIDogMTtcbiAgfTtcbiAgcmV0dXJuIHNpZ247XG59XG52YXIgZ09QRDtcbnZhciBoYXNSZXF1aXJlZEdPUEQ7XG5mdW5jdGlvbiByZXF1aXJlR09QRCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkR09QRCkgcmV0dXJuIGdPUEQ7XG4gIGhhc1JlcXVpcmVkR09QRCA9IDE7XG4gIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICByZXR1cm4gZ09QRDtcbn1cbnZhciBnb3BkO1xudmFyIGhhc1JlcXVpcmVkR29wZDtcbmZ1bmN0aW9uIHJlcXVpcmVHb3BkKCkge1xuICBpZiAoaGFzUmVxdWlyZWRHb3BkKSByZXR1cm4gZ29wZDtcbiAgaGFzUmVxdWlyZWRHb3BkID0gMTtcbiAgdmFyICRnT1BEID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVHT1BEKCk7XG4gIGlmICgkZ09QRCkge1xuICAgIHRyeSB7XG4gICAgICAkZ09QRChbXSwgXCJsZW5ndGhcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgJGdPUEQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBnb3BkID0gJGdPUEQ7XG4gIHJldHVybiBnb3BkO1xufVxudmFyIGVzRGVmaW5lUHJvcGVydHk7XG52YXIgaGFzUmVxdWlyZWRFc0RlZmluZVByb3BlcnR5O1xuZnVuY3Rpb24gcmVxdWlyZUVzRGVmaW5lUHJvcGVydHkoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEVzRGVmaW5lUHJvcGVydHkpIHJldHVybiBlc0RlZmluZVByb3BlcnR5O1xuICBoYXNSZXF1aXJlZEVzRGVmaW5lUHJvcGVydHkgPSAxO1xuICB2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZhbHNlO1xuICBpZiAoJGRlZmluZVByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eSh7fSwgXCJhXCIsIHsgdmFsdWU6IDEgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVzRGVmaW5lUHJvcGVydHkgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJldHVybiBlc0RlZmluZVByb3BlcnR5O1xufVxudmFyIGhhc1N5bWJvbHM7XG52YXIgaGFzUmVxdWlyZWRIYXNTeW1ib2xzO1xuZnVuY3Rpb24gcmVxdWlyZUhhc1N5bWJvbHMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEhhc1N5bWJvbHMpIHJldHVybiBoYXNTeW1ib2xzO1xuICBoYXNSZXF1aXJlZEhhc1N5bWJvbHMgPSAxO1xuICB2YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sO1xuICB2YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmVTaGFtcyQxKCk7XG4gIGhhc1N5bWJvbHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuICAgIGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnU3ltYm9sKFwiZm9vXCIpICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgU3ltYm9sKFwiYmFyXCIpICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG4gIH07XG4gIHJldHVybiBoYXNTeW1ib2xzO1xufVxudmFyIFJlZmxlY3RfZ2V0UHJvdG90eXBlT2Y7XG52YXIgaGFzUmVxdWlyZWRSZWZsZWN0X2dldFByb3RvdHlwZU9mO1xuZnVuY3Rpb24gcmVxdWlyZVJlZmxlY3RfZ2V0UHJvdG90eXBlT2YoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFJlZmxlY3RfZ2V0UHJvdG90eXBlT2YpIHJldHVybiBSZWZsZWN0X2dldFByb3RvdHlwZU9mO1xuICBoYXNSZXF1aXJlZFJlZmxlY3RfZ2V0UHJvdG90eXBlT2YgPSAxO1xuICBSZWZsZWN0X2dldFByb3RvdHlwZU9mID0gdHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXRQcm90b3R5cGVPZiB8fCBudWxsO1xuICByZXR1cm4gUmVmbGVjdF9nZXRQcm90b3R5cGVPZjtcbn1cbnZhciBPYmplY3RfZ2V0UHJvdG90eXBlT2Y7XG52YXIgaGFzUmVxdWlyZWRPYmplY3RfZ2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiByZXF1aXJlT2JqZWN0X2dldFByb3RvdHlwZU9mKCkge1xuICBpZiAoaGFzUmVxdWlyZWRPYmplY3RfZ2V0UHJvdG90eXBlT2YpIHJldHVybiBPYmplY3RfZ2V0UHJvdG90eXBlT2Y7XG4gIGhhc1JlcXVpcmVkT2JqZWN0X2dldFByb3RvdHlwZU9mID0gMTtcbiAgdmFyICRPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZUVzT2JqZWN0QXRvbXMoKTtcbiAgT2JqZWN0X2dldFByb3RvdHlwZU9mID0gJE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBudWxsO1xuICByZXR1cm4gT2JqZWN0X2dldFByb3RvdHlwZU9mO1xufVxudmFyIGltcGxlbWVudGF0aW9uO1xudmFyIGhhc1JlcXVpcmVkSW1wbGVtZW50YXRpb247XG5mdW5jdGlvbiByZXF1aXJlSW1wbGVtZW50YXRpb24oKSB7XG4gIGlmIChoYXNSZXF1aXJlZEltcGxlbWVudGF0aW9uKSByZXR1cm4gaW1wbGVtZW50YXRpb247XG4gIGhhc1JlcXVpcmVkSW1wbGVtZW50YXRpb24gPSAxO1xuICB2YXIgRVJST1JfTUVTU0FHRSA9IFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjtcbiAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG1heDIgPSBNYXRoLm1heDtcbiAgdmFyIGZ1bmNUeXBlID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICB2YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eTIoYSwgYikge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgYXJyW2ogKyBhLmxlbmd0aF0gPSBiW2pdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuICB2YXIgc2xpY3kgPSBmdW5jdGlvbiBzbGljeTIoYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICBhcnJbal0gPSBhcnJMaWtlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuICB2YXIgam9pbnkgPSBmdW5jdGlvbihhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBpbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIgfHwgdG9TdHIuYXBwbHkodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICB0aGF0LFxuICAgICAgICBjb25jYXR0eShhcmdzLCBhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gbWF4MigwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvdW5kQXJnc1tpXSA9IFwiJFwiICsgaTtcbiAgICB9XG4gICAgYm91bmQgPSBGdW5jdGlvbihcImJpbmRlclwiLCBcInJldHVybiBmdW5jdGlvbiAoXCIgKyBqb2lueShib3VuZEFyZ3MsIFwiLFwiKSArIFwiKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH1cIikoYmluZGVyKTtcbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkyKCkge1xuICAgICAgfTtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbiAgfTtcbiAgcmV0dXJuIGltcGxlbWVudGF0aW9uO1xufVxudmFyIGZ1bmN0aW9uQmluZDtcbnZhciBoYXNSZXF1aXJlZEZ1bmN0aW9uQmluZDtcbmZ1bmN0aW9uIHJlcXVpcmVGdW5jdGlvbkJpbmQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEZ1bmN0aW9uQmluZCkgcmV0dXJuIGZ1bmN0aW9uQmluZDtcbiAgaGFzUmVxdWlyZWRGdW5jdGlvbkJpbmQgPSAxO1xuICB2YXIgaW1wbGVtZW50YXRpb24yID0gcmVxdWlyZUltcGxlbWVudGF0aW9uKCk7XG4gIGZ1bmN0aW9uQmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uMjtcbiAgcmV0dXJuIGZ1bmN0aW9uQmluZDtcbn1cbnZhciBmdW5jdGlvbkNhbGw7XG52YXIgaGFzUmVxdWlyZWRGdW5jdGlvbkNhbGw7XG5mdW5jdGlvbiByZXF1aXJlRnVuY3Rpb25DYWxsKCkge1xuICBpZiAoaGFzUmVxdWlyZWRGdW5jdGlvbkNhbGwpIHJldHVybiBmdW5jdGlvbkNhbGw7XG4gIGhhc1JlcXVpcmVkRnVuY3Rpb25DYWxsID0gMTtcbiAgZnVuY3Rpb25DYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4gIHJldHVybiBmdW5jdGlvbkNhbGw7XG59XG52YXIgZnVuY3Rpb25BcHBseTtcbnZhciBoYXNSZXF1aXJlZEZ1bmN0aW9uQXBwbHk7XG5mdW5jdGlvbiByZXF1aXJlRnVuY3Rpb25BcHBseSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRnVuY3Rpb25BcHBseSkgcmV0dXJuIGZ1bmN0aW9uQXBwbHk7XG4gIGhhc1JlcXVpcmVkRnVuY3Rpb25BcHBseSA9IDE7XG4gIGZ1bmN0aW9uQXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG4gIHJldHVybiBmdW5jdGlvbkFwcGx5O1xufVxudmFyIHJlZmxlY3RBcHBseTtcbnZhciBoYXNSZXF1aXJlZFJlZmxlY3RBcHBseTtcbmZ1bmN0aW9uIHJlcXVpcmVSZWZsZWN0QXBwbHkoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFJlZmxlY3RBcHBseSkgcmV0dXJuIHJlZmxlY3RBcHBseTtcbiAgaGFzUmVxdWlyZWRSZWZsZWN0QXBwbHkgPSAxO1xuICByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0ICYmIFJlZmxlY3QuYXBwbHk7XG4gIHJldHVybiByZWZsZWN0QXBwbHk7XG59XG52YXIgYWN0dWFsQXBwbHk7XG52YXIgaGFzUmVxdWlyZWRBY3R1YWxBcHBseTtcbmZ1bmN0aW9uIHJlcXVpcmVBY3R1YWxBcHBseSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkQWN0dWFsQXBwbHkpIHJldHVybiBhY3R1YWxBcHBseTtcbiAgaGFzUmVxdWlyZWRBY3R1YWxBcHBseSA9IDE7XG4gIHZhciBiaW5kID0gcmVxdWlyZUZ1bmN0aW9uQmluZCgpO1xuICB2YXIgJGFwcGx5ID0gcmVxdWlyZUZ1bmN0aW9uQXBwbHkoKTtcbiAgdmFyICRjYWxsID0gcmVxdWlyZUZ1bmN0aW9uQ2FsbCgpO1xuICB2YXIgJHJlZmxlY3RBcHBseSA9IHJlcXVpcmVSZWZsZWN0QXBwbHkoKTtcbiAgYWN0dWFsQXBwbHkgPSAkcmVmbGVjdEFwcGx5IHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcbiAgcmV0dXJuIGFjdHVhbEFwcGx5O1xufVxudmFyIGNhbGxCaW5kQXBwbHlIZWxwZXJzO1xudmFyIGhhc1JlcXVpcmVkQ2FsbEJpbmRBcHBseUhlbHBlcnM7XG5mdW5jdGlvbiByZXF1aXJlQ2FsbEJpbmRBcHBseUhlbHBlcnMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZENhbGxCaW5kQXBwbHlIZWxwZXJzKSByZXR1cm4gY2FsbEJpbmRBcHBseUhlbHBlcnM7XG4gIGhhc1JlcXVpcmVkQ2FsbEJpbmRBcHBseUhlbHBlcnMgPSAxO1xuICB2YXIgYmluZCA9IHJlcXVpcmVGdW5jdGlvbkJpbmQoKTtcbiAgdmFyICRUeXBlRXJyb3IgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZVR5cGUoKTtcbiAgdmFyICRjYWxsID0gcmVxdWlyZUZ1bmN0aW9uQ2FsbCgpO1xuICB2YXIgJGFjdHVhbEFwcGx5ID0gcmVxdWlyZUFjdHVhbEFwcGx5KCk7XG4gIGNhbGxCaW5kQXBwbHlIZWxwZXJzID0gZnVuY3Rpb24gY2FsbEJpbmRCYXNpYyhhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMSB8fCB0eXBlb2YgYXJnc1swXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImEgZnVuY3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHJldHVybiAkYWN0dWFsQXBwbHkoYmluZCwgJGNhbGwsIGFyZ3MpO1xuICB9O1xuICByZXR1cm4gY2FsbEJpbmRBcHBseUhlbHBlcnM7XG59XG52YXIgZ2V0O1xudmFyIGhhc1JlcXVpcmVkR2V0O1xuZnVuY3Rpb24gcmVxdWlyZUdldCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkR2V0KSByZXR1cm4gZ2V0O1xuICBoYXNSZXF1aXJlZEdldCA9IDE7XG4gIHZhciBjYWxsQmluZDIgPSByZXF1aXJlQ2FsbEJpbmRBcHBseUhlbHBlcnMoKTtcbiAgdmFyIGdPUEQyID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVHb3BkKCk7XG4gIHZhciBoYXNQcm90b0FjY2Vzc29yO1xuICB0cnkge1xuICAgIGhhc1Byb3RvQWNjZXNzb3IgPSAvKiogQHR5cGUge3sgX19wcm90b19fPzogdHlwZW9mIEFycmF5LnByb3RvdHlwZSB9fSAqL1xuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKCFlIHx8IHR5cGVvZiBlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJjb2RlXCIgaW4gZSkgfHwgZS5jb2RlICE9PSBcIkVSUl9QUk9UT19BQ0NFU1NcIikge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgdmFyIGRlc2MgPSAhIWhhc1Byb3RvQWNjZXNzb3IgJiYgZ09QRDIgJiYgZ09QRDIoXG4gICAgT2JqZWN0LnByb3RvdHlwZSxcbiAgICAvKiogQHR5cGUge2tleW9mIHR5cGVvZiBPYmplY3QucHJvdG90eXBlfSAqL1xuICAgIFwiX19wcm90b19fXCJcbiAgKTtcbiAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gIHZhciAkZ2V0UHJvdG90eXBlT2YgPSAkT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICBnZXQgPSBkZXNjICYmIHR5cGVvZiBkZXNjLmdldCA9PT0gXCJmdW5jdGlvblwiID8gY2FsbEJpbmQyKFtkZXNjLmdldF0pIDogdHlwZW9mICRnZXRQcm90b3R5cGVPZiA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KCcuL2dldCcpfSAqL1xuICAgIGZ1bmN0aW9uIGdldER1bmRlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiAkT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuICApIDogZmFsc2U7XG4gIHJldHVybiBnZXQ7XG59XG52YXIgZ2V0UHJvdG87XG52YXIgaGFzUmVxdWlyZWRHZXRQcm90bztcbmZ1bmN0aW9uIHJlcXVpcmVHZXRQcm90bygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkR2V0UHJvdG8pIHJldHVybiBnZXRQcm90bztcbiAgaGFzUmVxdWlyZWRHZXRQcm90byA9IDE7XG4gIHZhciByZWZsZWN0R2V0UHJvdG8gPSByZXF1aXJlUmVmbGVjdF9nZXRQcm90b3R5cGVPZigpO1xuICB2YXIgb3JpZ2luYWxHZXRQcm90byA9IHJlcXVpcmVPYmplY3RfZ2V0UHJvdG90eXBlT2YoKTtcbiAgdmFyIGdldER1bmRlclByb3RvID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVHZXQoKTtcbiAgZ2V0UHJvdG8gPSByZWZsZWN0R2V0UHJvdG8gPyBmdW5jdGlvbiBnZXRQcm90bzIoTykge1xuICAgIHJldHVybiByZWZsZWN0R2V0UHJvdG8oTyk7XG4gIH0gOiBvcmlnaW5hbEdldFByb3RvID8gZnVuY3Rpb24gZ2V0UHJvdG8yKE8pIHtcbiAgICBpZiAoIU8gfHwgdHlwZW9mIE8gIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIE8gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdldFByb3RvOiBub3QgYW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ2luYWxHZXRQcm90byhPKTtcbiAgfSA6IGdldER1bmRlclByb3RvID8gZnVuY3Rpb24gZ2V0UHJvdG8yKE8pIHtcbiAgICByZXR1cm4gZ2V0RHVuZGVyUHJvdG8oTyk7XG4gIH0gOiBudWxsO1xuICByZXR1cm4gZ2V0UHJvdG87XG59XG52YXIgaGFzb3duO1xudmFyIGhhc1JlcXVpcmVkSGFzb3duO1xuZnVuY3Rpb24gcmVxdWlyZUhhc293bigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSGFzb3duKSByZXR1cm4gaGFzb3duO1xuICBoYXNSZXF1aXJlZEhhc293biA9IDE7XG4gIHZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4gIHZhciAkaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGJpbmQgPSByZXF1aXJlRnVuY3Rpb25CaW5kKCk7XG4gIGhhc293biA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcbiAgcmV0dXJuIGhhc293bjtcbn1cbnZhciBnZXRJbnRyaW5zaWM7XG52YXIgaGFzUmVxdWlyZWRHZXRJbnRyaW5zaWM7XG5mdW5jdGlvbiByZXF1aXJlR2V0SW50cmluc2ljKCkge1xuICBpZiAoaGFzUmVxdWlyZWRHZXRJbnRyaW5zaWMpIHJldHVybiBnZXRJbnRyaW5zaWM7XG4gIGhhc1JlcXVpcmVkR2V0SW50cmluc2ljID0gMTtcbiAgdmFyIHVuZGVmaW5lZCQxO1xuICB2YXIgJE9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlRXNPYmplY3RBdG9tcygpO1xuICB2YXIgJEVycm9yID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVFc0Vycm9ycygpO1xuICB2YXIgJEV2YWxFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlX2V2YWwoKTtcbiAgdmFyICRSYW5nZUVycm9yID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVSYW5nZSgpO1xuICB2YXIgJFJlZmVyZW5jZUVycm9yID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVSZWYoKTtcbiAgdmFyICRTeW50YXhFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlU3ludGF4KCk7XG4gIHZhciAkVHlwZUVycm9yID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVUeXBlKCk7XG4gIHZhciAkVVJJRXJyb3IgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZVVyaSgpO1xuICB2YXIgYWJzMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlQWJzKCk7XG4gIHZhciBmbG9vcjIgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZUZsb29yKCk7XG4gIHZhciBtYXgyID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVNYXgoKTtcbiAgdmFyIG1pbjIgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZU1pbigpO1xuICB2YXIgcG93MiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlUG93KCk7XG4gIHZhciByb3VuZDIgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZVJvdW5kKCk7XG4gIHZhciBzaWduMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlU2lnbigpO1xuICB2YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG4gIHZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbihleHByZXNzaW9uU3ludGF4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgXCIpLmNvbnN0cnVjdG9yO1wiKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH07XG4gIHZhciAkZ09QRCA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR29wZCgpO1xuICB2YXIgJGRlZmluZVByb3BlcnR5ID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVFc0RlZmluZVByb3BlcnR5KCk7XG4gIHZhciB0aHJvd1R5cGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG4gIH07XG4gIHZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEID8gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICByZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG4gICAgfSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gJGdPUEQoYXJndW1lbnRzLCBcImNhbGxlZVwiKS5nZXQ7XG4gICAgICB9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG4gICAgICAgIHJldHVybiB0aHJvd1R5cGVFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0oKSA6IHRocm93VHlwZUVycm9yO1xuICB2YXIgaGFzU3ltYm9sczIgPSByZXF1aXJlSGFzU3ltYm9scygpKCk7XG4gIHZhciBnZXRQcm90bzIgPSByZXF1aXJlR2V0UHJvdG8oKTtcbiAgdmFyICRPYmplY3RHUE8gPSByZXF1aXJlT2JqZWN0X2dldFByb3RvdHlwZU9mKCk7XG4gIHZhciAkUmVmbGVjdEdQTyA9IHJlcXVpcmVSZWZsZWN0X2dldFByb3RvdHlwZU9mKCk7XG4gIHZhciAkYXBwbHkgPSByZXF1aXJlRnVuY3Rpb25BcHBseSgpO1xuICB2YXIgJGNhbGwgPSByZXF1aXJlRnVuY3Rpb25DYWxsKCk7XG4gIHZhciBuZWVkc0V2YWwgPSB7fTtcbiAgdmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhZ2V0UHJvdG8yID8gdW5kZWZpbmVkJDEgOiBnZXRQcm90bzIoVWludDhBcnJheSk7XG4gIHZhciBJTlRSSU5TSUNTID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBcIiVBZ2dyZWdhdGVFcnJvciVcIjogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBBZ2dyZWdhdGVFcnJvcixcbiAgICBcIiVBcnJheSVcIjogQXJyYXksXG4gICAgXCIlQXJyYXlCdWZmZXIlXCI6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCQxIDogQXJyYXlCdWZmZXIsXG4gICAgXCIlQXJyYXlJdGVyYXRvclByb3RvdHlwZSVcIjogaGFzU3ltYm9sczIgJiYgZ2V0UHJvdG8yID8gZ2V0UHJvdG8yKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQkMSxcbiAgICBcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6IHVuZGVmaW5lZCQxLFxuICAgIFwiJUFzeW5jRnVuY3Rpb24lXCI6IG5lZWRzRXZhbCxcbiAgICBcIiVBc3luY0dlbmVyYXRvciVcIjogbmVlZHNFdmFsLFxuICAgIFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCI6IG5lZWRzRXZhbCxcbiAgICBcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiOiBuZWVkc0V2YWwsXG4gICAgXCIlQXRvbWljcyVcIjogdHlwZW9mIEF0b21pY3MgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQkMSA6IEF0b21pY3MsXG4gICAgXCIlQmlnSW50JVwiOiB0eXBlb2YgQmlnSW50ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBCaWdJbnQsXG4gICAgXCIlQmlnSW50NjRBcnJheSVcIjogdHlwZW9mIEJpZ0ludDY0QXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQkMSA6IEJpZ0ludDY0QXJyYXksXG4gICAgXCIlQmlnVWludDY0QXJyYXklXCI6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCQxIDogQmlnVWludDY0QXJyYXksXG4gICAgXCIlQm9vbGVhbiVcIjogQm9vbGVhbixcbiAgICBcIiVEYXRhVmlldyVcIjogdHlwZW9mIERhdGFWaWV3ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBEYXRhVmlldyxcbiAgICBcIiVEYXRlJVwiOiBEYXRlLFxuICAgIFwiJWRlY29kZVVSSSVcIjogZGVjb2RlVVJJLFxuICAgIFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjogZGVjb2RlVVJJQ29tcG9uZW50LFxuICAgIFwiJWVuY29kZVVSSSVcIjogZW5jb2RlVVJJLFxuICAgIFwiJWVuY29kZVVSSUNvbXBvbmVudCVcIjogZW5jb2RlVVJJQ29tcG9uZW50LFxuICAgIFwiJUVycm9yJVwiOiAkRXJyb3IsXG4gICAgXCIlZXZhbCVcIjogZXZhbCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcbiAgICBcIiVFdmFsRXJyb3IlXCI6ICRFdmFsRXJyb3IsXG4gICAgXCIlRmxvYXQxNkFycmF5JVwiOiB0eXBlb2YgRmxvYXQxNkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBGbG9hdDE2QXJyYXksXG4gICAgXCIlRmxvYXQzMkFycmF5JVwiOiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBGbG9hdDMyQXJyYXksXG4gICAgXCIlRmxvYXQ2NEFycmF5JVwiOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBGbG9hdDY0QXJyYXksXG4gICAgXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCQxIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG4gICAgXCIlRnVuY3Rpb24lXCI6ICRGdW5jdGlvbixcbiAgICBcIiVHZW5lcmF0b3JGdW5jdGlvbiVcIjogbmVlZHNFdmFsLFxuICAgIFwiJUludDhBcnJheSVcIjogdHlwZW9mIEludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCQxIDogSW50OEFycmF5LFxuICAgIFwiJUludDE2QXJyYXklXCI6IHR5cGVvZiBJbnQxNkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBJbnQxNkFycmF5LFxuICAgIFwiJUludDMyQXJyYXklXCI6IHR5cGVvZiBJbnQzMkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBJbnQzMkFycmF5LFxuICAgIFwiJWlzRmluaXRlJVwiOiBpc0Zpbml0ZSxcbiAgICBcIiVpc05hTiVcIjogaXNOYU4sXG4gICAgXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6IGhhc1N5bWJvbHMyICYmIGdldFByb3RvMiA/IGdldFByb3RvMihnZXRQcm90bzIoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQkMSxcbiAgICBcIiVKU09OJVwiOiB0eXBlb2YgSlNPTiA9PT0gXCJvYmplY3RcIiA/IEpTT04gOiB1bmRlZmluZWQkMSxcbiAgICBcIiVNYXAlXCI6IHR5cGVvZiBNYXAgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQkMSA6IE1hcCxcbiAgICBcIiVNYXBJdGVyYXRvclByb3RvdHlwZSVcIjogdHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhaGFzU3ltYm9sczIgfHwgIWdldFByb3RvMiA/IHVuZGVmaW5lZCQxIDogZ2V0UHJvdG8yKCgvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuICAgIFwiJU1hdGglXCI6IE1hdGgsXG4gICAgXCIlTnVtYmVyJVwiOiBOdW1iZXIsXG4gICAgXCIlT2JqZWN0JVwiOiAkT2JqZWN0LFxuICAgIFwiJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlXCI6ICRnT1BELFxuICAgIFwiJXBhcnNlRmxvYXQlXCI6IHBhcnNlRmxvYXQsXG4gICAgXCIlcGFyc2VJbnQlXCI6IHBhcnNlSW50LFxuICAgIFwiJVByb21pc2UlXCI6IHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBQcm9taXNlLFxuICAgIFwiJVByb3h5JVwiOiB0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQkMSA6IFByb3h5LFxuICAgIFwiJVJhbmdlRXJyb3IlXCI6ICRSYW5nZUVycm9yLFxuICAgIFwiJVJlZmVyZW5jZUVycm9yJVwiOiAkUmVmZXJlbmNlRXJyb3IsXG4gICAgXCIlUmVmbGVjdCVcIjogdHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQkMSA6IFJlZmxlY3QsXG4gICAgXCIlUmVnRXhwJVwiOiBSZWdFeHAsXG4gICAgXCIlU2V0JVwiOiB0eXBlb2YgU2V0ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBTZXQsXG4gICAgXCIlU2V0SXRlcmF0b3JQcm90b3R5cGUlXCI6IHR5cGVvZiBTZXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWhhc1N5bWJvbHMyIHx8ICFnZXRQcm90bzIgPyB1bmRlZmluZWQkMSA6IGdldFByb3RvMigoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSlbU3ltYm9sLml0ZXJhdG9yXSgpKSxcbiAgICBcIiVTaGFyZWRBcnJheUJ1ZmZlciVcIjogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBTaGFyZWRBcnJheUJ1ZmZlcixcbiAgICBcIiVTdHJpbmclXCI6IFN0cmluZyxcbiAgICBcIiVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSVcIjogaGFzU3ltYm9sczIgJiYgZ2V0UHJvdG8yID8gZ2V0UHJvdG8yKFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCQxLFxuICAgIFwiJVN5bWJvbCVcIjogaGFzU3ltYm9sczIgPyBTeW1ib2wgOiB1bmRlZmluZWQkMSxcbiAgICBcIiVTeW50YXhFcnJvciVcIjogJFN5bnRheEVycm9yLFxuICAgIFwiJVRocm93VHlwZUVycm9yJVwiOiBUaHJvd1R5cGVFcnJvcixcbiAgICBcIiVUeXBlZEFycmF5JVwiOiBUeXBlZEFycmF5LFxuICAgIFwiJVR5cGVFcnJvciVcIjogJFR5cGVFcnJvcixcbiAgICBcIiVVaW50OEFycmF5JVwiOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHVuZGVmaW5lZCQxIDogVWludDhBcnJheSxcbiAgICBcIiVVaW50OENsYW1wZWRBcnJheSVcIjogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBVaW50OENsYW1wZWRBcnJheSxcbiAgICBcIiVVaW50MTZBcnJheSVcIjogdHlwZW9mIFVpbnQxNkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBVaW50MTZBcnJheSxcbiAgICBcIiVVaW50MzJBcnJheSVcIjogdHlwZW9mIFVpbnQzMkFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBVaW50MzJBcnJheSxcbiAgICBcIiVVUklFcnJvciVcIjogJFVSSUVycm9yLFxuICAgIFwiJVdlYWtNYXAlXCI6IHR5cGVvZiBXZWFrTWFwID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBXZWFrTWFwLFxuICAgIFwiJVdlYWtSZWYlXCI6IHR5cGVvZiBXZWFrUmVmID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBXZWFrUmVmLFxuICAgIFwiJVdlYWtTZXQlXCI6IHR5cGVvZiBXZWFrU2V0ID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkJDEgOiBXZWFrU2V0LFxuICAgIFwiJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJVwiOiAkY2FsbCxcbiAgICBcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCI6ICRhcHBseSxcbiAgICBcIiVPYmplY3QuZGVmaW5lUHJvcGVydHklXCI6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgICBcIiVPYmplY3QuZ2V0UHJvdG90eXBlT2YlXCI6ICRPYmplY3RHUE8sXG4gICAgXCIlTWF0aC5hYnMlXCI6IGFiczIsXG4gICAgXCIlTWF0aC5mbG9vciVcIjogZmxvb3IyLFxuICAgIFwiJU1hdGgubWF4JVwiOiBtYXgyLFxuICAgIFwiJU1hdGgubWluJVwiOiBtaW4yLFxuICAgIFwiJU1hdGgucG93JVwiOiBwb3cyLFxuICAgIFwiJU1hdGgucm91bmQlXCI6IHJvdW5kMixcbiAgICBcIiVNYXRoLnNpZ24lXCI6IHNpZ24yLFxuICAgIFwiJVJlZmxlY3QuZ2V0UHJvdG90eXBlT2YlXCI6ICRSZWZsZWN0R1BPXG4gIH07XG4gIGlmIChnZXRQcm90bzIpIHtcbiAgICB0cnkge1xuICAgICAgbnVsbC5lcnJvcjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIgZXJyb3JQcm90byA9IGdldFByb3RvMihnZXRQcm90bzIoZSkpO1xuICAgICAgSU5UUklOU0lDU1tcIiVFcnJvci5wcm90b3R5cGUlXCJdID0gZXJyb3JQcm90bztcbiAgICB9XG4gIH1cbiAgdmFyIGRvRXZhbCA9IGZ1bmN0aW9uIGRvRXZhbDIobmFtZSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAobmFtZSA9PT0gXCIlQXN5bmNGdW5jdGlvbiVcIikge1xuICAgICAgdmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoXCJhc3luYyBmdW5jdGlvbiAoKSB7fVwiKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKSB7XG4gICAgICB2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpIHtcbiAgICAgIHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCIlQXN5bmNHZW5lcmF0b3IlXCIpIHtcbiAgICAgIHZhciBmbiA9IGRvRXZhbDIoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgdmFsdWUgPSBmbi5wcm90b3R5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcIiVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJVwiKSB7XG4gICAgICB2YXIgZ2VuID0gZG9FdmFsMihcIiVBc3luY0dlbmVyYXRvciVcIik7XG4gICAgICBpZiAoZ2VuICYmIGdldFByb3RvMikge1xuICAgICAgICB2YWx1ZSA9IGdldFByb3RvMihnZW4ucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgSU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdmFyIExFR0FDWV9BTElBU0VTID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjogW1wiQXJyYXlCdWZmZXJcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlQXJyYXlQcm90b3R5cGUlXCI6IFtcIkFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjogW1wiQXJyYXlcIiwgXCJwcm90b3R5cGVcIiwgXCJlbnRyaWVzXCJdLFxuICAgIFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjogW1wiQXJyYXlcIiwgXCJwcm90b3R5cGVcIiwgXCJmb3JFYWNoXCJdLFxuICAgIFwiJUFycmF5UHJvdG9fa2V5cyVcIjogW1wiQXJyYXlcIiwgXCJwcm90b3R5cGVcIiwgXCJrZXlzXCJdLFxuICAgIFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOiBbXCJBcnJheVwiLCBcInByb3RvdHlwZVwiLCBcInZhbHVlc1wiXSxcbiAgICBcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOiBbXCJBc3luY0Z1bmN0aW9uXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUFzeW5jR2VuZXJhdG9yJVwiOiBbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJVwiOiBbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsIFwicHJvdG90eXBlXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUJvb2xlYW5Qcm90b3R5cGUlXCI6IFtcIkJvb2xlYW5cIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6IFtcIkRhdGFWaWV3XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJURhdGVQcm90b3R5cGUlXCI6IFtcIkRhdGVcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlRXJyb3JQcm90b3R5cGUlXCI6IFtcIkVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjogW1wiRXZhbEVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjogW1wiRmxvYXQzMkFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUZsb2F0NjRBcnJheVByb3RvdHlwZSVcIjogW1wiRmxvYXQ2NEFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOiBbXCJGdW5jdGlvblwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVHZW5lcmF0b3IlXCI6IFtcIkdlbmVyYXRvckZ1bmN0aW9uXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUdlbmVyYXRvclByb3RvdHlwZSVcIjogW1wiR2VuZXJhdG9yRnVuY3Rpb25cIiwgXCJwcm90b3R5cGVcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlSW50OEFycmF5UHJvdG90eXBlJVwiOiBbXCJJbnQ4QXJyYXlcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjogW1wiSW50MTZBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOiBbXCJJbnQzMkFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJUpTT05QYXJzZSVcIjogW1wiSlNPTlwiLCBcInBhcnNlXCJdLFxuICAgIFwiJUpTT05TdHJpbmdpZnklXCI6IFtcIkpTT05cIiwgXCJzdHJpbmdpZnlcIl0sXG4gICAgXCIlTWFwUHJvdG90eXBlJVwiOiBbXCJNYXBcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlTnVtYmVyUHJvdG90eXBlJVwiOiBbXCJOdW1iZXJcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlT2JqZWN0UHJvdG90eXBlJVwiOiBbXCJPYmplY3RcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6IFtcIk9iamVjdFwiLCBcInByb3RvdHlwZVwiLCBcInRvU3RyaW5nXCJdLFxuICAgIFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6IFtcIk9iamVjdFwiLCBcInByb3RvdHlwZVwiLCBcInZhbHVlT2ZcIl0sXG4gICAgXCIlUHJvbWlzZVByb3RvdHlwZSVcIjogW1wiUHJvbWlzZVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVQcm9taXNlUHJvdG9fdGhlbiVcIjogW1wiUHJvbWlzZVwiLCBcInByb3RvdHlwZVwiLCBcInRoZW5cIl0sXG4gICAgXCIlUHJvbWlzZV9hbGwlXCI6IFtcIlByb21pc2VcIiwgXCJhbGxcIl0sXG4gICAgXCIlUHJvbWlzZV9yZWplY3QlXCI6IFtcIlByb21pc2VcIiwgXCJyZWplY3RcIl0sXG4gICAgXCIlUHJvbWlzZV9yZXNvbHZlJVwiOiBbXCJQcm9taXNlXCIsIFwicmVzb2x2ZVwiXSxcbiAgICBcIiVSYW5nZUVycm9yUHJvdG90eXBlJVwiOiBbXCJSYW5nZUVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOiBbXCJSZWZlcmVuY2VFcnJvclwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVSZWdFeHBQcm90b3R5cGUlXCI6IFtcIlJlZ0V4cFwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVTZXRQcm90b3R5cGUlXCI6IFtcIlNldFwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjogW1wiU2hhcmVkQXJyYXlCdWZmZXJcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlU3RyaW5nUHJvdG90eXBlJVwiOiBbXCJTdHJpbmdcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlU3ltYm9sUHJvdG90eXBlJVwiOiBbXCJTeW1ib2xcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6IFtcIlN5bnRheEVycm9yXCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6IFtcIlR5cGVkQXJyYXlcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlVHlwZUVycm9yUHJvdG90eXBlJVwiOiBbXCJUeXBlRXJyb3JcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjogW1wiVWludDhBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjogW1wiVWludDhDbGFtcGVkQXJyYXlcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlVWludDE2QXJyYXlQcm90b3R5cGUlXCI6IFtcIlVpbnQxNkFycmF5XCIsIFwicHJvdG90eXBlXCJdLFxuICAgIFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOiBbXCJVaW50MzJBcnJheVwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVVUklFcnJvclByb3RvdHlwZSVcIjogW1wiVVJJRXJyb3JcIiwgXCJwcm90b3R5cGVcIl0sXG4gICAgXCIlV2Vha01hcFByb3RvdHlwZSVcIjogW1wiV2Vha01hcFwiLCBcInByb3RvdHlwZVwiXSxcbiAgICBcIiVXZWFrU2V0UHJvdG90eXBlJVwiOiBbXCJXZWFrU2V0XCIsIFwicHJvdG90eXBlXCJdXG4gIH07XG4gIHZhciBiaW5kID0gcmVxdWlyZUZ1bmN0aW9uQmluZCgpO1xuICB2YXIgaGFzT3duID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVIYXNvd24oKTtcbiAgdmFyICRjb25jYXQgPSBiaW5kLmNhbGwoJGNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xuICB2YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKCRhcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG4gIHZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbCgkY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbiAgdmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbCgkY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG4gIHZhciAkZXhlYyA9IGJpbmQuY2FsbCgkY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcbiAgdmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuICB2YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoMihzdHJpbmcpIHtcbiAgICB2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcbiAgICB2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcbiAgICBpZiAoZmlyc3QgPT09IFwiJVwiICYmIGxhc3QgIT09IFwiJVwiKSB7XG4gICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09IFwiJVwiICYmIGZpcnN0ICE9PSBcIiVcIikge1xuICAgICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIik7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsIFwiJDFcIikgOiBudW1iZXIgfHwgbWF0Y2g7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgdmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljMihuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICB2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG4gICAgdmFyIGFsaWFzO1xuICAgIGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG4gICAgICBhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuICAgICAgaW50cmluc2ljTmFtZSA9IFwiJVwiICsgYWxpYXNbMF0gKyBcIiVcIjtcbiAgICB9XG4gICAgaWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG4gICAgICAgIHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiaW50cmluc2ljIFwiICsgbmFtZSArIFwiIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsaWFzLFxuICAgICAgICBuYW1lOiBpbnRyaW5zaWNOYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3ICRTeW50YXhFcnJvcihcImludHJpbnNpYyBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdCFcIik7XG4gIH07XG4gIGdldEludHJpbnNpYyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB9XG4gICAgaWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgJFN5bnRheEVycm9yKFwiYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZVwiKTtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuICAgIHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6IFwiXCI7XG4gICAgdmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoXCIlXCIgKyBpbnRyaW5zaWNCYXNlTmFtZSArIFwiJVwiLCBhbGxvd01pc3NpbmcpO1xuICAgIHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuICAgIHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcbiAgICB2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG4gICAgdmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgaW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcbiAgICAgICRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcbiAgICAgIHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcbiAgICAgIGlmICgoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSBcImBcIiB8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSBcImBcIikpICYmIGZpcnN0ICE9PSBsYXN0KSB7XG4gICAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgPT09IFwiY29uc3RydWN0b3JcIiB8fCAhaXNPd24pIHtcbiAgICAgICAgc2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGludHJpbnNpY0Jhc2VOYW1lICs9IFwiLlwiICsgcGFydDtcbiAgICAgIGludHJpbnNpY1JlYWxOYW1lID0gXCIlXCIgKyBpbnRyaW5zaWNCYXNlTmFtZSArIFwiJVwiO1xuICAgICAgaWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcbiAgICAgICAgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuICAgICAgICAgIGlmICghYWxsb3dNaXNzaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImJhc2UgaW50cmluc2ljIGZvciBcIiArIG5hbWUgKyBcIiBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRnT1BEICYmIGkgKyAxID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuICAgICAgICAgIGlzT3duID0gISFkZXNjO1xuICAgICAgICAgIGlmIChpc093biAmJiBcImdldFwiIGluIGRlc2MgJiYgIShcIm9yaWdpbmFsVmFsdWVcIiBpbiBkZXNjLmdldCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVzYy5nZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbcGFydF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG4gICAgICAgICAgSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHJldHVybiBnZXRJbnRyaW5zaWM7XG59XG52YXIgY2FsbEJpbmQgPSB7IGV4cG9ydHM6IHt9IH07XG52YXIgZGVmaW5lRGF0YVByb3BlcnR5O1xudmFyIGhhc1JlcXVpcmVkRGVmaW5lRGF0YVByb3BlcnR5O1xuZnVuY3Rpb24gcmVxdWlyZURlZmluZURhdGFQcm9wZXJ0eSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRGVmaW5lRGF0YVByb3BlcnR5KSByZXR1cm4gZGVmaW5lRGF0YVByb3BlcnR5O1xuICBoYXNSZXF1aXJlZERlZmluZURhdGFQcm9wZXJ0eSA9IDE7XG4gIHZhciAkZGVmaW5lUHJvcGVydHkgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZUVzRGVmaW5lUHJvcGVydHkoKTtcbiAgdmFyICRTeW50YXhFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlU3ludGF4KCk7XG4gIHZhciAkVHlwZUVycm9yID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVUeXBlKCk7XG4gIHZhciBnb3BkMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR29wZCgpO1xuICBkZWZpbmVEYXRhUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkyKG9iaiwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiYG9iamAgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbmBcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImBwcm9wZXJ0eWAgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbGBcIik7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdICE9PSBcImJvb2xlYW5cIiAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbFwiKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHR5cGVvZiBhcmd1bWVudHNbNF0gIT09IFwiYm9vbGVhblwiICYmIGFyZ3VtZW50c1s0XSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJgbm9uV3JpdGFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbFwiKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09IFwiYm9vbGVhblwiICYmIGFyZ3VtZW50c1s1XSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJgbm9uQ29uZmlndXJhYmxlYCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBib29sZWFuIG9yIG51bGxcIik7XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gNiAmJiB0eXBlb2YgYXJndW1lbnRzWzZdICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgfVxuICAgIHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHZhciBub25Xcml0YWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogbnVsbDtcbiAgICB2YXIgbm9uQ29uZmlndXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiBudWxsO1xuICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG4gICAgdmFyIGRlc2MgPSAhIWdvcGQyICYmIGdvcGQyKG9iaiwgcHJvcGVydHkpO1xuICAgIGlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogbm9uQ29uZmlndXJhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLmNvbmZpZ3VyYWJsZSA6ICFub25Db25maWd1cmFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IG5vbkVudW1lcmFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2MuZW51bWVyYWJsZSA6ICFub25FbnVtZXJhYmxlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IG5vbldyaXRhYmxlID09PSBudWxsICYmIGRlc2MgPyBkZXNjLndyaXRhYmxlIDogIW5vbldyaXRhYmxlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGxvb3NlIHx8ICFub25FbnVtZXJhYmxlICYmICFub25Xcml0YWJsZSAmJiAhbm9uQ29uZmlndXJhYmxlKSB7XG4gICAgICBvYmpbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyAkU3ludGF4RXJyb3IoXCJUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLlwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBkZWZpbmVEYXRhUHJvcGVydHk7XG59XG52YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yc18xO1xudmFyIGhhc1JlcXVpcmVkSGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbmZ1bmN0aW9uIHJlcXVpcmVIYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuICBpZiAoaGFzUmVxdWlyZWRIYXNQcm9wZXJ0eURlc2NyaXB0b3JzKSByZXR1cm4gaGFzUHJvcGVydHlEZXNjcmlwdG9yc18xO1xuICBoYXNSZXF1aXJlZEhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSAxO1xuICB2YXIgJGRlZmluZVByb3BlcnR5ID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVFc0RlZmluZVByb3BlcnR5KCk7XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9yczIoKSB7XG4gICAgcmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xuICB9O1xuICBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzLmhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnID0gZnVuY3Rpb24gaGFzQXJyYXlMZW5ndGhEZWZpbmVCdWcoKSB7XG4gICAgaWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShbXSwgXCJsZW5ndGhcIiwgeyB2YWx1ZTogMSB9KS5sZW5ndGggIT09IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzXzEgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzO1xuICByZXR1cm4gaGFzUHJvcGVydHlEZXNjcmlwdG9yc18xO1xufVxudmFyIHNldEZ1bmN0aW9uTGVuZ3RoO1xudmFyIGhhc1JlcXVpcmVkU2V0RnVuY3Rpb25MZW5ndGg7XG5mdW5jdGlvbiByZXF1aXJlU2V0RnVuY3Rpb25MZW5ndGgoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFNldEZ1bmN0aW9uTGVuZ3RoKSByZXR1cm4gc2V0RnVuY3Rpb25MZW5ndGg7XG4gIGhhc1JlcXVpcmVkU2V0RnVuY3Rpb25MZW5ndGggPSAxO1xuICB2YXIgR2V0SW50cmluc2ljID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVHZXRJbnRyaW5zaWMoKTtcbiAgdmFyIGRlZmluZSA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlRGVmaW5lRGF0YVByb3BlcnR5KCk7XG4gIHZhciBoYXNEZXNjcmlwdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlSGFzUHJvcGVydHlEZXNjcmlwdG9ycygpKCk7XG4gIHZhciBnT1BEMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR29wZCgpO1xuICB2YXIgJFR5cGVFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlVHlwZSgpO1xuICB2YXIgJGZsb29yID0gR2V0SW50cmluc2ljKFwiJU1hdGguZmxvb3IlXCIpO1xuICBzZXRGdW5jdGlvbkxlbmd0aCA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoMihmbiwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImBmbmAgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gNDI5NDk2NzI5NSB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcImBsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlclwiKTtcbiAgICB9XG4gICAgdmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG4gICAgdmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuICAgIHZhciBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSB0cnVlO1xuICAgIGlmIChcImxlbmd0aFwiIGluIGZuICYmIGdPUEQyKSB7XG4gICAgICB2YXIgZGVzYyA9IGdPUEQyKGZuLCBcImxlbmd0aFwiKTtcbiAgICAgIGlmIChkZXNjICYmICFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICBmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZGVzYyAmJiAhZGVzYy53cml0YWJsZSkge1xuICAgICAgICBmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgfHwgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlIHx8ICFsb29zZSkge1xuICAgICAgaWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgICAgIGRlZmluZShcbiAgICAgICAgICAvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi9cbiAgICAgICAgICBmbixcbiAgICAgICAgICBcImxlbmd0aFwiLFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZShcbiAgICAgICAgICAvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi9cbiAgICAgICAgICBmbixcbiAgICAgICAgICBcImxlbmd0aFwiLFxuICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm47XG4gIH07XG4gIHJldHVybiBzZXRGdW5jdGlvbkxlbmd0aDtcbn1cbnZhciBoYXNSZXF1aXJlZENhbGxCaW5kO1xuZnVuY3Rpb24gcmVxdWlyZUNhbGxCaW5kKCkge1xuICBpZiAoaGFzUmVxdWlyZWRDYWxsQmluZCkgcmV0dXJuIGNhbGxCaW5kLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkQ2FsbEJpbmQgPSAxO1xuICAoZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgdmFyIGJpbmQgPSByZXF1aXJlRnVuY3Rpb25CaW5kKCk7XG4gICAgdmFyIEdldEludHJpbnNpYyA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR2V0SW50cmluc2ljKCk7XG4gICAgdmFyIHNldEZ1bmN0aW9uTGVuZ3RoMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlU2V0RnVuY3Rpb25MZW5ndGgoKTtcbiAgICB2YXIgJFR5cGVFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlVHlwZSgpO1xuICAgIHZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoXCIlRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JVwiKTtcbiAgICB2YXIgJGNhbGwgPSBHZXRJbnRyaW5zaWMoXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO1xuICAgIHZhciAkcmVmbGVjdEFwcGx5ID0gR2V0SW50cmluc2ljKFwiJVJlZmxlY3QuYXBwbHklXCIsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcbiAgICB2YXIgJGRlZmluZVByb3BlcnR5ID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVFc0RlZmluZVByb3BlcnR5KCk7XG4gICAgdmFyICRtYXggPSBHZXRJbnRyaW5zaWMoXCIlTWF0aC5tYXglXCIpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQyKG9yaWdpbmFsRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyAkVHlwZUVycm9yKFwiYSBmdW5jdGlvbiBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBzZXRGdW5jdGlvbkxlbmd0aDIoXG4gICAgICAgIGZ1bmMsXG4gICAgICAgIDEgKyAkbWF4KDAsIG9yaWdpbmFsRnVuY3Rpb24ubGVuZ3RoIC0gKGFyZ3VtZW50cy5sZW5ndGggLSAxKSksXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfTtcbiAgICB2YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kMigpIHtcbiAgICAgIHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGlmICgkZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJhcHBseVwiLCB7IHZhbHVlOiBhcHBseUJpbmQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xuICAgIH1cbiAgfSkoY2FsbEJpbmQpO1xuICByZXR1cm4gY2FsbEJpbmQuZXhwb3J0cztcbn1cbnZhciBjYWxsQm91bmQ7XG52YXIgaGFzUmVxdWlyZWRDYWxsQm91bmQ7XG5mdW5jdGlvbiByZXF1aXJlQ2FsbEJvdW5kKCkge1xuICBpZiAoaGFzUmVxdWlyZWRDYWxsQm91bmQpIHJldHVybiBjYWxsQm91bmQ7XG4gIGhhc1JlcXVpcmVkQ2FsbEJvdW5kID0gMTtcbiAgdmFyIEdldEludHJpbnNpYyA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR2V0SW50cmluc2ljKCk7XG4gIHZhciBjYWxsQmluZDIgPSByZXF1aXJlQ2FsbEJpbmQoKTtcbiAgdmFyICRpbmRleE9mID0gY2FsbEJpbmQyKEdldEludHJpbnNpYyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7XG4gIGNhbGxCb3VuZCA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcbiAgICB2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcbiAgICBpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gXCJmdW5jdGlvblwiICYmICRpbmRleE9mKG5hbWUsIFwiLnByb3RvdHlwZS5cIikgPiAtMSkge1xuICAgICAgcmV0dXJuIGNhbGxCaW5kMihpbnRyaW5zaWMpO1xuICAgIH1cbiAgICByZXR1cm4gaW50cmluc2ljO1xuICB9O1xuICByZXR1cm4gY2FsbEJvdW5kO1xufVxudmFyIGlzQXJndW1lbnRzO1xudmFyIGhhc1JlcXVpcmVkSXNBcmd1bWVudHM7XG5mdW5jdGlvbiByZXF1aXJlSXNBcmd1bWVudHMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZElzQXJndW1lbnRzKSByZXR1cm4gaXNBcmd1bWVudHM7XG4gIGhhc1JlcXVpcmVkSXNBcmd1bWVudHMgPSAxO1xuICB2YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlU2hhbXMoKSgpO1xuICB2YXIgY2FsbEJvdW5kMiA9IHJlcXVpcmVDYWxsQm91bmQoKTtcbiAgdmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZDIoXCJPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXCIpO1xuICB2YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzMih2YWx1ZSkge1xuICAgIGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiO1xuICB9O1xuICB2YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50czIodmFsdWUpIHtcbiAgICBpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09IFwibnVtYmVyXCIgJiYgdmFsdWUubGVuZ3RoID49IDAgJiYgJHRvU3RyaW5nKHZhbHVlKSAhPT0gXCJbb2JqZWN0IEFycmF5XVwiICYmICR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gIH07XG4gIHZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgfSgpO1xuICBpc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7XG4gIGlzQXJndW1lbnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiAgcmV0dXJuIGlzQXJndW1lbnRzO1xufVxudmFyIGlzR2VuZXJhdG9yRnVuY3Rpb247XG52YXIgaGFzUmVxdWlyZWRJc0dlbmVyYXRvckZ1bmN0aW9uO1xuZnVuY3Rpb24gcmVxdWlyZUlzR2VuZXJhdG9yRnVuY3Rpb24oKSB7XG4gIGlmIChoYXNSZXF1aXJlZElzR2VuZXJhdG9yRnVuY3Rpb24pIHJldHVybiBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuICBoYXNSZXF1aXJlZElzR2VuZXJhdG9yRnVuY3Rpb24gPSAxO1xuICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzRm5SZWdleCA9IC9eXFxzKig/OmZ1bmN0aW9uKT9cXCovO1xuICB2YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlU2hhbXMoKSgpO1xuICB2YXIgZ2V0UHJvdG8yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgZ2V0R2VuZXJhdG9yRnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghaGFzVG9TdHJpbmdUYWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBGdW5jdGlvbihcInJldHVybiBmdW5jdGlvbiooKSB7fVwiKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gIH07XG4gIHZhciBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24yKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0ZuUmVnZXgudGVzdChmblRvU3RyLmNhbGwoZm4pKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghaGFzVG9TdHJpbmdUYWcpIHtcbiAgICAgIHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcbiAgICAgIHJldHVybiBzdHIgPT09IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIjtcbiAgICB9XG4gICAgaWYgKCFnZXRQcm90bzIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG4gICAgICBHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90bzIoZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFByb3RvMihmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xuICB9O1xuICByZXR1cm4gaXNHZW5lcmF0b3JGdW5jdGlvbjtcbn1cbnZhciBpc0NhbGxhYmxlO1xudmFyIGhhc1JlcXVpcmVkSXNDYWxsYWJsZTtcbmZ1bmN0aW9uIHJlcXVpcmVJc0NhbGxhYmxlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRJc0NhbGxhYmxlKSByZXR1cm4gaXNDYWxsYWJsZTtcbiAgaGFzUmVxdWlyZWRJc0NhbGxhYmxlID0gMTtcbiAgdmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciByZWZsZWN0QXBwbHkyID0gdHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xuICB2YXIgYmFkQXJyYXlMaWtlO1xuICB2YXIgaXNDYWxsYWJsZU1hcmtlcjtcbiAgaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkyID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJsZW5ndGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IGlzQ2FsbGFibGVNYXJrZXI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXNDYWxsYWJsZU1hcmtlciA9IHt9O1xuICAgICAgcmVmbGVjdEFwcGx5MihmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgNDI7XG4gICAgICB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGlmIChfICE9PSBpc0NhbGxhYmxlTWFya2VyKSB7XG4gICAgICAgIHJlZmxlY3RBcHBseTIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWZsZWN0QXBwbHkyID0gbnVsbDtcbiAgfVxuICB2YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbiAgdmFyIGlzRVM2Q2xhc3NGbiA9IGZ1bmN0aW9uIGlzRVM2Q2xhc3NGdW5jdGlvbih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yUmVnZXgudGVzdChmblN0cik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHRyeUZ1bmN0aW9uT2JqZWN0ID0gZnVuY3Rpb24gdHJ5RnVuY3Rpb25Ub1N0cih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmblRvU3RyLmNhbGwodmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG9iamVjdENsYXNzID0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgdmFyIGZuQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gIHZhciBnZW5DbGFzcyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIjtcbiAgdmFyIGRkYUNsYXNzID0gXCJbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXVwiO1xuICB2YXIgZGRhQ2xhc3MyID0gXCJbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXVwiO1xuICB2YXIgZGRhQ2xhc3MzID0gXCJbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXVwiO1xuICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgISFTeW1ib2wudG9TdHJpbmdUYWc7XG4gIHZhciBpc0lFNjggPSAhKDAgaW4gWyxdKTtcbiAgdmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICB2YXIgYWxsID0gZG9jdW1lbnQuYWxsO1xuICAgIGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuICAgICAgaXNEREEgPSBmdW5jdGlvbiBpc0RvY3VtZW50RG90QWxsKHZhbHVlKSB7XG4gICAgICAgIGlmICgoaXNJRTY4IHx8ICF2YWx1ZSkgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoc3RyID09PSBkZGFDbGFzcyB8fCBzdHIgPT09IGRkYUNsYXNzMiB8fCBzdHIgPT09IGRkYUNsYXNzMyB8fCBzdHIgPT09IG9iamVjdENsYXNzKSAmJiB2YWx1ZShcIlwiKSA9PSBudWxsO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaXNDYWxsYWJsZSA9IHJlZmxlY3RBcHBseTIgPyBmdW5jdGlvbiBpc0NhbGxhYmxlMih2YWx1ZSkge1xuICAgIGlmIChpc0REQSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlZmxlY3RBcHBseTIodmFsdWUsIG51bGwsIGJhZEFycmF5TGlrZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIWlzRVM2Q2xhc3NGbih2YWx1ZSkgJiYgdHJ5RnVuY3Rpb25PYmplY3QodmFsdWUpO1xuICB9IDogZnVuY3Rpb24gaXNDYWxsYWJsZTIodmFsdWUpIHtcbiAgICBpZiAoaXNEREEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChoYXNUb1N0cmluZ1RhZykge1xuICAgICAgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHN0ckNsYXNzID0gdG9TdHIuY2FsbCh2YWx1ZSk7XG4gICAgaWYgKHN0ckNsYXNzICE9PSBmbkNsYXNzICYmIHN0ckNsYXNzICE9PSBnZW5DbGFzcyAmJiAhL15cXFtvYmplY3QgSFRNTC8udGVzdChzdHJDbGFzcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIGlzQ2FsbGFibGU7XG59XG52YXIgZm9yRWFjaF8xO1xudmFyIGhhc1JlcXVpcmVkRm9yRWFjaDtcbmZ1bmN0aW9uIHJlcXVpcmVGb3JFYWNoKCkge1xuICBpZiAoaGFzUmVxdWlyZWRGb3JFYWNoKSByZXR1cm4gZm9yRWFjaF8xO1xuICBoYXNSZXF1aXJlZEZvckVhY2ggPSAxO1xuICB2YXIgaXNDYWxsYWJsZTIgPSByZXF1aXJlSXNDYWxsYWJsZSgpO1xuICB2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgZm9yRWFjaEFycmF5ID0gZnVuY3Rpb24gZm9yRWFjaEFycmF5MihhcnJheSwgaXRlcmF0b3IsIHJlY2VpdmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09IG51bGwpIHtcbiAgICAgICAgICBpdGVyYXRvcihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwocmVjZWl2ZXIsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZzIoc3RyaW5nLCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdDIob2JqZWN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT0gbnVsbCkge1xuICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrXSwgaywgb2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBmb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaDIobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUyKGl0ZXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgdmFyIHJlY2VpdmVyO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG4gICAgaWYgKHRvU3RyLmNhbGwobGlzdCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfVxuICB9O1xuICBmb3JFYWNoXzEgPSBmb3JFYWNoO1xuICByZXR1cm4gZm9yRWFjaF8xO1xufVxudmFyIHBvc3NpYmxlVHlwZWRBcnJheU5hbWVzO1xudmFyIGhhc1JlcXVpcmVkUG9zc2libGVUeXBlZEFycmF5TmFtZXM7XG5mdW5jdGlvbiByZXF1aXJlUG9zc2libGVUeXBlZEFycmF5TmFtZXMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFBvc3NpYmxlVHlwZWRBcnJheU5hbWVzKSByZXR1cm4gcG9zc2libGVUeXBlZEFycmF5TmFtZXM7XG4gIGhhc1JlcXVpcmVkUG9zc2libGVUeXBlZEFycmF5TmFtZXMgPSAxO1xuICBwb3NzaWJsZVR5cGVkQXJyYXlOYW1lcyA9IFtcbiAgICBcIkZsb2F0MzJBcnJheVwiLFxuICAgIFwiRmxvYXQ2NEFycmF5XCIsXG4gICAgXCJJbnQ4QXJyYXlcIixcbiAgICBcIkludDE2QXJyYXlcIixcbiAgICBcIkludDMyQXJyYXlcIixcbiAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gICAgXCJVaW50MTZBcnJheVwiLFxuICAgIFwiVWludDMyQXJyYXlcIixcbiAgICBcIkJpZ0ludDY0QXJyYXlcIixcbiAgICBcIkJpZ1VpbnQ2NEFycmF5XCJcbiAgXTtcbiAgcmV0dXJuIHBvc3NpYmxlVHlwZWRBcnJheU5hbWVzO1xufVxudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzO1xudmFyIGhhc1JlcXVpcmVkQXZhaWxhYmxlVHlwZWRBcnJheXM7XG5mdW5jdGlvbiByZXF1aXJlQXZhaWxhYmxlVHlwZWRBcnJheXMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEF2YWlsYWJsZVR5cGVkQXJyYXlzKSByZXR1cm4gYXZhaWxhYmxlVHlwZWRBcnJheXM7XG4gIGhhc1JlcXVpcmVkQXZhaWxhYmxlVHlwZWRBcnJheXMgPSAxO1xuICB2YXIgcG9zc2libGVOYW1lcyA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlUG9zc2libGVUeXBlZEFycmF5TmFtZXMoKTtcbiAgdmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIiA/IGNvbW1vbmpzR2xvYmFsIDogZ2xvYmFsVGhpcztcbiAgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSBmdW5jdGlvbiBhdmFpbGFibGVUeXBlZEFycmF5czIoKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBnW3Bvc3NpYmxlTmFtZXNbaV1dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbiAgcmV0dXJuIGF2YWlsYWJsZVR5cGVkQXJyYXlzO1xufVxudmFyIHdoaWNoVHlwZWRBcnJheTtcbnZhciBoYXNSZXF1aXJlZFdoaWNoVHlwZWRBcnJheTtcbmZ1bmN0aW9uIHJlcXVpcmVXaGljaFR5cGVkQXJyYXkoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFdoaWNoVHlwZWRBcnJheSkgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTtcbiAgaGFzUmVxdWlyZWRXaGljaFR5cGVkQXJyYXkgPSAxO1xuICB2YXIgZm9yRWFjaCA9IHJlcXVpcmVGb3JFYWNoKCk7XG4gIHZhciBhdmFpbGFibGVUeXBlZEFycmF5czIgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZUF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG4gIHZhciBjYWxsQmluZDIgPSByZXF1aXJlQ2FsbEJpbmQoKTtcbiAgdmFyIGNhbGxCb3VuZDIgPSByZXF1aXJlQ2FsbEJvdW5kKCk7XG4gIHZhciBnT1BEMiA9IC8qIEBfX1BVUkVfXyAqLyByZXF1aXJlR29wZCgpO1xuICB2YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kMihcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7XG4gIHZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmVTaGFtcygpKCk7XG4gIHZhciBnID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwidW5kZWZpbmVkXCIgPyBjb21tb25qc0dsb2JhbCA6IGdsb2JhbFRoaXM7XG4gIHZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzMigpO1xuICB2YXIgJHNsaWNlID0gY2FsbEJvdW5kMihcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7XG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyICRpbmRleE9mID0gY2FsbEJvdW5kMihcIkFycmF5LnByb3RvdHlwZS5pbmRleE9mXCIsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICB2YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuICBpZiAoaGFzVG9TdHJpbmdUYWcgJiYgZ09QRDIgJiYgZ2V0UHJvdG90eXBlT2YpIHtcbiAgICBmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbih0eXBlZEFycmF5KSB7XG4gICAgICB2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcbiAgICAgIGlmIChTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSB7XG4gICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZU9mKGFycik7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ09QRDIocHJvdG8sIFN5bWJvbC50b1N0cmluZ1RhZyk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvcikge1xuICAgICAgICAgIHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICAgIGRlc2NyaXB0b3IgPSBnT1BEMihzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW1wiJFwiICsgdHlwZWRBcnJheV0gPSBjYWxsQmluZDIoZGVzY3JpcHRvci5nZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uKHR5cGVkQXJyYXkpIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuICAgICAgdmFyIGZuID0gYXJyLnNsaWNlIHx8IGFyci5zZXQ7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgY2FjaGVbXCIkXCIgKyB0eXBlZEFycmF5XSA9IGNhbGxCaW5kMihmbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3JFYWNoKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8YFxcJCR7VHlwZWRBcnJheU5hbWV9YCwgR2V0dGVyPn0gKi9cbiAgICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICAgY2FjaGUsXG4gICAgICAvKiogQHR5cGUgeyhnZXR0ZXI6IEdldHRlciwgbmFtZTogYFxcJCR7aW1wb3J0KCcuJykuVHlwZWRBcnJheU5hbWV9YCkgPT4gdm9pZH0gKi9cbiAgICAgIGZ1bmN0aW9uKGdldHRlciwgdHlwZWRBcnJheSkge1xuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChcIiRcIiArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSAkc2xpY2UodHlwZWRBcnJheSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuICB2YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yRWFjaChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcbiAgICAgIC8qKiBAdHlwZSB7UmVjb3JkPGBcXCQke1R5cGVkQXJyYXlOYW1lfWAsIEdldHRlcj59ICovXG4gICAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICAgIGNhY2hlLFxuICAgICAgLyoqIEB0eXBlIHsoZ2V0dGVyOiB0eXBlb2YgY2FjaGUsIG5hbWU6IGBcXCQke2ltcG9ydCgnLicpLlR5cGVkQXJyYXlOYW1lfWApID0+IHZvaWR9ICovXG4gICAgICBmdW5jdGlvbihnZXR0ZXIsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnZXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgZm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9O1xuICB3aGljaFR5cGVkQXJyYXkgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkyKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFoYXNUb1N0cmluZ1RhZykge1xuICAgICAgdmFyIHRhZyA9ICRzbGljZSgkdG9TdHJpbmcodmFsdWUpLCA4LCAtMSk7XG4gICAgICBpZiAoJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKHRhZyAhPT0gXCJPYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ5U2xpY2VzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFnT1BEMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG4gIH07XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXk7XG59XG52YXIgaXNUeXBlZEFycmF5O1xudmFyIGhhc1JlcXVpcmVkSXNUeXBlZEFycmF5O1xuZnVuY3Rpb24gcmVxdWlyZUlzVHlwZWRBcnJheSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSXNUeXBlZEFycmF5KSByZXR1cm4gaXNUeXBlZEFycmF5O1xuICBoYXNSZXF1aXJlZElzVHlwZWRBcnJheSA9IDE7XG4gIHZhciB3aGljaFR5cGVkQXJyYXkyID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVXaGljaFR5cGVkQXJyYXkoKTtcbiAgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gaXNUeXBlZEFycmF5Mih2YWx1ZSkge1xuICAgIHJldHVybiAhIXdoaWNoVHlwZWRBcnJheTIodmFsdWUpO1xuICB9O1xuICByZXR1cm4gaXNUeXBlZEFycmF5O1xufVxudmFyIGhhc1JlcXVpcmVkVHlwZXM7XG5mdW5jdGlvbiByZXF1aXJlVHlwZXMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFR5cGVzKSByZXR1cm4gdHlwZXM7XG4gIGhhc1JlcXVpcmVkVHlwZXMgPSAxO1xuICAoZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIHZhciBpc0FyZ3VtZW50c09iamVjdCA9IHJlcXVpcmVJc0FyZ3VtZW50cygpO1xuICAgIHZhciBpc0dlbmVyYXRvckZ1bmN0aW9uMiA9IHJlcXVpcmVJc0dlbmVyYXRvckZ1bmN0aW9uKCk7XG4gICAgdmFyIHdoaWNoVHlwZWRBcnJheTIgPSAvKiBAX19QVVJFX18gKi8gcmVxdWlyZVdoaWNoVHlwZWRBcnJheSgpO1xuICAgIHZhciBpc1R5cGVkQXJyYXkyID0gLyogQF9fUFVSRV9fICovIHJlcXVpcmVJc1R5cGVkQXJyYXkoKTtcbiAgICBmdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG4gICAgfVxuICAgIHZhciBCaWdJbnRTdXBwb3J0ZWQgPSB0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBTeW1ib2xTdXBwb3J0ZWQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuICAgIHZhciBudW1iZXJWYWx1ZSA9IHVuY3VycnlUaGlzKE51bWJlci5wcm90b3R5cGUudmFsdWVPZik7XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbiAgICB2YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG4gICAgaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICAgICAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbiAgICB9XG4gICAgaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICAgICAgdmFyIHN5bWJvbFZhbHVlID0gdW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgcHJvdG90eXBlVmFsdWVPZikge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5pc0FyZ3VtZW50c09iamVjdCA9IGlzQXJndW1lbnRzT2JqZWN0O1xuICAgIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb24yO1xuICAgIGV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5MjtcbiAgICBmdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIFByb21pc2UgfHwgaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBpbnB1dC50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGlucHV0LmNhdGNoID09PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEFycmF5QnVmZmVyLmlzVmlldykge1xuICAgICAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1R5cGVkQXJyYXkyKHZhbHVlKSB8fCBpc0RhdGFWaWV3KHZhbHVlKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuICAgIGZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIlVpbnQ4QXJyYXlcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG4gICAgZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIlVpbnQ4Q2xhbXBlZEFycmF5XCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG4gICAgZnVuY3Rpb24gaXNVaW50MTZBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIlVpbnQxNkFycmF5XCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNVaW50MTZBcnJheSA9IGlzVWludDE2QXJyYXk7XG4gICAgZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIlVpbnQzMkFycmF5XCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG4gICAgZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB3aGljaFR5cGVkQXJyYXkyKHZhbHVlKSA9PT0gXCJJbnQ4QXJyYXlcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuICAgIGZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIkludDE2QXJyYXlcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0ludDE2QXJyYXkgPSBpc0ludDE2QXJyYXk7XG4gICAgZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gd2hpY2hUeXBlZEFycmF5Mih2YWx1ZSkgPT09IFwiSW50MzJBcnJheVwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcbiAgICBmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIkZsb2F0MzJBcnJheVwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG4gICAgZnVuY3Rpb24gaXNGbG9hdDY0QXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiB3aGljaFR5cGVkQXJyYXkyKHZhbHVlKSA9PT0gXCJGbG9hdDY0QXJyYXlcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0Zsb2F0NjRBcnJheSA9IGlzRmxvYXQ2NEFycmF5O1xuICAgIGZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIkJpZ0ludDY0QXJyYXlcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG4gICAgZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheTIodmFsdWUpID09PSBcIkJpZ1VpbnQ2NEFycmF5XCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG4gICAgZnVuY3Rpb24gaXNNYXBUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbiAgICB9XG4gICAgaXNNYXBUb1N0cmluZy53b3JraW5nID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc01hcFRvU3RyaW5nKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nID8gaXNNYXBUb1N0cmluZyh2YWx1ZSkgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbiAgICB9XG4gICAgZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuICAgIGZ1bmN0aW9uIGlzU2V0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09IFwiW29iamVjdCBTZXRdXCI7XG4gICAgfVxuICAgIGlzU2V0VG9TdHJpbmcud29ya2luZyA9IHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNTZXRUb1N0cmluZygvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBTZXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZyA/IGlzU2V0VG9TdHJpbmcodmFsdWUpIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNTZXQgPSBpc1NldDtcbiAgICBmdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFdlYWtNYXBdXCI7XG4gICAgfVxuICAgIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSB0eXBlb2YgV2Vha01hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc1dlYWtNYXBUb1N0cmluZygvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSk7XG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIFdlYWtNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkgOiB2YWx1ZSBpbnN0YW5jZW9mIFdlYWtNYXA7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgV2Vha1NldF1cIjtcbiAgICB9XG4gICAgaXNXZWFrU2V0VG9TdHJpbmcud29ya2luZyA9IHR5cGVvZiBXZWFrU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzV2Vha1NldFRvU3RyaW5nKC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiO1xuICAgIH1cbiAgICBpc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKCkpO1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID8gaXNBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgRGF0YVZpZXddXCI7XG4gICAgfVxuICAgIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBEYXRhVmlldyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0RhdGFWaWV3VG9TdHJpbmcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSwgMCwgMSkpO1xuICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID8gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNEYXRhVmlldyA9IGlzRGF0YVZpZXc7XG4gICAgdmFyIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IFNoYXJlZEFycmF5QnVmZmVyIDogdm9pZCAwO1xuICAgIGZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyQ29weSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBTaGFyZWRBcnJheUJ1ZmZlckNvcHkoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPyBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG4gICAgZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG4gICAgZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gXCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc01hcEl0ZXJhdG9yID0gaXNNYXBJdGVyYXRvcjtcbiAgICBmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgU2V0IEl0ZXJhdG9yXVwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuICAgIGZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSBcIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSA9IGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtcbiAgICBmdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIG51bWJlclZhbHVlKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xuICAgIH1cbiAgICBleHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0Jvb2xlYW5PYmplY3QgPSBpc0Jvb2xlYW5PYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBCaWdJbnRTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYmlnSW50VmFsdWUpO1xuICAgIH1cbiAgICBleHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xuICAgIH1cbiAgICBleHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG4gICAgZnVuY3Rpb24gaXNCb3hlZFByaW1pdGl2ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fCBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHwgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fCBpc0JpZ0ludE9iamVjdCh2YWx1ZSkgfHwgaXNTeW1ib2xPYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBleHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuICAgIGZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkpO1xuICAgIH1cbiAgICBleHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuICAgIFtcImlzUHJveHlcIiwgXCJpc0V4dGVybmFsXCIsIFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgXCIgaXMgbm90IHN1cHBvcnRlZCBpbiB1c2VybGFuZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pKHR5cGVzKTtcbiAgcmV0dXJuIHR5cGVzO1xufVxudmFyIGlzQnVmZmVyQnJvd3NlcjtcbnZhciBoYXNSZXF1aXJlZElzQnVmZmVyQnJvd3NlcjtcbmZ1bmN0aW9uIHJlcXVpcmVJc0J1ZmZlckJyb3dzZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZElzQnVmZmVyQnJvd3NlcikgcmV0dXJuIGlzQnVmZmVyQnJvd3NlcjtcbiAgaGFzUmVxdWlyZWRJc0J1ZmZlckJyb3dzZXIgPSAxO1xuICBpc0J1ZmZlckJyb3dzZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGFyZy5maWxsID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09IFwiZnVuY3Rpb25cIjtcbiAgfTtcbiAgcmV0dXJuIGlzQnVmZmVyQnJvd3Nlcjtcbn1cbnZhciBoYXNSZXF1aXJlZFV0aWw7XG5mdW5jdGlvbiByZXF1aXJlVXRpbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkVXRpbCkgcmV0dXJuIHV0aWw7XG4gIGhhc1JlcXVpcmVkVXRpbCA9IDE7XG4gIChmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzMihvYmopIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICAgIH07XG4gICAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG4gICAgZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gICAgICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdHMuam9pbihcIiBcIik7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDE7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgyKSB7XG4gICAgICAgIGlmICh4MiA9PT0gXCIlJVwiKSByZXR1cm4gXCIlXCI7XG4gICAgICAgIGlmIChpID49IGxlbikgcmV0dXJuIHgyO1xuICAgICAgICBzd2l0Y2ggKHgyKSB7XG4gICAgICAgICAgY2FzZSBcIiVzXCI6XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgY2FzZSBcIiVkXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgY2FzZSBcIiVqXCI6XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyXVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geDI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICAgICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgICAgICBzdHIgKz0gXCIgXCIgKyB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBcIiBcIiArIGluc3BlY3QoeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBleHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyQxICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MkMS5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyQxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MkMS50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MkMS50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXByZWNhdGVkO1xuICAgIH07XG4gICAgdmFyIGRlYnVncyA9IHt9O1xuICAgIHZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcbiAgICBpZiAocHJvY2VzcyQxLmVudi5OT0RFX0RFQlVHKSB7XG4gICAgICB2YXIgZGVidWdFbnYgPSBwcm9jZXNzJDEuZW52Lk5PREVfREVCVUc7XG4gICAgICBkZWJ1Z0VudiA9IGRlYnVnRW52LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csIFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLCBcIi4qXCIpLnJlcGxhY2UoLywvZywgXCIkfF5cIikudG9VcHBlckNhc2UoKTtcbiAgICAgIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgZGVidWdFbnYgKyBcIiRcIiwgXCJpXCIpO1xuICAgIH1cbiAgICBleHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gICAgICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICghZGVidWdzW3NldF0pIHtcbiAgICAgICAgaWYgKGRlYnVnRW52UmVnZXgudGVzdChzZXQpKSB7XG4gICAgICAgICAgdmFyIHBpZCA9IHByb2Nlc3MkMS5waWQ7XG4gICAgICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIiVzICVkOiAlc1wiLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYnVnc1tzZXRdO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgICAgIHZhciBjdHggPSB7XG4gICAgICAgIHNlZW46IFtdLFxuICAgICAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICAgICAgfTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gICAgICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgICAgIH0gZWxzZSBpZiAob3B0cykge1xuICAgICAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gICAgICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICAgICAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpbnNwZWN0LmNvbG9ycyA9IHtcbiAgICAgIFwiYm9sZFwiOiBbMSwgMjJdLFxuICAgICAgXCJpdGFsaWNcIjogWzMsIDIzXSxcbiAgICAgIFwidW5kZXJsaW5lXCI6IFs0LCAyNF0sXG4gICAgICBcImludmVyc2VcIjogWzcsIDI3XSxcbiAgICAgIFwid2hpdGVcIjogWzM3LCAzOV0sXG4gICAgICBcImdyZXlcIjogWzkwLCAzOV0sXG4gICAgICBcImJsYWNrXCI6IFszMCwgMzldLFxuICAgICAgXCJibHVlXCI6IFszNCwgMzldLFxuICAgICAgXCJjeWFuXCI6IFszNiwgMzldLFxuICAgICAgXCJncmVlblwiOiBbMzIsIDM5XSxcbiAgICAgIFwibWFnZW50YVwiOiBbMzUsIDM5XSxcbiAgICAgIFwicmVkXCI6IFszMSwgMzldLFxuICAgICAgXCJ5ZWxsb3dcIjogWzMzLCAzOV1cbiAgICB9O1xuICAgIGluc3BlY3Quc3R5bGVzID0ge1xuICAgICAgXCJzcGVjaWFsXCI6IFwiY3lhblwiLFxuICAgICAgXCJudW1iZXJcIjogXCJ5ZWxsb3dcIixcbiAgICAgIFwiYm9vbGVhblwiOiBcInllbGxvd1wiLFxuICAgICAgXCJ1bmRlZmluZWRcIjogXCJncmV5XCIsXG4gICAgICBcIm51bGxcIjogXCJib2xkXCIsXG4gICAgICBcInN0cmluZ1wiOiBcImdyZWVuXCIsXG4gICAgICBcImRhdGVcIjogXCJtYWdlbnRhXCIsXG4gICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgXCJyZWdleHBcIjogXCJyZWRcIlxuICAgIH07XG4gICAgZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICAgICAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICByZXR1cm4gXCJcXHgxQltcIiArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArIFwibVwiICsgc3RyICsgXCJcXHgxQltcIiArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArIFwibVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gICAgICB2YXIgaGFzaDIgPSB7fTtcbiAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICAgICAgaGFzaDJbdmFsXSA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoYXNoMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gICAgICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiYgdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJiAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJiAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgICAgIGlmIChwcmltaXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG4gICAgICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Vycm9yKHZhbHVlKSAmJiAoa2V5cy5pbmRleE9mKFwibWVzc2FnZVwiKSA+PSAwIHx8IGtleXMuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpID49IDApKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gXCI6IFwiICsgdmFsdWUubmFtZSA6IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFwiW0Z1bmN0aW9uXCIgKyBuYW1lICsgXCJdXCIsIFwic3BlY2lhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksIFwicmVnZXhwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCBcImRhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGJhc2UgPSBcIlwiLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbXCJ7XCIsIFwifVwiXTtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnJheSA9IHRydWU7XG4gICAgICAgIGJyYWNlcyA9IFtcIltcIiwgXCJdXCJdO1xuICAgICAgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/IFwiOiBcIiArIHZhbHVlLm5hbWUgOiBcIlwiO1xuICAgICAgICBiYXNlID0gXCIgW0Z1bmN0aW9uXCIgKyBuICsgXCJdXCI7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIGJhc2UgPSBcIiBcIiArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBiYXNlID0gXCIgXCIgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgICBiYXNlID0gXCIgXCIgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgICB9XG4gICAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksIFwicmVnZXhwXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcIltPYmplY3RdXCIsIFwic3BlY2lhbFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICB2YXIgb3V0cHV0O1xuICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZWVuLnBvcCgpO1xuICAgICAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcInVuZGVmaW5lZFwiLCBcInVuZGVmaW5lZFwiKTtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHNpbXBsZSA9IFwiJ1wiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgXCJcIikucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArIFwiJ1wiO1xuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcIlwiICsgdmFsdWUsIFwibnVtYmVyXCIpO1xuICAgICAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShcIlwiICsgdmFsdWUsIFwiYm9vbGVhblwiKTtcbiAgICAgIGlmIChpc051bGwodmFsdWUpKVxuICAgICAgICByZXR1cm4gY3R4LnN0eWxpemUoXCJudWxsXCIsIFwibnVsbFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBcIltcIiArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArIFwiXVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgcmVjdXJzZVRpbWVzLFxuICAgICAgICAgICAgdmlzaWJsZUtleXMsXG4gICAgICAgICAgICBTdHJpbmcoaSksXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJlY3Vyc2VUaW1lcyxcbiAgICAgICAgICAgIHZpc2libGVLZXlzLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgICAgIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIiwgXCJzcGVjaWFsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKFwiW0dldHRlcl1cIiwgXCJzcGVjaWFsXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZShcIltTZXR0ZXJdXCIsIFwic3BlY2lhbFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgICAgICBuYW1lID0gXCJbXCIgKyBrZXkgKyBcIl1cIjtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyKSB7XG4gICAgICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKFwiXFxuXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIgIFwiICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbihcIlxcblwiKS5zbGljZSgyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9IFwiXFxuXCIgKyBzdHIuc3BsaXQoXCJcXG5cIikubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIgICBcIiArIGxpbmU7XG4gICAgICAgICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKFwiW0NpcmN1bGFyXVwiLCBcInNwZWNpYWxcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgICAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KFwiXCIgKyBrZXkpO1xuICAgICAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsIFwibmFtZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csICdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsIFwic3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArIFwiOiBcIiArIHN0cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCJcXG5cIikgPj0gMCkgO1xuICAgICAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgXCJcIikubGVuZ3RoICsgMTtcbiAgICAgIH0sIDApO1xuICAgICAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgICAgIHJldHVybiBicmFjZXNbMF0gKyAoYmFzZSA9PT0gXCJcIiA/IFwiXCIgOiBiYXNlICsgXCJcXG4gXCIpICsgXCIgXCIgKyBvdXRwdXQuam9pbihcIixcXG4gIFwiKSArIFwiIFwiICsgYnJhY2VzWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBcIiBcIiArIG91dHB1dC5qb2luKFwiLCBcIikgKyBcIiBcIiArIGJyYWNlc1sxXTtcbiAgICB9XG4gICAgZXhwb3J0cy50eXBlcyA9IHJlcXVpcmVUeXBlcygpO1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJib29sZWFuXCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuICAgIGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICAgICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICAgIH1cbiAgICBleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN5bWJvbFwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBleHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiAmJiBhcmcgIT09IG51bGw7XG4gICAgfVxuICAgIGV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBmdW5jdGlvbiBpc0RhdGUoZCkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QoZSkgJiYgKG9iamVjdFRvU3RyaW5nKGUpID09PSBcIltvYmplY3QgRXJyb3JdXCIgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbiAgICB9XG4gICAgZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBleHBvcnRzLnR5cGVzLmlzTmF0aXZlRXJyb3IgPSBpc0Vycm9yO1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgYXJnID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGFyZyA9PT0gXCJzeW1ib2xcIiB8fCAvLyBFUzYgc3ltYm9sXG4gICAgICB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG4gICAgZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmVJc0J1ZmZlckJyb3dzZXIoKTtcbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYWQobikge1xuICAgICAgcmV0dXJuIG4gPCAxMCA/IFwiMFwiICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdmFyIG1vbnRocyA9IFtcbiAgICAgIFwiSmFuXCIsXG4gICAgICBcIkZlYlwiLFxuICAgICAgXCJNYXJcIixcbiAgICAgIFwiQXByXCIsXG4gICAgICBcIk1heVwiLFxuICAgICAgXCJKdW5cIixcbiAgICAgIFwiSnVsXCIsXG4gICAgICBcIkF1Z1wiLFxuICAgICAgXCJTZXBcIixcbiAgICAgIFwiT2N0XCIsXG4gICAgICBcIk5vdlwiLFxuICAgICAgXCJEZWNcIlxuICAgIF07XG4gICAgZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICAgICAgdmFyIGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIHZhciB0aW1lID0gW1xuICAgICAgICBwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKVxuICAgICAgXS5qb2luKFwiOlwiKTtcbiAgICAgIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiJXMgLSAlc1wiLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZUluaGVyaXRzX2Jyb3dzZXIoKTtcbiAgICBleHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAgICAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gICAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG4gICAgfVxuICAgIHZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sKFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIpIDogdm9pZCAwO1xuICAgIGV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICAgICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgICAgICB2YWx1ZTogZm4sXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICAgICAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgICAgdmFsdWU6IGZuLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgICAgICBmbixcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2w7XG4gICAgZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoXCJQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWVcIik7XG4gICAgICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihyZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYyLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uKHJldCkge1xuICAgICAgICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgcmV0KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbihyZWopIHtcbiAgICAgICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgICAgIGNhbGxiYWNraWZpZWQsXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcbiAgfSkodXRpbCk7XG4gIHJldHVybiB1dGlsO1xufVxudmFyIGJ1ZmZlcl9saXN0O1xudmFyIGhhc1JlcXVpcmVkQnVmZmVyX2xpc3Q7XG5mdW5jdGlvbiByZXF1aXJlQnVmZmVyX2xpc3QoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEJ1ZmZlcl9saXN0KSByZXR1cm4gYnVmZmVyX2xpc3Q7XG4gIGhhc1JlcXVpcmVkQnVmZmVyX2xpc3QgPSAxO1xuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZUJ1ZmZlcigpLCBCdWZmZXIyID0gX3JlcXVpcmUuQnVmZmVyO1xuICB2YXIgX3JlcXVpcmUyID0gcmVxdWlyZVV0aWwoKSwgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuICB2YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCBcImluc3BlY3RcIjtcbiAgZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gICAgQnVmZmVyMi5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xuICB9XG4gIGJ1ZmZlcl9saXN0ID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG4gICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckxpc3QsIFt7XG4gICAgICBrZXk6IFwicHVzaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgZGF0YTogdixcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7XG4gICAgICAgIGVsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICArK3RoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgICBkYXRhOiB2LFxuICAgICAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2hpZnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImpvaW5cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJcIjtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHZhciByZXQgPSBcIlwiICsgcC5kYXRhO1xuICAgICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbmNhdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlcjIuYWxsb2MoMCk7XG4gICAgICAgIHZhciByZXQgPSBCdWZmZXIyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgb3IgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICAgIHZhciByZXQ7XG4gICAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaXJzdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgICB9XG4gICAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgICB2YXIgYyA9IDE7XG4gICAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO1xuICAgICAgICAgIGVsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgICBuIC09IG5iO1xuICAgICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7XG4gICAgICAgICAgICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgKytjO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2dldEJ1ZmZlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgICB2YXIgcmV0ID0gQnVmZmVyMi5hbGxvY1Vuc2FmZShuKTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHZhciBjID0gMTtcbiAgICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgICAgbiAtPSBuYjtcbiAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O1xuICAgICAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgICsrYztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBsaW5rZWQgbGlzdCBvbmx5IHNob3dzIHRoZSBtaW5pbWFsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbi5cbiAgICB9LCB7XG4gICAgICBrZXk6IGN1c3RvbSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfV0pO1xuICAgIHJldHVybiBCdWZmZXJMaXN0O1xuICB9KCk7XG4gIHJldHVybiBidWZmZXJfbGlzdDtcbn1cbnZhciBkZXN0cm95XzE7XG52YXIgaGFzUmVxdWlyZWREZXN0cm95O1xuZnVuY3Rpb24gcmVxdWlyZURlc3Ryb3koKSB7XG4gIGlmIChoYXNSZXF1aXJlZERlc3Ryb3kpIHJldHVybiBkZXN0cm95XzE7XG4gIGhhc1JlcXVpcmVkRGVzdHJveSA9IDE7XG4gIGZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICAgIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgICBwcm9jZXNzJDEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uKGVycjIpIHtcbiAgICAgIGlmICghY2IgJiYgZXJyMikge1xuICAgICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIyKTtcbiAgICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICBwcm9jZXNzJDEubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgICBjYihlcnIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZjIsIGVycikge1xuICAgIGVtaXRFcnJvck5UKHNlbGYyLCBlcnIpO1xuICAgIGVtaXRDbG9zZU5UKHNlbGYyKTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmMikge1xuICAgIGlmIChzZWxmMi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZjIuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gICAgaWYgKHNlbGYyLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmMi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgICBzZWxmMi5lbWl0KFwiY2xvc2VcIik7XG4gIH1cbiAgZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZjIsIGVycikge1xuICAgIHNlbGYyLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICB9XG4gIGZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICAgIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgZWxzZSBzdHJlYW0uZW1pdChcImVycm9yXCIsIGVycik7XG4gIH1cbiAgZGVzdHJveV8xID0ge1xuICAgIGRlc3Ryb3ksXG4gICAgdW5kZXN0cm95LFxuICAgIGVycm9yT3JEZXN0cm95XG4gIH07XG4gIHJldHVybiBkZXN0cm95XzE7XG59XG52YXIgZXJyb3JzQnJvd3NlciA9IHt9O1xudmFyIGhhc1JlcXVpcmVkRXJyb3JzQnJvd3NlcjtcbmZ1bmN0aW9uIHJlcXVpcmVFcnJvcnNCcm93c2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRFcnJvcnNCcm93c2VyKSByZXR1cm4gZXJyb3JzQnJvd3NlcjtcbiAgaGFzUmVxdWlyZWRFcnJvcnNCcm93c2VyID0gMTtcbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG4gIHZhciBjb2RlcyA9IHt9O1xuICBmdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICAgIGlmICghQmFzZSkge1xuICAgICAgQmFzZSA9IEVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgTm9kZUVycm9yID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKF9CYXNlKSB7XG4gICAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IyLCBfQmFzZSk7XG4gICAgICBmdW5jdGlvbiBOb2RlRXJyb3IyKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBOb2RlRXJyb3IyO1xuICAgIH0oQmFzZSk7XG4gICAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICAgIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGU7XG4gICAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG4gIH1cbiAgZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgICAgfSk7XG4gICAgICBpZiAobGVuID4gMikge1xuICAgICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oXCIsIFwiKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZFswXSwgXCIgb3IgXCIpLmNvbmNhdChleHBlY3RlZFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBzZWFyY2gsIHBvcykge1xuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbiAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2gsIHRoaXNfbGVuKSB7XG4gICAgaWYgKHRoaXNfbGVuID09PSB2b2lkIDAgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXNfbGVuIC0gc2VhcmNoLmxlbmd0aCwgdGhpc19sZW4pID09PSBzZWFyY2g7XG4gIH1cbiAgZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICAgIH1cbiAgfVxuICBjcmVhdGVFcnJvclR5cGUoXCJFUlJfSU5WQUxJRF9PUFRfVkFMVUVcIiwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG4gIH0sIFR5cGVFcnJvcik7XG4gIGNyZWF0ZUVycm9yVHlwZShcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsIGZ1bmN0aW9uKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICB2YXIgZGV0ZXJtaW5lcjtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSBcInN0cmluZ1wiICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsIFwibm90IFwiKSkge1xuICAgICAgZGV0ZXJtaW5lciA9IFwibXVzdCBub3QgYmVcIjtcbiAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0ZXJtaW5lciA9IFwibXVzdCBiZVwiO1xuICAgIH1cbiAgICB2YXIgbXNnO1xuICAgIGlmIChlbmRzV2l0aChuYW1lLCBcIiBhcmd1bWVudFwiKSkge1xuICAgICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgXCJ0eXBlXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUyID0gaW5jbHVkZXMobmFtZSwgXCIuXCIpID8gXCJwcm9wZXJ0eVwiIDogXCJhcmd1bWVudFwiO1xuICAgICAgbXNnID0gJ1RoZSBcIicuY29uY2F0KG5hbWUsICdcIiAnKS5jb25jYXQodHlwZTIsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgXCJ0eXBlXCIpKTtcbiAgICB9XG4gICAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgICByZXR1cm4gbXNnO1xuICB9LCBUeXBlRXJyb3IpO1xuICBjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GXCIsIFwic3RyZWFtLnB1c2goKSBhZnRlciBFT0ZcIik7XG4gIGNyZWF0ZUVycm9yVHlwZShcIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEXCIsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gXCJUaGUgXCIgKyBuYW1lICsgXCIgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZFwiO1xuICB9KTtcbiAgY3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIiwgXCJQcmVtYXR1cmUgY2xvc2VcIik7XG4gIGNyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fREVTVFJPWUVEXCIsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gXCJDYW5ub3QgY2FsbCBcIiArIG5hbWUgKyBcIiBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkXCI7XG4gIH0pO1xuICBjcmVhdGVFcnJvclR5cGUoXCJFUlJfTVVMVElQTEVfQ0FMTEJBQ0tcIiwgXCJDYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXNcIik7XG4gIGNyZWF0ZUVycm9yVHlwZShcIkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEVcIiwgXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpO1xuICBjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORFwiLCBcIndyaXRlIGFmdGVyIGVuZFwiKTtcbiAgY3JlYXRlRXJyb3JUeXBlKFwiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFU1wiLCBcIk1heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtXCIsIFR5cGVFcnJvcik7XG4gIGNyZWF0ZUVycm9yVHlwZShcIkVSUl9VTktOT1dOX0VOQ09ESU5HXCIsIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgYXJnO1xuICB9LCBUeXBlRXJyb3IpO1xuICBjcmVhdGVFcnJvclR5cGUoXCJFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UXCIsIFwic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnRcIik7XG4gIGVycm9yc0Jyb3dzZXIuY29kZXMgPSBjb2RlcztcbiAgcmV0dXJuIGVycm9yc0Jyb3dzZXI7XG59XG52YXIgc3RhdGU7XG52YXIgaGFzUmVxdWlyZWRTdGF0ZTtcbmZ1bmN0aW9uIHJlcXVpcmVTdGF0ZSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkU3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgaGFzUmVxdWlyZWRTdGF0ZSA9IDE7XG4gIHZhciBFUlJfSU5WQUxJRF9PUFRfVkFMVUUgPSByZXF1aXJlRXJyb3JzQnJvd3NlcigpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcbiAgZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICAgIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlMiwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICAgIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcbiAgICBpZiAoaHdtICE9IG51bGwpIHtcbiAgICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6IFwiaGlnaFdhdGVyTWFya1wiO1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUyLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgfVxuICBzdGF0ZSA9IHtcbiAgICBnZXRIaWdoV2F0ZXJNYXJrXG4gIH07XG4gIHJldHVybiBzdGF0ZTtcbn1cbnZhciBicm93c2VyO1xudmFyIGhhc1JlcXVpcmVkQnJvd3NlcjtcbmZ1bmN0aW9uIHJlcXVpcmVCcm93c2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRCcm93c2VyKSByZXR1cm4gYnJvd3NlcjtcbiAgaGFzUmVxdWlyZWRCcm93c2VyID0gMTtcbiAgYnJvd3NlciA9IGRlcHJlY2F0ZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtc2cpIHtcbiAgICBpZiAoY29uZmlnKFwibm9EZXByZWNhdGlvblwiKSkge1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgIGlmIChjb25maWcoXCJ0aHJvd0RlcHJlY2F0aW9uXCIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnKFwidHJhY2VEZXByZWNhdGlvblwiKSkge1xuICAgICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgfVxuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBkZXByZWNhdGVkO1xuICB9XG4gIGZ1bmN0aW9uIGNvbmZpZyhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghY29tbW9uanNHbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmFsID0gY29tbW9uanNHbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICAgIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSBcInRydWVcIjtcbiAgfVxuICByZXR1cm4gYnJvd3Nlcjtcbn1cbnZhciBfc3RyZWFtX3dyaXRhYmxlO1xudmFyIGhhc1JlcXVpcmVkX3N0cmVhbV93cml0YWJsZTtcbmZ1bmN0aW9uIHJlcXVpcmVfc3RyZWFtX3dyaXRhYmxlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRfc3RyZWFtX3dyaXRhYmxlKSByZXR1cm4gX3N0cmVhbV93cml0YWJsZTtcbiAgaGFzUmVxdWlyZWRfc3RyZWFtX3dyaXRhYmxlID0gMTtcbiAgX3N0cmVhbV93cml0YWJsZSA9IFdyaXRhYmxlO1xuICBmdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlMikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlMik7XG4gICAgfTtcbiAgfVxuICB2YXIgRHVwbGV4O1xuICBXcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbiAgdmFyIGludGVybmFsVXRpbCA9IHtcbiAgICBkZXByZWNhdGU6IHJlcXVpcmVCcm93c2VyKClcbiAgfTtcbiAgdmFyIFN0cmVhbSA9IHJlcXVpcmVTdHJlYW1Ccm93c2VyKCk7XG4gIHZhciBCdWZmZXIyID0gcmVxdWlyZUJ1ZmZlcigpLkJ1ZmZlcjtcbiAgdmFyIE91clVpbnQ4QXJyYXkgPSBjb21tb25qc0dsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uKCkge1xuICB9O1xuICBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gICAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShjaHVuayk7XG4gIH1cbiAgZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgICByZXR1cm4gQnVmZmVyMi5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG4gIH1cbiAgdmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZURlc3Ryb3koKTtcbiAgdmFyIF9yZXF1aXJlID0gcmVxdWlyZVN0YXRlKCksIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuICB2YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlRXJyb3JzQnJvd3NlcigpLmNvZGVzLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELCBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLCBFUlJfU1RSRUFNX0RFU1RST1lFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fREVTVFJPWUVELCBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUywgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCwgRVJSX1VOS05PV05fRU5DT0RJTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVU5LTk9XTl9FTkNPRElORztcbiAgdmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG4gIHJlcXVpcmVJbmhlcml0c19icm93c2VyKCkoV3JpdGFibGUsIFN0cmVhbSk7XG4gIGZ1bmN0aW9uIG5vcCgpIHtcbiAgfVxuICBmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZV9zdHJlYW1fZHVwbGV4KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gXCJib29sZWFuXCIpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuICAgIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICAgIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCBcIndyaXRhYmxlSGlnaFdhdGVyTWFya1wiLCBpc0R1cGxleCk7XG4gICAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gICAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG4gICAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCBcInV0ZjhcIjtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy53cml0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jb3JrZWQgPSAwO1xuICAgIHRoaXMuc3luYyA9IHRydWU7XG4gICAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gICAgfTtcbiAgICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICAgIHRoaXMud3JpdGVsZW4gPSAwO1xuICAgIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ2NiID0gMDtcbiAgICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTtcbiAgICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuICAgIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICAgIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG4gIH1cbiAgV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG4gIChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCBcImJ1ZmZlclwiLCB7XG4gICAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgICB9LCBcIl93cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyIGluc3RlYWQuXCIsIFwiREVQMDAwM1wiKVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgIH1cbiAgfSkoKTtcbiAgdmFyIHJlYWxIYXNJbnN0YW5jZTtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlMihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAgIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlX3N0cmVhbV9kdXBsZXgoKTtcbiAgICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICAgIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICAgIH1cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgfVxuICBXcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFKCkpO1xuICB9O1xuICBmdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzJDEubmV4dFRpY2soY2IsIGVyKTtcbiAgfVxuICBmdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUyLCBjaHVuaywgY2IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09IFwic3RyaW5nXCIgJiYgIXN0YXRlMi5vYmplY3RNb2RlKSB7XG4gICAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcImNodW5rXCIsIFtcInN0cmluZ1wiLCBcIkJ1ZmZlclwiXSwgY2h1bmspO1xuICAgIH1cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGNiLCBlcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFdyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgICB2YXIgcmV0ID0gZmFsc2U7XG4gICAgdmFyIGlzQnVmID0gIXN0YXRlMi5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuICAgIGlmIChpc0J1ZiAmJiAhQnVmZmVyMi5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGlzQnVmKSBlbmNvZGluZyA9IFwiYnVmZmVyXCI7XG4gICAgZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlMi5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSBjYiA9IG5vcDtcbiAgICBpZiAoc3RhdGUyLmVuZGluZykgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7XG4gICAgZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZTIsIGNodW5rLCBjYikpIHtcbiAgICAgIHN0YXRlMi5wZW5kaW5nY2IrKztcbiAgICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUyLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIFdyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbiAgfTtcbiAgV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZTIgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICAgIGlmIChzdGF0ZTIuY29ya2VkKSB7XG4gICAgICBzdGF0ZTIuY29ya2VkLS07XG4gICAgICBpZiAoIXN0YXRlMi53cml0aW5nICYmICFzdGF0ZTIuY29ya2VkICYmICFzdGF0ZTIuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZTIuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZTIpO1xuICAgIH1cbiAgfTtcbiAgV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwic3RyaW5nXCIpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIShbXCJoZXhcIiwgXCJ1dGY4XCIsIFwidXRmLThcIiwgXCJhc2NpaVwiLCBcImJpbmFyeVwiLCBcImJhc2U2NFwiLCBcInVjczJcIiwgXCJ1Y3MtMlwiLCBcInV0ZjE2bGVcIiwgXCJ1dGYtMTZsZVwiLCBcInJhd1wiXS5pbmRleE9mKChlbmNvZGluZyArIFwiXCIpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsIFwid3JpdGFibGVCdWZmZXJcIiwge1xuICAgIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gICAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZTIsIGNodW5rLCBlbmNvZGluZykge1xuICAgIGlmICghc3RhdGUyLm9iamVjdE1vZGUgJiYgc3RhdGUyLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY2h1bmsgPSBCdWZmZXIyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsIFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIsIHtcbiAgICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAgIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0MigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlMiwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoIWlzQnVmKSB7XG4gICAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZTIsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgICAgZW5jb2RpbmcgPSBcImJ1ZmZlclwiO1xuICAgICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbGVuID0gc3RhdGUyLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIHN0YXRlMi5sZW5ndGggKz0gbGVuO1xuICAgIHZhciByZXQgPSBzdGF0ZTIubGVuZ3RoIDwgc3RhdGUyLmhpZ2hXYXRlck1hcms7XG4gICAgaWYgKCFyZXQpIHN0YXRlMi5uZWVkRHJhaW4gPSB0cnVlO1xuICAgIGlmIChzdGF0ZTIud3JpdGluZyB8fCBzdGF0ZTIuY29ya2VkKSB7XG4gICAgICB2YXIgbGFzdCA9IHN0YXRlMi5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgc3RhdGUyLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICAgIGNodW5rLFxuICAgICAgICBlbmNvZGluZyxcbiAgICAgICAgaXNCdWYsXG4gICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgIGxhc3QubmV4dCA9IHN0YXRlMi5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUyLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlMi5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgICAgfVxuICAgICAgc3RhdGUyLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZTIsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZTIsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgc3RhdGUyLndyaXRlbGVuID0gbGVuO1xuICAgIHN0YXRlMi53cml0ZWNiID0gY2I7XG4gICAgc3RhdGUyLndyaXRpbmcgPSB0cnVlO1xuICAgIHN0YXRlMi5zeW5jID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUyLmRlc3Ryb3llZCkgc3RhdGUyLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKFwid3JpdGVcIikpO1xuICAgIGVsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlMi5vbndyaXRlKTtcbiAgICBlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZTIub253cml0ZSk7XG4gICAgc3RhdGUyLnN5bmMgPSBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZTIsIHN5bmMsIGVyLCBjYikge1xuICAgIC0tc3RhdGUyLnBlbmRpbmdjYjtcbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGNiLCBlcik7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUyKTtcbiAgICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKGVyKTtcbiAgICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlMik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZTIpIHtcbiAgICBzdGF0ZTIud3JpdGluZyA9IGZhbHNlO1xuICAgIHN0YXRlMi53cml0ZWNiID0gbnVsbDtcbiAgICBzdGF0ZTIubGVuZ3RoIC09IHN0YXRlMi53cml0ZWxlbjtcbiAgICBzdGF0ZTIud3JpdGVsZW4gPSAwO1xuICB9XG4gIGZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICAgIHZhciBzdGF0ZTIgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gICAgdmFyIHN5bmMgPSBzdGF0ZTIuc3luYztcbiAgICB2YXIgY2IgPSBzdGF0ZTIud3JpdGVjYjtcbiAgICBpZiAodHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUyKTtcbiAgICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlMiwgc3luYywgZXIsIGNiKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUyKSB8fCBzdHJlYW0uZGVzdHJveWVkO1xuICAgICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUyLmNvcmtlZCAmJiAhc3RhdGUyLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUyLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlMik7XG4gICAgICB9XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBwcm9jZXNzJDEubmV4dFRpY2soYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZTIsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUyLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUyLCBmaW5pc2hlZCwgY2IpIHtcbiAgICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZTIpO1xuICAgIHN0YXRlMi5wZW5kaW5nY2ItLTtcbiAgICBjYigpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUyKTtcbiAgfVxuICBmdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZTIpIHtcbiAgICBpZiAoc3RhdGUyLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZTIubmVlZERyYWluKSB7XG4gICAgICBzdGF0ZTIubmVlZERyYWluID0gZmFsc2U7XG4gICAgICBzdHJlYW0uZW1pdChcImRyYWluXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlMikge1xuICAgIHN0YXRlMi5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZTIuYnVmZmVyZWRSZXF1ZXN0O1xuICAgIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgICB2YXIgbCA9IHN0YXRlMi5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICAgIHZhciBidWZmZXIyID0gbmV3IEFycmF5KGwpO1xuICAgICAgdmFyIGhvbGRlciA9IHN0YXRlMi5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgYnVmZmVyMltjb3VudF0gPSBlbnRyeTtcbiAgICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBidWZmZXIyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlMiwgdHJ1ZSwgc3RhdGUyLmxlbmd0aCwgYnVmZmVyMiwgXCJcIiwgaG9sZGVyLmZpbmlzaCk7XG4gICAgICBzdGF0ZTIucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZTIubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgICAgc3RhdGUyLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZTIuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUyKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlMi5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgICB2YXIgbGVuID0gc3RhdGUyLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUyLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICBzdGF0ZTIuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgICAgaWYgKHN0YXRlMi53cml0aW5nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUyLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0ZTIuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gICAgc3RhdGUyLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRChcIl93cml0ZSgpXCIpKTtcbiAgfTtcbiAgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuICBXcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIHZhciBzdGF0ZTIgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2IgPSBjaHVuaztcbiAgICAgIGNodW5rID0gbnVsbDtcbiAgICAgIGVuY29kaW5nID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgZW5jb2RpbmcgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHZvaWQgMCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChzdGF0ZTIuY29ya2VkKSB7XG4gICAgICBzdGF0ZTIuY29ya2VkID0gMTtcbiAgICAgIHRoaXMudW5jb3JrKCk7XG4gICAgfVxuICAgIGlmICghc3RhdGUyLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUyLCBjYik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsIFwid3JpdGFibGVMZW5ndGhcIiwge1xuICAgIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gICAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUyKSB7XG4gICAgcmV0dXJuIHN0YXRlMi5lbmRpbmcgJiYgc3RhdGUyLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZTIuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZTIuZmluaXNoZWQgJiYgIXN0YXRlMi53cml0aW5nO1xuICB9XG4gIGZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlMikge1xuICAgIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzdGF0ZTIucGVuZGluZ2NiLS07XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlMi5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdChcInByZWZpbmlzaFwiKTtcbiAgICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUyKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZTIpIHtcbiAgICBpZiAoIXN0YXRlMi5wcmVmaW5pc2hlZCAmJiAhc3RhdGUyLmZpbmFsQ2FsbGVkKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09IFwiZnVuY3Rpb25cIiAmJiAhc3RhdGUyLmRlc3Ryb3llZCkge1xuICAgICAgICBzdGF0ZTIucGVuZGluZ2NiKys7XG4gICAgICAgIHN0YXRlMi5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlMi5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5lbWl0KFwicHJlZmluaXNoXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlMikge1xuICAgIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZTIpO1xuICAgIGlmIChuZWVkKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZTIpO1xuICAgICAgaWYgKHN0YXRlMi5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgICAgc3RhdGUyLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoXCJmaW5pc2hcIik7XG4gICAgICAgIGlmIChzdGF0ZTIuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5lZWQ7XG4gIH1cbiAgZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZTIsIGNiKSB7XG4gICAgc3RhdGUyLmVuZGluZyA9IHRydWU7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZTIpO1xuICAgIGlmIChjYikge1xuICAgICAgaWYgKHN0YXRlMi5maW5pc2hlZCkgcHJvY2VzcyQxLm5leHRUaWNrKGNiKTtcbiAgICAgIGVsc2Ugc3RyZWFtLm9uY2UoXCJmaW5pc2hcIiwgY2IpO1xuICAgIH1cbiAgICBzdGF0ZTIuZW5kZWQgPSB0cnVlO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlMiwgZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUyLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXJyKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICB9XG4gICAgc3RhdGUyLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldDIoKSB7XG4gICAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG4gIFdyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuICBXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7XG4gICAgY2IoZXJyKTtcbiAgfTtcbiAgcmV0dXJuIF9zdHJlYW1fd3JpdGFibGU7XG59XG52YXIgX3N0cmVhbV9kdXBsZXg7XG52YXIgaGFzUmVxdWlyZWRfc3RyZWFtX2R1cGxleDtcbmZ1bmN0aW9uIHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkX3N0cmVhbV9kdXBsZXgpIHJldHVybiBfc3RyZWFtX2R1cGxleDtcbiAgaGFzUmVxdWlyZWRfc3RyZWFtX2R1cGxleCA9IDE7XG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMyID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAga2V5czIucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5czI7XG4gIH07XG4gIF9zdHJlYW1fZHVwbGV4ID0gRHVwbGV4O1xuICB2YXIgUmVhZGFibGUgPSByZXF1aXJlX3N0cmVhbV9yZWFkYWJsZSgpO1xuICB2YXIgV3JpdGFibGUgPSByZXF1aXJlX3N0cmVhbV93cml0YWJsZSgpO1xuICByZXF1aXJlSW5oZXJpdHNfYnJvd3NlcigpKER1cGxleCwgUmVhZGFibGUpO1xuICB7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbmNlKFwiZW5kXCIsIG9uZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsIFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIsIHtcbiAgICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAgIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0MigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsIFwid3JpdGFibGVCdWZmZXJcIiwge1xuICAgIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gICAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgXCJ3cml0YWJsZUxlbmd0aFwiLCB7XG4gICAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldDIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcbiAgICBwcm9jZXNzJDEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG4gIH1cbiAgZnVuY3Rpb24gb25FbmROVChzZWxmMikge1xuICAgIHNlbGYyLmVuZCgpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldDIoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdm9pZCAwIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHZvaWQgMCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIF9zdHJlYW1fZHVwbGV4O1xufVxudmFyIHN0cmluZ19kZWNvZGVyID0ge307XG52YXIgc2FmZUJ1ZmZlciA9IHsgZXhwb3J0czoge30gfTtcbnZhciBoYXNSZXF1aXJlZFNhZmVCdWZmZXI7XG5mdW5jdGlvbiByZXF1aXJlU2FmZUJ1ZmZlcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkU2FmZUJ1ZmZlcikgcmV0dXJuIHNhZmVCdWZmZXIuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRTYWZlQnVmZmVyID0gMTtcbiAgKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIHZhciBidWZmZXIyID0gcmVxdWlyZUJ1ZmZlcigpO1xuICAgIHZhciBCdWZmZXIyID0gYnVmZmVyMi5CdWZmZXI7XG4gICAgZnVuY3Rpb24gY29weVByb3BzKHNyYywgZHN0KSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChCdWZmZXIyLmZyb20gJiYgQnVmZmVyMi5hbGxvYyAmJiBCdWZmZXIyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlcjIuYWxsb2NVbnNhZmVTbG93KSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlcjI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlQcm9wcyhidWZmZXIyLCBleHBvcnRzKTtcbiAgICAgIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2FmZUJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlcjIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cbiAgICBjb3B5UHJvcHMoQnVmZmVyMiwgU2FmZUJ1ZmZlcik7XG4gICAgU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCdWZmZXIyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIFNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlcjIoc2l6ZSk7XG4gICAgICBpZiAoZmlsbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmLmZpbGwoZmlsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5maWxsKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuICAgIFNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICBpZiAodHlwZW9mIHNpemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyMihzaXplKTtcbiAgICB9O1xuICAgIFNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlcjIuU2xvd0J1ZmZlcihzaXplKTtcbiAgICB9O1xuICB9KShzYWZlQnVmZmVyLCBzYWZlQnVmZmVyLmV4cG9ydHMpO1xuICByZXR1cm4gc2FmZUJ1ZmZlci5leHBvcnRzO1xufVxudmFyIGhhc1JlcXVpcmVkU3RyaW5nX2RlY29kZXI7XG5mdW5jdGlvbiByZXF1aXJlU3RyaW5nX2RlY29kZXIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFN0cmluZ19kZWNvZGVyKSByZXR1cm4gc3RyaW5nX2RlY29kZXI7XG4gIGhhc1JlcXVpcmVkU3RyaW5nX2RlY29kZXIgPSAxO1xuICB2YXIgQnVmZmVyMiA9IHJlcXVpcmVTYWZlQnVmZmVyKCkuQnVmZmVyO1xuICB2YXIgaXNFbmNvZGluZyA9IEJ1ZmZlcjIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgIGVuY29kaW5nID0gXCJcIiArIGVuY29kaW5nO1xuICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcImhleFwiOlxuICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICAgIGlmICghZW5jKSByZXR1cm4gXCJ1dGY4XCI7XG4gICAgdmFyIHJldHJpZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgIGNhc2UgXCJ1dGYtOFwiOlxuICAgICAgICAgIHJldHVybiBcInV0ZjhcIjtcbiAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgIHJldHVybiBcInV0ZjE2bGVcIjtcbiAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgcmV0dXJuIFwibGF0aW4xXCI7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47XG4gICAgICAgICAgZW5jID0gKFwiXCIgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICAgIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gICAgaWYgKHR5cGVvZiBuZW5jICE9PSBcInN0cmluZ1wiICYmIChCdWZmZXIyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgZW5jKTtcbiAgICByZXR1cm4gbmVuYyB8fCBlbmM7XG4gIH1cbiAgc3RyaW5nX2RlY29kZXIuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG4gIGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgIHZhciBuYjtcbiAgICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgICAgbmIgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICAgIG5iID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgICBuYiA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gICAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlcjIuYWxsb2NVbnNhZmUobmIpO1xuICB9XG4gIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiBcIlwiO1xuICAgIHZhciByO1xuICAgIHZhciBpO1xuICAgIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgICAgaWYgKHIgPT09IHZvaWQgMCkgcmV0dXJuIFwiXCI7XG4gICAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gMDtcbiAgICB9XG4gICAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICAgIHJldHVybiByIHx8IFwiXCI7XG4gIH07XG4gIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG4gIFN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcbiAgU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbihidWYpIHtcbiAgICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICAgIH1cbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbiAgfTtcbiAgZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gICAgaWYgKGJ5dGUgPD0gMTI3KSByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChieXRlID4+IDUgPT09IDYpIHJldHVybiAyO1xuICAgIGVsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMTQpIHJldHVybiAzO1xuICAgIGVsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMzApIHJldHVybiA0O1xuICAgIHJldHVybiBieXRlID4+IDYgPT09IDIgPyAtMSA6IC0yO1xuICB9XG4gIGZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZjIsIGJ1ZiwgaSkge1xuICAgIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gICAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gICAgaWYgKG5iID49IDApIHtcbiAgICAgIGlmIChuYiA+IDApIHNlbGYyLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgICAgcmV0dXJuIG5iO1xuICAgIH1cbiAgICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICAgIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICAgIGlmIChuYiA+PSAwKSB7XG4gICAgICBpZiAobmIgPiAwKSBzZWxmMi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICAgIHJldHVybiBuYjtcbiAgICB9XG4gICAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgICBpZiAobmIgPj0gMCkge1xuICAgICAgaWYgKG5iID4gMCkge1xuICAgICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtcbiAgICAgICAgZWxzZSBzZWxmMi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmMiwgYnVmLCBwKSB7XG4gICAgaWYgKChidWZbMF0gJiAxOTIpICE9PSAxMjgpIHtcbiAgICAgIHNlbGYyLmxhc3ROZWVkID0gMDtcbiAgICAgIHJldHVybiBcIu+/vVwiO1xuICAgIH1cbiAgICBpZiAoc2VsZjIubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoKGJ1ZlsxXSAmIDE5MikgIT09IDEyOCkge1xuICAgICAgICBzZWxmMi5sYXN0TmVlZCA9IDE7XG4gICAgICAgIHJldHVybiBcIu+/vVwiO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYyLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgICBpZiAoKGJ1ZlsyXSAmIDE5MikgIT09IDEyOCkge1xuICAgICAgICAgIHNlbGYyLmxhc3ROZWVkID0gMjtcbiAgICAgICAgICByZXR1cm4gXCLvv71cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gICAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1Zik7XG4gICAgaWYgKHIgIT09IHZvaWQgMCkgcmV0dXJuIHI7XG4gICAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gICAgfVxuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICAgIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gICAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKFwidXRmOFwiLCBpKTtcbiAgICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICAgIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKFwidXRmOFwiLCBpLCBlbmQpO1xuICB9XG4gIGZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gICAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6IFwiXCI7XG4gICAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgXCLvv71cIjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gICAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgICB2YXIgciA9IGJ1Zi50b1N0cmluZyhcInV0ZjE2bGVcIiwgaSk7XG4gICAgICBpZiAocikge1xuICAgICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoYyA+PSA1NTI5NiAmJiBjIDw9IDU2MzE5KSB7XG4gICAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHRoaXMubGFzdE5lZWQgPSAxO1xuICAgIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKFwidXRmMTZsZVwiLCBpLCBidWYubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gICAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6IFwiXCI7XG4gICAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoXCJ1dGYxNmxlXCIsIDAsIGVuZCk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gICAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZyhcImJhc2U2NFwiLCBpKTtcbiAgICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gICAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICAgIGlmIChuID09PSAxKSB7XG4gICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhcImJhc2U2NFwiLCBpLCBidWYubGVuZ3RoIC0gbik7XG4gIH1cbiAgZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICAgIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiBcIlwiO1xuICAgIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoXCJiYXNlNjRcIiwgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICAgIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG4gIH1cbiAgZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICAgIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ19kZWNvZGVyO1xufVxudmFyIGVuZE9mU3RyZWFtO1xudmFyIGhhc1JlcXVpcmVkRW5kT2ZTdHJlYW07XG5mdW5jdGlvbiByZXF1aXJlRW5kT2ZTdHJlYW0oKSB7XG4gIGlmIChoYXNSZXF1aXJlZEVuZE9mU3RyZWFtKSByZXR1cm4gZW5kT2ZTdHJlYW07XG4gIGhhc1JlcXVpcmVkRW5kT2ZTdHJlYW0gPSAxO1xuICB2YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlRXJyb3JzQnJvd3NlcigpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuICBmdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbm9vcDIoKSB7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgfVxuICBmdW5jdGlvbiBlb3Moc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3AyKTtcbiAgICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcbiAgICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaDIoKSB7XG4gICAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgICB9O1xuICAgIHZhciB3cml0YWJsZUVuZGVkID0gc3RyZWFtLl93cml0YWJsZVN0YXRlICYmIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZDtcbiAgICB2YXIgb25maW5pc2ggPSBmdW5jdGlvbiBvbmZpbmlzaDIoKSB7XG4gICAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gICAgfTtcbiAgICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcbiAgICB2YXIgb25lbmQgPSBmdW5jdGlvbiBvbmVuZDIoKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IyKGVycikge1xuICAgICAgY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfTtcbiAgICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UyKCkge1xuICAgICAgdmFyIGVycjtcbiAgICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgICAgfVxuICAgICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0MigpIHtcbiAgICAgIHN0cmVhbS5yZXEub24oXCJmaW5pc2hcIiwgb25maW5pc2gpO1xuICAgIH07XG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgICBzdHJlYW0ub24oXCJjb21wbGV0ZVwiLCBvbmZpbmlzaCk7XG4gICAgICBzdHJlYW0ub24oXCJhYm9ydFwiLCBvbmNsb3NlKTtcbiAgICAgIGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtcbiAgICAgIGVsc2Ugc3RyZWFtLm9uKFwicmVxdWVzdFwiLCBvbnJlcXVlc3QpO1xuICAgIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgc3RyZWFtLm9uKFwiZW5kXCIsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICAgIHN0cmVhbS5vbihcImNsb3NlXCIsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICB9XG4gICAgc3RyZWFtLm9uKFwiZW5kXCIsIG9uZW5kKTtcbiAgICBzdHJlYW0ub24oXCJmaW5pc2hcIiwgb25maW5pc2gpO1xuICAgIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgc3RyZWFtLm9uKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiY29tcGxldGVcIiwgb25maW5pc2gpO1xuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiYWJvcnRcIiwgb25jbG9zZSk7XG4gICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoXCJyZXF1ZXN0XCIsIG9ucmVxdWVzdCk7XG4gICAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLCBvbmZpbmlzaCk7XG4gICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgb25sZWdhY3lmaW5pc2gpO1xuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25sZWdhY3lmaW5pc2gpO1xuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsIG9uZmluaXNoKTtcbiAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbmVuZCk7XG4gICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uY2xvc2UpO1xuICAgIH07XG4gIH1cbiAgZW5kT2ZTdHJlYW0gPSBlb3M7XG4gIHJldHVybiBlbmRPZlN0cmVhbTtcbn1cbnZhciBhc3luY19pdGVyYXRvcjtcbnZhciBoYXNSZXF1aXJlZEFzeW5jX2l0ZXJhdG9yO1xuZnVuY3Rpb24gcmVxdWlyZUFzeW5jX2l0ZXJhdG9yKCkge1xuICBpZiAoaGFzUmVxdWlyZWRBc3luY19pdGVyYXRvcikgcmV0dXJuIGFzeW5jX2l0ZXJhdG9yO1xuICBoYXNSZXF1aXJlZEFzeW5jX2l0ZXJhdG9yID0gMTtcbiAgdmFyIF9PYmplY3Qkc2V0UHJvdG90eXBlTztcbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgdmFyIGZpbmlzaGVkID0gcmVxdWlyZUVuZE9mU3RyZWFtKCk7XG4gIHZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woXCJsYXN0UmVzb2x2ZVwiKTtcbiAgdmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKFwibGFzdFJlamVjdFwiKTtcbiAgdmFyIGtFcnJvciA9IFN5bWJvbChcImVycm9yXCIpO1xuICB2YXIga0VuZGVkID0gU3ltYm9sKFwiZW5kZWRcIik7XG4gIHZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woXCJsYXN0UHJvbWlzZVwiKTtcbiAgdmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKFwiaGFuZGxlUHJvbWlzZVwiKTtcbiAgdmFyIGtTdHJlYW0gPSBTeW1ib2woXCJzdHJlYW1cIik7XG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gICAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7XG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgICBwcm9jZXNzJDEubmV4dFRpY2socmVhZEFuZFJlc29sdmUsIGl0ZXIpO1xuICB9XG4gIGZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGl0ZXJba0VuZGVkXSkge1xuICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfTtcbiAgfVxuICB2YXIgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmdW5jdGlvbigpIHtcbiAgfSk7XG4gIHZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgICBnZXQgc3RyZWFtKCkge1xuICAgICAgcmV0dXJuIHRoaXNba1N0cmVhbV07XG4gICAgfSxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNba0VuZGVkXSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodm9pZCAwLCB0cnVlKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICAgIH1cbiAgICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgX3RoaXMyW2tTdHJlYW1dLmRlc3Ryb3kobnVsbCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHZvaWQgMCwgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjIoc3RyZWFtKSB7XG4gICAgdmFyIF9PYmplY3QkY3JlYXRlO1xuICAgIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgICB2YWx1ZTogc3RyZWFtLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgICAgdmFsdWU6IHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09IFwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIikge1xuICAgICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdO1xuICAgICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcmVzb2x2ZSA9IGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV07XG4gICAgICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh2b2lkIDAsIHRydWUpKTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIHN0cmVhbS5vbihcInJlYWRhYmxlXCIsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbiAgfTtcbiAgYXN5bmNfaXRlcmF0b3IgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG4gIHJldHVybiBhc3luY19pdGVyYXRvcjtcbn1cbnZhciBmcm9tQnJvd3NlcjtcbnZhciBoYXNSZXF1aXJlZEZyb21Ccm93c2VyO1xuZnVuY3Rpb24gcmVxdWlyZUZyb21Ccm93c2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRGcm9tQnJvd3NlcikgcmV0dXJuIGZyb21Ccm93c2VyO1xuICBoYXNSZXF1aXJlZEZyb21Ccm93c2VyID0gMTtcbiAgZnJvbUJyb3dzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXJcIik7XG4gIH07XG4gIHJldHVybiBmcm9tQnJvd3Nlcjtcbn1cbnZhciBfc3RyZWFtX3JlYWRhYmxlO1xudmFyIGhhc1JlcXVpcmVkX3N0cmVhbV9yZWFkYWJsZTtcbmZ1bmN0aW9uIHJlcXVpcmVfc3RyZWFtX3JlYWRhYmxlKCkge1xuICBpZiAoaGFzUmVxdWlyZWRfc3RyZWFtX3JlYWRhYmxlKSByZXR1cm4gX3N0cmVhbV9yZWFkYWJsZTtcbiAgaGFzUmVxdWlyZWRfc3RyZWFtX3JlYWRhYmxlID0gMTtcbiAgX3N0cmVhbV9yZWFkYWJsZSA9IFJlYWRhYmxlO1xuICB2YXIgRHVwbGV4O1xuICBSZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbiAgcmVxdWlyZUV2ZW50cygpLkV2ZW50RW1pdHRlcjtcbiAgdmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudDIoZW1pdHRlciwgdHlwZTIpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZTIpLmxlbmd0aDtcbiAgfTtcbiAgdmFyIFN0cmVhbSA9IHJlcXVpcmVTdHJlYW1Ccm93c2VyKCk7XG4gIHZhciBCdWZmZXIyID0gcmVxdWlyZUJ1ZmZlcigpLkJ1ZmZlcjtcbiAgdmFyIE91clVpbnQ4QXJyYXkgPSBjb21tb25qc0dsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uKCkge1xuICB9O1xuICBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gICAgcmV0dXJuIEJ1ZmZlcjIuZnJvbShjaHVuayk7XG4gIH1cbiAgZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgICByZXR1cm4gQnVmZmVyMi5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG4gIH1cbiAgdmFyIGRlYnVnVXRpbCA9IHJlcXVpcmVVdGlsKCk7XG4gIHZhciBkZWJ1ZztcbiAgaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZyhcInN0cmVhbVwiKTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnMigpIHtcbiAgICB9O1xuICB9XG4gIHZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZUJ1ZmZlcl9saXN0KCk7XG4gIHZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmVEZXN0cm95KCk7XG4gIHZhciBfcmVxdWlyZSA9IHJlcXVpcmVTdGF0ZSgpLCBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcbiAgdmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZUVycm9yc0Jyb3dzZXIoKS5jb2RlcywgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UO1xuICB2YXIgU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbiAgdmFyIGZyb207XG4gIHJlcXVpcmVJbmhlcml0c19icm93c2VyKCkoUmVhZGFibGUsIFN0cmVhbSk7XG4gIHZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuICB2YXIga1Byb3h5RXZlbnRzID0gW1wiZXJyb3JcIiwgXCJjbG9zZVwiLCBcImRlc3Ryb3lcIiwgXCJwYXVzZVwiLCBcInJlc3VtZVwiXTtcbiAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAgIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO1xuICAgIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbiAgZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gICAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgaXNEdXBsZXggIT09IFwiYm9vbGVhblwiKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcbiAgICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuICAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIiwgaXNEdXBsZXgpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5waXBlcyA9IG51bGw7XG4gICAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN5bmMgPSB0cnVlO1xuICAgIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7XG4gICAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgXCJ1dGY4XCI7XG4gICAgdGhpcy5hd2FpdERyYWluID0gMDtcbiAgICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gICAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZVN0cmluZ19kZWNvZGVyKCkuU3RyaW5nRGVjb2RlcjtcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZV9zdHJlYW1fZHVwbGV4KCk7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcbiAgICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gXCJmdW5jdGlvblwiKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIH1cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldDIoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBSZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuICBSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIsIGNiKSB7XG4gICAgY2IoZXJyKTtcbiAgfTtcbiAgUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgc2tpcENodW5rQ2hlY2s7XG4gICAgaWYgKCFzdGF0ZTIub2JqZWN0TW9kZSkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlMi5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUyLmVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgICBlbmNvZGluZyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbiAgfTtcbiAgUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICAgIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG4gIH07XG4gIGZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gICAgZGVidWcoXCJyZWFkYWJsZUFkZENodW5rXCIsIGNodW5rKTtcbiAgICB2YXIgc3RhdGUyID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgc3RhdGUyLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZTIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXI7XG4gICAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZTIsIGNodW5rKTtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUyLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSBcInN0cmluZ1wiICYmICFzdGF0ZTIub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIyLnByb3RvdHlwZSkge1xuICAgICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgICBpZiAoc3RhdGUyLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7XG4gICAgICAgICAgZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlMiwgY2h1bmssIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlMi5lbmRlZCkge1xuICAgICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZTIucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChzdGF0ZTIuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNodW5rID0gc3RhdGUyLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgaWYgKHN0YXRlMi5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZTIsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZTIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlMiwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUyLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhc3RhdGUyLmVuZGVkICYmIChzdGF0ZTIubGVuZ3RoIDwgc3RhdGUyLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUyLmxlbmd0aCA9PT0gMCk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZTIsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gICAgaWYgKHN0YXRlMi5mbG93aW5nICYmIHN0YXRlMi5sZW5ndGggPT09IDAgJiYgIXN0YXRlMi5zeW5jKSB7XG4gICAgICBzdGF0ZTIuYXdhaXREcmFpbiA9IDA7XG4gICAgICBzdHJlYW0uZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZTIubGVuZ3RoICs9IHN0YXRlMi5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZTIuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgZWxzZSBzdGF0ZTIuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgaWYgKHN0YXRlMi5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgIH1cbiAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUyKTtcbiAgfVxuICBmdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUyLCBjaHVuaykge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gXCJzdHJpbmdcIiAmJiBjaHVuayAhPT0gdm9pZCAwICYmICFzdGF0ZTIub2JqZWN0TW9kZSkge1xuICAgICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXCJjaHVua1wiLCBbXCJzdHJpbmdcIiwgXCJCdWZmZXJcIiwgXCJVaW50OEFycmF5XCJdLCBjaHVuayk7XG4gICAgfVxuICAgIHJldHVybiBlcjtcbiAgfVxuICBSZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbiAgfTtcbiAgUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZVN0cmluZ19kZWNvZGVyKCkuU3RyaW5nRGVjb2RlcjtcbiAgICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nO1xuICAgIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgICBpZiAoY29udGVudCAhPT0gXCJcIikgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICB2YXIgTUFYX0hXTSA9IDEwNzM3NDE4MjQ7XG4gIGZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgICBuID0gTUFYX0hXTTtcbiAgICB9IGVsc2Uge1xuICAgICAgbi0tO1xuICAgICAgbiB8PSBuID4+PiAxO1xuICAgICAgbiB8PSBuID4+PiAyO1xuICAgICAgbiB8PSBuID4+PiA0O1xuICAgICAgbiB8PSBuID4+PiA4O1xuICAgICAgbiB8PSBuID4+PiAxNjtcbiAgICAgIG4rKztcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZTIpIHtcbiAgICBpZiAobiA8PSAwIHx8IHN0YXRlMi5sZW5ndGggPT09IDAgJiYgc3RhdGUyLmVuZGVkKSByZXR1cm4gMDtcbiAgICBpZiAoc3RhdGUyLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICAgIGlmIChuICE9PSBuKSB7XG4gICAgICBpZiAoc3RhdGUyLmZsb3dpbmcgJiYgc3RhdGUyLmxlbmd0aCkgcmV0dXJuIHN0YXRlMi5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtcbiAgICAgIGVsc2UgcmV0dXJuIHN0YXRlMi5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChuID4gc3RhdGUyLmhpZ2hXYXRlck1hcmspIHN0YXRlMi5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gICAgaWYgKG4gPD0gc3RhdGUyLmxlbmd0aCkgcmV0dXJuIG47XG4gICAgaWYgKCFzdGF0ZTIuZW5kZWQpIHtcbiAgICAgIHN0YXRlMi5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTIubGVuZ3RoO1xuICB9XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKFwicmVhZFwiLCBuKTtcbiAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgIHZhciBzdGF0ZTIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIHZhciBuT3JpZyA9IG47XG4gICAgaWYgKG4gIT09IDApIHN0YXRlMi5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAobiA9PT0gMCAmJiBzdGF0ZTIubmVlZFJlYWRhYmxlICYmICgoc3RhdGUyLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZTIubGVuZ3RoID49IHN0YXRlMi5oaWdoV2F0ZXJNYXJrIDogc3RhdGUyLmxlbmd0aCA+IDApIHx8IHN0YXRlMi5lbmRlZCkpIHtcbiAgICAgIGRlYnVnKFwicmVhZDogZW1pdFJlYWRhYmxlXCIsIHN0YXRlMi5sZW5ndGgsIHN0YXRlMi5lbmRlZCk7XG4gICAgICBpZiAoc3RhdGUyLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZTIuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgICAgZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUyKTtcbiAgICBpZiAobiA9PT0gMCAmJiBzdGF0ZTIuZW5kZWQpIHtcbiAgICAgIGlmIChzdGF0ZTIubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZG9SZWFkID0gc3RhdGUyLm5lZWRSZWFkYWJsZTtcbiAgICBkZWJ1ZyhcIm5lZWQgcmVhZGFibGVcIiwgZG9SZWFkKTtcbiAgICBpZiAoc3RhdGUyLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZTIubGVuZ3RoIC0gbiA8IHN0YXRlMi5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgICBkb1JlYWQgPSB0cnVlO1xuICAgICAgZGVidWcoXCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFya1wiLCBkb1JlYWQpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUyLmVuZGVkIHx8IHN0YXRlMi5yZWFkaW5nKSB7XG4gICAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICAgIGRlYnVnKFwicmVhZGluZyBvciBlbmRlZFwiLCBkb1JlYWQpO1xuICAgIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgICBkZWJ1ZyhcImRvIHJlYWRcIik7XG4gICAgICBzdGF0ZTIucmVhZGluZyA9IHRydWU7XG4gICAgICBzdGF0ZTIuc3luYyA9IHRydWU7XG4gICAgICBpZiAoc3RhdGUyLmxlbmd0aCA9PT0gMCkgc3RhdGUyLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkKHN0YXRlMi5oaWdoV2F0ZXJNYXJrKTtcbiAgICAgIHN0YXRlMi5zeW5jID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlMi5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUyKTtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlMik7XG4gICAgZWxzZSByZXQgPSBudWxsO1xuICAgIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlMi5uZWVkUmVhZGFibGUgPSBzdGF0ZTIubGVuZ3RoIDw9IHN0YXRlMi5oaWdoV2F0ZXJNYXJrO1xuICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlMi5sZW5ndGggLT0gbjtcbiAgICAgIHN0YXRlMi5hd2FpdERyYWluID0gMDtcbiAgICB9XG4gICAgaWYgKHN0YXRlMi5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICghc3RhdGUyLmVuZGVkKSBzdGF0ZTIubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZTIuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoXCJkYXRhXCIsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlMikge1xuICAgIGRlYnVnKFwib25Fb2ZDaHVua1wiKTtcbiAgICBpZiAoc3RhdGUyLmVuZGVkKSByZXR1cm47XG4gICAgaWYgKHN0YXRlMi5kZWNvZGVyKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZTIuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUyLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgICAgc3RhdGUyLmxlbmd0aCArPSBzdGF0ZTIub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlMi5lbmRlZCA9IHRydWU7XG4gICAgaWYgKHN0YXRlMi5zeW5jKSB7XG4gICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUyLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZTIuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICAgIHN0YXRlMi5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgICB2YXIgc3RhdGUyID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKFwiZW1pdFJlYWRhYmxlXCIsIHN0YXRlMi5uZWVkUmVhZGFibGUsIHN0YXRlMi5lbWl0dGVkUmVhZGFibGUpO1xuICAgIHN0YXRlMi5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlMi5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIGRlYnVnKFwiZW1pdFJlYWRhYmxlXCIsIHN0YXRlMi5mbG93aW5nKTtcbiAgICAgIHN0YXRlMi5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlMiA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZyhcImVtaXRSZWFkYWJsZV9cIiwgc3RhdGUyLmRlc3Ryb3llZCwgc3RhdGUyLmxlbmd0aCwgc3RhdGUyLmVuZGVkKTtcbiAgICBpZiAoIXN0YXRlMi5kZXN0cm95ZWQgJiYgKHN0YXRlMi5sZW5ndGggfHwgc3RhdGUyLmVuZGVkKSkge1xuICAgICAgc3RyZWFtLmVtaXQoXCJyZWFkYWJsZVwiKTtcbiAgICAgIHN0YXRlMi5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGUyLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZTIuZmxvd2luZyAmJiAhc3RhdGUyLmVuZGVkICYmIHN0YXRlMi5sZW5ndGggPD0gc3RhdGUyLmhpZ2hXYXRlck1hcms7XG4gICAgZmxvdyhzdHJlYW0pO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZTIpIHtcbiAgICBpZiAoIXN0YXRlMi5yZWFkaW5nTW9yZSkge1xuICAgICAgc3RhdGUyLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlMikge1xuICAgIHdoaWxlICghc3RhdGUyLnJlYWRpbmcgJiYgIXN0YXRlMi5lbmRlZCAmJiAoc3RhdGUyLmxlbmd0aCA8IHN0YXRlMi5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlMi5mbG93aW5nICYmIHN0YXRlMi5sZW5ndGggPT09IDApKSB7XG4gICAgICB2YXIgbGVuID0gc3RhdGUyLmxlbmd0aDtcbiAgICAgIGRlYnVnKFwibWF5YmVSZWFkTW9yZSByZWFkIDBcIik7XG4gICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIGlmIChsZW4gPT09IHN0YXRlMi5sZW5ndGgpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzdGF0ZTIucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgfVxuICBSZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKFwiX3JlYWQoKVwiKSk7XG4gIH07XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgICB2YXIgc3JjID0gdGhpcztcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBzd2l0Y2ggKHN0YXRlMi5waXBlc0NvdW50KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHN0YXRlMi5waXBlcyA9IGRlc3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBzdGF0ZTIucGlwZXMgPSBbc3RhdGUyLnBpcGVzLCBkZXN0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdGF0ZTIucGlwZXMucHVzaChkZXN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0YXRlMi5waXBlc0NvdW50ICs9IDE7XG4gICAgZGVidWcoXCJwaXBlIGNvdW50PSVkIG9wdHM9JWpcIiwgc3RhdGUyLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3MkMS5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2VzcyQxLnN0ZGVycjtcbiAgICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICAgIGlmIChzdGF0ZTIuZW5kRW1pdHRlZCkgcHJvY2VzcyQxLm5leHRUaWNrKGVuZEZuKTtcbiAgICBlbHNlIHNyYy5vbmNlKFwiZW5kXCIsIGVuZEZuKTtcbiAgICBkZXN0Lm9uKFwidW5waXBlXCIsIG9udW5waXBlKTtcbiAgICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgICAgZGVidWcoXCJvbnVucGlwZVwiKTtcbiAgICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICAgIGRlYnVnKFwib25lbmRcIik7XG4gICAgICBkZXN0LmVuZCgpO1xuICAgIH1cbiAgICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gICAgZGVzdC5vbihcImRyYWluXCIsIG9uZHJhaW4pO1xuICAgIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgZGVidWcoXCJjbGVhbnVwXCIpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uY2xvc2UpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLCBvbmZpbmlzaCk7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIiwgb25kcmFpbik7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwidW5waXBlXCIsIG9udW5waXBlKTtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbmVuZCk7XG4gICAgICBzcmMucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgdW5waXBlKTtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25kYXRhKTtcbiAgICAgIGNsZWFuZWRVcCA9IHRydWU7XG4gICAgICBpZiAoc3RhdGUyLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICAgIH1cbiAgICBzcmMub24oXCJkYXRhXCIsIG9uZGF0YSk7XG4gICAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgICBkZWJ1ZyhcIm9uZGF0YVwiKTtcbiAgICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICAgIGRlYnVnKFwiZGVzdC53cml0ZVwiLCByZXQpO1xuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKChzdGF0ZTIucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZTIucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUyLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUyLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgICBkZWJ1ZyhcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLCBzdGF0ZTIuYXdhaXREcmFpbik7XG4gICAgICAgICAgc3RhdGUyLmF3YWl0RHJhaW4rKztcbiAgICAgICAgfVxuICAgICAgICBzcmMucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgICAgZGVidWcoXCJvbmVycm9yXCIsIGVyKTtcbiAgICAgIHVucGlwZSgpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCBcImVycm9yXCIpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gICAgfVxuICAgIHByZXBlbmRMaXN0ZW5lcihkZXN0LCBcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsIG9uZmluaXNoKTtcbiAgICAgIHVucGlwZSgpO1xuICAgIH1cbiAgICBkZXN0Lm9uY2UoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICAgIGRlYnVnKFwib25maW5pc2hcIik7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25jbG9zZSk7XG4gICAgICB1bnBpcGUoKTtcbiAgICB9XG4gICAgZGVzdC5vbmNlKFwiZmluaXNoXCIsIG9uZmluaXNoKTtcbiAgICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgICBkZWJ1ZyhcInVucGlwZVwiKTtcbiAgICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gICAgfVxuICAgIGRlc3QuZW1pdChcInBpcGVcIiwgc3JjKTtcbiAgICBpZiAoIXN0YXRlMi5mbG93aW5nKSB7XG4gICAgICBkZWJ1ZyhcInBpcGUgcmVzdW1lXCIpO1xuICAgICAgc3JjLnJlc3VtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfTtcbiAgZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgICB2YXIgc3RhdGUyID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgICAgZGVidWcoXCJwaXBlT25EcmFpblwiLCBzdGF0ZTIuYXdhaXREcmFpbik7XG4gICAgICBpZiAoc3RhdGUyLmF3YWl0RHJhaW4pIHN0YXRlMi5hd2FpdERyYWluLS07XG4gICAgICBpZiAoc3RhdGUyLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgXCJkYXRhXCIpKSB7XG4gICAgICAgIHN0YXRlMi5mbG93aW5nID0gdHJ1ZTtcbiAgICAgICAgZmxvdyhzcmMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoc3RhdGUyLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChzdGF0ZTIucGlwZXNDb3VudCA9PT0gMSkge1xuICAgICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUyLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlMi5waXBlcztcbiAgICAgIHN0YXRlMi5waXBlcyA9IG51bGw7XG4gICAgICBzdGF0ZTIucGlwZXNDb3VudCA9IDA7XG4gICAgICBzdGF0ZTIuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgaWYgKGRlc3QpIGRlc3QuZW1pdChcInVucGlwZVwiLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIHZhciBkZXN0cyA9IHN0YXRlMi5waXBlcztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZTIucGlwZXNDb3VudDtcbiAgICAgIHN0YXRlMi5waXBlcyA9IG51bGw7XG4gICAgICBzdGF0ZTIucGlwZXNDb3VudCA9IDA7XG4gICAgICBzdGF0ZTIuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkZXN0c1tpXS5lbWl0KFwidW5waXBlXCIsIHRoaXMsIHtcbiAgICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlMi5waXBlcywgZGVzdCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gICAgc3RhdGUyLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgc3RhdGUyLnBpcGVzQ291bnQgLT0gMTtcbiAgICBpZiAoc3RhdGUyLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlMi5waXBlcyA9IHN0YXRlMi5waXBlc1swXTtcbiAgICBkZXN0LmVtaXQoXCJ1bnBpcGVcIiwgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICAgIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoZXYgPT09IFwiZGF0YVwiKSB7XG4gICAgICBzdGF0ZTIucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoXCJyZWFkYWJsZVwiKSA+IDA7XG4gICAgICBpZiAoc3RhdGUyLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICAgIH0gZWxzZSBpZiAoZXYgPT09IFwicmVhZGFibGVcIikge1xuICAgICAgaWYgKCFzdGF0ZTIuZW5kRW1pdHRlZCAmJiAhc3RhdGUyLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICAgIHN0YXRlMi5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlMi5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgICBzdGF0ZTIuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZTIuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIGRlYnVnKFwib24gcmVhZGFibGVcIiwgc3RhdGUyLmxlbmd0aCwgc3RhdGUyLnJlYWRpbmcpO1xuICAgICAgICBpZiAoc3RhdGUyLmxlbmd0aCkge1xuICAgICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGUyLnJlYWRpbmcpIHtcbiAgICAgICAgICBwcm9jZXNzJDEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuICBSZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG4gICAgaWYgKGV2ID09PSBcInJlYWRhYmxlXCIpIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldikge1xuICAgIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChldiA9PT0gXCJyZWFkYWJsZVwiIHx8IGV2ID09PSB2b2lkIDApIHtcbiAgICAgIHByb2Nlc3MkMS5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIGZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYyKSB7XG4gICAgdmFyIHN0YXRlMiA9IHNlbGYyLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlMi5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYyLmxpc3RlbmVyQ291bnQoXCJyZWFkYWJsZVwiKSA+IDA7XG4gICAgaWYgKHN0YXRlMi5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlMi5wYXVzZWQpIHtcbiAgICAgIHN0YXRlMi5mbG93aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNlbGYyLmxpc3RlbmVyQ291bnQoXCJkYXRhXCIpID4gMCkge1xuICAgICAgc2VsZjIucmVzdW1lKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZjIpIHtcbiAgICBkZWJ1ZyhcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKTtcbiAgICBzZWxmMi5yZWFkKDApO1xuICB9XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlMi5mbG93aW5nKSB7XG4gICAgICBkZWJ1ZyhcInJlc3VtZVwiKTtcbiAgICAgIHN0YXRlMi5mbG93aW5nID0gIXN0YXRlMi5yZWFkYWJsZUxpc3RlbmluZztcbiAgICAgIHJlc3VtZSh0aGlzLCBzdGF0ZTIpO1xuICAgIH1cbiAgICBzdGF0ZTIucGF1c2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlMikge1xuICAgIGlmICghc3RhdGUyLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgICAgc3RhdGUyLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUyKSB7XG4gICAgZGVidWcoXCJyZXN1bWVcIiwgc3RhdGUyLnJlYWRpbmcpO1xuICAgIGlmICghc3RhdGUyLnJlYWRpbmcpIHtcbiAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIH1cbiAgICBzdGF0ZTIucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoXCJyZXN1bWVcIik7XG4gICAgZmxvdyhzdHJlYW0pO1xuICAgIGlmIChzdGF0ZTIuZmxvd2luZyAmJiAhc3RhdGUyLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xuICB9XG4gIFJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKFwiY2FsbCBwYXVzZSBmbG93aW5nPSVqXCIsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICAgIGRlYnVnKFwicGF1c2VcIik7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1pdChcInBhdXNlXCIpO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlMiA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZyhcImZsb3dcIiwgc3RhdGUyLmZsb3dpbmcpO1xuICAgIHdoaWxlIChzdGF0ZTIuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgfVxuICB9XG4gIFJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgc3RhdGUyID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gICAgc3RyZWFtLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoXCJ3cmFwcGVkIGVuZFwiKTtcbiAgICAgIGlmIChzdGF0ZTIuZGVjb2RlciAmJiAhc3RhdGUyLmVuZGVkKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHN0YXRlMi5kZWNvZGVyLmVuZCgpO1xuICAgICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLnB1c2gobnVsbCk7XG4gICAgfSk7XG4gICAgc3RyZWFtLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgZGVidWcoXCJ3cmFwcGVkIGRhdGFcIik7XG4gICAgICBpZiAoc3RhdGUyLmRlY29kZXIpIGNodW5rID0gc3RhdGUyLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgaWYgKHN0YXRlMi5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdm9pZCAwKSkgcmV0dXJuO1xuICAgICAgZWxzZSBpZiAoIXN0YXRlMi5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcbiAgICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gdm9pZCAwICYmIHR5cGVvZiBzdHJlYW1baV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzW2ldID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfShpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkID0gZnVuY3Rpb24objIpIHtcbiAgICAgIGRlYnVnKFwid3JhcHBlZCBfcmVhZFwiLCBuMik7XG4gICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHZvaWQgMCkge1xuICAgICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlQXN5bmNfaXRlcmF0b3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCBcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLCB7XG4gICAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldDIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsIFwicmVhZGFibGVCdWZmZXJcIiwge1xuICAgIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gICAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgXCJyZWFkYWJsZUZsb3dpbmdcIiwge1xuICAgIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gICAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlMikge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGUyO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCBcInJlYWRhYmxlTGVuZ3RoXCIsIHtcbiAgICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAgIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0MigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZTIpIHtcbiAgICBpZiAoc3RhdGUyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoc3RhdGUyLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlMi5idWZmZXIuc2hpZnQoKTtcbiAgICBlbHNlIGlmICghbiB8fCBuID49IHN0YXRlMi5sZW5ndGgpIHtcbiAgICAgIGlmIChzdGF0ZTIuZGVjb2RlcikgcmV0ID0gc3RhdGUyLmJ1ZmZlci5qb2luKFwiXCIpO1xuICAgICAgZWxzZSBpZiAoc3RhdGUyLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlMi5idWZmZXIuZmlyc3QoKTtcbiAgICAgIGVsc2UgcmV0ID0gc3RhdGUyLmJ1ZmZlci5jb25jYXQoc3RhdGUyLmxlbmd0aCk7XG4gICAgICBzdGF0ZTIuYnVmZmVyLmNsZWFyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IHN0YXRlMi5idWZmZXIuY29uc3VtZShuLCBzdGF0ZTIuZGVjb2Rlcik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gICAgdmFyIHN0YXRlMiA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZyhcImVuZFJlYWRhYmxlXCIsIHN0YXRlMi5lbmRFbWl0dGVkKTtcbiAgICBpZiAoIXN0YXRlMi5lbmRFbWl0dGVkKSB7XG4gICAgICBzdGF0ZTIuZW5kZWQgPSB0cnVlO1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlMiwgc3RyZWFtKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZTIsIHN0cmVhbSkge1xuICAgIGRlYnVnKFwiZW5kUmVhZGFibGVOVFwiLCBzdGF0ZTIuZW5kRW1pdHRlZCwgc3RhdGUyLmxlbmd0aCk7XG4gICAgaWYgKCFzdGF0ZTIuZW5kRW1pdHRlZCAmJiBzdGF0ZTIubGVuZ3RoID09PSAwKSB7XG4gICAgICBzdGF0ZTIuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5lbWl0KFwiZW5kXCIpO1xuICAgICAgaWYgKHN0YXRlMi5hdXRvRGVzdHJveSkge1xuICAgICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICAgICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZyb20gPSByZXF1aXJlRnJvbUJyb3dzZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gX3N0cmVhbV9yZWFkYWJsZTtcbn1cbnZhciBfc3RyZWFtX3RyYW5zZm9ybTtcbnZhciBoYXNSZXF1aXJlZF9zdHJlYW1fdHJhbnNmb3JtO1xuZnVuY3Rpb24gcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtKCkge1xuICBpZiAoaGFzUmVxdWlyZWRfc3RyZWFtX3RyYW5zZm9ybSkgcmV0dXJuIF9zdHJlYW1fdHJhbnNmb3JtO1xuICBoYXNSZXF1aXJlZF9zdHJlYW1fdHJhbnNmb3JtID0gMTtcbiAgX3N0cmVhbV90cmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG4gIHZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmVFcnJvcnNCcm93c2VyKCkuY29kZXMsIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSywgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpO1xuICByZXF1aXJlSW5oZXJpdHNfYnJvd3NlcigpKFRyYW5zZm9ybSwgRHVwbGV4KTtcbiAgZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gICAgfVxuICAgIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICAgIHRzLndyaXRlY2IgPSBudWxsO1xuICAgIGlmIChkYXRhICE9IG51bGwpXG4gICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgY2IoZXIpO1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgcnMucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gICAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICAgIHdyaXRlY2I6IG51bGwsXG4gICAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICAgIH07XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgICB9XG4gICAgdGhpcy5vbihcInByZWZpbmlzaFwiLCBwcmVmaW5pc2gpO1xuICB9XG4gIGZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09IFwiZnVuY3Rpb25cIiAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgfVxuICBUcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG4gIH07XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoXCJfdHJhbnNmb3JtKClcIikpO1xuICB9O1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgICB0cy53cml0ZWNiID0gY2I7XG4gICAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICAgIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICAgIH1cbiAgfTtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gICAgfVxuICB9O1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24oZXJyLCBjYikge1xuICAgIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uKGVycjIpIHtcbiAgICAgIGNiKGVycjIpO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdChcImVycm9yXCIsIGVyKTtcbiAgICBpZiAoZGF0YSAhPSBudWxsKVxuICAgICAgc3RyZWFtLnB1c2goZGF0YSk7XG4gICAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gICAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xuICB9XG4gIHJldHVybiBfc3RyZWFtX3RyYW5zZm9ybTtcbn1cbnZhciBfc3RyZWFtX3Bhc3N0aHJvdWdoO1xudmFyIGhhc1JlcXVpcmVkX3N0cmVhbV9wYXNzdGhyb3VnaDtcbmZ1bmN0aW9uIHJlcXVpcmVfc3RyZWFtX3Bhc3N0aHJvdWdoKCkge1xuICBpZiAoaGFzUmVxdWlyZWRfc3RyZWFtX3Bhc3N0aHJvdWdoKSByZXR1cm4gX3N0cmVhbV9wYXNzdGhyb3VnaDtcbiAgaGFzUmVxdWlyZWRfc3RyZWFtX3Bhc3N0aHJvdWdoID0gMTtcbiAgX3N0cmVhbV9wYXNzdGhyb3VnaCA9IFBhc3NUaHJvdWdoO1xuICB2YXIgVHJhbnNmb3JtID0gcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtKCk7XG4gIHJlcXVpcmVJbmhlcml0c19icm93c2VyKCkoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG4gIGZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIFBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGNiKG51bGwsIGNodW5rKTtcbiAgfTtcbiAgcmV0dXJuIF9zdHJlYW1fcGFzc3Rocm91Z2g7XG59XG52YXIgcGlwZWxpbmVfMTtcbnZhciBoYXNSZXF1aXJlZFBpcGVsaW5lO1xuZnVuY3Rpb24gcmVxdWlyZVBpcGVsaW5lKCkge1xuICBpZiAoaGFzUmVxdWlyZWRQaXBlbGluZSkgcmV0dXJuIHBpcGVsaW5lXzE7XG4gIGhhc1JlcXVpcmVkUGlwZWxpbmUgPSAxO1xuICB2YXIgZW9zO1xuICBmdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICB2YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlRXJyb3JzQnJvd3NlcigpLmNvZGVzLCBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUywgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcbiAgZnVuY3Rpb24gbm9vcDIoZXJyKSB7XG4gICAgaWYgKGVycikgdGhyb3cgZXJyO1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSBcImZ1bmN0aW9uXCI7XG4gIH1cbiAgZnVuY3Rpb24gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICAgIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgICBzdHJlYW0ub24oXCJjbG9zZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgaWYgKGVvcyA9PT0gdm9pZCAwKSBlb3MgPSByZXF1aXJlRW5kT2ZTdHJlYW0oKTtcbiAgICBlb3Moc3RyZWFtLCB7XG4gICAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRChcInBpcGVcIikpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY2FsbChmbikge1xuICAgIGZuKCk7XG4gIH1cbiAgZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICAgIHJldHVybiBmcm9tLnBpcGUodG8pO1xuICB9XG4gIGZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDI7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG5vb3AyO1xuICAgIHJldHVybiBzdHJlYW1zLnBvcCgpO1xuICB9XG4gIGZ1bmN0aW9uIHBpcGVsaW5lKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrID0gcG9wQ2FsbGJhY2soc3RyZWFtcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKFwic3RyZWFtc1wiKTtcbiAgICB9XG4gICAgdmFyIGVycm9yO1xuICAgIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uKHN0cmVhbSwgaSkge1xuICAgICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW1zLnJlZHVjZShwaXBlKTtcbiAgfVxuICBwaXBlbGluZV8xID0gcGlwZWxpbmU7XG4gIHJldHVybiBwaXBlbGluZV8xO1xufVxudmFyIHN0cmVhbUJyb3dzZXJpZnk7XG52YXIgaGFzUmVxdWlyZWRTdHJlYW1Ccm93c2VyaWZ5O1xuZnVuY3Rpb24gcmVxdWlyZVN0cmVhbUJyb3dzZXJpZnkoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFN0cmVhbUJyb3dzZXJpZnkpIHJldHVybiBzdHJlYW1Ccm93c2VyaWZ5O1xuICBoYXNSZXF1aXJlZFN0cmVhbUJyb3dzZXJpZnkgPSAxO1xuICBzdHJlYW1Ccm93c2VyaWZ5ID0gU3RyZWFtO1xuICB2YXIgRUUgPSByZXF1aXJlRXZlbnRzKCkuRXZlbnRFbWl0dGVyO1xuICB2YXIgaW5oZXJpdHMgPSByZXF1aXJlSW5oZXJpdHNfYnJvd3NlcigpO1xuICBpbmhlcml0cyhTdHJlYW0sIEVFKTtcbiAgU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZV9zdHJlYW1fcmVhZGFibGUoKTtcbiAgU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZV9zdHJlYW1fd3JpdGFibGUoKTtcbiAgU3RyZWFtLkR1cGxleCA9IHJlcXVpcmVfc3RyZWFtX2R1cGxleCgpO1xuICBTdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZV9zdHJlYW1fdHJhbnNmb3JtKCk7XG4gIFN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmVfc3RyZWFtX3Bhc3N0aHJvdWdoKCk7XG4gIFN0cmVhbS5maW5pc2hlZCA9IHJlcXVpcmVFbmRPZlN0cmVhbSgpO1xuICBTdHJlYW0ucGlwZWxpbmUgPSByZXF1aXJlUGlwZWxpbmUoKTtcbiAgU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcbiAgZnVuY3Rpb24gU3RyZWFtKCkge1xuICAgIEVFLmNhbGwodGhpcyk7XG4gIH1cbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICAgIHZhciBzb3VyY2UgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2Uub24oXCJkYXRhXCIsIG9uZGF0YSk7XG4gICAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Qub24oXCJkcmFpblwiLCBvbmRyYWluKTtcbiAgICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICAgIHNvdXJjZS5vbihcImVuZFwiLCBvbmVuZCk7XG4gICAgICBzb3VyY2Uub24oXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICB9XG4gICAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICAgIGRpZE9uRW5kID0gdHJ1ZTtcbiAgICAgIGRlc3QuZW5kKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICAgIGRpZE9uRW5kID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCIpIGRlc3QuZGVzdHJveSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCBcImVycm9yXCIpID09PSAwKSB7XG4gICAgICAgIHRocm93IGVyO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2Uub24oXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICBkZXN0Lm9uKFwiZXJyb3JcIiwgb25lcnJvcik7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25kYXRhKTtcbiAgICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoXCJkcmFpblwiLCBvbmRyYWluKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbmVuZCk7XG4gICAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIGNsZWFudXApO1xuICAgICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xlYW51cCk7XG4gICAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xlYW51cCk7XG4gICAgfVxuICAgIHNvdXJjZS5vbihcImVuZFwiLCBjbGVhbnVwKTtcbiAgICBzb3VyY2Uub24oXCJjbG9zZVwiLCBjbGVhbnVwKTtcbiAgICBkZXN0Lm9uKFwiY2xvc2VcIiwgY2xlYW51cCk7XG4gICAgZGVzdC5lbWl0KFwicGlwZVwiLCBzb3VyY2UpO1xuICAgIHJldHVybiBkZXN0O1xuICB9O1xuICByZXR1cm4gc3RyZWFtQnJvd3NlcmlmeTtcbn1cbnZhciBoYXNSZXF1aXJlZFNheDtcbmZ1bmN0aW9uIHJlcXVpcmVTYXgoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFNheCkgcmV0dXJuIHNheDtcbiAgaGFzUmVxdWlyZWRTYXggPSAxO1xuICAoZnVuY3Rpb24oZXhwb3J0cykge1xuICAgIChmdW5jdGlvbihzYXgyKSB7XG4gICAgICBzYXgyLnBhcnNlciA9IGZ1bmN0aW9uKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KTtcbiAgICAgIH07XG4gICAgICBzYXgyLlNBWFBhcnNlciA9IFNBWFBhcnNlcjtcbiAgICAgIHNheDIuU0FYU3RyZWFtID0gU0FYU3RyZWFtO1xuICAgICAgc2F4Mi5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW07XG4gICAgICBzYXgyLk1BWF9CVUZGRVJfTEVOR1RIID0gNjQgKiAxMDI0O1xuICAgICAgdmFyIGJ1ZmZlcnMgPSBbXG4gICAgICAgIFwiY29tbWVudFwiLFxuICAgICAgICBcInNnbWxEZWNsXCIsXG4gICAgICAgIFwidGV4dE5vZGVcIixcbiAgICAgICAgXCJ0YWdOYW1lXCIsXG4gICAgICAgIFwiZG9jdHlwZVwiLFxuICAgICAgICBcInByb2NJbnN0TmFtZVwiLFxuICAgICAgICBcInByb2NJbnN0Qm9keVwiLFxuICAgICAgICBcImVudGl0eVwiLFxuICAgICAgICBcImF0dHJpYk5hbWVcIixcbiAgICAgICAgXCJhdHRyaWJWYWx1ZVwiLFxuICAgICAgICBcImNkYXRhXCIsXG4gICAgICAgIFwic2NyaXB0XCJcbiAgICAgIF07XG4gICAgICBzYXgyLkVWRU5UUyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwicHJvY2Vzc2luZ2luc3RydWN0aW9uXCIsXG4gICAgICAgIFwic2dtbGRlY2xhcmF0aW9uXCIsXG4gICAgICAgIFwiZG9jdHlwZVwiLFxuICAgICAgICBcImNvbW1lbnRcIixcbiAgICAgICAgXCJvcGVudGFnc3RhcnRcIixcbiAgICAgICAgXCJhdHRyaWJ1dGVcIixcbiAgICAgICAgXCJvcGVudGFnXCIsXG4gICAgICAgIFwiY2xvc2V0YWdcIixcbiAgICAgICAgXCJvcGVuY2RhdGFcIixcbiAgICAgICAgXCJjZGF0YVwiLFxuICAgICAgICBcImNsb3NlY2RhdGFcIixcbiAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICBcImVuZFwiLFxuICAgICAgICBcInJlYWR5XCIsXG4gICAgICAgIFwic2NyaXB0XCIsXG4gICAgICAgIFwib3Blbm5hbWVzcGFjZVwiLFxuICAgICAgICBcImNsb3NlbmFtZXNwYWNlXCJcbiAgICAgIF07XG4gICAgICBmdW5jdGlvbiBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXM7XG4gICAgICAgIGNsZWFyQnVmZmVycyhwYXJzZXIpO1xuICAgICAgICBwYXJzZXIucSA9IHBhcnNlci5jID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBzYXgyLk1BWF9CVUZGRVJfTEVOR1RIO1xuICAgICAgICBwYXJzZXIub3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICBwYXJzZXIub3B0Lmxvd2VyY2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlIHx8IHBhcnNlci5vcHQubG93ZXJjYXNldGFncztcbiAgICAgICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gXCJ0b0xvd2VyQ2FzZVwiIDogXCJ0b1VwcGVyQ2FzZVwiO1xuICAgICAgICBwYXJzZXIudGFncyA9IFtdO1xuICAgICAgICBwYXJzZXIuY2xvc2VkID0gcGFyc2VyLmNsb3NlZFJvb3QgPSBwYXJzZXIuc2F3Um9vdCA9IGZhbHNlO1xuICAgICAgICBwYXJzZXIudGFnID0gcGFyc2VyLmVycm9yID0gbnVsbDtcbiAgICAgICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0O1xuICAgICAgICBwYXJzZXIubm9zY3JpcHQgPSAhIShzdHJpY3QgfHwgcGFyc2VyLm9wdC5ub3NjcmlwdCk7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQkVHSU47XG4gICAgICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXM7XG4gICAgICAgIHBhcnNlci5FTlRJVElFUyA9IHBhcnNlci5zdHJpY3RFbnRpdGllcyA/IE9iamVjdC5jcmVhdGUoc2F4Mi5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXgyLkVOVElUSUVTKTtcbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXTtcbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICBwYXJzZXIubnMgPSBPYmplY3QuY3JlYXRlKHJvb3ROUyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRyYWNrUG9zaXRpb24gPSBwYXJzZXIub3B0LnBvc2l0aW9uICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgcGFyc2VyLnBvc2l0aW9uID0gcGFyc2VyLmxpbmUgPSBwYXJzZXIuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbWl0KHBhcnNlciwgXCJvbnJlYWR5XCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3QuY3JlYXRlKSB7XG4gICAgICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgRi5wcm90b3R5cGUgPSBvO1xuICAgICAgICAgIHZhciBuZXdmID0gbmV3IEYoKTtcbiAgICAgICAgICByZXR1cm4gbmV3ZjtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIG8pIGlmIChvLmhhc093blByb3BlcnR5KGkpKSBhLnB1c2goaSk7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpIHtcbiAgICAgICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXgyLk1BWF9CVUZGRVJfTEVOR1RILCAxMCk7XG4gICAgICAgIHZhciBtYXhBY3R1YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbiA+IG1heEFsbG93ZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dE5vZGVcIjpcbiAgICAgICAgICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImNkYXRhXCI6XG4gICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2RhdGFcIiwgcGFyc2VyLmNkYXRhKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2NyaXB0XCIsIHBhcnNlci5zY3JpcHQpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGVycm9yKHBhcnNlciwgXCJNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogXCIgKyBidWZmZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbWF4QWN0dWFsID0gTWF0aC5tYXgobWF4QWN0dWFsLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtID0gc2F4Mi5NQVhfQlVGRkVSX0xFTkdUSCAtIG1heEFjdHVhbDtcbiAgICAgICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYXJCdWZmZXJzKHBhcnNlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcGFyc2VyW2J1ZmZlcnNbaV1dID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzKHBhcnNlcikge1xuICAgICAgICBjbG9zZVRleHQocGFyc2VyKTtcbiAgICAgICAgaWYgKHBhcnNlci5jZGF0YSAhPT0gXCJcIikge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNkYXRhXCIsIHBhcnNlci5jZGF0YSk7XG4gICAgICAgICAgcGFyc2VyLmNkYXRhID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCAhPT0gXCJcIikge1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnNjcmlwdFwiLCBwYXJzZXIuc2NyaXB0KTtcbiAgICAgICAgICBwYXJzZXIuc2NyaXB0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgU0FYUGFyc2VyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbmQodGhpcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlLFxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGUobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZsdXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmbHVzaEJ1ZmZlcnModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgU3RyZWFtO1xuICAgICAgdHJ5IHtcbiAgICAgICAgU3RyZWFtID0gcmVxdWlyZVN0cmVhbUJyb3dzZXJpZnkoKS5TdHJlYW07XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJlYW1XcmFwcyA9IHNheDIuRVZFTlRTLmZpbHRlcihmdW5jdGlvbihldikge1xuICAgICAgICByZXR1cm4gZXYgIT09IFwiZXJyb3JcIiAmJiBldiAhPT0gXCJlbmRcIjtcbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtKHN0cmljdCwgb3B0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFNBWFN0cmVhbShzdHJpY3QsIG9wdCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU0FYU3RyZWFtKHN0cmljdCwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBTdHJlYW0uYXBwbHkodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1lLmVtaXQoXCJlbmRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BhcnNlci5vbmVycm9yID0gZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgICBtZS5lbWl0KFwiZXJyb3JcIiwgZXIpO1xuICAgICAgICAgIG1lLl9wYXJzZXIuZXJyb3IgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kZWNvZGVyID0gbnVsbDtcbiAgICAgICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbihldikge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgXCJvblwiICsgZXYsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyW1wib25cIiArIGV2XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KTtcbiAgICAgICAgICAgICAgICBtZS5fcGFyc2VyW1wib25cIiArIGV2XSA9IGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWUub24oZXYsIGgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgU0FYU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBTQVhTdHJlYW1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgICAgIHZhciBTRCA9IHJlcXVpcmVTdHJpbmdfZGVjb2RlcigpLlN0cmluZ0RlY29kZXI7XG4gICAgICAgICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFNEKFwidXRmOFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VyLndyaXRlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcnNlci5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgU0FYU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgIGlmICghbWUuX3BhcnNlcltcIm9uXCIgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICAgICAgbWUuX3BhcnNlcltcIm9uXCIgKyBldl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDAsIGV2KTtcbiAgICAgICAgICAgIG1lLmVtaXQuYXBwbHkobWUsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmVhbS5wcm90b3R5cGUub24uY2FsbChtZSwgZXYsIGhhbmRsZXIpO1xuICAgICAgfTtcbiAgICAgIHZhciBDREFUQSA9IFwiW0NEQVRBW1wiO1xuICAgICAgdmFyIERPQ1RZUEUgPSBcIkRPQ1RZUEVcIjtcbiAgICAgIHZhciBYTUxfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbiAgICAgIHZhciBYTUxOU19OQU1FU1BBQ0UgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCI7XG4gICAgICB2YXIgcm9vdE5TID0geyB4bWw6IFhNTF9OQU1FU1BBQ0UsIHhtbG5zOiBYTUxOU19OQU1FU1BBQ0UgfTtcbiAgICAgIHZhciBuYW1lU3RhcnQgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS87XG4gICAgICB2YXIgbmFtZUJvZHkgPSAvWzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS87XG4gICAgICB2YXIgZW50aXR5U3RhcnQgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vO1xuICAgICAgdmFyIGVudGl0eUJvZHkgPSAvWyM6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vO1xuICAgICAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIiB8fCBjID09PSBcIlx0XCI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc1F1b3RlKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc0F0dHJpYkVuZChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSBcIj5cIiB8fCBpc1doaXRlc3BhY2UoYyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc01hdGNoKHJlZ2V4LCBjKSB7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KGMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbm90TWF0Y2gocmVnZXgsIGMpIHtcbiAgICAgICAgcmV0dXJuICFpc01hdGNoKHJlZ2V4LCBjKTtcbiAgICAgIH1cbiAgICAgIHZhciBTID0gMDtcbiAgICAgIHNheDIuU1RBVEUgPSB7XG4gICAgICAgIEJFR0lOOiBTKyssXG4gICAgICAgIC8vIGxlYWRpbmcgYnl0ZSBvcmRlciBtYXJrIG9yIHdoaXRlc3BhY2VcbiAgICAgICAgQkVHSU5fV0hJVEVTUEFDRTogUysrLFxuICAgICAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgVEVYVDogUysrLFxuICAgICAgICAvLyBnZW5lcmFsIHN0dWZmXG4gICAgICAgIFRFWFRfRU5USVRZOiBTKyssXG4gICAgICAgIC8vICZhbXAgYW5kIHN1Y2guXG4gICAgICAgIE9QRU5fV0FLQTogUysrLFxuICAgICAgICAvLyA8XG4gICAgICAgIFNHTUxfREVDTDogUysrLFxuICAgICAgICAvLyA8IUJMQVJHXG4gICAgICAgIFNHTUxfREVDTF9RVU9URUQ6IFMrKyxcbiAgICAgICAgLy8gPCFCTEFSRyBmb28gXCJiYXJcbiAgICAgICAgRE9DVFlQRTogUysrLFxuICAgICAgICAvLyA8IURPQ1RZUEVcbiAgICAgICAgRE9DVFlQRV9RVU9URUQ6IFMrKyxcbiAgICAgICAgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgICAgIERPQ1RZUEVfRFREOiBTKyssXG4gICAgICAgIC8vIDwhRE9DVFlQRSBcIi8vYmxhaFwiIFsgLi4uXG4gICAgICAgIERPQ1RZUEVfRFREX1FVT1RFRDogUysrLFxuICAgICAgICAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIFwiZm9vXG4gICAgICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKyxcbiAgICAgICAgLy8gPCEtXG4gICAgICAgIENPTU1FTlQ6IFMrKyxcbiAgICAgICAgLy8gPCEtLVxuICAgICAgICBDT01NRU5UX0VORElORzogUysrLFxuICAgICAgICAvLyA8IS0tIGJsYWggLVxuICAgICAgICBDT01NRU5UX0VOREVEOiBTKyssXG4gICAgICAgIC8vIDwhLS0gYmxhaCAtLVxuICAgICAgICBDREFUQTogUysrLFxuICAgICAgICAvLyA8IVtDREFUQVsgc29tZXRoaW5nXG4gICAgICAgIENEQVRBX0VORElORzogUysrLFxuICAgICAgICAvLyBdXG4gICAgICAgIENEQVRBX0VORElOR18yOiBTKyssXG4gICAgICAgIC8vIF1dXG4gICAgICAgIFBST0NfSU5TVDogUysrLFxuICAgICAgICAvLyA8P2hpXG4gICAgICAgIFBST0NfSU5TVF9CT0RZOiBTKyssXG4gICAgICAgIC8vIDw/aGkgdGhlcmVcbiAgICAgICAgUFJPQ19JTlNUX0VORElORzogUysrLFxuICAgICAgICAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgICAgIE9QRU5fVEFHOiBTKyssXG4gICAgICAgIC8vIDxzdHJvbmdcbiAgICAgICAgT1BFTl9UQUdfU0xBU0g6IFMrKyxcbiAgICAgICAgLy8gPHN0cm9uZyAvXG4gICAgICAgIEFUVFJJQjogUysrLFxuICAgICAgICAvLyA8YVxuICAgICAgICBBVFRSSUJfTkFNRTogUysrLFxuICAgICAgICAvLyA8YSBmb29cbiAgICAgICAgQVRUUklCX05BTUVfU0FXX1dISVRFOiBTKyssXG4gICAgICAgIC8vIDxhIGZvbyBfXG4gICAgICAgIEFUVFJJQl9WQUxVRTogUysrLFxuICAgICAgICAvLyA8YSBmb289XG4gICAgICAgIEFUVFJJQl9WQUxVRV9RVU9URUQ6IFMrKyxcbiAgICAgICAgLy8gPGEgZm9vPVwiYmFyXG4gICAgICAgIEFUVFJJQl9WQUxVRV9DTE9TRUQ6IFMrKyxcbiAgICAgICAgLy8gPGEgZm9vPVwiYmFyXCJcbiAgICAgICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssXG4gICAgICAgIC8vIDxhIGZvbz1iYXJcbiAgICAgICAgQVRUUklCX1ZBTFVFX0VOVElUWV9ROiBTKyssXG4gICAgICAgIC8vIDxmb28gYmFyPVwiJnF1b3Q7XCJcbiAgICAgICAgQVRUUklCX1ZBTFVFX0VOVElUWV9VOiBTKyssXG4gICAgICAgIC8vIDxmb28gYmFyPSZxdW90XG4gICAgICAgIENMT1NFX1RBRzogUysrLFxuICAgICAgICAvLyA8L2FcbiAgICAgICAgQ0xPU0VfVEFHX1NBV19XSElURTogUysrLFxuICAgICAgICAvLyA8L2EgICA+XG4gICAgICAgIFNDUklQVDogUysrLFxuICAgICAgICAvLyA8c2NyaXB0PiAuLi5cbiAgICAgICAgU0NSSVBUX0VORElORzogUysrXG4gICAgICAgIC8vIDxzY3JpcHQ+IC4uLiA8XG4gICAgICB9O1xuICAgICAgc2F4Mi5YTUxfRU5USVRJRVMgPSB7XG4gICAgICAgIFwiYW1wXCI6IFwiJlwiLFxuICAgICAgICBcImd0XCI6IFwiPlwiLFxuICAgICAgICBcImx0XCI6IFwiPFwiLFxuICAgICAgICBcInF1b3RcIjogJ1wiJyxcbiAgICAgICAgXCJhcG9zXCI6IFwiJ1wiXG4gICAgICB9O1xuICAgICAgc2F4Mi5FTlRJVElFUyA9IHtcbiAgICAgICAgXCJhbXBcIjogXCImXCIsXG4gICAgICAgIFwiZ3RcIjogXCI+XCIsXG4gICAgICAgIFwibHRcIjogXCI8XCIsXG4gICAgICAgIFwicXVvdFwiOiAnXCInLFxuICAgICAgICBcImFwb3NcIjogXCInXCIsXG4gICAgICAgIFwiQUVsaWdcIjogMTk4LFxuICAgICAgICBcIkFhY3V0ZVwiOiAxOTMsXG4gICAgICAgIFwiQWNpcmNcIjogMTk0LFxuICAgICAgICBcIkFncmF2ZVwiOiAxOTIsXG4gICAgICAgIFwiQXJpbmdcIjogMTk3LFxuICAgICAgICBcIkF0aWxkZVwiOiAxOTUsXG4gICAgICAgIFwiQXVtbFwiOiAxOTYsXG4gICAgICAgIFwiQ2NlZGlsXCI6IDE5OSxcbiAgICAgICAgXCJFVEhcIjogMjA4LFxuICAgICAgICBcIkVhY3V0ZVwiOiAyMDEsXG4gICAgICAgIFwiRWNpcmNcIjogMjAyLFxuICAgICAgICBcIkVncmF2ZVwiOiAyMDAsXG4gICAgICAgIFwiRXVtbFwiOiAyMDMsXG4gICAgICAgIFwiSWFjdXRlXCI6IDIwNSxcbiAgICAgICAgXCJJY2lyY1wiOiAyMDYsXG4gICAgICAgIFwiSWdyYXZlXCI6IDIwNCxcbiAgICAgICAgXCJJdW1sXCI6IDIwNyxcbiAgICAgICAgXCJOdGlsZGVcIjogMjA5LFxuICAgICAgICBcIk9hY3V0ZVwiOiAyMTEsXG4gICAgICAgIFwiT2NpcmNcIjogMjEyLFxuICAgICAgICBcIk9ncmF2ZVwiOiAyMTAsXG4gICAgICAgIFwiT3NsYXNoXCI6IDIxNixcbiAgICAgICAgXCJPdGlsZGVcIjogMjEzLFxuICAgICAgICBcIk91bWxcIjogMjE0LFxuICAgICAgICBcIlRIT1JOXCI6IDIyMixcbiAgICAgICAgXCJVYWN1dGVcIjogMjE4LFxuICAgICAgICBcIlVjaXJjXCI6IDIxOSxcbiAgICAgICAgXCJVZ3JhdmVcIjogMjE3LFxuICAgICAgICBcIlV1bWxcIjogMjIwLFxuICAgICAgICBcIllhY3V0ZVwiOiAyMjEsXG4gICAgICAgIFwiYWFjdXRlXCI6IDIyNSxcbiAgICAgICAgXCJhY2lyY1wiOiAyMjYsXG4gICAgICAgIFwiYWVsaWdcIjogMjMwLFxuICAgICAgICBcImFncmF2ZVwiOiAyMjQsXG4gICAgICAgIFwiYXJpbmdcIjogMjI5LFxuICAgICAgICBcImF0aWxkZVwiOiAyMjcsXG4gICAgICAgIFwiYXVtbFwiOiAyMjgsXG4gICAgICAgIFwiY2NlZGlsXCI6IDIzMSxcbiAgICAgICAgXCJlYWN1dGVcIjogMjMzLFxuICAgICAgICBcImVjaXJjXCI6IDIzNCxcbiAgICAgICAgXCJlZ3JhdmVcIjogMjMyLFxuICAgICAgICBcImV0aFwiOiAyNDAsXG4gICAgICAgIFwiZXVtbFwiOiAyMzUsXG4gICAgICAgIFwiaWFjdXRlXCI6IDIzNyxcbiAgICAgICAgXCJpY2lyY1wiOiAyMzgsXG4gICAgICAgIFwiaWdyYXZlXCI6IDIzNixcbiAgICAgICAgXCJpdW1sXCI6IDIzOSxcbiAgICAgICAgXCJudGlsZGVcIjogMjQxLFxuICAgICAgICBcIm9hY3V0ZVwiOiAyNDMsXG4gICAgICAgIFwib2NpcmNcIjogMjQ0LFxuICAgICAgICBcIm9ncmF2ZVwiOiAyNDIsXG4gICAgICAgIFwib3NsYXNoXCI6IDI0OCxcbiAgICAgICAgXCJvdGlsZGVcIjogMjQ1LFxuICAgICAgICBcIm91bWxcIjogMjQ2LFxuICAgICAgICBcInN6bGlnXCI6IDIyMyxcbiAgICAgICAgXCJ0aG9yblwiOiAyNTQsXG4gICAgICAgIFwidWFjdXRlXCI6IDI1MCxcbiAgICAgICAgXCJ1Y2lyY1wiOiAyNTEsXG4gICAgICAgIFwidWdyYXZlXCI6IDI0OSxcbiAgICAgICAgXCJ1dW1sXCI6IDI1MixcbiAgICAgICAgXCJ5YWN1dGVcIjogMjUzLFxuICAgICAgICBcInl1bWxcIjogMjU1LFxuICAgICAgICBcImNvcHlcIjogMTY5LFxuICAgICAgICBcInJlZ1wiOiAxNzQsXG4gICAgICAgIFwibmJzcFwiOiAxNjAsXG4gICAgICAgIFwiaWV4Y2xcIjogMTYxLFxuICAgICAgICBcImNlbnRcIjogMTYyLFxuICAgICAgICBcInBvdW5kXCI6IDE2MyxcbiAgICAgICAgXCJjdXJyZW5cIjogMTY0LFxuICAgICAgICBcInllblwiOiAxNjUsXG4gICAgICAgIFwiYnJ2YmFyXCI6IDE2NixcbiAgICAgICAgXCJzZWN0XCI6IDE2NyxcbiAgICAgICAgXCJ1bWxcIjogMTY4LFxuICAgICAgICBcIm9yZGZcIjogMTcwLFxuICAgICAgICBcImxhcXVvXCI6IDE3MSxcbiAgICAgICAgXCJub3RcIjogMTcyLFxuICAgICAgICBcInNoeVwiOiAxNzMsXG4gICAgICAgIFwibWFjclwiOiAxNzUsXG4gICAgICAgIFwiZGVnXCI6IDE3NixcbiAgICAgICAgXCJwbHVzbW5cIjogMTc3LFxuICAgICAgICBcInN1cDFcIjogMTg1LFxuICAgICAgICBcInN1cDJcIjogMTc4LFxuICAgICAgICBcInN1cDNcIjogMTc5LFxuICAgICAgICBcImFjdXRlXCI6IDE4MCxcbiAgICAgICAgXCJtaWNyb1wiOiAxODEsXG4gICAgICAgIFwicGFyYVwiOiAxODIsXG4gICAgICAgIFwibWlkZG90XCI6IDE4MyxcbiAgICAgICAgXCJjZWRpbFwiOiAxODQsXG4gICAgICAgIFwib3JkbVwiOiAxODYsXG4gICAgICAgIFwicmFxdW9cIjogMTg3LFxuICAgICAgICBcImZyYWMxNFwiOiAxODgsXG4gICAgICAgIFwiZnJhYzEyXCI6IDE4OSxcbiAgICAgICAgXCJmcmFjMzRcIjogMTkwLFxuICAgICAgICBcImlxdWVzdFwiOiAxOTEsXG4gICAgICAgIFwidGltZXNcIjogMjE1LFxuICAgICAgICBcImRpdmlkZVwiOiAyNDcsXG4gICAgICAgIFwiT0VsaWdcIjogMzM4LFxuICAgICAgICBcIm9lbGlnXCI6IDMzOSxcbiAgICAgICAgXCJTY2Fyb25cIjogMzUyLFxuICAgICAgICBcInNjYXJvblwiOiAzNTMsXG4gICAgICAgIFwiWXVtbFwiOiAzNzYsXG4gICAgICAgIFwiZm5vZlwiOiA0MDIsXG4gICAgICAgIFwiY2lyY1wiOiA3MTAsXG4gICAgICAgIFwidGlsZGVcIjogNzMyLFxuICAgICAgICBcIkFscGhhXCI6IDkxMyxcbiAgICAgICAgXCJCZXRhXCI6IDkxNCxcbiAgICAgICAgXCJHYW1tYVwiOiA5MTUsXG4gICAgICAgIFwiRGVsdGFcIjogOTE2LFxuICAgICAgICBcIkVwc2lsb25cIjogOTE3LFxuICAgICAgICBcIlpldGFcIjogOTE4LFxuICAgICAgICBcIkV0YVwiOiA5MTksXG4gICAgICAgIFwiVGhldGFcIjogOTIwLFxuICAgICAgICBcIklvdGFcIjogOTIxLFxuICAgICAgICBcIkthcHBhXCI6IDkyMixcbiAgICAgICAgXCJMYW1iZGFcIjogOTIzLFxuICAgICAgICBcIk11XCI6IDkyNCxcbiAgICAgICAgXCJOdVwiOiA5MjUsXG4gICAgICAgIFwiWGlcIjogOTI2LFxuICAgICAgICBcIk9taWNyb25cIjogOTI3LFxuICAgICAgICBcIlBpXCI6IDkyOCxcbiAgICAgICAgXCJSaG9cIjogOTI5LFxuICAgICAgICBcIlNpZ21hXCI6IDkzMSxcbiAgICAgICAgXCJUYXVcIjogOTMyLFxuICAgICAgICBcIlVwc2lsb25cIjogOTMzLFxuICAgICAgICBcIlBoaVwiOiA5MzQsXG4gICAgICAgIFwiQ2hpXCI6IDkzNSxcbiAgICAgICAgXCJQc2lcIjogOTM2LFxuICAgICAgICBcIk9tZWdhXCI6IDkzNyxcbiAgICAgICAgXCJhbHBoYVwiOiA5NDUsXG4gICAgICAgIFwiYmV0YVwiOiA5NDYsXG4gICAgICAgIFwiZ2FtbWFcIjogOTQ3LFxuICAgICAgICBcImRlbHRhXCI6IDk0OCxcbiAgICAgICAgXCJlcHNpbG9uXCI6IDk0OSxcbiAgICAgICAgXCJ6ZXRhXCI6IDk1MCxcbiAgICAgICAgXCJldGFcIjogOTUxLFxuICAgICAgICBcInRoZXRhXCI6IDk1MixcbiAgICAgICAgXCJpb3RhXCI6IDk1MyxcbiAgICAgICAgXCJrYXBwYVwiOiA5NTQsXG4gICAgICAgIFwibGFtYmRhXCI6IDk1NSxcbiAgICAgICAgXCJtdVwiOiA5NTYsXG4gICAgICAgIFwibnVcIjogOTU3LFxuICAgICAgICBcInhpXCI6IDk1OCxcbiAgICAgICAgXCJvbWljcm9uXCI6IDk1OSxcbiAgICAgICAgXCJwaVwiOiA5NjAsXG4gICAgICAgIFwicmhvXCI6IDk2MSxcbiAgICAgICAgXCJzaWdtYWZcIjogOTYyLFxuICAgICAgICBcInNpZ21hXCI6IDk2MyxcbiAgICAgICAgXCJ0YXVcIjogOTY0LFxuICAgICAgICBcInVwc2lsb25cIjogOTY1LFxuICAgICAgICBcInBoaVwiOiA5NjYsXG4gICAgICAgIFwiY2hpXCI6IDk2NyxcbiAgICAgICAgXCJwc2lcIjogOTY4LFxuICAgICAgICBcIm9tZWdhXCI6IDk2OSxcbiAgICAgICAgXCJ0aGV0YXN5bVwiOiA5NzcsXG4gICAgICAgIFwidXBzaWhcIjogOTc4LFxuICAgICAgICBcInBpdlwiOiA5ODIsXG4gICAgICAgIFwiZW5zcFwiOiA4MTk0LFxuICAgICAgICBcImVtc3BcIjogODE5NSxcbiAgICAgICAgXCJ0aGluc3BcIjogODIwMSxcbiAgICAgICAgXCJ6d25qXCI6IDgyMDQsXG4gICAgICAgIFwiendqXCI6IDgyMDUsXG4gICAgICAgIFwibHJtXCI6IDgyMDYsXG4gICAgICAgIFwicmxtXCI6IDgyMDcsXG4gICAgICAgIFwibmRhc2hcIjogODIxMSxcbiAgICAgICAgXCJtZGFzaFwiOiA4MjEyLFxuICAgICAgICBcImxzcXVvXCI6IDgyMTYsXG4gICAgICAgIFwicnNxdW9cIjogODIxNyxcbiAgICAgICAgXCJzYnF1b1wiOiA4MjE4LFxuICAgICAgICBcImxkcXVvXCI6IDgyMjAsXG4gICAgICAgIFwicmRxdW9cIjogODIyMSxcbiAgICAgICAgXCJiZHF1b1wiOiA4MjIyLFxuICAgICAgICBcImRhZ2dlclwiOiA4MjI0LFxuICAgICAgICBcIkRhZ2dlclwiOiA4MjI1LFxuICAgICAgICBcImJ1bGxcIjogODIyNixcbiAgICAgICAgXCJoZWxsaXBcIjogODIzMCxcbiAgICAgICAgXCJwZXJtaWxcIjogODI0MCxcbiAgICAgICAgXCJwcmltZVwiOiA4MjQyLFxuICAgICAgICBcIlByaW1lXCI6IDgyNDMsXG4gICAgICAgIFwibHNhcXVvXCI6IDgyNDksXG4gICAgICAgIFwicnNhcXVvXCI6IDgyNTAsXG4gICAgICAgIFwib2xpbmVcIjogODI1NCxcbiAgICAgICAgXCJmcmFzbFwiOiA4MjYwLFxuICAgICAgICBcImV1cm9cIjogODM2NCxcbiAgICAgICAgXCJpbWFnZVwiOiA4NDY1LFxuICAgICAgICBcIndlaWVycFwiOiA4NDcyLFxuICAgICAgICBcInJlYWxcIjogODQ3NixcbiAgICAgICAgXCJ0cmFkZVwiOiA4NDgyLFxuICAgICAgICBcImFsZWZzeW1cIjogODUwMSxcbiAgICAgICAgXCJsYXJyXCI6IDg1OTIsXG4gICAgICAgIFwidWFyclwiOiA4NTkzLFxuICAgICAgICBcInJhcnJcIjogODU5NCxcbiAgICAgICAgXCJkYXJyXCI6IDg1OTUsXG4gICAgICAgIFwiaGFyclwiOiA4NTk2LFxuICAgICAgICBcImNyYXJyXCI6IDg2MjksXG4gICAgICAgIFwibEFyclwiOiA4NjU2LFxuICAgICAgICBcInVBcnJcIjogODY1NyxcbiAgICAgICAgXCJyQXJyXCI6IDg2NTgsXG4gICAgICAgIFwiZEFyclwiOiA4NjU5LFxuICAgICAgICBcImhBcnJcIjogODY2MCxcbiAgICAgICAgXCJmb3JhbGxcIjogODcwNCxcbiAgICAgICAgXCJwYXJ0XCI6IDg3MDYsXG4gICAgICAgIFwiZXhpc3RcIjogODcwNyxcbiAgICAgICAgXCJlbXB0eVwiOiA4NzA5LFxuICAgICAgICBcIm5hYmxhXCI6IDg3MTEsXG4gICAgICAgIFwiaXNpblwiOiA4NzEyLFxuICAgICAgICBcIm5vdGluXCI6IDg3MTMsXG4gICAgICAgIFwibmlcIjogODcxNSxcbiAgICAgICAgXCJwcm9kXCI6IDg3MTksXG4gICAgICAgIFwic3VtXCI6IDg3MjEsXG4gICAgICAgIFwibWludXNcIjogODcyMixcbiAgICAgICAgXCJsb3dhc3RcIjogODcyNyxcbiAgICAgICAgXCJyYWRpY1wiOiA4NzMwLFxuICAgICAgICBcInByb3BcIjogODczMyxcbiAgICAgICAgXCJpbmZpblwiOiA4NzM0LFxuICAgICAgICBcImFuZ1wiOiA4NzM2LFxuICAgICAgICBcImFuZFwiOiA4NzQzLFxuICAgICAgICBcIm9yXCI6IDg3NDQsXG4gICAgICAgIFwiY2FwXCI6IDg3NDUsXG4gICAgICAgIFwiY3VwXCI6IDg3NDYsXG4gICAgICAgIFwiaW50XCI6IDg3NDcsXG4gICAgICAgIFwidGhlcmU0XCI6IDg3NTYsXG4gICAgICAgIFwic2ltXCI6IDg3NjQsXG4gICAgICAgIFwiY29uZ1wiOiA4NzczLFxuICAgICAgICBcImFzeW1wXCI6IDg3NzYsXG4gICAgICAgIFwibmVcIjogODgwMCxcbiAgICAgICAgXCJlcXVpdlwiOiA4ODAxLFxuICAgICAgICBcImxlXCI6IDg4MDQsXG4gICAgICAgIFwiZ2VcIjogODgwNSxcbiAgICAgICAgXCJzdWJcIjogODgzNCxcbiAgICAgICAgXCJzdXBcIjogODgzNSxcbiAgICAgICAgXCJuc3ViXCI6IDg4MzYsXG4gICAgICAgIFwic3ViZVwiOiA4ODM4LFxuICAgICAgICBcInN1cGVcIjogODgzOSxcbiAgICAgICAgXCJvcGx1c1wiOiA4ODUzLFxuICAgICAgICBcIm90aW1lc1wiOiA4ODU1LFxuICAgICAgICBcInBlcnBcIjogODg2OSxcbiAgICAgICAgXCJzZG90XCI6IDg5MDEsXG4gICAgICAgIFwibGNlaWxcIjogODk2OCxcbiAgICAgICAgXCJyY2VpbFwiOiA4OTY5LFxuICAgICAgICBcImxmbG9vclwiOiA4OTcwLFxuICAgICAgICBcInJmbG9vclwiOiA4OTcxLFxuICAgICAgICBcImxhbmdcIjogOTAwMSxcbiAgICAgICAgXCJyYW5nXCI6IDkwMDIsXG4gICAgICAgIFwibG96XCI6IDk2NzQsXG4gICAgICAgIFwic3BhZGVzXCI6IDk4MjQsXG4gICAgICAgIFwiY2x1YnNcIjogOTgyNyxcbiAgICAgICAgXCJoZWFydHNcIjogOTgyOSxcbiAgICAgICAgXCJkaWFtc1wiOiA5ODMwXG4gICAgICB9O1xuICAgICAgT2JqZWN0LmtleXMoc2F4Mi5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGUgPSBzYXgyLkVOVElUSUVTW2tleV07XG4gICAgICAgIHZhciBzMiA9IHR5cGVvZiBlID09PSBcIm51bWJlclwiID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGU7XG4gICAgICAgIHNheDIuRU5USVRJRVNba2V5XSA9IHMyO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBzIGluIHNheDIuU1RBVEUpIHtcbiAgICAgICAgc2F4Mi5TVEFURVtzYXgyLlNUQVRFW3NdXSA9IHM7XG4gICAgICB9XG4gICAgICBTID0gc2F4Mi5TVEFURTtcbiAgICAgIGZ1bmN0aW9uIGVtaXQocGFyc2VyLCBldmVudCwgZGF0YSkge1xuICAgICAgICBwYXJzZXJbZXZlbnRdICYmIHBhcnNlcltldmVudF0oZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbWl0Tm9kZShwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKSB7XG4gICAgICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBlbWl0KHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xvc2VUZXh0KHBhcnNlcikge1xuICAgICAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpO1xuICAgICAgICBpZiAocGFyc2VyLnRleHROb2RlKSBlbWl0KHBhcnNlciwgXCJvbnRleHRcIiwgcGFyc2VyLnRleHROb2RlKTtcbiAgICAgICAgcGFyc2VyLnRleHROb2RlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRleHRvcHRzKG9wdCwgdGV4dCkge1xuICAgICAgICBpZiAob3B0LnRyaW0pIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgaWYgKG9wdC5ub3JtYWxpemUpIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVycm9yKHBhcnNlciwgZXIpIHtcbiAgICAgICAgY2xvc2VUZXh0KHBhcnNlcik7XG4gICAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgIGVyICs9IFwiXFxuTGluZTogXCIgKyBwYXJzZXIubGluZSArIFwiXFxuQ29sdW1uOiBcIiArIHBhcnNlci5jb2x1bW4gKyBcIlxcbkNoYXI6IFwiICsgcGFyc2VyLmM7XG4gICAgICAgIH1cbiAgICAgICAgZXIgPSBuZXcgRXJyb3IoZXIpO1xuICAgICAgICBwYXJzZXIuZXJyb3IgPSBlcjtcbiAgICAgICAgZW1pdChwYXJzZXIsIFwib25lcnJvclwiLCBlcik7XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlbmQocGFyc2VyKSB7XG4gICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHN0cmljdEZhaWwocGFyc2VyLCBcIlVuY2xvc2VkIHJvb3QgdGFnXCIpO1xuICAgICAgICBpZiAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOICYmIHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTl9XSElURVNQQUNFICYmIHBhcnNlci5zdGF0ZSAhPT0gUy5URVhUKSB7XG4gICAgICAgICAgZXJyb3IocGFyc2VyLCBcIlVuZXhwZWN0ZWQgZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlVGV4dChwYXJzZXIpO1xuICAgICAgICBwYXJzZXIuYyA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICBlbWl0KHBhcnNlciwgXCJvbmVuZFwiKTtcbiAgICAgICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdEZhaWwocGFyc2VyLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSBcIm9iamVjdFwiIHx8ICEocGFyc2VyIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjYWxsIHRvIHN0cmljdEZhaWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuZXdUYWcocGFyc2VyKSB7XG4gICAgICAgIGlmICghcGFyc2VyLnN0cmljdCkgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH07XG4gICAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAgICAgdGFnLm5zID0gcGFyZW50Lm5zO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW50YWdzdGFydFwiLCB0YWcpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcW5hbWUobmFtZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBpID0gbmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgdmFyIHF1YWxOYW1lID0gaSA8IDAgPyBbXCJcIiwgbmFtZV0gOiBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lWzBdO1xuICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZVsxXTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICBwcmVmaXggPSBcInhtbG5zXCI7XG4gICAgICAgICAgbG9jYWwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgbG9jYWwgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGF0dHJpYihwYXJzZXIpIHtcbiAgICAgICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuYXR0cmliTGlzdC5pbmRleE9mKHBhcnNlci5hdHRyaWJOYW1lKSAhPT0gLTEgfHwgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIuYXR0cmliTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeDtcbiAgICAgICAgICB2YXIgbG9jYWwgPSBxbi5sb2NhbDtcbiAgICAgICAgICBpZiAocHJlZml4ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbCA9PT0gXCJ4bWxcIiAmJiBwYXJzZXIuYXR0cmliVmFsdWUgIT09IFhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChcbiAgICAgICAgICAgICAgICBwYXJzZXIsXG4gICAgICAgICAgICAgICAgXCJ4bWw6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvIFwiICsgWE1MX05BTUVTUEFDRSArIFwiXFxuQWN0dWFsOiBcIiArIHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbCA9PT0gXCJ4bWxuc1wiICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwoXG4gICAgICAgICAgICAgICAgcGFyc2VyLFxuICAgICAgICAgICAgICAgIFwieG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvIFwiICsgWE1MTlNfTkFNRVNQQUNFICsgXCJcXG5BY3R1YWw6IFwiICsgcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZztcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgICAgICAgaWYgKHRhZy5ucyA9PT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5hdHRyaWJMaXN0LnB1c2goW3BhcnNlci5hdHRyaWJOYW1lLCBwYXJzZXIuYXR0cmliVmFsdWVdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gcGFyc2VyLmF0dHJpYlZhbHVlO1xuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmF0dHJpYnV0ZVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBwYXJzZXIuYXR0cmliTmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvcGVuVGFnKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZztcbiAgICAgICAgICB2YXIgcW4gPSBxbmFtZShwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeDtcbiAgICAgICAgICB0YWcubG9jYWwgPSBxbi5sb2NhbDtcbiAgICAgICAgICB0YWcudXJpID0gdGFnLm5zW3FuLnByZWZpeF0gfHwgXCJcIjtcbiAgICAgICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiBcIiArIEpTT04uc3RyaW5naWZ5KHBhcnNlci50YWdOYW1lKSk7XG4gICAgICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyO1xuICAgICAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRhZy5ucykuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbm9wZW5uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgICAgIHByZWZpeDogcCxcbiAgICAgICAgICAgICAgICB1cmk6IHRhZy5uc1twXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdmFyIG52ID0gcGFyc2VyLmF0dHJpYkxpc3RbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG52WzBdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbnZbMV07XG4gICAgICAgICAgICB2YXIgcXVhbE5hbWUgPSBxbmFtZShuYW1lLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXg7XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZS5sb2NhbDtcbiAgICAgICAgICAgIHZhciB1cmkyID0gcHJlZml4ID09PSBcIlwiID8gXCJcIiA6IHRhZy5uc1twcmVmaXhdIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbG9jYWwsXG4gICAgICAgICAgICAgIHVyaTogdXJpMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggJiYgcHJlZml4ICE9PSBcInhtbG5zXCIgJiYgIXVyaTIpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiBcIiArIEpTT04uc3RyaW5naWZ5KHByZWZpeCkpO1xuICAgICAgICAgICAgICBhLnVyaSA9IHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGE7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25hdHRyaWJ1dGVcIiwgYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZy5pc1NlbGZDbG9zaW5nID0gISFzZWxmQ2xvc2luZztcbiAgICAgICAgcGFyc2VyLnNhd1Jvb3QgPSB0cnVlO1xuICAgICAgICBwYXJzZXIudGFncy5wdXNoKHBhcnNlci50YWcpO1xuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVudGFnXCIsIHBhcnNlci50YWcpO1xuICAgICAgICBpZiAoIXNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VyLnRhZyA9IG51bGw7XG4gICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsb3NlVGFnKHBhcnNlcikge1xuICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiV2VpcmQgZW1wdHkgY2xvc2UgdGFnLlwiKTtcbiAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gXCI8Lz5cIjtcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgaWYgKHBhcnNlci50YWdOYW1lICE9PSBcInNjcmlwdFwiKSB7XG4gICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uc2NyaXB0XCIsIHBhcnNlci5zY3JpcHQpO1xuICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gcGFyc2VyLnRhZ3MubGVuZ3RoO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHBhcnNlci50YWdOYW1lO1xuICAgICAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9zZVRvID0gdGFnTmFtZTtcbiAgICAgICAgd2hpbGUgKHQtLSkge1xuICAgICAgICAgIHZhciBjbG9zZSA9IHBhcnNlci50YWdzW3RdO1xuICAgICAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmV4cGVjdGVkIGNsb3NlIHRhZ1wiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIlVubWF0Y2hlZCBjbG9zaW5nIHRhZzogXCIgKyBwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHZhciBzMiA9IHBhcnNlci50YWdzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHMyLS0gPiB0KSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWcgPSBwYXJzZXIudGFncy5wb3AoKTtcbiAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZTtcbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25jbG9zZXRhZ1wiLCBwYXJzZXIudGFnTmFtZSk7XG4gICAgICAgICAgdmFyIHggPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICAgICAgeFtpXSA9IHRhZy5uc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlcjtcbiAgICAgICAgICBpZiAocGFyc2VyLm9wdC54bWxucyAmJiB0YWcubnMgIT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF07XG4gICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmNsb3NlbmFtZXNwYWNlXCIsIHsgcHJlZml4OiBwLCB1cmk6IG4gfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPT09IDApIHBhcnNlci5jbG9zZWRSb290ID0gdHJ1ZTtcbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9IFwiXCI7XG4gICAgICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhcnNlRW50aXR5KHBhcnNlcikge1xuICAgICAgICB2YXIgZW50aXR5ID0gcGFyc2VyLmVudGl0eTtcbiAgICAgICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBudW07XG4gICAgICAgIHZhciBudW1TdHIgPSBcIlwiO1xuICAgICAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ10pIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXTtcbiAgICAgICAgfVxuICAgICAgICBlbnRpdHkgPSBlbnRpdHlMQztcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMSkgPT09IFwieFwiKSB7XG4gICAgICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMik7XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KTtcbiAgICAgICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgxKTtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTApO1xuICAgICAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnJlcGxhY2UoL14wKy8sIFwiXCIpO1xuICAgICAgICBpZiAoaXNOYU4obnVtKSB8fCBudW1TdHIudG9Mb3dlckNhc2UoKSAhPT0gZW50aXR5KSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXIgZW50aXR5XCIpO1xuICAgICAgICAgIHJldHVybiBcIiZcIiArIHBhcnNlci5lbnRpdHkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpIHtcbiAgICAgICAgaWYgKGMgPT09IFwiPFwiKSB7XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0E7XG4gICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIk5vbi13aGl0ZXNwYWNlIGJlZm9yZSBmaXJzdCB0YWcuXCIpO1xuICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IGM7XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjaGFyQXQoY2h1bmssIGkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChpIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2h1bmsuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3cml0ZShjaHVuaykge1xuICAgICAgICB2YXIgcGFyc2VyID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgICAgcGFyc2VyLFxuICAgICAgICAgICAgXCJDYW5ub3Qgd3JpdGUgYWZ0ZXIgY2xvc2UuIEFzc2lnbiBhbiBvbnJlYWR5IGhhbmRsZXIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBlbmQocGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSBcIlwiO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKyk7XG4gICAgICAgICAgcGFyc2VyLmMgPSBjO1xuICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKys7XG4gICAgICAgICAgICBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICBwYXJzZXIubGluZSsrO1xuICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUy5CRUdJTjpcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFO1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJcXHVGRUZGXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQkVHSU5fV0hJVEVTUEFDRTpcbiAgICAgICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlRFWFQ6XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGMgJiYgYyAhPT0gXCI8XCIgJiYgYyAhPT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKyk7XG4gICAgICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIucG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrO1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY2h1bmsuc3Vic3RyaW5nKHN0YXJ0aSwgaSAtIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIjxcIiAmJiAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9XQUtBO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJUZXh0IGRhdGEgb3V0c2lkZSBvZiByb290IG5vZGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIjxcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUX0VORElORztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuU0NSSVBUX0VORElORzpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBcIjxcIiArIGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIhXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTDtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkgO1xuICAgICAgICAgICAgICBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHO1xuICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gYztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHO1xuICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIj9cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUO1xuICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJVbmVuY29kZWQgPFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFkID0gcGFyc2VyLnBvc2l0aW9uIC0gcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbihcIiBcIikgKyBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gXCI8XCIgKyBjO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgICAgIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gQ0RBVEEpIHtcbiAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25vcGVuY2RhdGFcIik7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9IFwiXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNnbWxEZWNsICsgYyA9PT0gXCItLVwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBET0NUWVBFKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuZG9jdHlwZSB8fCBwYXJzZXIuc2F3Um9vdCkge1xuICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLFxuICAgICAgICAgICAgICAgICAgICBcIkluYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb25cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9IFwiXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsIFwib25zZ21sZGVjbGFyYXRpb25cIiwgcGFyc2VyLnNnbWxEZWNsKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xfUVVPVEVEO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlNHTUxfREVDTF9RVU9URUQ6XG4gICAgICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMO1xuICAgICAgICAgICAgICAgIHBhcnNlci5xID0gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgKz0gYztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUO1xuICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbmRvY3R5cGVcIiwgcGFyc2VyLmRvY3R5cGUpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URUQ7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIucSA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREOlxuICAgICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjO1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVERfUVVPVEVEO1xuICAgICAgICAgICAgICAgIHBhcnNlci5xID0gYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGM7XG4gICAgICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9EVEQ7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnEgPSBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLkNPTU1FTlQ6XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VOREVEO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY29tbWVudFwiLCBwYXJzZXIuY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBcIi1cIiArIGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ERUQ6XG4gICAgICAgICAgICAgIGlmIChjICE9PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIk1hbGZvcm1lZCBjb21tZW50XCIpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9IFwiLS1cIiArIGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5DREFUQTpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HOlxuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBcIl1cIiArIGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5DREFUQV9FTkRJTkdfMjpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5jZGF0YSkge1xuICAgICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2RhdGFcIiwgcGFyc2VyLmNkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uY2xvc2VjZGF0YVwiKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBcIl1cIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gXCJdXVwiICsgYztcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfRU5ESU5HO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSArPSBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9CT0RZOlxuICAgICAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgXCJvbnByb2Nlc3NpbmdpbnN0cnVjdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBwYXJzZXIucHJvY0luc3ROYW1lLFxuICAgICAgICAgICAgICAgICAgYm9keTogcGFyc2VyLnByb2NJbnN0Qm9keVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBcIj9cIiArIGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5QUk9DX0lOU1RfQk9EWTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5PUEVOX1RBRzpcbiAgICAgICAgICAgICAgaWYgKGlzTWF0Y2gobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdUYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPlwiKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0g7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjO1xuICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FOlxuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkF0dHJpYnV0ZSB3aXRob3V0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lO1xuICAgICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lICs9IGM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBhdHRyaWJ1dGUgbmFtZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkF0dHJpYnV0ZSB3aXRob3V0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1twYXJzZXIuYXR0cmliTmFtZV0gPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCBcIm9uYXR0cmlidXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gYztcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNRdW90ZShjKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5xID0gYztcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URUQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEO1xuICAgICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1FVT1RFRDpcbiAgICAgICAgICAgICAgaWYgKGMgIT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICBwYXJzZXIucSA9IFwiXCI7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0NMT1NFRDpcbiAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgXCJObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlc1wiKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGM7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgYXR0cmlidXRlIG5hbWVcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEOlxuICAgICAgICAgICAgICBpZiAoIWlzQXR0cmliRW5kKGMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpO1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgICAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RNYXRjaChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIGM7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNYXRjaChuYW1lQm9keSwgYykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIudGFnTmFtZSArPSBjO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc2NyaXB0ICs9IFwiPC9cIiArIHBhcnNlci50YWdOYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR19TQVdfV0hJVEU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHX1NBV19XSElURTpcbiAgICAgICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIj5cIikge1xuICAgICAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsIFwiSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgIHZhciByZXR1cm5TdGF0ZTtcbiAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjI7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTLlRFWFRfRU5USVRZOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLlRFWFQ7XG4gICAgICAgICAgICAgICAgICBidWZmZXIyID0gXCJ0ZXh0Tm9kZVwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgYnVmZmVyMiA9IFwiYXR0cmliVmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEO1xuICAgICAgICAgICAgICAgICAgYnVmZmVyMiA9IFwiYXR0cmliVmFsdWVcIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgIHBhcnNlcltidWZmZXIyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmVudGl0eSArPSBjO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCBcIkludmFsaWQgY2hhcmFjdGVyIGluIGVudGl0eSBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIHBhcnNlcltidWZmZXIyXSArPSBcIiZcIiArIHBhcnNlci5lbnRpdHkgKyBjO1xuICAgICAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcnNlciwgXCJVbmtub3duIHN0YXRlOiBcIiArIHBhcnNlci5zdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIucG9zaXRpb24gPj0gcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24pIHtcbiAgICAgICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICB9XG4gICAgICAvKiEgaHR0cDovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4xLjAgYnkgQG1hdGhpYXMgKi9cbiAgICAgIGlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgICAgICAgIHZhciBmbG9vcjIgPSBNYXRoLmZsb29yO1xuICAgICAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgTUFYX1NJWkUgPSAxNjM4NDtcbiAgICAgICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBoaWdoU3Vycm9nYXRlO1xuICAgICAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgY29kZVBvaW50ID4gMTExNDExMSB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgZmxvb3IyKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCkge1xuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnQ6IFwiICsgY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgLT0gNjU1MzY7XG4gICAgICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgNTUyOTY7XG4gICAgICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gY29kZVBvaW50ICUgMTAyNCArIDU2MzIwO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbGVuZ3RoIHx8IGNvZGVVbml0cy5sZW5ndGggPiBNQVhfU0laRSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcsIFwiZnJvbUNvZGVQb2ludFwiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBmcm9tQ29kZVBvaW50LFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cbiAgICB9KShleHBvcnRzKTtcbiAgfSkoc2F4KTtcbiAgcmV0dXJuIHNheDtcbn1cbnZhciBhcnJheUhlbHBlcjtcbnZhciBoYXNSZXF1aXJlZEFycmF5SGVscGVyO1xuZnVuY3Rpb24gcmVxdWlyZUFycmF5SGVscGVyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRBcnJheUhlbHBlcikgcmV0dXJuIGFycmF5SGVscGVyO1xuICBoYXNSZXF1aXJlZEFycmF5SGVscGVyID0gMTtcbiAgYXJyYXlIZWxwZXIgPSB7XG4gICAgaXNBcnJheTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXJyYXlIZWxwZXI7XG59XG52YXIgb3B0aW9uc0hlbHBlcjtcbnZhciBoYXNSZXF1aXJlZE9wdGlvbnNIZWxwZXI7XG5mdW5jdGlvbiByZXF1aXJlT3B0aW9uc0hlbHBlcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkT3B0aW9uc0hlbHBlcikgcmV0dXJuIG9wdGlvbnNIZWxwZXI7XG4gIGhhc1JlcXVpcmVkT3B0aW9uc0hlbHBlciA9IDE7XG4gIHZhciBpc0FycmF5ID0gcmVxdWlyZUFycmF5SGVscGVyKCkuaXNBcnJheTtcbiAgb3B0aW9uc0hlbHBlciA9IHtcbiAgICBjb3B5T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGtleSwgY29weSA9IHt9O1xuICAgICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29weVtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIGVuc3VyZUZsYWdFeGlzdHM6IGZ1bmN0aW9uKGl0ZW0sIG9wdGlvbnMpIHtcbiAgICAgIGlmICghKGl0ZW0gaW4gb3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnNbaXRlbV0gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG9wdGlvbnNbaXRlbV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuc3VyZVNwYWNlc0V4aXN0czogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCEoXCJzcGFjZXNcIiBpbiBvcHRpb25zKSB8fCB0eXBlb2Ygb3B0aW9ucy5zcGFjZXMgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG9wdGlvbnMuc3BhY2VzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMuc3BhY2VzID0gMDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuc3VyZUFsd2F5c0FycmF5RXhpc3RzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIShcImFsd2F5c0FycmF5XCIgaW4gb3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnMuYWx3YXlzQXJyYXkgIT09IFwiYm9vbGVhblwiICYmICFpc0FycmF5KG9wdGlvbnMuYWx3YXlzQXJyYXkpKSB7XG4gICAgICAgIG9wdGlvbnMuYWx3YXlzQXJyYXkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuc3VyZUtleUV4aXN0czogZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIShrZXkgKyBcIktleVwiIGluIG9wdGlvbnMpIHx8IHR5cGVvZiBvcHRpb25zW2tleSArIFwiS2V5XCJdICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnNba2V5ICsgXCJLZXlcIl0gPSBvcHRpb25zLmNvbXBhY3QgPyBcIl9cIiArIGtleSA6IGtleTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNoZWNrRm5FeGlzdHM6IGZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGtleSArIFwiRm5cIiBpbiBvcHRpb25zO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIG9wdGlvbnNIZWxwZXI7XG59XG52YXIgeG1sMmpzO1xudmFyIGhhc1JlcXVpcmVkWG1sMmpzO1xuZnVuY3Rpb24gcmVxdWlyZVhtbDJqcygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkWG1sMmpzKSByZXR1cm4geG1sMmpzO1xuICBoYXNSZXF1aXJlZFhtbDJqcyA9IDE7XG4gIHZhciBzYXgyID0gcmVxdWlyZVNheCgpO1xuICB2YXIgaGVscGVyID0gcmVxdWlyZU9wdGlvbnNIZWxwZXIoKTtcbiAgdmFyIGlzQXJyYXkgPSByZXF1aXJlQXJyYXlIZWxwZXIoKS5pc0FycmF5O1xuICB2YXIgb3B0aW9ucztcbiAgdmFyIGN1cnJlbnRFbGVtZW50O1xuICBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gaGVscGVyLmNvcHlPcHRpb25zKHVzZXJPcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImlnbm9yZURlY2xhcmF0aW9uXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiaWdub3JlSW5zdHJ1Y3Rpb25cIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpZ25vcmVBdHRyaWJ1dGVzXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiaWdub3JlVGV4dFwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImlnbm9yZUNvbW1lbnRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpZ25vcmVDZGF0YVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImlnbm9yZURvY3R5cGVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJjb21wYWN0XCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiYWx3YXlzQ2hpbGRyZW5cIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJhZGRQYXJlbnRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJ0cmltXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwibmF0aXZlVHlwZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcIm5hdGl2ZVR5cGVBdHRyaWJ1dGVzXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwic2FuaXRpemVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpbnN0cnVjdGlvbkhhc0F0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJjYXB0dXJlU3BhY2VzQmV0d2VlbkVsZW1lbnRzXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVBbHdheXNBcnJheUV4aXN0cyhvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwiZGVjbGFyYXRpb25cIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcImluc3RydWN0aW9uXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJhdHRyaWJ1dGVzXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJ0ZXh0XCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJjb21tZW50XCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJjZGF0YVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwiZG9jdHlwZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwidHlwZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwibmFtZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwiZWxlbWVudHNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcInBhcmVudFwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImRvY3R5cGVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJpbnN0cnVjdGlvblwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImNkYXRhXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5jaGVja0ZuRXhpc3RzKFwiY29tbWVudFwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcInRleHRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJpbnN0cnVjdGlvbk5hbWVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJlbGVtZW50TmFtZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImF0dHJpYnV0ZU5hbWVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJhdHRyaWJ1dGVWYWx1ZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImF0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gbmF0aXZlVHlwZSh2YWx1ZSkge1xuICAgIHZhciBuVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmICghaXNOYU4oblZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5WYWx1ZTtcbiAgICB9XG4gICAgdmFyIGJWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGJWYWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYlZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEZpZWxkKHR5cGUyLCB2YWx1ZSkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFjdCkge1xuICAgICAgaWYgKCFjdXJyZW50RWxlbWVudFtvcHRpb25zW3R5cGUyICsgXCJLZXlcIl1dICYmIChpc0FycmF5KG9wdGlvbnMuYWx3YXlzQXJyYXkpID8gb3B0aW9ucy5hbHdheXNBcnJheS5pbmRleE9mKG9wdGlvbnNbdHlwZTIgKyBcIktleVwiXSkgIT09IC0xIDogb3B0aW9ucy5hbHdheXNBcnJheSkpIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9uc1t0eXBlMiArIFwiS2V5XCJdXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50W29wdGlvbnNbdHlwZTIgKyBcIktleVwiXV0gJiYgIWlzQXJyYXkoY3VycmVudEVsZW1lbnRbb3B0aW9uc1t0eXBlMiArIFwiS2V5XCJdXSkpIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9uc1t0eXBlMiArIFwiS2V5XCJdXSA9IFtjdXJyZW50RWxlbWVudFtvcHRpb25zW3R5cGUyICsgXCJLZXlcIl1dXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlMiArIFwiRm5cIiBpbiBvcHRpb25zICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnNbdHlwZTIgKyBcIkZuXCJdKHZhbHVlLCBjdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZTIgPT09IFwiaW5zdHJ1Y3Rpb25cIiAmJiAoXCJpbnN0cnVjdGlvbkZuXCIgaW4gb3B0aW9ucyB8fCBcImluc3RydWN0aW9uTmFtZUZuXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKFwiaW5zdHJ1Y3Rpb25GblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IG9wdGlvbnMuaW5zdHJ1Y3Rpb25Gbih2YWx1ZVtrZXldLCBrZXksIGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgIHZhbHVlW29wdGlvbnMuaW5zdHJ1Y3Rpb25OYW1lRm4oa2V5LCB0ZW1wLCBjdXJyZW50RWxlbWVudCldID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KGN1cnJlbnRFbGVtZW50W29wdGlvbnNbdHlwZTIgKyBcIktleVwiXV0pKSB7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnNbdHlwZTIgKyBcIktleVwiXV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zW3R5cGUyICsgXCJLZXlcIl1dID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY3VycmVudEVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0pIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0ge307XG4gICAgICBlbGVtZW50W29wdGlvbnMudHlwZUtleV0gPSB0eXBlMjtcbiAgICAgIGlmICh0eXBlMiA9PT0gXCJpbnN0cnVjdGlvblwiKSB7XG4gICAgICAgIGZvciAoa2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50W29wdGlvbnMubmFtZUtleV0gPSBcImluc3RydWN0aW9uTmFtZUZuXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaW5zdHJ1Y3Rpb25OYW1lRm4oa2V5LCB2YWx1ZSwgY3VycmVudEVsZW1lbnQpIDoga2V5O1xuICAgICAgICBpZiAob3B0aW9ucy5pbnN0cnVjdGlvbkhhc0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0gPSB2YWx1ZVtrZXldW29wdGlvbnMuYXR0cmlidXRlc0tleV07XG4gICAgICAgICAgaWYgKFwiaW5zdHJ1Y3Rpb25GblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSA9IG9wdGlvbnMuaW5zdHJ1Y3Rpb25GbihlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0sIGtleSwgY3VycmVudEVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoXCJpbnN0cnVjdGlvbkZuXCIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdmFsdWVba2V5XSA9IG9wdGlvbnMuaW5zdHJ1Y3Rpb25Gbih2YWx1ZVtrZXldLCBrZXksIGN1cnJlbnRFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudFtvcHRpb25zLmluc3RydWN0aW9uS2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlMiArIFwiRm5cIiBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFsdWUgPSBvcHRpb25zW3R5cGUyICsgXCJGblwiXSh2YWx1ZSwgY3VycmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRbb3B0aW9uc1t0eXBlMiArIFwiS2V5XCJdXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYWRkUGFyZW50KSB7XG4gICAgICAgIGVsZW1lbnRbb3B0aW9ucy5wYXJlbnRLZXldID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYW5pcHVsYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKFwiYXR0cmlidXRlc0ZuXCIgaW4gb3B0aW9ucyAmJiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzRm4oYXR0cmlidXRlcywgY3VycmVudEVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMudHJpbSB8fCBcImF0dHJpYnV0ZVZhbHVlRm5cIiBpbiBvcHRpb25zIHx8IFwiYXR0cmlidXRlTmFtZUZuXCIgaW4gb3B0aW9ucyB8fCBvcHRpb25zLm5hdGl2ZVR5cGVBdHRyaWJ1dGVzKSAmJiBhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudHJpbSkgYXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlc1trZXldLnRyaW0oKTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5uYXRpdmVUeXBlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gbmF0aXZlVHlwZShhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJhdHRyaWJ1dGVWYWx1ZUZuXCIgaW4gb3B0aW9ucykgYXR0cmlidXRlc1trZXldID0gb3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZUZuKGF0dHJpYnV0ZXNba2V5XSwga2V5LCBjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgaWYgKFwiYXR0cmlidXRlTmFtZUZuXCIgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgYXR0cmlidXRlc1tvcHRpb25zLmF0dHJpYnV0ZU5hbWVGbihrZXksIGF0dHJpYnV0ZXNba2V5XSwgY3VycmVudEVsZW1lbnQpXSA9IHRlbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG4gIGZ1bmN0aW9uIG9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24pIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChpbnN0cnVjdGlvbi5ib2R5ICYmIChpbnN0cnVjdGlvbi5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwieG1sXCIgfHwgb3B0aW9ucy5pbnN0cnVjdGlvbkhhc0F0dHJpYnV0ZXMpKSB7XG4gICAgICB2YXIgYXR0cnNSZWdFeHAgPSAvKFtcXHc6LV0rKVxccyo9XFxzKig/OlwiKFteXCJdKilcInwnKFteJ10qKSd8KFxcdyspKVxccyovZztcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSBhdHRyc1JlZ0V4cC5leGVjKGluc3RydWN0aW9uLmJvZHkpKSAhPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzW21hdGNoWzFdXSA9IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcyA9IG1hbmlwdWxhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoaW5zdHJ1Y3Rpb24ubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInhtbFwiKSB7XG4gICAgICBpZiAob3B0aW9ucy5pZ25vcmVEZWNsYXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmRlY2xhcmF0aW9uS2V5XSA9IHt9O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmRlY2xhcmF0aW9uS2V5XVtvcHRpb25zLmF0dHJpYnV0ZXNLZXldID0gYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFkZFBhcmVudCkge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmRlY2xhcmF0aW9uS2V5XVtvcHRpb25zLnBhcmVudEtleV0gPSBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuaWdub3JlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJpbSkge1xuICAgICAgICBpbnN0cnVjdGlvbi5ib2R5ID0gaW5zdHJ1Y3Rpb24uYm9keS50cmltKCk7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSB7fTtcbiAgICAgIGlmIChvcHRpb25zLmluc3RydWN0aW9uSGFzQXR0cmlidXRlcyAmJiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVbaW5zdHJ1Y3Rpb24ubmFtZV0gPSB7fTtcbiAgICAgICAgdmFsdWVbaW5zdHJ1Y3Rpb24ubmFtZV1bb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSA9IGF0dHJpYnV0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVtpbnN0cnVjdGlvbi5uYW1lXSA9IGluc3RydWN0aW9uLmJvZHk7XG4gICAgICB9XG4gICAgICBhZGRGaWVsZChcImluc3RydWN0aW9uXCIsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25TdGFydEVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbGVtZW50O1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYXR0cmlidXRlcyA9IG5hbWUuYXR0cmlidXRlcztcbiAgICAgIG5hbWUgPSBuYW1lLm5hbWU7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSBtYW5pcHVsYXRlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICBpZiAoXCJlbGVtZW50TmFtZUZuXCIgaW4gb3B0aW9ucykge1xuICAgICAgbmFtZSA9IG9wdGlvbnMuZWxlbWVudE5hbWVGbihuYW1lLCBjdXJyZW50RWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvbXBhY3QpIHtcbiAgICAgIGVsZW1lbnQgPSB7fTtcbiAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVBdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSA9IHt9O1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIShuYW1lIGluIGN1cnJlbnRFbGVtZW50KSAmJiAoaXNBcnJheShvcHRpb25zLmFsd2F5c0FycmF5KSA/IG9wdGlvbnMuYWx3YXlzQXJyYXkuaW5kZXhPZihuYW1lKSAhPT0gLTEgOiBvcHRpb25zLmFsd2F5c0FycmF5KSkge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50W25hbWVdICYmICFpc0FycmF5KGN1cnJlbnRFbGVtZW50W25hbWVdKSkge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtuYW1lXSA9IFtjdXJyZW50RWxlbWVudFtuYW1lXV07XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheShjdXJyZW50RWxlbWVudFtuYW1lXSkpIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnRbbmFtZV0ucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50W25hbWVdID0gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjdXJyZW50RWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSkge1xuICAgICAgICBjdXJyZW50RWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IHt9O1xuICAgICAgZWxlbWVudFtvcHRpb25zLnR5cGVLZXldID0gXCJlbGVtZW50XCI7XG4gICAgICBlbGVtZW50W29wdGlvbnMubmFtZUtleV0gPSBuYW1lO1xuICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcyAmJiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldID0gYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFsd2F5c0NoaWxkcmVuKSB7XG4gICAgICAgIGVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRFbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIGVsZW1lbnRbb3B0aW9ucy5wYXJlbnRLZXldID0gY3VycmVudEVsZW1lbnQ7XG4gICAgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIG9uVGV4dCh0ZXh0KSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlVGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRleHQudHJpbSgpICYmICFvcHRpb25zLmNhcHR1cmVTcGFjZXNCZXR3ZWVuRWxlbWVudHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJpbSkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYXRpdmVUeXBlKSB7XG4gICAgICB0ZXh0ID0gbmF0aXZlVHlwZSh0ZXh0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2FuaXRpemUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG4gICAgYWRkRmllbGQoXCJ0ZXh0XCIsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG9uQ29tbWVudChjb21tZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlQ29tbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cmltKSB7XG4gICAgICBjb21tZW50ID0gY29tbWVudC50cmltKCk7XG4gICAgfVxuICAgIGFkZEZpZWxkKFwiY29tbWVudFwiLCBjb21tZW50KTtcbiAgfVxuICBmdW5jdGlvbiBvbkVuZEVsZW1lbnQobmFtZSkge1xuICAgIHZhciBwYXJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnRbb3B0aW9ucy5wYXJlbnRLZXldO1xuICAgIGlmICghb3B0aW9ucy5hZGRQYXJlbnQpIHtcbiAgICAgIGRlbGV0ZSBjdXJyZW50RWxlbWVudFtvcHRpb25zLnBhcmVudEtleV07XG4gICAgfVxuICAgIGN1cnJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudDtcbiAgfVxuICBmdW5jdGlvbiBvbkNkYXRhKGNkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlQ2RhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJpbSkge1xuICAgICAgY2RhdGEgPSBjZGF0YS50cmltKCk7XG4gICAgfVxuICAgIGFkZEZpZWxkKFwiY2RhdGFcIiwgY2RhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRG9jdHlwZShkb2N0eXBlKSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlRG9jdHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N0eXBlID0gZG9jdHlwZS5yZXBsYWNlKC9eIC8sIFwiXCIpO1xuICAgIGlmIChvcHRpb25zLnRyaW0pIHtcbiAgICAgIGRvY3R5cGUgPSBkb2N0eXBlLnRyaW0oKTtcbiAgICB9XG4gICAgYWRkRmllbGQoXCJkb2N0eXBlXCIsIGRvY3R5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICBlcnJvci5ub3RlID0gZXJyb3I7XG4gIH1cbiAgeG1sMmpzID0gZnVuY3Rpb24oeG1sMiwgdXNlck9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VyID0gc2F4Mi5wYXJzZXIodHJ1ZSwge30pO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBjdXJyZW50RWxlbWVudCA9IHJlc3VsdDtcbiAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKHVzZXJPcHRpb25zKTtcbiAgICB7XG4gICAgICBwYXJzZXIub3B0ID0geyBzdHJpY3RFbnRpdGllczogdHJ1ZSB9O1xuICAgICAgcGFyc2VyLm9ub3BlbnRhZyA9IG9uU3RhcnRFbGVtZW50O1xuICAgICAgcGFyc2VyLm9udGV4dCA9IG9uVGV4dDtcbiAgICAgIHBhcnNlci5vbmNvbW1lbnQgPSBvbkNvbW1lbnQ7XG4gICAgICBwYXJzZXIub25jbG9zZXRhZyA9IG9uRW5kRWxlbWVudDtcbiAgICAgIHBhcnNlci5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgIHBhcnNlci5vbmNkYXRhID0gb25DZGF0YTtcbiAgICAgIHBhcnNlci5vbmRvY3R5cGUgPSBvbkRvY3R5cGU7XG4gICAgICBwYXJzZXIub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24gPSBvbkluc3RydWN0aW9uO1xuICAgIH1cbiAgICB7XG4gICAgICBwYXJzZXIud3JpdGUoeG1sMikuY2xvc2UoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFtvcHRpb25zLmVsZW1lbnRzS2V5XSkge1xuICAgICAgdmFyIHRlbXAgPSByZXN1bHRbb3B0aW9ucy5lbGVtZW50c0tleV07XG4gICAgICBkZWxldGUgcmVzdWx0W29wdGlvbnMuZWxlbWVudHNLZXldO1xuICAgICAgcmVzdWx0W29wdGlvbnMuZWxlbWVudHNLZXldID0gdGVtcDtcbiAgICAgIGRlbGV0ZSByZXN1bHQudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuIHhtbDJqcztcbn1cbnZhciB4bWwyanNvbjtcbnZhciBoYXNSZXF1aXJlZFhtbDJqc29uO1xuZnVuY3Rpb24gcmVxdWlyZVhtbDJqc29uKCkge1xuICBpZiAoaGFzUmVxdWlyZWRYbWwyanNvbikgcmV0dXJuIHhtbDJqc29uO1xuICBoYXNSZXF1aXJlZFhtbDJqc29uID0gMTtcbiAgdmFyIGhlbHBlciA9IHJlcXVpcmVPcHRpb25zSGVscGVyKCk7XG4gIHZhciB4bWwyanMyID0gcmVxdWlyZVhtbDJqcygpO1xuICBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGhlbHBlci5jb3B5T3B0aW9ucyh1c2VyT3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZVNwYWNlc0V4aXN0cyhvcHRpb25zKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICB4bWwyanNvbiA9IGZ1bmN0aW9uKHhtbDIsIHVzZXJPcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMsIGpzLCBqc29uLCBwYXJlbnRLZXk7XG4gICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyh1c2VyT3B0aW9ucyk7XG4gICAganMgPSB4bWwyanMyKHhtbDIsIG9wdGlvbnMpO1xuICAgIHBhcmVudEtleSA9IFwiY29tcGFjdFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wYWN0ID8gXCJfcGFyZW50XCIgOiBcInBhcmVudFwiO1xuICAgIGlmIChcImFkZFBhcmVudFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5hZGRQYXJlbnQpIHtcbiAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShqcywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICByZXR1cm4gayA9PT0gcGFyZW50S2V5ID8gXCJfXCIgOiB2O1xuICAgICAgfSwgb3B0aW9ucy5zcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkoanMsIG51bGwsIG9wdGlvbnMuc3BhY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKS5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xuICB9O1xuICByZXR1cm4geG1sMmpzb247XG59XG52YXIganMyeG1sO1xudmFyIGhhc1JlcXVpcmVkSnMyeG1sO1xuZnVuY3Rpb24gcmVxdWlyZUpzMnhtbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSnMyeG1sKSByZXR1cm4ganMyeG1sO1xuICBoYXNSZXF1aXJlZEpzMnhtbCA9IDE7XG4gIHZhciBoZWxwZXIgPSByZXF1aXJlT3B0aW9uc0hlbHBlcigpO1xuICB2YXIgaXNBcnJheSA9IHJlcXVpcmVBcnJheUhlbHBlcigpLmlzQXJyYXk7XG4gIHZhciBjdXJyZW50RWxlbWVudCwgY3VycmVudEVsZW1lbnROYW1lO1xuICBmdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGhlbHBlci5jb3B5T3B0aW9ucyh1c2VyT3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpZ25vcmVEZWNsYXJhdGlvblwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImlnbm9yZUluc3RydWN0aW9uXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiaWdub3JlQXR0cmlidXRlc1wiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImlnbm9yZVRleHRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpZ25vcmVDb21tZW50XCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiaWdub3JlQ2RhdGFcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpZ25vcmVEb2N0eXBlXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVGbGFnRXhpc3RzKFwiY29tcGFjdFwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImluZGVudFRleHRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpbmRlbnRDZGF0YVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImluZGVudEF0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJpbmRlbnRJbnN0cnVjdGlvblwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlRmxhZ0V4aXN0cyhcImZ1bGxUYWdFbXB0eUVsZW1lbnRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUZsYWdFeGlzdHMoXCJub1F1b3Rlc0Zvck5hdGl2ZUF0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZVNwYWNlc0V4aXN0cyhvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3BhY2VzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBvcHRpb25zLnNwYWNlcyA9IEFycmF5KG9wdGlvbnMuc3BhY2VzICsgMSkuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJkZWNsYXJhdGlvblwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuZW5zdXJlS2V5RXhpc3RzKFwiaW5zdHJ1Y3Rpb25cIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcImF0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcInRleHRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcImNvbW1lbnRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmVuc3VyZUtleUV4aXN0cyhcImNkYXRhXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJkb2N0eXBlXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJ0eXBlXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJuYW1lXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5lbnN1cmVLZXlFeGlzdHMoXCJlbGVtZW50c1wiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImRvY3R5cGVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJpbnN0cnVjdGlvblwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImNkYXRhXCIsIG9wdGlvbnMpO1xuICAgIGhlbHBlci5jaGVja0ZuRXhpc3RzKFwiY29tbWVudFwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcInRleHRcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJpbnN0cnVjdGlvbk5hbWVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJlbGVtZW50TmFtZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImF0dHJpYnV0ZU5hbWVcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJhdHRyaWJ1dGVWYWx1ZVwiLCBvcHRpb25zKTtcbiAgICBoZWxwZXIuY2hlY2tGbkV4aXN0cyhcImF0dHJpYnV0ZXNcIiwgb3B0aW9ucyk7XG4gICAgaGVscGVyLmNoZWNrRm5FeGlzdHMoXCJmdWxsVGFnRW1wdHlFbGVtZW50XCIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkge1xuICAgIHJldHVybiAoIWZpcnN0TGluZSAmJiBvcHRpb25zLnNwYWNlcyA/IFwiXFxuXCIgOiBcIlwiKSArIEFycmF5KGRlcHRoICsgMSkuam9pbihvcHRpb25zLnNwYWNlcyk7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMsIGRlcHRoKSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlQXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGlmIChcImF0dHJpYnV0ZXNGblwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXNGbihhdHRyaWJ1dGVzLCBjdXJyZW50RWxlbWVudE5hbWUsIGN1cnJlbnRFbGVtZW50KTtcbiAgICB9XG4gICAgdmFyIGtleSwgYXR0ciwgYXR0ck5hbWUsIHF1b3RlLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGF0dHJpYnV0ZXNba2V5XSAhPT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBxdW90ZSA9IG9wdGlvbnMubm9RdW90ZXNGb3JOYXRpdmVBdHRyaWJ1dGVzICYmIHR5cGVvZiBhdHRyaWJ1dGVzW2tleV0gIT09IFwic3RyaW5nXCIgPyBcIlwiIDogJ1wiJztcbiAgICAgICAgYXR0ciA9IFwiXCIgKyBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIGF0dHIgPSBhdHRyLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpO1xuICAgICAgICBhdHRyTmFtZSA9IFwiYXR0cmlidXRlTmFtZUZuXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuYXR0cmlidXRlTmFtZUZuKGtleSwgYXR0ciwgY3VycmVudEVsZW1lbnROYW1lLCBjdXJyZW50RWxlbWVudCkgOiBrZXk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9wdGlvbnMuc3BhY2VzICYmIG9wdGlvbnMuaW5kZW50QXR0cmlidXRlcyA/IHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGggKyAxLCBmYWxzZSkgOiBcIiBcIik7XG4gICAgICAgIHJlc3VsdC5wdXNoKGF0dHJOYW1lICsgXCI9XCIgKyBxdW90ZSArIChcImF0dHJpYnV0ZVZhbHVlRm5cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5hdHRyaWJ1dGVWYWx1ZUZuKGF0dHIsIGtleSwgY3VycmVudEVsZW1lbnROYW1lLCBjdXJyZW50RWxlbWVudCkgOiBhdHRyKSArIHF1b3RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXMgJiYgT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoICYmIG9wdGlvbnMuc3BhY2VzICYmIG9wdGlvbnMuaW5kZW50QXR0cmlidXRlcykge1xuICAgICAgcmVzdWx0LnB1c2god3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmFsc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlRGVjbGFyYXRpb24oZGVjbGFyYXRpb24sIG9wdGlvbnMsIGRlcHRoKSB7XG4gICAgY3VycmVudEVsZW1lbnQgPSBkZWNsYXJhdGlvbjtcbiAgICBjdXJyZW50RWxlbWVudE5hbWUgPSBcInhtbFwiO1xuICAgIHJldHVybiBvcHRpb25zLmlnbm9yZURlY2xhcmF0aW9uID8gXCJcIiA6IFwiPD94bWxcIiArIHdyaXRlQXR0cmlidXRlcyhkZWNsYXJhdGlvbltvcHRpb25zLmF0dHJpYnV0ZXNLZXldLCBvcHRpb25zLCBkZXB0aCkgKyBcIj8+XCI7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgb3B0aW9ucywgZGVwdGgpIHtcbiAgICBpZiAob3B0aW9ucy5pZ25vcmVJbnN0cnVjdGlvbikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5zdHJ1Y3Rpb25OYW1lID0gXCJpbnN0cnVjdGlvbk5hbWVGblwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluc3RydWN0aW9uTmFtZUZuKGtleSwgaW5zdHJ1Y3Rpb25ba2V5XSwgY3VycmVudEVsZW1lbnROYW1lLCBjdXJyZW50RWxlbWVudCkgOiBrZXk7XG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbltrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGluc3RydWN0aW9uO1xuICAgICAgY3VycmVudEVsZW1lbnROYW1lID0gaW5zdHJ1Y3Rpb25OYW1lO1xuICAgICAgcmV0dXJuIFwiPD9cIiArIGluc3RydWN0aW9uTmFtZSArIHdyaXRlQXR0cmlidXRlcyhpbnN0cnVjdGlvbltrZXldW29wdGlvbnMuYXR0cmlidXRlc0tleV0sIG9wdGlvbnMsIGRlcHRoKSArIFwiPz5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluc3RydWN0aW9uVmFsdWUgPSBpbnN0cnVjdGlvbltrZXldID8gaW5zdHJ1Y3Rpb25ba2V5XSA6IFwiXCI7XG4gICAgICBpZiAoXCJpbnN0cnVjdGlvbkZuXCIgaW4gb3B0aW9ucykgaW5zdHJ1Y3Rpb25WYWx1ZSA9IG9wdGlvbnMuaW5zdHJ1Y3Rpb25GbihpbnN0cnVjdGlvblZhbHVlLCBrZXksIGN1cnJlbnRFbGVtZW50TmFtZSwgY3VycmVudEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIFwiPD9cIiArIGluc3RydWN0aW9uTmFtZSArIChpbnN0cnVjdGlvblZhbHVlID8gXCIgXCIgKyBpbnN0cnVjdGlvblZhbHVlIDogXCJcIikgKyBcIj8+XCI7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHdyaXRlQ29tbWVudChjb21tZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaWdub3JlQ29tbWVudCA/IFwiXCIgOiBcIjwhLS1cIiArIChcImNvbW1lbnRGblwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmNvbW1lbnRGbihjb21tZW50LCBjdXJyZW50RWxlbWVudE5hbWUsIGN1cnJlbnRFbGVtZW50KSA6IGNvbW1lbnQpICsgXCItLT5cIjtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZUNkYXRhKGNkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaWdub3JlQ2RhdGEgPyBcIlwiIDogXCI8IVtDREFUQVtcIiArIChcImNkYXRhRm5cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5jZGF0YUZuKGNkYXRhLCBjdXJyZW50RWxlbWVudE5hbWUsIGN1cnJlbnRFbGVtZW50KSA6IGNkYXRhLnJlcGxhY2UoXCJdXT5cIiwgXCJdXV1dPjwhW0NEQVRBWz5cIikpICsgXCJdXT5cIjtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZURvY3R5cGUoZG9jdHlwZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmlnbm9yZURvY3R5cGUgPyBcIlwiIDogXCI8IURPQ1RZUEUgXCIgKyAoXCJkb2N0eXBlRm5cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kb2N0eXBlRm4oZG9jdHlwZSwgY3VycmVudEVsZW1lbnROYW1lLCBjdXJyZW50RWxlbWVudCkgOiBkb2N0eXBlKSArIFwiPlwiO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaWdub3JlVGV4dCkgcmV0dXJuIFwiXCI7XG4gICAgdGV4dCA9IFwiXCIgKyB0ZXh0O1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKTtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIik7XG4gICAgcmV0dXJuIFwidGV4dEZuXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGV4dEZuKHRleHQsIGN1cnJlbnRFbGVtZW50TmFtZSwgY3VycmVudEVsZW1lbnQpIDogdGV4dDtcbiAgfVxuICBmdW5jdGlvbiBoYXNDb250ZW50KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBpZiAoZWxlbWVudC5lbGVtZW50cyAmJiBlbGVtZW50LmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnQuZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50LmVsZW1lbnRzW2ldW29wdGlvbnMudHlwZUtleV0pIHtcbiAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50VGV4dCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCBrZXlcbiAgICAgICAgICBjYXNlIFwiY2RhdGFcIjpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluZGVudENkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gc2tpcCB0byBuZXh0IGtleVxuICAgICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvblwiOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50SW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBza2lwIHRvIG5leHQga2V5XG4gICAgICAgICAgY2FzZSBcImRvY3R5cGVcIjpcbiAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlRWxlbWVudChlbGVtZW50LCBvcHRpb25zLCBkZXB0aCkge1xuICAgIGN1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjdXJyZW50RWxlbWVudE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgdmFyIHhtbDIgPSBbXSwgZWxlbWVudE5hbWUgPSBcImVsZW1lbnROYW1lRm5cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5lbGVtZW50TmFtZUZuKGVsZW1lbnQubmFtZSwgZWxlbWVudCkgOiBlbGVtZW50Lm5hbWU7XG4gICAgeG1sMi5wdXNoKFwiPFwiICsgZWxlbWVudE5hbWUpO1xuICAgIGlmIChlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0pIHtcbiAgICAgIHhtbDIucHVzaCh3cml0ZUF0dHJpYnV0ZXMoZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldLCBvcHRpb25zLCBkZXB0aCkpO1xuICAgIH1cbiAgICB2YXIgd2l0aENsb3NpbmdUYWcgPSBlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldICYmIGVsZW1lbnRbb3B0aW9ucy5lbGVtZW50c0tleV0ubGVuZ3RoIHx8IGVsZW1lbnRbb3B0aW9ucy5hdHRyaWJ1dGVzS2V5XSAmJiBlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV1bXCJ4bWw6c3BhY2VcIl0gPT09IFwicHJlc2VydmVcIjtcbiAgICBpZiAoIXdpdGhDbG9zaW5nVGFnKSB7XG4gICAgICBpZiAoXCJmdWxsVGFnRW1wdHlFbGVtZW50Rm5cIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHdpdGhDbG9zaW5nVGFnID0gb3B0aW9ucy5mdWxsVGFnRW1wdHlFbGVtZW50Rm4oZWxlbWVudC5uYW1lLCBlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpdGhDbG9zaW5nVGFnID0gb3B0aW9ucy5mdWxsVGFnRW1wdHlFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2l0aENsb3NpbmdUYWcpIHtcbiAgICAgIHhtbDIucHVzaChcIj5cIik7XG4gICAgICBpZiAoZWxlbWVudFtvcHRpb25zLmVsZW1lbnRzS2V5XSAmJiBlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldLmxlbmd0aCkge1xuICAgICAgICB4bWwyLnB1c2god3JpdGVFbGVtZW50cyhlbGVtZW50W29wdGlvbnMuZWxlbWVudHNLZXldLCBvcHRpb25zLCBkZXB0aCArIDEpKTtcbiAgICAgICAgY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBjdXJyZW50RWxlbWVudE5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgICB9XG4gICAgICB4bWwyLnB1c2gob3B0aW9ucy5zcGFjZXMgJiYgaGFzQ29udGVudChlbGVtZW50LCBvcHRpb25zKSA/IFwiXFxuXCIgKyBBcnJheShkZXB0aCArIDEpLmpvaW4ob3B0aW9ucy5zcGFjZXMpIDogXCJcIik7XG4gICAgICB4bWwyLnB1c2goXCI8L1wiICsgZWxlbWVudE5hbWUgKyBcIj5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhtbDIucHVzaChcIi8+XCIpO1xuICAgIH1cbiAgICByZXR1cm4geG1sMi5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlRWxlbWVudHMoZWxlbWVudHMsIG9wdGlvbnMsIGRlcHRoLCBmaXJzdExpbmUpIHtcbiAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKHhtbDIsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBpbmRlbnQgPSB3cml0ZUluZGVudGF0aW9uKG9wdGlvbnMsIGRlcHRoLCBmaXJzdExpbmUgJiYgIXhtbDIpO1xuICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImVsZW1lbnRcIjpcbiAgICAgICAgICByZXR1cm4geG1sMiArIGluZGVudCArIHdyaXRlRWxlbWVudChlbGVtZW50LCBvcHRpb25zLCBkZXB0aCk7XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgcmV0dXJuIHhtbDIgKyBpbmRlbnQgKyB3cml0ZUNvbW1lbnQoZWxlbWVudFtvcHRpb25zLmNvbW1lbnRLZXldLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBcImRvY3R5cGVcIjpcbiAgICAgICAgICByZXR1cm4geG1sMiArIGluZGVudCArIHdyaXRlRG9jdHlwZShlbGVtZW50W29wdGlvbnMuZG9jdHlwZUtleV0sIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIFwiY2RhdGFcIjpcbiAgICAgICAgICByZXR1cm4geG1sMiArIChvcHRpb25zLmluZGVudENkYXRhID8gaW5kZW50IDogXCJcIikgKyB3cml0ZUNkYXRhKGVsZW1lbnRbb3B0aW9ucy5jZGF0YUtleV0sIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgIHJldHVybiB4bWwyICsgKG9wdGlvbnMuaW5kZW50VGV4dCA/IGluZGVudCA6IFwiXCIpICsgd3JpdGVUZXh0KGVsZW1lbnRbb3B0aW9ucy50ZXh0S2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJpbnN0cnVjdGlvblwiOlxuICAgICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IHt9O1xuICAgICAgICAgIGluc3RydWN0aW9uW2VsZW1lbnRbb3B0aW9ucy5uYW1lS2V5XV0gPSBlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0gPyBlbGVtZW50IDogZWxlbWVudFtvcHRpb25zLmluc3RydWN0aW9uS2V5XTtcbiAgICAgICAgICByZXR1cm4geG1sMiArIChvcHRpb25zLmluZGVudEluc3RydWN0aW9uID8gaW5kZW50IDogXCJcIikgKyB3cml0ZUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBvcHRpb25zLCBkZXB0aCk7XG4gICAgICB9XG4gICAgfSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gaGFzQ29udGVudENvbXBhY3QoZWxlbWVudCwgb3B0aW9ucywgYW55Q29udGVudCkge1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2Ugb3B0aW9ucy5wYXJlbnRLZXk6XG4gICAgICAgICAgY2FzZSBvcHRpb25zLmF0dHJpYnV0ZXNLZXk6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBza2lwIHRvIG5leHQga2V5XG4gICAgICAgICAgY2FzZSBvcHRpb25zLnRleHRLZXk6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRUZXh0IHx8IGFueUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBza2lwIHRvIG5leHQga2V5XG4gICAgICAgICAgY2FzZSBvcHRpb25zLmNkYXRhS2V5OlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5kZW50Q2RhdGEgfHwgYW55Q29udGVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIHNraXAgdG8gbmV4dCBrZXlcbiAgICAgICAgICBjYXNlIG9wdGlvbnMuaW5zdHJ1Y3Rpb25LZXk6XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbmRlbnRJbnN0cnVjdGlvbiB8fCBhbnlDb250ZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gc2tpcCB0byBuZXh0IGtleVxuICAgICAgICAgIGNhc2Ugb3B0aW9ucy5kb2N0eXBlS2V5OlxuICAgICAgICAgIGNhc2Ugb3B0aW9ucy5jb21tZW50S2V5OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZUVsZW1lbnRDb21wYWN0KGVsZW1lbnQsIG5hbWUsIG9wdGlvbnMsIGRlcHRoLCBpbmRlbnQpIHtcbiAgICBjdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY3VycmVudEVsZW1lbnROYW1lID0gbmFtZTtcbiAgICB2YXIgZWxlbWVudE5hbWUgPSBcImVsZW1lbnROYW1lRm5cIiBpbiBvcHRpb25zID8gb3B0aW9ucy5lbGVtZW50TmFtZUZuKG5hbWUsIGVsZW1lbnQpIDogbmFtZTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gXCJmdWxsVGFnRW1wdHlFbGVtZW50Rm5cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuZnVsbFRhZ0VtcHR5RWxlbWVudEZuKG5hbWUsIGVsZW1lbnQpIHx8IG9wdGlvbnMuZnVsbFRhZ0VtcHR5RWxlbWVudCA/IFwiPFwiICsgZWxlbWVudE5hbWUgKyBcIj48L1wiICsgZWxlbWVudE5hbWUgKyBcIj5cIiA6IFwiPFwiICsgZWxlbWVudE5hbWUgKyBcIi8+XCI7XG4gICAgfVxuICAgIHZhciB4bWwyID0gW107XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHhtbDIucHVzaChcIjxcIiArIGVsZW1lbnROYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB4bWwyLnB1c2goXCI+XCIgKyB3cml0ZVRleHQoZWxlbWVudCwgb3B0aW9ucykgKyBcIjwvXCIgKyBlbGVtZW50TmFtZSArIFwiPlwiKTtcbiAgICAgICAgcmV0dXJuIHhtbDIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0pIHtcbiAgICAgICAgeG1sMi5wdXNoKHdyaXRlQXR0cmlidXRlcyhlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0sIG9wdGlvbnMsIGRlcHRoKSk7XG4gICAgICB9XG4gICAgICB2YXIgd2l0aENsb3NpbmdUYWcgPSBoYXNDb250ZW50Q29tcGFjdChlbGVtZW50LCBvcHRpb25zLCB0cnVlKSB8fCBlbGVtZW50W29wdGlvbnMuYXR0cmlidXRlc0tleV0gJiYgZWxlbWVudFtvcHRpb25zLmF0dHJpYnV0ZXNLZXldW1wieG1sOnNwYWNlXCJdID09PSBcInByZXNlcnZlXCI7XG4gICAgICBpZiAoIXdpdGhDbG9zaW5nVGFnKSB7XG4gICAgICAgIGlmIChcImZ1bGxUYWdFbXB0eUVsZW1lbnRGblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICB3aXRoQ2xvc2luZ1RhZyA9IG9wdGlvbnMuZnVsbFRhZ0VtcHR5RWxlbWVudEZuKG5hbWUsIGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpdGhDbG9zaW5nVGFnID0gb3B0aW9ucy5mdWxsVGFnRW1wdHlFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAod2l0aENsb3NpbmdUYWcpIHtcbiAgICAgICAgeG1sMi5wdXNoKFwiPlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhtbDIucHVzaChcIi8+XCIpO1xuICAgICAgICByZXR1cm4geG1sMi5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB4bWwyLnB1c2god3JpdGVFbGVtZW50c0NvbXBhY3QoZWxlbWVudCwgb3B0aW9ucywgZGVwdGggKyAxLCBmYWxzZSkpO1xuICAgIGN1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjdXJyZW50RWxlbWVudE5hbWUgPSBuYW1lO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB4bWwyLnB1c2goKGluZGVudCA/IHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGgsIGZhbHNlKSA6IFwiXCIpICsgXCI8L1wiICsgZWxlbWVudE5hbWUgKyBcIj5cIik7XG4gICAgfVxuICAgIHJldHVybiB4bWwyLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVFbGVtZW50c0NvbXBhY3QoZWxlbWVudCwgb3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkge1xuICAgIHZhciBpLCBrZXksIG5vZGVzLCB4bWwyID0gW107XG4gICAgZm9yIChrZXkgaW4gZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBub2RlcyA9IGlzQXJyYXkoZWxlbWVudFtrZXldKSA/IGVsZW1lbnRba2V5XSA6IFtlbGVtZW50W2tleV1dO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSBvcHRpb25zLmRlY2xhcmF0aW9uS2V5OlxuICAgICAgICAgICAgICB4bWwyLnB1c2god3JpdGVEZWNsYXJhdGlvbihub2Rlc1tpXSwgb3B0aW9ucywgZGVwdGgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG9wdGlvbnMuaW5zdHJ1Y3Rpb25LZXk6XG4gICAgICAgICAgICAgIHhtbDIucHVzaCgob3B0aW9ucy5pbmRlbnRJbnN0cnVjdGlvbiA/IHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkgOiBcIlwiKSArIHdyaXRlSW5zdHJ1Y3Rpb24obm9kZXNbaV0sIG9wdGlvbnMsIGRlcHRoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBvcHRpb25zLmF0dHJpYnV0ZXNLZXk6XG4gICAgICAgICAgICBjYXNlIG9wdGlvbnMucGFyZW50S2V5OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy50ZXh0S2V5OlxuICAgICAgICAgICAgICB4bWwyLnB1c2goKG9wdGlvbnMuaW5kZW50VGV4dCA/IHdyaXRlSW5kZW50YXRpb24ob3B0aW9ucywgZGVwdGgsIGZpcnN0TGluZSkgOiBcIlwiKSArIHdyaXRlVGV4dChub2Rlc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5jZGF0YUtleTpcbiAgICAgICAgICAgICAgeG1sMi5wdXNoKChvcHRpb25zLmluZGVudENkYXRhID8gd3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSA6IFwiXCIpICsgd3JpdGVDZGF0YShub2Rlc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5kb2N0eXBlS2V5OlxuICAgICAgICAgICAgICB4bWwyLnB1c2god3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSArIHdyaXRlRG9jdHlwZShub2Rlc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3B0aW9ucy5jb21tZW50S2V5OlxuICAgICAgICAgICAgICB4bWwyLnB1c2god3JpdGVJbmRlbnRhdGlvbihvcHRpb25zLCBkZXB0aCwgZmlyc3RMaW5lKSArIHdyaXRlQ29tbWVudChub2Rlc1tpXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHhtbDIucHVzaCh3cml0ZUluZGVudGF0aW9uKG9wdGlvbnMsIGRlcHRoLCBmaXJzdExpbmUpICsgd3JpdGVFbGVtZW50Q29tcGFjdChub2Rlc1tpXSwga2V5LCBvcHRpb25zLCBkZXB0aCwgaGFzQ29udGVudENvbXBhY3Qobm9kZXNbaV0sIG9wdGlvbnMpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpcnN0TGluZSA9IGZpcnN0TGluZSAmJiAheG1sMi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhtbDIuam9pbihcIlwiKTtcbiAgfVxuICBqczJ4bWwgPSBmdW5jdGlvbihqcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIHhtbDIgPSBbXTtcbiAgICBjdXJyZW50RWxlbWVudCA9IGpzO1xuICAgIGN1cnJlbnRFbGVtZW50TmFtZSA9IFwiX3Jvb3RfXCI7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFjdCkge1xuICAgICAgeG1sMi5wdXNoKHdyaXRlRWxlbWVudHNDb21wYWN0KGpzLCBvcHRpb25zLCAwLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChqc1tvcHRpb25zLmRlY2xhcmF0aW9uS2V5XSkge1xuICAgICAgICB4bWwyLnB1c2god3JpdGVEZWNsYXJhdGlvbihqc1tvcHRpb25zLmRlY2xhcmF0aW9uS2V5XSwgb3B0aW9ucywgMCkpO1xuICAgICAgfVxuICAgICAgaWYgKGpzW29wdGlvbnMuZWxlbWVudHNLZXldICYmIGpzW29wdGlvbnMuZWxlbWVudHNLZXldLmxlbmd0aCkge1xuICAgICAgICB4bWwyLnB1c2god3JpdGVFbGVtZW50cyhqc1tvcHRpb25zLmVsZW1lbnRzS2V5XSwgb3B0aW9ucywgMCwgIXhtbDIubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4bWwyLmpvaW4oXCJcIik7XG4gIH07XG4gIHJldHVybiBqczJ4bWw7XG59XG52YXIganNvbjJ4bWw7XG52YXIgaGFzUmVxdWlyZWRKc29uMnhtbDtcbmZ1bmN0aW9uIHJlcXVpcmVKc29uMnhtbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkSnNvbjJ4bWwpIHJldHVybiBqc29uMnhtbDtcbiAgaGFzUmVxdWlyZWRKc29uMnhtbCA9IDE7XG4gIHZhciBqczJ4bWwyID0gcmVxdWlyZUpzMnhtbCgpO1xuICBqc29uMnhtbCA9IGZ1bmN0aW9uKGpzb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoanNvbiBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAganNvbiA9IGpzb24udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIGpzID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGpzID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gc3RydWN0dXJlIGlzIGludmFsaWRcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzID0ganNvbjtcbiAgICB9XG4gICAgcmV0dXJuIGpzMnhtbDIoanMsIG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4ganNvbjJ4bWw7XG59XG52YXIgbGliO1xudmFyIGhhc1JlcXVpcmVkTGliO1xuZnVuY3Rpb24gcmVxdWlyZUxpYigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTGliKSByZXR1cm4gbGliO1xuICBoYXNSZXF1aXJlZExpYiA9IDE7XG4gIHZhciB4bWwyanMyID0gcmVxdWlyZVhtbDJqcygpO1xuICB2YXIgeG1sMmpzb24yID0gcmVxdWlyZVhtbDJqc29uKCk7XG4gIHZhciBqczJ4bWwyID0gcmVxdWlyZUpzMnhtbCgpO1xuICB2YXIganNvbjJ4bWwyID0gcmVxdWlyZUpzb24yeG1sKCk7XG4gIGxpYiA9IHtcbiAgICB4bWwyanM6IHhtbDJqczIsXG4gICAgeG1sMmpzb246IHhtbDJqc29uMixcbiAgICBqczJ4bWw6IGpzMnhtbDIsXG4gICAganNvbjJ4bWw6IGpzb24yeG1sMlxuICB9O1xuICByZXR1cm4gbGliO1xufVxudmFyIGxpYkV4cG9ydHMgPSByZXF1aXJlTGliKCk7XG5jb25zdCBjb252ZXJ0VG9YbWxDb21wb25lbnQgPSAoZWxlbWVudCkgPT4ge1xuICBzd2l0Y2ggKGVsZW1lbnQudHlwZSkge1xuICAgIGNhc2Ugdm9pZCAwOlxuICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICBjb25zdCB4bWxDb21wb25lbnQgPSBuZXcgSW1wb3J0ZWRYbWxDb21wb25lbnQoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgY29uc3QgY2hpbGRFbGVtZW50cyA9IGVsZW1lbnQuZWxlbWVudHMgfHwgW107XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkRWxtIG9mIGNoaWxkRWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjb252ZXJ0VG9YbWxDb21wb25lbnQoY2hpbGRFbG0pO1xuICAgICAgICBpZiAoY2hpbGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHhtbENvbXBvbmVudC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHhtbENvbXBvbmVudDtcbiAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgcmV0dXJuIGVsZW1lbnQudGV4dDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbmNsYXNzIEltcG9ydGVkWG1sQ29tcG9uZW50QXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIC8vIG5vb3Bcbn1cbmNsYXNzIEltcG9ydGVkWG1sQ29tcG9uZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB4bWwgc3RyaW5nIHRvIGEgWG1sQ29tcG9uZW50IHRyZWUuXG4gICAqXG4gICAqIEBwYXJhbSBpbXBvcnRlZENvbnRlbnQgeG1sIGNvbnRlbnQgb2YgdGhlIGltcG9ydGVkIGNvbXBvbmVudFxuICAgKi9cbiAgc3RhdGljIGZyb21YbWxTdHJpbmcoaW1wb3J0ZWRDb250ZW50KSB7XG4gICAgY29uc3QgeG1sT2JqID0gbGliRXhwb3J0cy54bWwyanMoaW1wb3J0ZWRDb250ZW50LCB7IGNvbXBhY3Q6IGZhbHNlIH0pO1xuICAgIHJldHVybiBjb252ZXJ0VG9YbWxDb21wb25lbnQoeG1sT2JqKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHhtbCBzdHJpbmcgdG8gYSBYbWxDb21wb25lbnQgdHJlZS5cbiAgICpcbiAgICogQHBhcmFtIGltcG9ydGVkQ29udGVudCB4bWwgY29udGVudCBvZiB0aGUgaW1wb3J0ZWQgY29tcG9uZW50XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdHJ1Y3Rvcihyb290S2V5LCBfYXR0cikge1xuICAgIHN1cGVyKHJvb3RLZXkpO1xuICAgIGlmIChfYXR0cikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEltcG9ydGVkWG1sQ29tcG9uZW50QXR0cmlidXRlcyhfYXR0cikpO1xuICAgIH1cbiAgfVxuICBwdXNoKHhtbENvbXBvbmVudCkge1xuICAgIHRoaXMucm9vdC5wdXNoKHhtbENvbXBvbmVudCk7XG4gIH1cbn1cbmNsYXNzIEltcG9ydGVkUm9vdEVsZW1lbnRBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3RydWN0b3IoX2F0dHIpIHtcbiAgICBzdXBlcihcIlwiKTtcbiAgICB0aGlzLl9hdHRyID0gX2F0dHI7XG4gIH1cbiAgcHJlcEZvclhtbChfKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9hdHRyOiB0aGlzLl9hdHRyXG4gICAgfTtcbiAgfVxufVxuY29uc3QgV09SS0FST1VORDMgPSBcIlwiO1xuY2xhc3MgSW5pdGlhbGl6YWJsZVhtbENvbXBvbmVudCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJvb3RLZXksIGluaXRDb21wb25lbnQpIHtcbiAgICBzdXBlcihyb290S2V5KTtcbiAgICBpZiAoaW5pdENvbXBvbmVudCkge1xuICAgICAgdGhpcy5yb290ID0gaW5pdENvbXBvbmVudC5yb290O1xuICAgIH1cbiAgfVxufVxuY29uc3QgZGVjaW1hbE51bWJlciA9ICh2YWwpID0+IHtcbiAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgJyR7dmFsfScgc3BlY2lmaWVkLiBNdXN0IGJlIGFuIGludGVnZXIuYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsKTtcbn07XG5jb25zdCB1bnNpZ25lZERlY2ltYWxOdW1iZXIgPSAodmFsKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gZGVjaW1hbE51bWJlcih2YWwpO1xuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlICcke3ZhbH0nIHNwZWNpZmllZC4gTXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuYCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IGhleEJpbmFyeSA9ICh2YWwsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBleHBlY3RlZExlbmd0aCA9IGxlbmd0aCAqIDI7XG4gIGlmICh2YWwubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCB8fCBpc05hTihOdW1iZXIoYDB4JHt2YWx9YCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhleCB2YWx1ZSAnJHt2YWx9Jy4gRXhwZWN0ZWQgJHtleHBlY3RlZExlbmd0aH0gZGlnaXQgaGV4IHZhbHVlYCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5jb25zdCBsb25nSGV4TnVtYmVyID0gKHZhbCkgPT4gaGV4QmluYXJ5KHZhbCwgNCk7XG5jb25zdCBzaG9ydEhleE51bWJlciA9ICh2YWwpID0+IGhleEJpbmFyeSh2YWwsIDIpO1xuY29uc3QgdUNoYXJIZXhOdW1iZXIgPSAodmFsKSA9PiBoZXhCaW5hcnkodmFsLCAxKTtcbmNvbnN0IHVuaXZlcnNhbE1lYXN1cmVWYWx1ZSA9ICh2YWwpID0+IHtcbiAgY29uc3QgdW5pdCA9IHZhbC5zbGljZSgtMik7XG4gIGNvbnN0IGFtb3VudCA9IHZhbC5zdWJzdHJpbmcoMCwgdmFsLmxlbmd0aCAtIDIpO1xuICByZXR1cm4gYCR7TnVtYmVyKGFtb3VudCl9JHt1bml0fWA7XG59O1xuY29uc3QgcG9zaXRpdmVVbml2ZXJzYWxNZWFzdXJlVmFsdWUgPSAodmFsKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gdW5pdmVyc2FsTWVhc3VyZVZhbHVlKHZhbCk7XG4gIGlmIChwYXJzZUZsb2F0KHZhbHVlKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgJyR7dmFsdWV9JyBzcGVjaWZpZWQuIEV4cGVjdGVkIGEgcG9zaXRpdmUgbnVtYmVyLmApO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBoZXhDb2xvclZhbHVlID0gKHZhbCkgPT4ge1xuICBpZiAodmFsID09PSBcImF1dG9cIikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgY29uc3QgY29sb3IgPSB2YWwuY2hhckF0KDApID09PSBcIiNcIiA/IHZhbC5zdWJzdHJpbmcoMSkgOiB2YWw7XG4gIHJldHVybiBoZXhCaW5hcnkoY29sb3IsIDMpO1xufTtcbmNvbnN0IHNpZ25lZFR3aXBzTWVhc3VyZVZhbHVlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IHVuaXZlcnNhbE1lYXN1cmVWYWx1ZSh2YWwpIDogZGVjaW1hbE51bWJlcih2YWwpO1xuY29uc3QgaHBzTWVhc3VyZVZhbHVlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IHBvc2l0aXZlVW5pdmVyc2FsTWVhc3VyZVZhbHVlKHZhbCkgOiB1bnNpZ25lZERlY2ltYWxOdW1iZXIodmFsKTtcbmNvbnN0IHNpZ25lZEhwc01lYXN1cmVWYWx1ZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyB1bml2ZXJzYWxNZWFzdXJlVmFsdWUodmFsKSA6IGRlY2ltYWxOdW1iZXIodmFsKTtcbmNvbnN0IHR3aXBzTWVhc3VyZVZhbHVlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IHBvc2l0aXZlVW5pdmVyc2FsTWVhc3VyZVZhbHVlKHZhbCkgOiB1bnNpZ25lZERlY2ltYWxOdW1iZXIodmFsKTtcbmNvbnN0IHBlcmNlbnRhZ2VWYWx1ZSA9ICh2YWwpID0+IHtcbiAgY29uc3QgcGVyY2VudCA9IHZhbC5zdWJzdHJpbmcoMCwgdmFsLmxlbmd0aCAtIDEpO1xuICByZXR1cm4gYCR7TnVtYmVyKHBlcmNlbnQpfSVgO1xufTtcbmNvbnN0IG1lYXN1cmVtZW50T3JQZXJjZW50VmFsdWUgPSAodmFsKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxOdW1iZXIodmFsKTtcbiAgfVxuICBpZiAodmFsLnNsaWNlKC0xKSA9PT0gXCIlXCIpIHtcbiAgICByZXR1cm4gcGVyY2VudGFnZVZhbHVlKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHVuaXZlcnNhbE1lYXN1cmVWYWx1ZSh2YWwpO1xufTtcbmNvbnN0IGVpZ2h0aFBvaW50TWVhc3VyZVZhbHVlID0gdW5zaWduZWREZWNpbWFsTnVtYmVyO1xuY29uc3QgcG9pbnRNZWFzdXJlVmFsdWUgPSB1bnNpZ25lZERlY2ltYWxOdW1iZXI7XG5jb25zdCBkYXRlVGltZVZhbHVlID0gKHZhbCkgPT4gdmFsLnRvSVNPU3RyaW5nKCk7XG5jbGFzcyBPbk9mZkVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwgPSB0cnVlKSB7XG4gICAgc3VwZXIobmFtZSk7XG4gICAgaWYgKHZhbCAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEF0dHJpYnV0ZXMoeyB2YWwgfSkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgSHBzTWVhc3VyZUVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwpIHtcbiAgICBzdXBlcihuYW1lKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQXR0cmlidXRlcyh7IHZhbDogaHBzTWVhc3VyZVZhbHVlKHZhbCkgfSkpO1xuICB9XG59XG5jbGFzcyBFbXB0eUVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xufVxuY2xhc3MgU3RyaW5nVmFsdWVFbGVtZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobmFtZSwgdmFsKSB7XG4gICAgc3VwZXIobmFtZSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IEF0dHJpYnV0ZXMoeyB2YWwgfSkpO1xuICB9XG59XG5jb25zdCBjcmVhdGVTdHJpbmdFbGVtZW50ID0gKG5hbWUsIHZhbHVlKSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgdmFsdWU6IHsga2V5OiBcInc6dmFsXCIsIHZhbHVlIH1cbiAgfVxufSk7XG5jbGFzcyBOdW1iZXJWYWx1ZUVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwpIHtcbiAgICBzdXBlcihuYW1lKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQXR0cmlidXRlcyh7IHZhbCB9KSk7XG4gIH1cbn1cbmNsYXNzIFN0cmluZ0VudW1WYWx1ZUVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwpIHtcbiAgICBzdXBlcihuYW1lKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQXR0cmlidXRlcyh7IHZhbCB9KSk7XG4gIH1cbn1cbmNsYXNzIFN0cmluZ0NvbnRhaW5lciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHZhbCkge1xuICAgIHN1cGVyKG5hbWUpO1xuICAgIHRoaXMucm9vdC5wdXNoKHZhbCk7XG4gIH1cbn1cbmNsYXNzIEJ1aWxkZXJFbGVtZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUsXG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9KSB7XG4gICAgc3VwZXIobmFtZSk7XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOZXh0QXR0cmlidXRlQ29tcG9uZW50KGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaCguLi5jaGlsZHJlbik7XG4gICAgfVxuICB9XG59XG5jb25zdCBBbGlnbm1lbnRUeXBlID0ge1xuICAvKiogQWxpZ24gU3RhcnQgKi9cbiAgU1RBUlQ6IFwic3RhcnRcIixcbiAgLyoqIEFsaWduIENlbnRlciAqL1xuICBDRU5URVI6IFwiY2VudGVyXCIsXG4gIC8qKiBFbmQgKi9cbiAgRU5EOiBcImVuZFwiLFxuICAvKiogSnVzdGlmaWVkICovXG4gIEJPVEg6IFwiYm90aFwiLFxuICAvKiogTWVkaXVtIEthc2hpZGEgTGVuZ3RoICovXG4gIE1FRElVTV9LQVNISURBOiBcIm1lZGl1bUthc2hpZGFcIixcbiAgLyoqIERpc3RyaWJ1dGUgQWxsIENoYXJhY3RlcnMgRXF1YWxseSAqL1xuICBESVNUUklCVVRFOiBcImRpc3RyaWJ1dGVcIixcbiAgLyoqIEFsaWduIHRvIExpc3QgVGFiICovXG4gIE5VTV9UQUI6IFwibnVtVGFiXCIsXG4gIC8qKiBXaWRlc3QgS2FzaGlkYSBMZW5ndGggKi9cbiAgSElHSF9LQVNISURBOiBcImhpZ2hLYXNoaWRhXCIsXG4gIC8qKiBMb3cgS2FzaGlkYSBMZW5ndGggKi9cbiAgTE9XX0tBU0hJREE6IFwibG93S2FzaGlkYVwiLFxuICAvKiogVGhhaSBMYW5ndWFnZSBKdXN0aWZpY2F0aW9uICovXG4gIFRIQUlfRElTVFJJQlVURTogXCJ0aGFpRGlzdHJpYnV0ZVwiLFxuICAvKiogQWxpZ24gTGVmdCAqL1xuICBMRUZUOiBcImxlZnRcIixcbiAgLyoqIEFsaWduIFJpZ2h0ICovXG4gIFJJR0hUOiBcInJpZ2h0XCIsXG4gIC8qKiBKdXN0aWZpZWQgKi9cbiAgSlVTVElGSUVEOiBcImJvdGhcIlxufTtcbmNsYXNzIEFsaWdubWVudEF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgdmFsOiBcInc6dmFsXCIgfSk7XG4gIH1cbn1cbmNsYXNzIEFsaWdubWVudCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUyKSB7XG4gICAgc3VwZXIoXCJ3OmpjXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBBbGlnbm1lbnRBdHRyaWJ1dGVzKHsgdmFsOiB0eXBlMiB9KSk7XG4gIH1cbn1cbmNsYXNzIEJvcmRlckVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50TmFtZSwgeyBjb2xvciwgc2l6ZSwgc3BhY2UsIHN0eWxlIH0pIHtcbiAgICBzdXBlcihlbGVtZW50TmFtZSk7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQm9yZGVyc0F0dHJpYnV0ZXMoe1xuICAgICAgICBzdHlsZSxcbiAgICAgICAgY29sb3I6IGNvbG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZXhDb2xvclZhbHVlKGNvbG9yKSxcbiAgICAgICAgc2l6ZTogc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWlnaHRoUG9pbnRNZWFzdXJlVmFsdWUoc2l6ZSksXG4gICAgICAgIHNwYWNlOiBzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRNZWFzdXJlVmFsdWUoc3BhY2UpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIEJvcmRlcnNBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBzdHlsZTogXCJ3OnZhbFwiLFxuICAgICAgY29sb3I6IFwidzpjb2xvclwiLFxuICAgICAgc2l6ZTogXCJ3OnN6XCIsXG4gICAgICBzcGFjZTogXCJ3OnNwYWNlXCJcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQm9yZGVyU3R5bGUgPSB7XG4gIC8qKiBhIHNpbmdsZSBsaW5lICovXG4gIFNJTkdMRTogXCJzaW5nbGVcIixcbiAgLyoqIGEgbGluZSB3aXRoIGEgc2VyaWVzIG9mIGFsdGVybmF0aW5nIHRoaW4gYW5kIHRoaWNrIHN0cm9rZXMgKi9cbiAgREFTSF9ET1RfU1RST0tFRDogXCJkYXNoRG90U3Ryb2tlZFwiLFxuICAvKiogYSBkYXNoZWQgbGluZSAqL1xuICBEQVNIRUQ6IFwiZGFzaGVkXCIsXG4gIC8qKiBhIGRhc2hlZCBsaW5lIHdpdGggc21hbGwgZ2FwcyAqL1xuICBEQVNIX1NNQUxMX0dBUDogXCJkYXNoU21hbGxHYXBcIixcbiAgLyoqIGEgbGluZSB3aXRoIGFsdGVybmF0aW5nIGRvdHMgYW5kIGRhc2hlcyAqL1xuICBET1RfREFTSDogXCJkb3REYXNoXCIsXG4gIC8qKiBhIGxpbmUgd2l0aCBhIHJlcGVhdGluZyBkb3QgLSBkb3QgLSBkYXNoIHNlcXVlbmNlICovXG4gIERPVF9ET1RfREFTSDogXCJkb3REb3REYXNoXCIsXG4gIC8qKiBhIGRvdHRlZCBsaW5lICovXG4gIERPVFRFRDogXCJkb3R0ZWRcIixcbiAgLyoqIGEgZG91YmxlIGxpbmUgKi9cbiAgRE9VQkxFOiBcImRvdWJsZVwiLFxuICAvKiogYSBkb3VibGUgd2F2eSBsaW5lICovXG4gIERPVUJMRV9XQVZFOiBcImRvdWJsZVdhdmVcIixcbiAgLyoqIGFuIGluc2V0IHNldCBvZiBsaW5lcyAqL1xuICBJTlNFVDogXCJpbnNldFwiLFxuICAvKiogbm8gYm9yZGVyICovXG4gIE5JTDogXCJuaWxcIixcbiAgLyoqIG5vIGJvcmRlciAqL1xuICBOT05FOiBcIm5vbmVcIixcbiAgLyoqIGFuIG91dHNldCBzZXQgb2YgbGluZXMgKi9cbiAgT1VUU0VUOiBcIm91dHNldFwiLFxuICAvKiogYSBzaW5nbGUgbGluZSAqL1xuICBUSElDSzogXCJ0aGlja1wiLFxuICAvKiogYSB0aGljayBsaW5lIGNvbnRhaW5lZCB3aXRoaW4gYSB0aGluIGxpbmUgd2l0aCBhIGxhcmdlLXNpemVkIGludGVybWVkaWF0ZSBnYXAgKi9cbiAgVEhJQ0tfVEhJTl9MQVJHRV9HQVA6IFwidGhpY2tUaGluTGFyZ2VHYXBcIixcbiAgLyoqIGEgdGhpY2sgbGluZSBjb250YWluZWQgd2l0aGluIGEgdGhpbiBsaW5lIHdpdGggYSBtZWRpdW0tc2l6ZWQgaW50ZXJtZWRpYXRlIGdhcCAqL1xuICBUSElDS19USElOX01FRElVTV9HQVA6IFwidGhpY2tUaGluTWVkaXVtR2FwXCIsXG4gIC8qKiBhIHRoaWNrIGxpbmUgY29udGFpbmVkIHdpdGhpbiBhIHRoaW4gbGluZSB3aXRoIGEgc21hbGwgaW50ZXJtZWRpYXRlIGdhcCAqL1xuICBUSElDS19USElOX1NNQUxMX0dBUDogXCJ0aGlja1RoaW5TbWFsbEdhcFwiLFxuICAvKiogYSB0aGluIGxpbmUgY29udGFpbmVkIHdpdGhpbiBhIHRoaWNrIGxpbmUgd2l0aCBhIGxhcmdlLXNpemVkIGludGVybWVkaWF0ZSBnYXAgKi9cbiAgVEhJTl9USElDS19MQVJHRV9HQVA6IFwidGhpblRoaWNrTGFyZ2VHYXBcIixcbiAgLyoqIGEgdGhpY2sgbGluZSBjb250YWluZWQgd2l0aGluIGEgdGhpbiBsaW5lIHdpdGggYSBtZWRpdW0tc2l6ZWQgaW50ZXJtZWRpYXRlIGdhcCAqL1xuICBUSElOX1RISUNLX01FRElVTV9HQVA6IFwidGhpblRoaWNrTWVkaXVtR2FwXCIsXG4gIC8qKiBhIHRoaWNrIGxpbmUgY29udGFpbmVkIHdpdGhpbiBhIHRoaW4gbGluZSB3aXRoIGEgc21hbGwgaW50ZXJtZWRpYXRlIGdhcCAqL1xuICBUSElOX1RISUNLX1NNQUxMX0dBUDogXCJ0aGluVGhpY2tTbWFsbEdhcFwiLFxuICAvKiogYSB0aGluLXRoaWNrLXRoaW4gbGluZSB3aXRoIGEgbGFyZ2UgZ2FwICovXG4gIFRISU5fVEhJQ0tfVEhJTl9MQVJHRV9HQVA6IFwidGhpblRoaWNrVGhpbkxhcmdlR2FwXCIsXG4gIC8qKiBhIHRoaW4tdGhpY2stdGhpbiBsaW5lIHdpdGggYSBtZWRpdW0gZ2FwICovXG4gIFRISU5fVEhJQ0tfVEhJTl9NRURJVU1fR0FQOiBcInRoaW5UaGlja1RoaW5NZWRpdW1HYXBcIixcbiAgLyoqIGEgdGhpbi10aGljay10aGluIGxpbmUgd2l0aCBhIHNtYWxsIGdhcCAqL1xuICBUSElOX1RISUNLX1RISU5fU01BTExfR0FQOiBcInRoaW5UaGlja1RoaW5TbWFsbEdhcFwiLFxuICAvKiogYSB0aHJlZS1zdGFnZWQgZ3JhZGllbnQgbGluZSwgZ2V0dGluZyBkYXJrZXIgdG93YXJkcyB0aGUgcGFyYWdyYXBoICovXG4gIFRIUkVFX0RfRU1CT1NTOiBcInRocmVlREVtYm9zc1wiLFxuICAvKiogYSB0aHJlZS1zdGFnZWQgZ3JhZGllbnQgbGlrZSwgZ2V0dGluZyBkYXJrZXIgYXdheSBmcm9tIHRoZSBwYXJhZ3JhcGggKi9cbiAgVEhSRUVfRF9FTkdSQVZFOiBcInRocmVlREVuZ3JhdmVcIixcbiAgLyoqIGEgdHJpcGxlIGxpbmUgKi9cbiAgVFJJUExFOiBcInRyaXBsZVwiLFxuICAvKiogYSB3YXZ5IGxpbmUgKi9cbiAgV0FWRTogXCJ3YXZlXCJcbn07XG5jbGFzcyBCb3JkZXIgZXh0ZW5kcyBJZ25vcmVJZkVtcHR5WG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzpwQmRyXCIpO1xuICAgIGlmIChvcHRpb25zLnRvcCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OnRvcFwiLCBvcHRpb25zLnRvcCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ib3R0b20pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzpib3R0b21cIiwgb3B0aW9ucy5ib3R0b20pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVmdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmxlZnRcIiwgb3B0aW9ucy5sZWZ0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJpZ2h0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6cmlnaHRcIiwgb3B0aW9ucy5yaWdodCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgVGhlbWF0aWNCcmVhayBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpwQmRyXCIpO1xuICAgIGNvbnN0IGJvdHRvbSA9IG5ldyBCb3JkZXJFbGVtZW50KFwidzpib3R0b21cIiwge1xuICAgICAgY29sb3I6IFwiYXV0b1wiLFxuICAgICAgc3BhY2U6IDEsXG4gICAgICBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLFxuICAgICAgc2l6ZTogNlxuICAgIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKGJvdHRvbSk7XG4gIH1cbn1cbmNsYXNzIEluZGVudCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHsgc3RhcnQsIGVuZCwgbGVmdCwgcmlnaHQsIGhhbmdpbmcsIGZpcnN0TGluZSB9KSB7XG4gICAgc3VwZXIoXCJ3OmluZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBOZXh0QXR0cmlidXRlQ29tcG9uZW50KHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBrZXk6IFwidzpzdGFydFwiLFxuICAgICAgICAgIHZhbHVlOiBzdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUoc3RhcnQpXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgIGtleTogXCJ3OmVuZFwiLFxuICAgICAgICAgIHZhbHVlOiBlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNpZ25lZFR3aXBzTWVhc3VyZVZhbHVlKGVuZClcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIGtleTogXCJ3OmxlZnRcIixcbiAgICAgICAgICB2YWx1ZTogbGVmdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUobGVmdClcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICBrZXk6IFwidzpyaWdodFwiLFxuICAgICAgICAgIHZhbHVlOiByaWdodCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUocmlnaHQpXG4gICAgICAgIH0sXG4gICAgICAgIGhhbmdpbmc6IHtcbiAgICAgICAgICBrZXk6IFwidzpoYW5naW5nXCIsXG4gICAgICAgICAgdmFsdWU6IGhhbmdpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR3aXBzTWVhc3VyZVZhbHVlKGhhbmdpbmcpXG4gICAgICAgIH0sXG4gICAgICAgIGZpcnN0TGluZToge1xuICAgICAgICAgIGtleTogXCJ3OmZpcnN0TGluZVwiLFxuICAgICAgICAgIHZhbHVlOiBmaXJzdExpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR3aXBzTWVhc3VyZVZhbHVlKGZpcnN0TGluZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5sZXQgQnJlYWskMSA9IGNsYXNzIEJyZWFrIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmJyXCIpO1xuICB9XG59O1xuY29uc3QgRmllbGRDaGFyYWN0ZXJUeXBlID0ge1xuICBCRUdJTjogXCJiZWdpblwiLFxuICBFTkQ6IFwiZW5kXCIsXG4gIFNFUEFSQVRFOiBcInNlcGFyYXRlXCJcbn07XG5jbGFzcyBGaWRDaGFyQXR0cnMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgdHlwZTogXCJ3OmZsZENoYXJUeXBlXCIsIGRpcnR5OiBcInc6ZGlydHlcIiB9KTtcbiAgfVxufVxuY2xhc3MgQmVnaW4gZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihkaXJ0eSkge1xuICAgIHN1cGVyKFwidzpmbGRDaGFyXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBGaWRDaGFyQXR0cnMoeyB0eXBlOiBGaWVsZENoYXJhY3RlclR5cGUuQkVHSU4sIGRpcnR5IH0pKTtcbiAgfVxufVxuY2xhc3MgU2VwYXJhdGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihkaXJ0eSkge1xuICAgIHN1cGVyKFwidzpmbGRDaGFyXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBGaWRDaGFyQXR0cnMoeyB0eXBlOiBGaWVsZENoYXJhY3RlclR5cGUuU0VQQVJBVEUsIGRpcnR5IH0pKTtcbiAgfVxufVxuY2xhc3MgRW5kIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZGlydHkpIHtcbiAgICBzdXBlcihcInc6ZmxkQ2hhclwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRmlkQ2hhckF0dHJzKHsgdHlwZTogRmllbGRDaGFyYWN0ZXJUeXBlLkVORCwgZGlydHkgfSkpO1xuICB9XG59XG5jb25zdCBIb3Jpem9udGFsUG9zaXRpb25BbGlnbiA9IHtcbiAgQ0VOVEVSOiBcImNlbnRlclwiLFxuICBJTlNJREU6IFwiaW5zaWRlXCIsXG4gIExFRlQ6IFwibGVmdFwiLFxuICBPVVRTSURFOiBcIm91dHNpZGVcIixcbiAgUklHSFQ6IFwicmlnaHRcIlxufTtcbmNvbnN0IFZlcnRpY2FsUG9zaXRpb25BbGlnbiA9IHtcbiAgQk9UVE9NOiBcImJvdHRvbVwiLFxuICBDRU5URVI6IFwiY2VudGVyXCIsXG4gIElOU0lERTogXCJpbnNpZGVcIixcbiAgT1VUU0lERTogXCJvdXRzaWRlXCIsXG4gIFRPUDogXCJ0b3BcIlxufTtcbmNvbnN0IE51bWJlckZvcm1hdCQxID0ge1xuICBERUNJTUFMOiBcImRlY2ltYWxcIixcbiAgVVBQRVJfUk9NQU46IFwidXBwZXJSb21hblwiLFxuICBMT1dFUl9ST01BTjogXCJsb3dlclJvbWFuXCIsXG4gIFVQUEVSX0xFVFRFUjogXCJ1cHBlckxldHRlclwiLFxuICBMT1dFUl9MRVRURVI6IFwibG93ZXJMZXR0ZXJcIixcbiAgT1JESU5BTDogXCJvcmRpbmFsXCIsXG4gIENBUkRJTkFMX1RFWFQ6IFwiY2FyZGluYWxUZXh0XCIsXG4gIE9SRElOQUxfVEVYVDogXCJvcmRpbmFsVGV4dFwiLFxuICBIRVg6IFwiaGV4XCIsXG4gIENISUNBR086IFwiY2hpY2Fnb1wiLFxuICBJREVPR1JBUEhfRElHSVRBTDogXCJpZGVvZ3JhcGhEaWdpdGFsXCIsXG4gIEpBUEFORVNFX0NPVU5USU5HOiBcImphcGFuZXNlQ291bnRpbmdcIixcbiAgQUlVRU86IFwiYWl1ZW9cIixcbiAgSVJPSEE6IFwiaXJvaGFcIixcbiAgREVDSU1BTF9GVUxMX1dJRFRIOiBcImRlY2ltYWxGdWxsV2lkdGhcIixcbiAgREVDSU1BTF9IQUxGX1dJRFRIOiBcImRlY2ltYWxIYWxmV2lkdGhcIixcbiAgSkFQQU5FU0VfTEVHQUw6IFwiamFwYW5lc2VMZWdhbFwiLFxuICBKQVBBTkVTRV9ESUdJVEFMX1RFTl9USE9VU0FORDogXCJqYXBhbmVzZURpZ2l0YWxUZW5UaG91c2FuZFwiLFxuICBERUNJTUFMX0VOQ0xPU0VEX0NJUkNMRTogXCJkZWNpbWFsRW5jbG9zZWRDaXJjbGVcIixcbiAgREVDSU1BTF9GVUxMX1dJRFRIXzI6IFwiZGVjaW1hbEZ1bGxXaWR0aDJcIixcbiAgQUlVRU9fRlVMTF9XSURUSDogXCJhaXVlb0Z1bGxXaWR0aFwiLFxuICBJUk9IQV9GVUxMX1dJRFRIOiBcImlyb2hhRnVsbFdpZHRoXCIsXG4gIERFQ0lNQUxfWkVSTzogXCJkZWNpbWFsWmVyb1wiLFxuICBCVUxMRVQ6IFwiYnVsbGV0XCIsXG4gIEdBTkFEQTogXCJnYW5hZGFcIixcbiAgQ0hPU1VORzogXCJjaG9zdW5nXCIsXG4gIERFQ0lNQUxfRU5DTE9TRURfRlVMTF9TVE9QOiBcImRlY2ltYWxFbmNsb3NlZEZ1bGxzdG9wXCIsXG4gIERFQ0lNQUxfRU5DTE9TRURfUEFSRU46IFwiZGVjaW1hbEVuY2xvc2VkUGFyZW5cIixcbiAgREVDSU1BTF9FTkNMT1NFRF9DSVJDTEVfQ0hJTkVTRTogXCJkZWNpbWFsRW5jbG9zZWRDaXJjbGVDaGluZXNlXCIsXG4gIElERU9HUkFQSF9FTkNMT1NFRF9DSVJDTEU6IFwiaWRlb2dyYXBoRW5jbG9zZWRDaXJjbGVcIixcbiAgSURFT0dSQVBIX1RSQURJVElPTkFMOiBcImlkZW9ncmFwaFRyYWRpdGlvbmFsXCIsXG4gIElERU9HUkFQSF9aT0RJQUM6IFwiaWRlb2dyYXBoWm9kaWFjXCIsXG4gIElERU9HUkFQSF9aT0RJQUNfVFJBRElUSU9OQUw6IFwiaWRlb2dyYXBoWm9kaWFjVHJhZGl0aW9uYWxcIixcbiAgVEFJV0FORVNFX0NPVU5USU5HOiBcInRhaXdhbmVzZUNvdW50aW5nXCIsXG4gIElERU9HUkFQSF9MRUdBTF9UUkFESVRJT05BTDogXCJpZGVvZ3JhcGhMZWdhbFRyYWRpdGlvbmFsXCIsXG4gIFRBSVdBTkVTRV9DT1VOVElOR19USE9VU0FORDogXCJ0YWl3YW5lc2VDb3VudGluZ1Rob3VzYW5kXCIsXG4gIFRBSVdBTkVTRV9ESUdJVEFMOiBcInRhaXdhbmVzZURpZ2l0YWxcIixcbiAgQ0hJTkVTRV9DT1VOVElORzogXCJjaGluZXNlQ291bnRpbmdcIixcbiAgQ0hJTkVTRV9MRUdBTF9TSU1QTElGSUVEOiBcImNoaW5lc2VMZWdhbFNpbXBsaWZpZWRcIixcbiAgQ0hJTkVTRV9DT1VOVElOR19URU5fVEhPVVNBTkQ6IFwiY2hpbmVzZUNvdW50aW5nVGhvdXNhbmRcIixcbiAgS09SRUFOX0RJR0lUQUw6IFwia29yZWFuRGlnaXRhbFwiLFxuICBLT1JFQU5fQ09VTlRJTkc6IFwia29yZWFuQ291bnRpbmdcIixcbiAgS09SRUFOX0xFR0FMOiBcImtvcmVhbkxlZ2FsXCIsXG4gIEtPUkVBTl9ESUdJVEFMXzI6IFwia29yZWFuRGlnaXRhbDJcIixcbiAgVklFVE5BTUVTRV9DT1VOVElORzogXCJ2aWV0bmFtZXNlQ291bnRpbmdcIixcbiAgUlVTU0lBTl9MT1dFUjogXCJydXNzaWFuTG93ZXJcIixcbiAgUlVTU0lBTl9VUFBFUjogXCJydXNzaWFuVXBwZXJcIixcbiAgTk9ORTogXCJub25lXCIsXG4gIE5VTUJFUl9JTl9EQVNIOiBcIm51bWJlckluRGFzaFwiLFxuICBIRUJSRVdfMTogXCJoZWJyZXcxXCIsXG4gIEhFQlJFV18yOiBcImhlYnJldzJcIixcbiAgQVJBQklDX0FMUEhBOiBcImFyYWJpY0FscGhhXCIsXG4gIEFSQUJJQ19BQkpBRDogXCJhcmFiaWNBYmphZFwiLFxuICBISU5ESV9WT1dFTFM6IFwiaGluZGlWb3dlbHNcIixcbiAgSElORElfQ09OU09OQU5UUzogXCJoaW5kaUNvbnNvbmFudHNcIixcbiAgSElORElfTlVNQkVSUzogXCJoaW5kaU51bWJlcnNcIixcbiAgSElORElfQ09VTlRJTkc6IFwiaGluZGlDb3VudGluZ1wiLFxuICBUSEFJX0xFVFRFUlM6IFwidGhhaUxldHRlcnNcIixcbiAgVEhBSV9OVU1CRVJTOiBcInRoYWlOdW1iZXJzXCIsXG4gIFRIQUlfQ09VTlRJTkc6IFwidGhhaUNvdW50aW5nXCIsXG4gIEJBSFRfVEVYVDogXCJiYWh0VGV4dFwiLFxuICBET0xMQVJfVEVYVDogXCJkb2xsYXJUZXh0XCJcbiAgLy8gICA8eHNkOmVudW1lcmF0aW9uIHZhbHVlPVwiY3VzdG9tXCIvPlxufTtcbmNvbnN0IFNwYWNlVHlwZSA9IHtcbiAgREVGQVVMVDogXCJkZWZhdWx0XCIsXG4gIFBSRVNFUlZFOiBcInByZXNlcnZlXCJcbn07XG5jbGFzcyBUZXh0QXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyBzcGFjZTogXCJ4bWw6c3BhY2VcIiB9KTtcbiAgfVxufVxuY2xhc3MgUGFnZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzppbnN0clRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgdGhpcy5yb290LnB1c2goXCJQQUdFXCIpO1xuICB9XG59XG5jbGFzcyBOdW1iZXJPZlBhZ2VzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3Omluc3RyVGV4dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dEF0dHJpYnV0ZXMoeyBzcGFjZTogU3BhY2VUeXBlLlBSRVNFUlZFIH0pKTtcbiAgICB0aGlzLnJvb3QucHVzaChcIk5VTVBBR0VTXCIpO1xuICB9XG59XG5jbGFzcyBOdW1iZXJPZlBhZ2VzU2VjdGlvbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzppbnN0clRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgdGhpcy5yb290LnB1c2goXCJTRUNUSU9OUEFHRVNcIik7XG4gIH1cbn1cbmNsYXNzIEN1cnJlbnRTZWN0aW9uIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3Omluc3RyVGV4dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dEF0dHJpYnV0ZXMoeyBzcGFjZTogU3BhY2VUeXBlLlBSRVNFUlZFIH0pKTtcbiAgICB0aGlzLnJvb3QucHVzaChcIlNFQ1RJT05cIik7XG4gIH1cbn1cbmNsYXNzIFNoYWRpbmdBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBmaWxsOiBcInc6ZmlsbFwiLFxuICAgICAgY29sb3I6IFwidzpjb2xvclwiLFxuICAgICAgdHlwZTogXCJ3OnZhbFwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFNoYWRpbmcgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7IGZpbGwsIGNvbG9yLCB0eXBlOiB0eXBlMiB9KSB7XG4gICAgc3VwZXIoXCJ3OnNoZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBTaGFkaW5nQXR0cmlidXRlcyh7XG4gICAgICAgIGZpbGw6IGZpbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhleENvbG9yVmFsdWUoZmlsbCksXG4gICAgICAgIGNvbG9yOiBjb2xvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGV4Q29sb3JWYWx1ZShjb2xvciksXG4gICAgICAgIHR5cGU6IHR5cGUyXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFNoYWRpbmdUeXBlID0ge1xuICBDTEVBUjogXCJjbGVhclwiLFxuICBESUFHT05BTF9DUk9TUzogXCJkaWFnQ3Jvc3NcIixcbiAgRElBR09OQUxfU1RSSVBFOiBcImRpYWdTdHJpcGVcIixcbiAgSE9SSVpPTlRBTF9DUk9TUzogXCJob3J6Q3Jvc3NcIixcbiAgSE9SSVpPTlRBTF9TVFJJUEU6IFwiaG9yelN0cmlwZVwiLFxuICBOSUw6IFwibmlsXCIsXG4gIFBFUkNFTlRfNTogXCJwY3Q1XCIsXG4gIFBFUkNFTlRfMTA6IFwicGN0MTBcIixcbiAgUEVSQ0VOVF8xMjogXCJwY3QxMlwiLFxuICBQRVJDRU5UXzE1OiBcInBjdDE1XCIsXG4gIFBFUkNFTlRfMjA6IFwicGN0MjBcIixcbiAgUEVSQ0VOVF8yNTogXCJwY3QyNVwiLFxuICBQRVJDRU5UXzMwOiBcInBjdDMwXCIsXG4gIFBFUkNFTlRfMzU6IFwicGN0MzVcIixcbiAgUEVSQ0VOVF8zNzogXCJwY3QzN1wiLFxuICBQRVJDRU5UXzQwOiBcInBjdDQwXCIsXG4gIFBFUkNFTlRfNDU6IFwicGN0NDVcIixcbiAgUEVSQ0VOVF81MDogXCJwY3Q1MFwiLFxuICBQRVJDRU5UXzU1OiBcInBjdDU1XCIsXG4gIFBFUkNFTlRfNjA6IFwicGN0NjBcIixcbiAgUEVSQ0VOVF82MjogXCJwY3Q2MlwiLFxuICBQRVJDRU5UXzY1OiBcInBjdDY1XCIsXG4gIFBFUkNFTlRfNzA6IFwicGN0NzBcIixcbiAgUEVSQ0VOVF83NTogXCJwY3Q3NVwiLFxuICBQRVJDRU5UXzgwOiBcInBjdDgwXCIsXG4gIFBFUkNFTlRfODU6IFwicGN0ODVcIixcbiAgUEVSQ0VOVF84NzogXCJwY3Q4N1wiLFxuICBQRVJDRU5UXzkwOiBcInBjdDkwXCIsXG4gIFBFUkNFTlRfOTU6IFwicGN0OTVcIixcbiAgUkVWRVJTRV9ESUFHT05BTF9TVFJJUEU6IFwicmV2ZXJzZURpYWdTdHJpcGVcIixcbiAgU09MSUQ6IFwic29saWRcIixcbiAgVEhJTl9ESUFHT05BTF9DUk9TUzogXCJ0aGluRGlhZ0Nyb3NzXCIsXG4gIFRISU5fRElBR09OQUxfU1RSSVBFOiBcInRoaW5EaWFnU3RyaXBlXCIsXG4gIFRISU5fSE9SSVpPTlRBTF9DUk9TUzogXCJ0aGluSG9yekNyb3NzXCIsXG4gIFRISU5fUkVWRVJTRV9ESUFHT05BTF9TVFJJUEU6IFwidGhpblJldmVyc2VEaWFnU3RyaXBlXCIsXG4gIFRISU5fVkVSVElDQUxfU1RSSVBFOiBcInRoaW5WZXJ0U3RyaXBlXCIsXG4gIFZFUlRJQ0FMX1NUUklQRTogXCJ2ZXJ0U3RyaXBlXCJcbn07XG5jbGFzcyBDaGFuZ2VBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBpZDogXCJ3OmlkXCIsXG4gICAgICBhdXRob3I6IFwidzphdXRob3JcIixcbiAgICAgIGRhdGU6IFwidzpkYXRlXCJcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgRW1waGFzaXNNYXJrVHlwZSA9IHtcbiAgRE9UOiBcImRvdFwiXG59O1xuY2xhc3MgQmFzZUVtcGhhc2lzTWFyayBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVtcGhhc2lzTWFya1R5cGUpIHtcbiAgICBzdXBlcihcInc6ZW1cIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogZW1waGFzaXNNYXJrVHlwZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBFbXBoYXNpc01hcmsgZXh0ZW5kcyBCYXNlRW1waGFzaXNNYXJrIHtcbiAgY29uc3RydWN0b3IoZW1waGFzaXNNYXJrVHlwZSA9IEVtcGhhc2lzTWFya1R5cGUuRE9UKSB7XG4gICAgc3VwZXIoZW1waGFzaXNNYXJrVHlwZSk7XG4gIH1cbn1cbmNsYXNzIERvdEVtcGhhc2lzTWFyayBleHRlbmRzIEJhc2VFbXBoYXNpc01hcmsge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihFbXBoYXNpc01hcmtUeXBlLkRPVCk7XG4gIH1cbn1cbmNsYXNzIENoYXJhY3RlclNwYWNpbmcgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzpzcGFjaW5nXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IHNpZ25lZFR3aXBzTWVhc3VyZVZhbHVlKHZhbHVlKVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBDb2xvciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yKSB7XG4gICAgc3VwZXIoXCJ3OmNvbG9yXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IGhleENvbG9yVmFsdWUoY29sb3IpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbG9yKSB7XG4gICAgc3VwZXIoXCJ3OmhpZ2hsaWdodFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiBjb2xvclxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBIaWdobGlnaHRDb21wbGV4U2NyaXB0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICBzdXBlcihcInc6aGlnaGxpZ2h0Q3NcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogY29sb3JcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlTGFuZ3VhZ2VDb21wb25lbnQgPSAob3B0aW9ucykgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3OmxhbmdcIixcbiAgYXR0cmlidXRlczoge1xuICAgIHZhbHVlOiB7XG4gICAgICBrZXk6IFwidzp2YWxcIixcbiAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlXG4gICAgfSxcbiAgICBlYXN0QXNpYToge1xuICAgICAga2V5OiBcInc6ZWFzdEFzaWFcIixcbiAgICAgIHZhbHVlOiBvcHRpb25zLmVhc3RBc2lhXG4gICAgfSxcbiAgICBiaWRpcmVjdGlvbmFsOiB7XG4gICAgICBrZXk6IFwidzpiaWRpXCIsXG4gICAgICB2YWx1ZTogb3B0aW9ucy5iaWRpcmVjdGlvbmFsXG4gICAgfVxuICB9XG59KTtcbmNsYXNzIFJ1bkZvbnRBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBhc2NpaTogXCJ3OmFzY2lpXCIsXG4gICAgICBjczogXCJ3OmNzXCIsXG4gICAgICBlYXN0QXNpYTogXCJ3OmVhc3RBc2lhXCIsXG4gICAgICBoQW5zaTogXCJ3OmhBbnNpXCIsXG4gICAgICBoaW50OiBcInc6aGludFwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFJ1bkZvbnRzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobmFtZU9yQXR0cnMsIGhpbnQpIHtcbiAgICBzdXBlcihcInc6ckZvbnRzXCIpO1xuICAgIGlmICh0eXBlb2YgbmFtZU9yQXR0cnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lT3JBdHRycztcbiAgICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgICBuZXcgUnVuRm9udEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGFzY2lpOiBuYW1lLFxuICAgICAgICAgIGNzOiBuYW1lLFxuICAgICAgICAgIGVhc3RBc2lhOiBuYW1lLFxuICAgICAgICAgIGhBbnNpOiBuYW1lLFxuICAgICAgICAgIGhpbnRcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbmFtZU9yQXR0cnM7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgUnVuRm9udEF0dHJpYnV0ZXMoYXR0cnMpKTtcbiAgICB9XG4gIH1cbn1cbmxldCBWZXJ0aWNhbEFsaWduJDEgPSBjbGFzcyBWZXJ0aWNhbEFsaWduIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodHlwZTIpIHtcbiAgICBzdXBlcihcInc6dmVydEFsaWduXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IHR5cGUyXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5jbGFzcyBTdXBlclNjcmlwdCBleHRlbmRzIFZlcnRpY2FsQWxpZ24kMSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwic3VwZXJzY3JpcHRcIik7XG4gIH1cbn1cbmNsYXNzIFN1YlNjcmlwdCBleHRlbmRzIFZlcnRpY2FsQWxpZ24kMSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwic3Vic2NyaXB0XCIpO1xuICB9XG59XG5jb25zdCBVbmRlcmxpbmVUeXBlID0ge1xuICBTSU5HTEU6IFwic2luZ2xlXCIsXG4gIFdPUkRTOiBcIndvcmRzXCIsXG4gIERPVUJMRTogXCJkb3VibGVcIixcbiAgVEhJQ0s6IFwidGhpY2tcIixcbiAgRE9UVEVEOiBcImRvdHRlZFwiLFxuICBET1RURURIRUFWWTogXCJkb3R0ZWRIZWF2eVwiLFxuICBEQVNIOiBcImRhc2hcIixcbiAgREFTSEVESEVBVlk6IFwiZGFzaGVkSGVhdnlcIixcbiAgREFTSExPTkc6IFwiZGFzaExvbmdcIixcbiAgREFTSExPTkdIRUFWWTogXCJkYXNoTG9uZ0hlYXZ5XCIsXG4gIERPVERBU0g6IFwiZG90RGFzaFwiLFxuICBEQVNIRE9USEVBVlk6IFwiZGFzaERvdEhlYXZ5XCIsXG4gIERPVERPVERBU0g6IFwiZG90RG90RGFzaFwiLFxuICBEQVNIRE9URE9USEVBVlk6IFwiZGFzaERvdERvdEhlYXZ5XCIsXG4gIFdBVkU6IFwid2F2ZVwiLFxuICBXQVZZSEVBVlk6IFwid2F2eUhlYXZ5XCIsXG4gIFdBVllET1VCTEU6IFwid2F2eURvdWJsZVwiLFxuICBOT05FOiBcIm5vbmVcIlxufTtcbmNsYXNzIFVuZGVybGluZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHVuZGVybGluZVR5cGUgPSBVbmRlcmxpbmVUeXBlLlNJTkdMRSwgY29sb3IpIHtcbiAgICBzdXBlcihcInc6dVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiB1bmRlcmxpbmVUeXBlLFxuICAgICAgICBjb2xvcjogY29sb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhleENvbG9yVmFsdWUoY29sb3IpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFRleHRFZmZlY3QgPSB7XG4gIEJMSU5LX0JBQ0tHUk9VTkQ6IFwiYmxpbmtCYWNrZ3JvdW5kXCIsXG4gIExJR0hUUzogXCJsaWdodHNcIixcbiAgQU5UU19CTEFDSzogXCJhbnRzQmxhY2tcIixcbiAgQU5UU19SRUQ6IFwiYW50c1JlZFwiLFxuICBTSElNTUVSOiBcInNoaW1tZXJcIixcbiAgU1BBUktMRTogXCJzcGFya2xlXCIsXG4gIE5PTkU6IFwibm9uZVwiXG59O1xuY29uc3QgSGlnaGxpZ2h0Q29sb3IgPSB7XG4gIEJMQUNLOiBcImJsYWNrXCIsXG4gIEJMVUU6IFwiYmx1ZVwiLFxuICBDWUFOOiBcImN5YW5cIixcbiAgREFSS19CTFVFOiBcImRhcmtCbHVlXCIsXG4gIERBUktfQ1lBTjogXCJkYXJrQ3lhblwiLFxuICBEQVJLX0dSQVk6IFwiZGFya0dyYXlcIixcbiAgREFSS19HUkVFTjogXCJkYXJrR3JlZW5cIixcbiAgREFSS19NQUdFTlRBOiBcImRhcmtNYWdlbnRhXCIsXG4gIERBUktfUkVEOiBcImRhcmtSZWRcIixcbiAgREFSS19ZRUxMT1c6IFwiZGFya1llbGxvd1wiLFxuICBHUkVFTjogXCJncmVlblwiLFxuICBMSUdIVF9HUkFZOiBcImxpZ2h0R3JheVwiLFxuICBNQUdFTlRBOiBcIm1hZ2VudGFcIixcbiAgTk9ORTogXCJub25lXCIsXG4gIFJFRDogXCJyZWRcIixcbiAgV0hJVEU6IFwid2hpdGVcIixcbiAgWUVMTE9XOiBcInllbGxvd1wiXG59O1xuY2xhc3MgUnVuUHJvcGVydGllcyBleHRlbmRzIElnbm9yZUlmRW1wdHlYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBzdXBlcihcInc6clByXCIpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBTdHJpbmdWYWx1ZUVsZW1lbnQoXCJ3OnJTdHlsZVwiLCBvcHRpb25zLnN0eWxlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvbnQpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMucHVzaChuZXcgUnVuRm9udHMob3B0aW9ucy5mb250KSk7XG4gICAgICB9IGVsc2UgaWYgKFwibmFtZVwiIGluIG9wdGlvbnMuZm9udCkge1xuICAgICAgICB0aGlzLnB1c2gobmV3IFJ1bkZvbnRzKG9wdGlvbnMuZm9udC5uYW1lLCBvcHRpb25zLmZvbnQuaGludCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoKG5ldyBSdW5Gb250cyhvcHRpb25zLmZvbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYm9sZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6YlwiLCBvcHRpb25zLmJvbGQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYm9sZENvbXBsZXhTY3JpcHQgPT09IHZvaWQgMCAmJiBvcHRpb25zLmJvbGQgIT09IHZvaWQgMCB8fCBvcHRpb25zLmJvbGRDb21wbGV4U2NyaXB0KSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6YkNzXCIsIChfYSA9IG9wdGlvbnMuYm9sZENvbXBsZXhTY3JpcHQpICE9IG51bGwgPyBfYSA6IG9wdGlvbnMuYm9sZCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGFsaWNzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzppXCIsIG9wdGlvbnMuaXRhbGljcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pdGFsaWNzQ29tcGxleFNjcmlwdCA9PT0gdm9pZCAwICYmIG9wdGlvbnMuaXRhbGljcyAhPT0gdm9pZCAwIHx8IG9wdGlvbnMuaXRhbGljc0NvbXBsZXhTY3JpcHQpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzppQ3NcIiwgKF9iID0gb3B0aW9ucy5pdGFsaWNzQ29tcGxleFNjcmlwdCkgIT0gbnVsbCA/IF9iIDogb3B0aW9ucy5pdGFsaWNzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNtYWxsQ2FwcyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c21hbGxDYXBzXCIsIG9wdGlvbnMuc21hbGxDYXBzKSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmFsbENhcHMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmNhcHNcIiwgb3B0aW9ucy5hbGxDYXBzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0cmlrZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3RyaWtlXCIsIG9wdGlvbnMuc3RyaWtlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvdWJsZVN0cmlrZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZHN0cmlrZVwiLCBvcHRpb25zLmRvdWJsZVN0cmlrZSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbWJvc3MgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmVtYm9zc1wiLCBvcHRpb25zLmVtYm9zcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbXByaW50ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzppbXByaW50XCIsIG9wdGlvbnMuaW1wcmludCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub1Byb29mICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpub1Byb29mXCIsIG9wdGlvbnMubm9Qcm9vZikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zbmFwVG9HcmlkICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpzbmFwVG9HcmlkXCIsIG9wdGlvbnMuc25hcFRvR3JpZCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52YW5pc2gpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp2YW5pc2hcIiwgb3B0aW9ucy52YW5pc2gpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY29sb3IpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgQ29sb3Iob3B0aW9ucy5jb2xvcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IENoYXJhY3RlclNwYWNpbmcob3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgTnVtYmVyVmFsdWVFbGVtZW50KFwidzp3XCIsIG9wdGlvbnMuc2NhbGUpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMua2Vybikge1xuICAgICAgdGhpcy5wdXNoKG5ldyBIcHNNZWFzdXJlRWxlbWVudChcInc6a2VyblwiLCBvcHRpb25zLmtlcm4pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMucHVzaChuZXcgU3RyaW5nVmFsdWVFbGVtZW50KFwidzpwb3NpdGlvblwiLCBvcHRpb25zLnBvc2l0aW9uKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpemUgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBIcHNNZWFzdXJlRWxlbWVudChcInc6c3pcIiwgb3B0aW9ucy5zaXplKSk7XG4gICAgfVxuICAgIGNvbnN0IHN6Q3MgPSBvcHRpb25zLnNpemVDb21wbGV4U2NyaXB0ID09PSB2b2lkIDAgfHwgb3B0aW9ucy5zaXplQ29tcGxleFNjcmlwdCA9PT0gdHJ1ZSA/IG9wdGlvbnMuc2l6ZSA6IG9wdGlvbnMuc2l6ZUNvbXBsZXhTY3JpcHQ7XG4gICAgaWYgKHN6Q3MpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgSHBzTWVhc3VyZUVsZW1lbnQoXCJ3OnN6Q3NcIiwgc3pDcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgSGlnaGxpZ2h0KG9wdGlvbnMuaGlnaGxpZ2h0KSk7XG4gICAgfVxuICAgIGNvbnN0IGhpZ2hsaWdodENzID0gb3B0aW9ucy5oaWdobGlnaHRDb21wbGV4U2NyaXB0ID09PSB2b2lkIDAgfHwgb3B0aW9ucy5oaWdobGlnaHRDb21wbGV4U2NyaXB0ID09PSB0cnVlID8gb3B0aW9ucy5oaWdobGlnaHQgOiBvcHRpb25zLmhpZ2hsaWdodENvbXBsZXhTY3JpcHQ7XG4gICAgaWYgKGhpZ2hsaWdodENzKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IEhpZ2hsaWdodENvbXBsZXhTY3JpcHQoaGlnaGxpZ2h0Q3MpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudW5kZXJsaW5lKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IFVuZGVybGluZShvcHRpb25zLnVuZGVybGluZS50eXBlLCBvcHRpb25zLnVuZGVybGluZS5jb2xvcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lZmZlY3QpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgU3RyaW5nVmFsdWVFbGVtZW50KFwidzplZmZlY3RcIiwgb3B0aW9ucy5lZmZlY3QpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmJkclwiLCBvcHRpb25zLmJvcmRlcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaGFkaW5nKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IFNoYWRpbmcob3B0aW9ucy5zaGFkaW5nKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1YlNjcmlwdCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBTdWJTY3JpcHQoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cGVyU2NyaXB0KSB7XG4gICAgICB0aGlzLnB1c2gobmV3IFN1cGVyU2NyaXB0KCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yaWdodFRvTGVmdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6cnRsXCIsIG9wdGlvbnMucmlnaHRUb0xlZnQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW1waGFzaXNNYXJrKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IEVtcGhhc2lzTWFyayhvcHRpb25zLmVtcGhhc2lzTWFyay50eXBlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgICB0aGlzLnB1c2goY3JlYXRlTGFuZ3VhZ2VDb21wb25lbnQob3B0aW9ucy5sYW5ndWFnZSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGVjVmFuaXNoKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3BlY1ZhbmlzaFwiLCBvcHRpb25zLnZhbmlzaCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYXRoKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6b01hdGhcIiwgb3B0aW9ucy5tYXRoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJldmlzaW9uKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IFJ1blByb3BlcnRpZXNDaGFuZ2Uob3B0aW9ucy5yZXZpc2lvbikpO1xuICAgIH1cbiAgfVxuICBwdXNoKGl0ZW0pIHtcbiAgICB0aGlzLnJvb3QucHVzaChpdGVtKTtcbiAgfVxufVxuY2xhc3MgUnVuUHJvcGVydGllc0NoYW5nZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6clByQ2hhbmdlXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IENoYW5nZUF0dHJpYnV0ZXMoe1xuICAgICAgICBpZDogb3B0aW9ucy5pZCxcbiAgICAgICAgYXV0aG9yOiBvcHRpb25zLmF1dGhvcixcbiAgICAgICAgZGF0ZTogb3B0aW9ucy5kYXRlXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5hZGRDaGlsZEVsZW1lbnQobmV3IFJ1blByb3BlcnRpZXMob3B0aW9ucykpO1xuICB9XG59XG5jbGFzcyBUZXh0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcihcInc6dFwiKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUZXh0QXR0cmlidXRlcyh7IHNwYWNlOiBTcGFjZVR5cGUuUFJFU0VSVkUgfSkpO1xuICAgICAgdGhpcy5yb290LnB1c2gob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUZXh0QXR0cmlidXRlcyh7IHNwYWNlOiAoX2EgPSBvcHRpb25zLnNwYWNlKSAhPSBudWxsID8gX2EgOiBTcGFjZVR5cGUuREVGQVVMVCB9KSk7XG4gICAgICB0aGlzLnJvb3QucHVzaChvcHRpb25zLnRleHQpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgUGFnZU51bWJlciA9IHtcbiAgQ1VSUkVOVDogXCJDVVJSRU5UXCIsXG4gIFRPVEFMX1BBR0VTOiBcIlRPVEFMX1BBR0VTXCIsXG4gIFRPVEFMX1BBR0VTX0lOX1NFQ1RJT046IFwiVE9UQUxfUEFHRVNfSU5fU0VDVElPTlwiLFxuICBDVVJSRU5UX1NFQ1RJT046IFwiU0VDVElPTlwiXG59O1xuY2xhc3MgUnVuIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzpyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9wZXJ0aWVzXCIpO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBSdW5Qcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucHJvcGVydGllcyk7XG4gICAgaWYgKG9wdGlvbnMuYnJlYWspIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5icmVhazsgaSsrKSB7XG4gICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCcmVhayQxKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNoaWxkKSB7XG4gICAgICAgICAgICBjYXNlIFBhZ2VOdW1iZXIuQ1VSUkVOVDpcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJlZ2luKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgUGFnZSgpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFNlcGFyYXRlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgRW5kKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFnZU51bWJlci5UT1RBTF9QQUdFUzpcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJlZ2luKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgTnVtYmVyT2ZQYWdlcygpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFNlcGFyYXRlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgRW5kKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFnZU51bWJlci5UT1RBTF9QQUdFU19JTl9TRUNUSU9OOlxuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgQmVnaW4oKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOdW1iZXJPZlBhZ2VzU2VjdGlvbigpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFNlcGFyYXRlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgRW5kKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFnZU51bWJlci5DVVJSRU5UX1NFQ1RJT046XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCZWdpbigpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IEN1cnJlbnRTZWN0aW9uKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgU2VwYXJhdGUoKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBFbmQoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFRleHQoY2hpbGQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGV4dCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dChvcHRpb25zLnRleHQpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFRleHRSdW4gZXh0ZW5kcyBSdW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyB7IHRleHQ6IG9wdGlvbnMgfSA6IG9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBTeW1ib2xBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBjaGFyOiBcInc6Y2hhclwiLFxuICAgICAgc3ltYm9sZm9udDogXCJ3OmZvbnRcIlxuICAgIH0pO1xuICB9XG59XG5sZXQgU3ltYm9sJDEgPSBjbGFzcyBTeW1ib2wyIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoY2hhciA9IFwiXCIsIHN5bWJvbGZvbnQgPSBcIldpbmdkaW5nc1wiKSB7XG4gICAgc3VwZXIoXCJ3OnN5bVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU3ltYm9sQXR0cmlidXRlcyh7IGNoYXIsIHN5bWJvbGZvbnQgfSkpO1xuICB9XG59O1xuY2xhc3MgU3ltYm9sUnVuIGV4dGVuZHMgUnVuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3VwZXIoe30pO1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN5bWJvbCQxKG9wdGlvbnMpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU3ltYm9sJDEob3B0aW9ucy5jaGFyLCBvcHRpb25zLnN5bWJvbGZvbnQpKTtcbiAgfVxufVxudmFyIGhhc2gkMSA9IHt9O1xudmFyIHV0aWxzID0ge307XG52YXIgbWluaW1hbGlzdGljQXNzZXJ0O1xudmFyIGhhc1JlcXVpcmVkTWluaW1hbGlzdGljQXNzZXJ0O1xuZnVuY3Rpb24gcmVxdWlyZU1pbmltYWxpc3RpY0Fzc2VydCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkTWluaW1hbGlzdGljQXNzZXJ0KSByZXR1cm4gbWluaW1hbGlzdGljQXNzZXJ0O1xuICBoYXNSZXF1aXJlZE1pbmltYWxpc3RpY0Fzc2VydCA9IDE7XG4gIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcbiAgZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8IFwiQXNzZXJ0aW9uIGZhaWxlZFwiKTtcbiAgfVxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgICBpZiAobCAhPSByKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCBcIkFzc2VydGlvbiBmYWlsZWQ6IFwiICsgbCArIFwiICE9IFwiICsgcik7XG4gIH07XG4gIHJldHVybiBtaW5pbWFsaXN0aWNBc3NlcnQ7XG59XG52YXIgaGFzUmVxdWlyZWRVdGlscztcbmZ1bmN0aW9uIHJlcXVpcmVVdGlscygpIHtcbiAgaWYgKGhhc1JlcXVpcmVkVXRpbHMpIHJldHVybiB1dGlscztcbiAgaGFzUmVxdWlyZWRVdGlscyA9IDE7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlTWluaW1hbGlzdGljQXNzZXJ0KCk7XG4gIHZhciBpbmhlcml0cyA9IHJlcXVpcmVJbmhlcml0c19icm93c2VyKCk7XG4gIHV0aWxzLmluaGVyaXRzID0gaW5oZXJpdHM7XG4gIGZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihtc2csIGkpIHtcbiAgICBpZiAoKG1zZy5jaGFyQ29kZUF0KGkpICYgNjQ1MTIpICE9PSA1NTI5Nikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDY0NTEyKSA9PT0gNTYzMjA7XG4gIH1cbiAgZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gICAgaWYgKCFtc2cpXG4gICAgICByZXR1cm4gW107XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGlmICh0eXBlb2YgbXNnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIWVuYykge1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgcmVzW3ArK10gPSBjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIHJlc1twKytdID0gYyA+PiA2IHwgMTkyO1xuICAgICAgICAgICAgcmVzW3ArK10gPSBjICYgNjMgfCAxMjg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSkge1xuICAgICAgICAgICAgYyA9IDY1NTM2ICsgKChjICYgMTAyMykgPDwgMTApICsgKG1zZy5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKTtcbiAgICAgICAgICAgIHJlc1twKytdID0gYyA+PiAxOCB8IDI0MDtcbiAgICAgICAgICAgIHJlc1twKytdID0gYyA+PiAxMiAmIDYzIHwgMTI4O1xuICAgICAgICAgICAgcmVzW3ArK10gPSBjID4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICAgIHJlc1twKytdID0gYyAmIDYzIHwgMTI4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNbcCsrXSA9IGMgPj4gMTIgfCAyMjQ7XG4gICAgICAgICAgICByZXNbcCsrXSA9IGMgPj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgICAgcmVzW3ArK10gPSBjICYgNjMgfCAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuYyA9PT0gXCJoZXhcIikge1xuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgXCJcIik7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICBtc2cgPSBcIjBcIiArIG1zZztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuICBmdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgICB2YXIgcmVzID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHV0aWxzLnRvSGV4ID0gdG9IZXg7XG4gIGZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgICB2YXIgcmVzID0gdyA+Pj4gMjQgfCB3ID4+PiA4ICYgNjUyODAgfCB3IDw8IDggJiAxNjcxMTY4MCB8ICh3ICYgMjU1KSA8PCAyNDtcbiAgICByZXR1cm4gcmVzID4+PiAwO1xuICB9XG4gIHV0aWxzLmh0b25sID0gaHRvbmw7XG4gIGZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgICB2YXIgcmVzID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBtc2dbaV07XG4gICAgICBpZiAoZW5kaWFuID09PSBcImxpdHRsZVwiKVxuICAgICAgICB3ID0gaHRvbmwodyk7XG4gICAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHV0aWxzLnRvSGV4MzIgPSB0b0hleDMyO1xuICBmdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gICAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIFwiMFwiICsgd29yZDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gd29yZDtcbiAgfVxuICB1dGlscy56ZXJvMiA9IHplcm8yO1xuICBmdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gICAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgICAgcmV0dXJuIFwiMFwiICsgd29yZDtcbiAgICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICAgIHJldHVybiBcIjAwXCIgKyB3b3JkO1xuICAgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgICAgcmV0dXJuIFwiMDAwXCIgKyB3b3JkO1xuICAgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgICAgcmV0dXJuIFwiMDAwMFwiICsgd29yZDtcbiAgICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICAgIHJldHVybiBcIjAwMDAwXCIgKyB3b3JkO1xuICAgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgICAgcmV0dXJuIFwiMDAwMDAwXCIgKyB3b3JkO1xuICAgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuIFwiMDAwMDAwMFwiICsgd29yZDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gd29yZDtcbiAgfVxuICB1dGlscy56ZXJvOCA9IHplcm84O1xuICBmdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgYXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgICB2YXIgdztcbiAgICAgIGlmIChlbmRpYW4gPT09IFwiYmlnXCIpXG4gICAgICAgIHcgPSBtc2dba10gPDwgMjQgfCBtc2dbayArIDFdIDw8IDE2IHwgbXNnW2sgKyAyXSA8PCA4IHwgbXNnW2sgKyAzXTtcbiAgICAgIGVsc2VcbiAgICAgICAgdyA9IG1zZ1trICsgM10gPDwgMjQgfCBtc2dbayArIDJdIDw8IDE2IHwgbXNnW2sgKyAxXSA8PCA4IHwgbXNnW2tdO1xuICAgICAgcmVzW2ldID0gdyA+Pj4gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB1dGlscy5qb2luMzIgPSBqb2luMzI7XG4gIGZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgICAgdmFyIG0gPSBtc2dbaV07XG4gICAgICBpZiAoZW5kaWFuID09PSBcImJpZ1wiKSB7XG4gICAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgICByZXNbayArIDFdID0gbSA+Pj4gMTYgJiAyNTU7XG4gICAgICAgIHJlc1trICsgMl0gPSBtID4+PiA4ICYgMjU1O1xuICAgICAgICByZXNbayArIDNdID0gbSAmIDI1NTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgICAgcmVzW2sgKyAyXSA9IG0gPj4+IDE2ICYgMjU1O1xuICAgICAgICByZXNbayArIDFdID0gbSA+Pj4gOCAmIDI1NTtcbiAgICAgICAgcmVzW2tdID0gbSAmIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB1dGlscy5zcGxpdDMyID0gc3BsaXQzMjtcbiAgZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgICByZXR1cm4gdyA+Pj4gYiB8IHcgPDwgMzIgLSBiO1xuICB9XG4gIHV0aWxzLnJvdHIzMiA9IHJvdHIzMjtcbiAgZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgICByZXR1cm4gdyA8PCBiIHwgdyA+Pj4gMzIgLSBiO1xuICB9XG4gIHV0aWxzLnJvdGwzMiA9IHJvdGwzMjtcbiAgZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICAgIHJldHVybiBhICsgYiA+Pj4gMDtcbiAgfVxuICB1dGlscy5zdW0zMiA9IHN1bTMyO1xuICBmdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYSArIGIgKyBjID4+PiAwO1xuICB9XG4gIHV0aWxzLnN1bTMyXzMgPSBzdW0zMl8zO1xuICBmdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYSArIGIgKyBjICsgZCA+Pj4gMDtcbiAgfVxuICB1dGlscy5zdW0zMl80ID0gc3VtMzJfNDtcbiAgZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gICAgcmV0dXJuIGEgKyBiICsgYyArIGQgKyBlID4+PiAwO1xuICB9XG4gIHV0aWxzLnN1bTMyXzUgPSBzdW0zMl81O1xuICBmdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gICAgdmFyIGJoID0gYnVmW3Bvc107XG4gICAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuICAgIHZhciBsbyA9IGFsICsgYmwgPj4+IDA7XG4gICAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICAgIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gICAgYnVmW3BvcyArIDFdID0gbG87XG4gIH1cbiAgdXRpbHMuc3VtNjQgPSBzdW02NDtcbiAgZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgICB2YXIgbG8gPSBhbCArIGJsID4+PiAwO1xuICAgIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgICByZXR1cm4gaGkgPj4+IDA7XG4gIH1cbiAgdXRpbHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcbiAgZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgICB2YXIgbG8gPSBhbCArIGJsO1xuICAgIHJldHVybiBsbyA+Pj4gMDtcbiAgfVxuICB1dGlscy5zdW02NF9sbyA9IHN1bTY0X2xvO1xuICBmdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgdmFyIGxvID0gYWw7XG4gICAgbG8gPSBsbyArIGJsID4+PiAwO1xuICAgIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgICBsbyA9IGxvICsgY2wgPj4+IDA7XG4gICAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICAgIGxvID0gbG8gKyBkbCA+Pj4gMDtcbiAgICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gICAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgICByZXR1cm4gaGkgPj4+IDA7XG4gIH1cbiAgdXRpbHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG4gIGZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gICAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gICAgcmV0dXJuIGxvID4+PiAwO1xuICB9XG4gIHV0aWxzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuICBmdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgbG8gPSBhbDtcbiAgICBsbyA9IGxvICsgYmwgPj4+IDA7XG4gICAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICAgIGxvID0gbG8gKyBjbCA+Pj4gMDtcbiAgICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gICAgbG8gPSBsbyArIGRsID4+PiAwO1xuICAgIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgICBsbyA9IGxvICsgZWwgPj4+IDA7XG4gICAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuICAgIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgICByZXR1cm4gaGkgPj4+IDA7XG4gIH1cbiAgdXRpbHMuc3VtNjRfNV9oaSA9IHN1bTY0XzVfaGk7XG4gIGZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuICAgIHJldHVybiBsbyA+Pj4gMDtcbiAgfVxuICB1dGlscy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcbiAgZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gICAgdmFyIHIgPSBhbCA8PCAzMiAtIG51bSB8IGFoID4+PiBudW07XG4gICAgcmV0dXJuIHIgPj4+IDA7XG4gIH1cbiAgdXRpbHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuICBmdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgICB2YXIgciA9IGFoIDw8IDMyIC0gbnVtIHwgYWwgPj4+IG51bTtcbiAgICByZXR1cm4gciA+Pj4gMDtcbiAgfVxuICB1dGlscy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG4gIGZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gICAgcmV0dXJuIGFoID4+PiBudW07XG4gIH1cbiAgdXRpbHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcbiAgZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgICB2YXIgciA9IGFoIDw8IDMyIC0gbnVtIHwgYWwgPj4+IG51bTtcbiAgICByZXR1cm4gciA+Pj4gMDtcbiAgfVxuICB1dGlscy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuICByZXR1cm4gdXRpbHM7XG59XG52YXIgY29tbW9uJDEgPSB7fTtcbnZhciBoYXNSZXF1aXJlZENvbW1vbiQxO1xuZnVuY3Rpb24gcmVxdWlyZUNvbW1vbiQxKCkge1xuICBpZiAoaGFzUmVxdWlyZWRDb21tb24kMSkgcmV0dXJuIGNvbW1vbiQxO1xuICBoYXNSZXF1aXJlZENvbW1vbiQxID0gMTtcbiAgdmFyIHV0aWxzMiA9IHJlcXVpcmVVdGlscygpO1xuICB2YXIgYXNzZXJ0ID0gcmVxdWlyZU1pbmltYWxpc3RpY0Fzc2VydCgpO1xuICBmdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gICAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgICB0aGlzLm91dFNpemUgPSB0aGlzLmNvbnN0cnVjdG9yLm91dFNpemU7XG4gICAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgICB0aGlzLmVuZGlhbiA9IFwiYmlnXCI7XG4gICAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICAgIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xuICB9XG4gIGNvbW1vbiQxLkJsb2NrSGFzaCA9IEJsb2NrSGFzaDtcbiAgQmxvY2tIYXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgICBtc2cgPSB1dGlsczIudG9BcnJheShtc2csIGVuYyk7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG4gICAgZWxzZVxuICAgICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICAgIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG4gICAgICB2YXIgciA9IG1zZy5sZW5ndGggJSB0aGlzLl9kZWx0YTg7XG4gICAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICBtc2cgPSB1dGlsczIuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSB0aGlzLl9kZWx0YTMyKVxuICAgICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBCbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gICAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xuICB9O1xuICBCbG9ja0hhc2gucHJvdG90eXBlLl9wYWQgPSBmdW5jdGlvbiBwYWQoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICAgIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgICB2YXIgayA9IGJ5dGVzIC0gKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcbiAgICByZXNbMF0gPSAxMjg7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBrOyBpKyspXG4gICAgICByZXNbaV0gPSAwO1xuICAgIGxlbiA8PD0gMztcbiAgICBpZiAodGhpcy5lbmRpYW4gPT09IFwiYmlnXCIpIHtcbiAgICAgIGZvciAodmFyIHQgPSA4OyB0IDwgdGhpcy5wYWRMZW5ndGg7IHQrKylcbiAgICAgICAgcmVzW2krK10gPSAwO1xuICAgICAgcmVzW2krK10gPSAwO1xuICAgICAgcmVzW2krK10gPSAwO1xuICAgICAgcmVzW2krK10gPSAwO1xuICAgICAgcmVzW2krK10gPSAwO1xuICAgICAgcmVzW2krK10gPSBsZW4gPj4+IDI0ICYgMjU1O1xuICAgICAgcmVzW2krK10gPSBsZW4gPj4+IDE2ICYgMjU1O1xuICAgICAgcmVzW2krK10gPSBsZW4gPj4+IDggJiAyNTU7XG4gICAgICByZXNbaSsrXSA9IGxlbiAmIDI1NTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2krK10gPSBsZW4gJiAyNTU7XG4gICAgICByZXNbaSsrXSA9IGxlbiA+Pj4gOCAmIDI1NTtcbiAgICAgIHJlc1tpKytdID0gbGVuID4+PiAxNiAmIDI1NTtcbiAgICAgIHJlc1tpKytdID0gbGVuID4+PiAyNCAmIDI1NTtcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgICAgIHJlc1tpKytdID0gMDtcbiAgICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgICByZXNbaSsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIHJldHVybiBjb21tb24kMTtcbn1cbnZhciBzaGEgPSB7fTtcbnZhciBjb21tb24gPSB7fTtcbnZhciBoYXNSZXF1aXJlZENvbW1vbjtcbmZ1bmN0aW9uIHJlcXVpcmVDb21tb24oKSB7XG4gIGlmIChoYXNSZXF1aXJlZENvbW1vbikgcmV0dXJuIGNvbW1vbjtcbiAgaGFzUmVxdWlyZWRDb21tb24gPSAxO1xuICB2YXIgdXRpbHMyID0gcmVxdWlyZVV0aWxzKCk7XG4gIHZhciByb3RyMzIgPSB1dGlsczIucm90cjMyO1xuICBmdW5jdGlvbiBmdF8xKHMsIHgsIHksIHopIHtcbiAgICBpZiAocyA9PT0gMClcbiAgICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICAgIGlmIChzID09PSAxIHx8IHMgPT09IDMpXG4gICAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICAgIGlmIChzID09PSAyKVxuICAgICAgcmV0dXJuIG1hajMyKHgsIHksIHopO1xuICB9XG4gIGNvbW1vbi5mdF8xID0gZnRfMTtcbiAgZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG4gICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuICB9XG4gIGNvbW1vbi5jaDMyID0gY2gzMjtcbiAgZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG4gIH1cbiAgY29tbW9uLm1hajMyID0gbWFqMzI7XG4gIGZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxuICBjb21tb24ucDMyID0gcDMyO1xuICBmdW5jdGlvbiBzMF8yNTYoeCkge1xuICAgIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbiAgfVxuICBjb21tb24uczBfMjU2ID0gczBfMjU2O1xuICBmdW5jdGlvbiBzMV8yNTYoeCkge1xuICAgIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbiAgfVxuICBjb21tb24uczFfMjU2ID0gczFfMjU2O1xuICBmdW5jdGlvbiBnMF8yNTYoeCkge1xuICAgIHJldHVybiByb3RyMzIoeCwgNykgXiByb3RyMzIoeCwgMTgpIF4geCA+Pj4gMztcbiAgfVxuICBjb21tb24uZzBfMjU2ID0gZzBfMjU2O1xuICBmdW5jdGlvbiBnMV8yNTYoeCkge1xuICAgIHJldHVybiByb3RyMzIoeCwgMTcpIF4gcm90cjMyKHgsIDE5KSBeIHggPj4+IDEwO1xuICB9XG4gIGNvbW1vbi5nMV8yNTYgPSBnMV8yNTY7XG4gIHJldHVybiBjb21tb247XG59XG52YXIgXzE7XG52YXIgaGFzUmVxdWlyZWRfMTtcbmZ1bmN0aW9uIHJlcXVpcmVfMSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkXzEpIHJldHVybiBfMTtcbiAgaGFzUmVxdWlyZWRfMSA9IDE7XG4gIHZhciB1dGlsczIgPSByZXF1aXJlVXRpbHMoKTtcbiAgdmFyIGNvbW1vbjIgPSByZXF1aXJlQ29tbW9uJDEoKTtcbiAgdmFyIHNoYUNvbW1vbiA9IHJlcXVpcmVDb21tb24oKTtcbiAgdmFyIHJvdGwzMiA9IHV0aWxzMi5yb3RsMzI7XG4gIHZhciBzdW0zMiA9IHV0aWxzMi5zdW0zMjtcbiAgdmFyIHN1bTMyXzUgPSB1dGlsczIuc3VtMzJfNTtcbiAgdmFyIGZ0XzEgPSBzaGFDb21tb24uZnRfMTtcbiAgdmFyIEJsb2NrSGFzaCA9IGNvbW1vbjIuQmxvY2tIYXNoO1xuICB2YXIgc2hhMV9LID0gW1xuICAgIDE1MTg1MDAyNDksXG4gICAgMTg1OTc3NTM5MyxcbiAgICAyNDAwOTU5NzA4LFxuICAgIDMzOTU0Njk3ODJcbiAgXTtcbiAgZnVuY3Rpb24gU0hBMSgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMSkpXG4gICAgICByZXR1cm4gbmV3IFNIQTEoKTtcbiAgICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgICB0aGlzLmggPSBbXG4gICAgICAxNzMyNTg0MTkzLFxuICAgICAgNDAyMzIzMzQxNyxcbiAgICAgIDI1NjIzODMxMDIsXG4gICAgICAyNzE3MzM4NzgsXG4gICAgICAzMjg1Mzc3NTIwXG4gICAgXTtcbiAgICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xuICB9XG4gIHV0aWxzMi5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xuICBfMSA9IFNIQTE7XG4gIFNIQTEuYmxvY2tTaXplID0gNTEyO1xuICBTSEExLm91dFNpemUgPSAxNjA7XG4gIFNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG4gIFNIQTEucGFkTGVuZ3RoID0gNjQ7XG4gIFNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgICB2YXIgVyA9IHRoaXMuVztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gICAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgICAgV1tpXSA9IHJvdGwzMihXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdLCAxKTtcbiAgICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgICB2YXIgZSA9IHRoaXMuaFs0XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHMgPSB+fihpIC8gMjApO1xuICAgICAgdmFyIHQgPSBzdW0zMl81KHJvdGwzMihhLCA1KSwgZnRfMShzLCBiLCBjLCBkKSwgZSwgV1tpXSwgc2hhMV9LW3NdKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm90bDMyKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gICAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgICB0aGlzLmhbMl0gPSBzdW0zMih0aGlzLmhbMl0sIGMpO1xuICAgIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gICAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgfTtcbiAgU0hBMS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgICBpZiAoZW5jID09PSBcImhleFwiKVxuICAgICAgcmV0dXJuIHV0aWxzMi50b0hleDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHV0aWxzMi5zcGxpdDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gIH07XG4gIHJldHVybiBfMTtcbn1cbnZhciBfMjU2O1xudmFyIGhhc1JlcXVpcmVkXzI1NjtcbmZ1bmN0aW9uIHJlcXVpcmVfMjU2KCkge1xuICBpZiAoaGFzUmVxdWlyZWRfMjU2KSByZXR1cm4gXzI1NjtcbiAgaGFzUmVxdWlyZWRfMjU2ID0gMTtcbiAgdmFyIHV0aWxzMiA9IHJlcXVpcmVVdGlscygpO1xuICB2YXIgY29tbW9uMiA9IHJlcXVpcmVDb21tb24kMSgpO1xuICB2YXIgc2hhQ29tbW9uID0gcmVxdWlyZUNvbW1vbigpO1xuICB2YXIgYXNzZXJ0ID0gcmVxdWlyZU1pbmltYWxpc3RpY0Fzc2VydCgpO1xuICB2YXIgc3VtMzIgPSB1dGlsczIuc3VtMzI7XG4gIHZhciBzdW0zMl80ID0gdXRpbHMyLnN1bTMyXzQ7XG4gIHZhciBzdW0zMl81ID0gdXRpbHMyLnN1bTMyXzU7XG4gIHZhciBjaDMyID0gc2hhQ29tbW9uLmNoMzI7XG4gIHZhciBtYWozMiA9IHNoYUNvbW1vbi5tYWozMjtcbiAgdmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG4gIHZhciBzMV8yNTYgPSBzaGFDb21tb24uczFfMjU2O1xuICB2YXIgZzBfMjU2ID0gc2hhQ29tbW9uLmcwXzI1NjtcbiAgdmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG4gIHZhciBCbG9ja0hhc2ggPSBjb21tb24yLkJsb2NrSGFzaDtcbiAgdmFyIHNoYTI1Nl9LID0gW1xuICAgIDExMTYzNTI0MDgsXG4gICAgMTg5OTQ0NzQ0MSxcbiAgICAzMDQ5MzIzNDcxLFxuICAgIDM5MjEwMDk1NzMsXG4gICAgOTYxOTg3MTYzLFxuICAgIDE1MDg5NzA5OTMsXG4gICAgMjQ1MzYzNTc0OCxcbiAgICAyODcwNzYzMjIxLFxuICAgIDM2MjQzODEwODAsXG4gICAgMzEwNTk4NDAxLFxuICAgIDYwNzIyNTI3OCxcbiAgICAxNDI2ODgxOTg3LFxuICAgIDE5MjUwNzgzODgsXG4gICAgMjE2MjA3ODIwNixcbiAgICAyNjE0ODg4MTAzLFxuICAgIDMyNDgyMjI1ODAsXG4gICAgMzgzNTM5MDQwMSxcbiAgICA0MDIyMjI0Nzc0LFxuICAgIDI2NDM0NzA3OCxcbiAgICA2MDQ4MDc2MjgsXG4gICAgNzcwMjU1OTgzLFxuICAgIDEyNDkxNTAxMjIsXG4gICAgMTU1NTA4MTY5MixcbiAgICAxOTk2MDY0OTg2LFxuICAgIDI1NTQyMjA4ODIsXG4gICAgMjgyMTgzNDM0OSxcbiAgICAyOTUyOTk2ODA4LFxuICAgIDMyMTAzMTM2NzEsXG4gICAgMzMzNjU3MTg5MSxcbiAgICAzNTg0NTI4NzExLFxuICAgIDExMzkyNjk5MyxcbiAgICAzMzgyNDE4OTUsXG4gICAgNjY2MzA3MjA1LFxuICAgIDc3MzUyOTkxMixcbiAgICAxMjk0NzU3MzcyLFxuICAgIDEzOTYxODIyOTEsXG4gICAgMTY5NTE4MzcwMCxcbiAgICAxOTg2NjYxMDUxLFxuICAgIDIxNzcwMjYzNTAsXG4gICAgMjQ1Njk1NjAzNyxcbiAgICAyNzMwNDg1OTIxLFxuICAgIDI4MjAzMDI0MTEsXG4gICAgMzI1OTczMDgwMCxcbiAgICAzMzQ1NzY0NzcxLFxuICAgIDM1MTYwNjU4MTcsXG4gICAgMzYwMDM1MjgwNCxcbiAgICA0MDk0NTcxOTA5LFxuICAgIDI3NTQyMzM0NCxcbiAgICA0MzAyMjc3MzQsXG4gICAgNTA2OTQ4NjE2LFxuICAgIDY1OTA2MDU1NixcbiAgICA4ODM5OTc4NzcsXG4gICAgOTU4MTM5NTcxLFxuICAgIDEzMjI4MjIyMTgsXG4gICAgMTUzNzAwMjA2MyxcbiAgICAxNzQ3ODczNzc5LFxuICAgIDE5NTU1NjIyMjIsXG4gICAgMjAyNDEwNDgxNSxcbiAgICAyMjI3NzMwNDUyLFxuICAgIDIzNjE4NTI0MjQsXG4gICAgMjQyODQzNjQ3NCxcbiAgICAyNzU2NzM0MTg3LFxuICAgIDMyMDQwMzE0NzksXG4gICAgMzMyOTMyNTI5OFxuICBdO1xuICBmdW5jdGlvbiBTSEEyNTYoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgICByZXR1cm4gbmV3IFNIQTI1NigpO1xuICAgIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaCA9IFtcbiAgICAgIDE3NzkwMzM3MDMsXG4gICAgICAzMTQ0MTM0Mjc3LFxuICAgICAgMTAxMzkwNDI0MixcbiAgICAgIDI3NzM0ODA3NjIsXG4gICAgICAxMzU5ODkzMTE5LFxuICAgICAgMjYwMDgyMjkyNCxcbiAgICAgIDUyODczNDYzNSxcbiAgICAgIDE1NDE0NTkyMjVcbiAgICBdO1xuICAgIHRoaXMuayA9IHNoYTI1Nl9LO1xuICAgIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG4gIH1cbiAgdXRpbHMyLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbiAgXzI1NiA9IFNIQTI1NjtcbiAgU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcbiAgU0hBMjU2Lm91dFNpemUgPSAyNTY7XG4gIFNIQTI1Ni5obWFjU3RyZW5ndGggPSAxOTI7XG4gIFNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcbiAgU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gICAgdmFyIFcgPSB0aGlzLlc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICAgIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcbiAgICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgICB2YXIgZSA9IHRoaXMuaFs0XTtcbiAgICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgICB2YXIgaCA9IHRoaXMuaFs3XTtcbiAgICBhc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICAgIHZhciBUMiA9IHN1bTMyKHMwXzI1NihhKSwgbWFqMzIoYSwgYiwgYykpO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgZSA9IHN1bTMyKGQsIFQxKTtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICAgIH1cbiAgICB0aGlzLmhbMF0gPSBzdW0zMih0aGlzLmhbMF0sIGEpO1xuICAgIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gICAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgICB0aGlzLmhbM10gPSBzdW0zMih0aGlzLmhbM10sIGQpO1xuICAgIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG4gICAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgICB0aGlzLmhbNl0gPSBzdW0zMih0aGlzLmhbNl0sIGcpO1xuICAgIHRoaXMuaFs3XSA9IHN1bTMyKHRoaXMuaFs3XSwgaCk7XG4gIH07XG4gIFNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgICBpZiAoZW5jID09PSBcImhleFwiKVxuICAgICAgcmV0dXJuIHV0aWxzMi50b0hleDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHV0aWxzMi5zcGxpdDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gIH07XG4gIHJldHVybiBfMjU2O1xufVxudmFyIF8yMjQ7XG52YXIgaGFzUmVxdWlyZWRfMjI0O1xuZnVuY3Rpb24gcmVxdWlyZV8yMjQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZF8yMjQpIHJldHVybiBfMjI0O1xuICBoYXNSZXF1aXJlZF8yMjQgPSAxO1xuICB2YXIgdXRpbHMyID0gcmVxdWlyZVV0aWxzKCk7XG4gIHZhciBTSEEyNTYgPSByZXF1aXJlXzI1NigpO1xuICBmdW5jdGlvbiBTSEEyMjQoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgICByZXR1cm4gbmV3IFNIQTIyNCgpO1xuICAgIFNIQTI1Ni5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaCA9IFtcbiAgICAgIDMyMzgzNzEwMzIsXG4gICAgICA5MTQxNTA2NjMsXG4gICAgICA4MTI3MDI5OTksXG4gICAgICA0MTQ0OTEyNjk3LFxuICAgICAgNDI5MDc3NTg1NyxcbiAgICAgIDE3NTA2MDMwMjUsXG4gICAgICAxNjk0MDc2ODM5LFxuICAgICAgMzIwNDA3NTQyOFxuICAgIF07XG4gIH1cbiAgdXRpbHMyLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbiAgXzIyNCA9IFNIQTIyNDtcbiAgU0hBMjI0LmJsb2NrU2l6ZSA9IDUxMjtcbiAgU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG4gIFNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG4gIFNIQTIyNC5wYWRMZW5ndGggPSA2NDtcbiAgU0hBMjI0LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAgIGlmIChlbmMgPT09IFwiaGV4XCIpXG4gICAgICByZXR1cm4gdXRpbHMyLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCBcImJpZ1wiKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdXRpbHMyLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCBcImJpZ1wiKTtcbiAgfTtcbiAgcmV0dXJuIF8yMjQ7XG59XG52YXIgXzUxMjtcbnZhciBoYXNSZXF1aXJlZF81MTI7XG5mdW5jdGlvbiByZXF1aXJlXzUxMigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkXzUxMikgcmV0dXJuIF81MTI7XG4gIGhhc1JlcXVpcmVkXzUxMiA9IDE7XG4gIHZhciB1dGlsczIgPSByZXF1aXJlVXRpbHMoKTtcbiAgdmFyIGNvbW1vbjIgPSByZXF1aXJlQ29tbW9uJDEoKTtcbiAgdmFyIGFzc2VydCA9IHJlcXVpcmVNaW5pbWFsaXN0aWNBc3NlcnQoKTtcbiAgdmFyIHJvdHI2NF9oaSA9IHV0aWxzMi5yb3RyNjRfaGk7XG4gIHZhciByb3RyNjRfbG8gPSB1dGlsczIucm90cjY0X2xvO1xuICB2YXIgc2hyNjRfaGkgPSB1dGlsczIuc2hyNjRfaGk7XG4gIHZhciBzaHI2NF9sbyA9IHV0aWxzMi5zaHI2NF9sbztcbiAgdmFyIHN1bTY0ID0gdXRpbHMyLnN1bTY0O1xuICB2YXIgc3VtNjRfaGkgPSB1dGlsczIuc3VtNjRfaGk7XG4gIHZhciBzdW02NF9sbyA9IHV0aWxzMi5zdW02NF9sbztcbiAgdmFyIHN1bTY0XzRfaGkgPSB1dGlsczIuc3VtNjRfNF9oaTtcbiAgdmFyIHN1bTY0XzRfbG8gPSB1dGlsczIuc3VtNjRfNF9sbztcbiAgdmFyIHN1bTY0XzVfaGkgPSB1dGlsczIuc3VtNjRfNV9oaTtcbiAgdmFyIHN1bTY0XzVfbG8gPSB1dGlsczIuc3VtNjRfNV9sbztcbiAgdmFyIEJsb2NrSGFzaCA9IGNvbW1vbjIuQmxvY2tIYXNoO1xuICB2YXIgc2hhNTEyX0sgPSBbXG4gICAgMTExNjM1MjQwOCxcbiAgICAzNjA5NzY3NDU4LFxuICAgIDE4OTk0NDc0NDEsXG4gICAgNjAyODkxNzI1LFxuICAgIDMwNDkzMjM0NzEsXG4gICAgMzk2NDQ4NDM5OSxcbiAgICAzOTIxMDA5NTczLFxuICAgIDIxNzMyOTU1NDgsXG4gICAgOTYxOTg3MTYzLFxuICAgIDQwODE2Mjg0NzIsXG4gICAgMTUwODk3MDk5MyxcbiAgICAzMDUzODM0MjY1LFxuICAgIDI0NTM2MzU3NDgsXG4gICAgMjkzNzY3MTU3OSxcbiAgICAyODcwNzYzMjIxLFxuICAgIDM2NjQ2MDk1NjAsXG4gICAgMzYyNDM4MTA4MCxcbiAgICAyNzM0ODgzMzk0LFxuICAgIDMxMDU5ODQwMSxcbiAgICAxMTY0OTk2NTQyLFxuICAgIDYwNzIyNTI3OCxcbiAgICAxMzIzNjEwNzY0LFxuICAgIDE0MjY4ODE5ODcsXG4gICAgMzU5MDMwNDk5NCxcbiAgICAxOTI1MDc4Mzg4LFxuICAgIDQwNjgxODIzODMsXG4gICAgMjE2MjA3ODIwNixcbiAgICA5OTEzMzYxMTMsXG4gICAgMjYxNDg4ODEwMyxcbiAgICA2MzM4MDMzMTcsXG4gICAgMzI0ODIyMjU4MCxcbiAgICAzNDc5Nzc0ODY4LFxuICAgIDM4MzUzOTA0MDEsXG4gICAgMjY2NjYxMzQ1OCxcbiAgICA0MDIyMjI0Nzc0LFxuICAgIDk0NDcxMTEzOSxcbiAgICAyNjQzNDcwNzgsXG4gICAgMjM0MTI2Mjc3MyxcbiAgICA2MDQ4MDc2MjgsXG4gICAgMjAwNzgwMDkzMyxcbiAgICA3NzAyNTU5ODMsXG4gICAgMTQ5NTk5MDkwMSxcbiAgICAxMjQ5MTUwMTIyLFxuICAgIDE4NTY0MzEyMzUsXG4gICAgMTU1NTA4MTY5MixcbiAgICAzMTc1MjE4MTMyLFxuICAgIDE5OTYwNjQ5ODYsXG4gICAgMjE5ODk1MDgzNyxcbiAgICAyNTU0MjIwODgyLFxuICAgIDM5OTk3MTkzMzksXG4gICAgMjgyMTgzNDM0OSxcbiAgICA3NjY3ODQwMTYsXG4gICAgMjk1Mjk5NjgwOCxcbiAgICAyNTY2NTk0ODc5LFxuICAgIDMyMTAzMTM2NzEsXG4gICAgMzIwMzMzNzk1NixcbiAgICAzMzM2NTcxODkxLFxuICAgIDEwMzQ0NTcwMjYsXG4gICAgMzU4NDUyODcxMSxcbiAgICAyNDY2OTQ4OTAxLFxuICAgIDExMzkyNjk5MyxcbiAgICAzNzU4MzI2MzgzLFxuICAgIDMzODI0MTg5NSxcbiAgICAxNjg3MTc5MzYsXG4gICAgNjY2MzA3MjA1LFxuICAgIDExODgxNzk5NjQsXG4gICAgNzczNTI5OTEyLFxuICAgIDE1NDYwNDU3MzQsXG4gICAgMTI5NDc1NzM3MixcbiAgICAxNTIyODA1NDg1LFxuICAgIDEzOTYxODIyOTEsXG4gICAgMjY0MzgzMzgyMyxcbiAgICAxNjk1MTgzNzAwLFxuICAgIDIzNDM1MjczOTAsXG4gICAgMTk4NjY2MTA1MSxcbiAgICAxMDE0NDc3NDgwLFxuICAgIDIxNzcwMjYzNTAsXG4gICAgMTIwNjc1OTE0MixcbiAgICAyNDU2OTU2MDM3LFxuICAgIDM0NDA3NzYyNyxcbiAgICAyNzMwNDg1OTIxLFxuICAgIDEyOTA4NjM0NjAsXG4gICAgMjgyMDMwMjQxMSxcbiAgICAzMTU4NDU0MjczLFxuICAgIDMyNTk3MzA4MDAsXG4gICAgMzUwNTk1MjY1NyxcbiAgICAzMzQ1NzY0NzcxLFxuICAgIDEwNjIxNzAwOCxcbiAgICAzNTE2MDY1ODE3LFxuICAgIDM2MDYwMDgzNDQsXG4gICAgMzYwMDM1MjgwNCxcbiAgICAxNDMyNzI1Nzc2LFxuICAgIDQwOTQ1NzE5MDksXG4gICAgMTQ2NzAzMTU5NCxcbiAgICAyNzU0MjMzNDQsXG4gICAgODUxMTY5NzIwLFxuICAgIDQzMDIyNzczNCxcbiAgICAzMTAwODIzNzUyLFxuICAgIDUwNjk0ODYxNixcbiAgICAxMzYzMjU4MTk1LFxuICAgIDY1OTA2MDU1NixcbiAgICAzNzUwNjg1NTkzLFxuICAgIDg4Mzk5Nzg3NyxcbiAgICAzNzg1MDUwMjgwLFxuICAgIDk1ODEzOTU3MSxcbiAgICAzMzE4MzA3NDI3LFxuICAgIDEzMjI4MjIyMTgsXG4gICAgMzgxMjcyMzQwMyxcbiAgICAxNTM3MDAyMDYzLFxuICAgIDIwMDMwMzQ5OTUsXG4gICAgMTc0Nzg3Mzc3OSxcbiAgICAzNjAyMDM2ODk5LFxuICAgIDE5NTU1NjIyMjIsXG4gICAgMTU3NTk5MDAxMixcbiAgICAyMDI0MTA0ODE1LFxuICAgIDExMjU1OTI5MjgsXG4gICAgMjIyNzczMDQ1MixcbiAgICAyNzE2OTA0MzA2LFxuICAgIDIzNjE4NTI0MjQsXG4gICAgNDQyNzc2MDQ0LFxuICAgIDI0Mjg0MzY0NzQsXG4gICAgNTkzNjk4MzQ0LFxuICAgIDI3NTY3MzQxODcsXG4gICAgMzczMzExMDI0OSxcbiAgICAzMjA0MDMxNDc5LFxuICAgIDI5OTkzNTE1NzMsXG4gICAgMzMyOTMyNTI5OCxcbiAgICAzODE1OTIwNDI3LFxuICAgIDMzOTE1Njk2MTQsXG4gICAgMzkyODM4MzkwMCxcbiAgICAzNTE1MjY3MjcxLFxuICAgIDU2NjI4MDcxMSxcbiAgICAzOTQwMTg3NjA2LFxuICAgIDM0NTQwNjk1MzQsXG4gICAgNDExODYzMDI3MSxcbiAgICA0MDAwMjM5OTkyLFxuICAgIDExNjQxODQ3NCxcbiAgICAxOTE0MTM4NTU0LFxuICAgIDE3NDI5MjQyMSxcbiAgICAyNzMxMDU1MjcwLFxuICAgIDI4OTM4MDM1NixcbiAgICAzMjAzOTkzMDA2LFxuICAgIDQ2MDM5MzI2OSxcbiAgICAzMjA2MjAzMTUsXG4gICAgNjg1NDcxNzMzLFxuICAgIDU4NzQ5NjgzNixcbiAgICA4NTIxNDI5NzEsXG4gICAgMTA4Njc5Mjg1MSxcbiAgICAxMDE3MDM2Mjk4LFxuICAgIDM2NTU0MzEwMCxcbiAgICAxMTI2MDAwNTgwLFxuICAgIDI2MTgyOTc2NzYsXG4gICAgMTI4ODAzMzQ3MCxcbiAgICAzNDA5ODU1MTU4LFxuICAgIDE1MDE1MDU5NDgsXG4gICAgNDIzNDUwOTg2NixcbiAgICAxNjA3MTY3OTE1LFxuICAgIDk4NzE2NzQ2OCxcbiAgICAxODE2NDAyMzE2LFxuICAgIDEyNDYxODk1OTFcbiAgXTtcbiAgZnVuY3Rpb24gU0hBNTEyKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEE1MTIpKVxuICAgICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcbiAgICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgICB0aGlzLmggPSBbXG4gICAgICAxNzc5MDMzNzAzLFxuICAgICAgNDA4OTIzNTcyMCxcbiAgICAgIDMxNDQxMzQyNzcsXG4gICAgICAyMjI3ODczNTk1LFxuICAgICAgMTAxMzkwNDI0MixcbiAgICAgIDQyNzExNzU3MjMsXG4gICAgICAyNzczNDgwNzYyLFxuICAgICAgMTU5NTc1MDEyOSxcbiAgICAgIDEzNTk4OTMxMTksXG4gICAgICAyOTE3NTY1MTM3LFxuICAgICAgMjYwMDgyMjkyNCxcbiAgICAgIDcyNTUxMTE5OSxcbiAgICAgIDUyODczNDYzNSxcbiAgICAgIDQyMTUzODk1NDcsXG4gICAgICAxNTQxNDU5MjI1LFxuICAgICAgMzI3MDMzMjA5XG4gICAgXTtcbiAgICB0aGlzLmsgPSBzaGE1MTJfSztcbiAgICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbiAgfVxuICB1dGlsczIuaW5oZXJpdHMoU0hBNTEyLCBCbG9ja0hhc2gpO1xuICBfNTEyID0gU0hBNTEyO1xuICBTSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcbiAgU0hBNTEyLm91dFNpemUgPSA1MTI7XG4gIFNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG4gIFNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG4gIFNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICAgIHZhciBXID0gdGhpcy5XO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pO1xuICAgICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG4gICAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07XG4gICAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG4gICAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pO1xuICAgICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTtcbiAgICAgIHZhciBjM19sbyA9IFdbaSAtIDMxXTtcbiAgICAgIFdbaV0gPSBzdW02NF80X2hpKFxuICAgICAgICBjMF9oaSxcbiAgICAgICAgYzBfbG8sXG4gICAgICAgIGMxX2hpLFxuICAgICAgICBjMV9sbyxcbiAgICAgICAgYzJfaGksXG4gICAgICAgIGMyX2xvLFxuICAgICAgICBjM19oaSxcbiAgICAgICAgYzNfbG9cbiAgICAgICk7XG4gICAgICBXW2kgKyAxXSA9IHN1bTY0XzRfbG8oXG4gICAgICAgIGMwX2hpLFxuICAgICAgICBjMF9sbyxcbiAgICAgICAgYzFfaGksXG4gICAgICAgIGMxX2xvLFxuICAgICAgICBjMl9oaSxcbiAgICAgICAgYzJfbG8sXG4gICAgICAgIGMzX2hpLFxuICAgICAgICBjM19sb1xuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIFNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICAgIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcbiAgICB2YXIgVyA9IHRoaXMuVztcbiAgICB2YXIgYWggPSB0aGlzLmhbMF07XG4gICAgdmFyIGFsID0gdGhpcy5oWzFdO1xuICAgIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgICB2YXIgYmwgPSB0aGlzLmhbM107XG4gICAgdmFyIGNoID0gdGhpcy5oWzRdO1xuICAgIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgICB2YXIgZGggPSB0aGlzLmhbNl07XG4gICAgdmFyIGRsID0gdGhpcy5oWzddO1xuICAgIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gICAgdmFyIGZoID0gdGhpcy5oWzEwXTtcbiAgICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICAgIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gICAgdmFyIGdsID0gdGhpcy5oWzEzXTtcbiAgICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICAgIHZhciBobCA9IHRoaXMuaFsxNV07XG4gICAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBjMF9oaSA9IGhoO1xuICAgICAgdmFyIGMwX2xvID0gaGw7XG4gICAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcbiAgICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gpO1xuICAgICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICAgIHZhciBjM19sbyA9IHRoaXMua1tpICsgMV07XG4gICAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG4gICAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgICBjMF9oaSxcbiAgICAgICAgYzBfbG8sXG4gICAgICAgIGMxX2hpLFxuICAgICAgICBjMV9sbyxcbiAgICAgICAgYzJfaGksXG4gICAgICAgIGMyX2xvLFxuICAgICAgICBjM19oaSxcbiAgICAgICAgYzNfbG8sXG4gICAgICAgIGM0X2hpLFxuICAgICAgICBjNF9sb1xuICAgICAgKTtcbiAgICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8oXG4gICAgICAgIGMwX2hpLFxuICAgICAgICBjMF9sbyxcbiAgICAgICAgYzFfaGksXG4gICAgICAgIGMxX2xvLFxuICAgICAgICBjMl9oaSxcbiAgICAgICAgYzJfbG8sXG4gICAgICAgIGMzX2hpLFxuICAgICAgICBjM19sbyxcbiAgICAgICAgYzRfaGksXG4gICAgICAgIGM0X2xvXG4gICAgICApO1xuICAgICAgYzBfaGkgPSBzMF81MTJfaGkoYWgsIGFsKTtcbiAgICAgIGMwX2xvID0gczBfNTEyX2xvKGFoLCBhbCk7XG4gICAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCk7XG4gICAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgICAgaGggPSBnaDtcbiAgICAgIGhsID0gZ2w7XG4gICAgICBnaCA9IGZoO1xuICAgICAgZ2wgPSBmbDtcbiAgICAgIGZoID0gZWg7XG4gICAgICBmbCA9IGVsO1xuICAgICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgICBlbCA9IHN1bTY0X2xvKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcbiAgICAgIGRoID0gY2g7XG4gICAgICBkbCA9IGNsO1xuICAgICAgY2ggPSBiaDtcbiAgICAgIGNsID0gYmw7XG4gICAgICBiaCA9IGFoO1xuICAgICAgYmwgPSBhbDtcbiAgICAgIGFoID0gc3VtNjRfaGkoVDFfaGksIFQxX2xvLCBUMl9oaSwgVDJfbG8pO1xuICAgICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgfVxuICAgIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgICBzdW02NCh0aGlzLmgsIDIsIGJoLCBibCk7XG4gICAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICAgIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgICBzdW02NCh0aGlzLmgsIDgsIGVoLCBlbCk7XG4gICAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICAgIHN1bTY0KHRoaXMuaCwgMTQsIGhoLCBobCk7XG4gIH07XG4gIFNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgICBpZiAoZW5jID09PSBcImhleFwiKVxuICAgICAgcmV0dXJuIHV0aWxzMi50b0hleDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHV0aWxzMi5zcGxpdDMyKHRoaXMuaCwgXCJiaWdcIik7XG4gIH07XG4gIGZ1bmN0aW9uIGNoNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG4gICAgdmFyIHIgPSB4aCAmIHloIF4gfnhoICYgemg7XG4gICAgaWYgKHIgPCAwKVxuICAgICAgciArPSA0Mjk0OTY3Mjk2O1xuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICAgIHZhciByID0geGwgJiB5bCBeIH54bCAmIHpsO1xuICAgIGlmIChyIDwgMClcbiAgICAgIHIgKz0gNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgICB2YXIgciA9IHhoICYgeWggXiB4aCAmIHpoIF4geWggJiB6aDtcbiAgICBpZiAociA8IDApXG4gICAgICByICs9IDQyOTQ5NjcyOTY7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gbWFqNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICAgIHZhciByID0geGwgJiB5bCBeIHhsICYgemwgXiB5bCAmIHpsO1xuICAgIGlmIChyIDwgMClcbiAgICAgIHIgKz0gNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBzMF81MTJfaGkoeGgsIHhsKSB7XG4gICAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICAgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDIpO1xuICAgIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpO1xuICAgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICAgIGlmIChyIDwgMClcbiAgICAgIHIgKz0gNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gICAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMjgpO1xuICAgIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDIpO1xuICAgIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDcpO1xuICAgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICAgIGlmIChyIDwgMClcbiAgICAgIHIgKz0gNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBzMV81MTJfaGkoeGgsIHhsKSB7XG4gICAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTQpO1xuICAgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA5KTtcbiAgICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgICBpZiAociA8IDApXG4gICAgICByICs9IDQyOTQ5NjcyOTY7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gczFfNTEyX2xvKHhoLCB4bCkge1xuICAgIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE0KTtcbiAgICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gICAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgOSk7XG4gICAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gICAgaWYgKHIgPCAwKVxuICAgICAgciArPSA0Mjk0OTY3Mjk2O1xuICAgIHJldHVybiByO1xuICB9XG4gIGZ1bmN0aW9uIGcwXzUxMl9oaSh4aCwgeGwpIHtcbiAgICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxKTtcbiAgICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgICB2YXIgYzJfaGkgPSBzaHI2NF9oaSh4aCwgeGwsIDcpO1xuICAgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICAgIGlmIChyIDwgMClcbiAgICAgIHIgKz0gNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBmdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gICAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMSk7XG4gICAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgOCk7XG4gICAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcbiAgICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgICBpZiAociA8IDApXG4gICAgICByICs9IDQyOTQ5NjcyOTY7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gZzFfNTEyX2hpKHhoLCB4bCkge1xuICAgIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyOSk7XG4gICAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcbiAgICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgICBpZiAociA8IDApXG4gICAgICByICs9IDQyOTQ5NjcyOTY7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gZzFfNTEyX2xvKHhoLCB4bCkge1xuICAgIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCAyOSk7XG4gICAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcbiAgICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgICBpZiAociA8IDApXG4gICAgICByICs9IDQyOTQ5NjcyOTY7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIF81MTI7XG59XG52YXIgXzM4NDtcbnZhciBoYXNSZXF1aXJlZF8zODQ7XG5mdW5jdGlvbiByZXF1aXJlXzM4NCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkXzM4NCkgcmV0dXJuIF8zODQ7XG4gIGhhc1JlcXVpcmVkXzM4NCA9IDE7XG4gIHZhciB1dGlsczIgPSByZXF1aXJlVXRpbHMoKTtcbiAgdmFyIFNIQTUxMiA9IHJlcXVpcmVfNTEyKCk7XG4gIGZ1bmN0aW9uIFNIQTM4NCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG4gICAgU0hBNTEyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oID0gW1xuICAgICAgMzQxODA3MDM2NSxcbiAgICAgIDMyMzgzNzEwMzIsXG4gICAgICAxNjU0MjcwMjUwLFxuICAgICAgOTE0MTUwNjYzLFxuICAgICAgMjQzODUyOTM3MCxcbiAgICAgIDgxMjcwMjk5OSxcbiAgICAgIDM1NTQ2MjM2MCxcbiAgICAgIDQxNDQ5MTI2OTcsXG4gICAgICAxNzMxNDA1NDE1LFxuICAgICAgNDI5MDc3NTg1NyxcbiAgICAgIDIzOTQxODAyMzEsXG4gICAgICAxNzUwNjAzMDI1LFxuICAgICAgMzY3NTAwODUyNSxcbiAgICAgIDE2OTQwNzY4MzksXG4gICAgICAxMjAzMDYyODEzLFxuICAgICAgMzIwNDA3NTQyOFxuICAgIF07XG4gIH1cbiAgdXRpbHMyLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbiAgXzM4NCA9IFNIQTM4NDtcbiAgU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG4gIFNIQTM4NC5vdXRTaXplID0gMzg0O1xuICBTSEEzODQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuICBTSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuICBTSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gICAgaWYgKGVuYyA9PT0gXCJoZXhcIilcbiAgICAgIHJldHVybiB1dGlsczIudG9IZXgzMih0aGlzLmguc2xpY2UoMCwgMTIpLCBcImJpZ1wiKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdXRpbHMyLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgXCJiaWdcIik7XG4gIH07XG4gIHJldHVybiBfMzg0O1xufVxudmFyIGhhc1JlcXVpcmVkU2hhO1xuZnVuY3Rpb24gcmVxdWlyZVNoYSgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkU2hhKSByZXR1cm4gc2hhO1xuICBoYXNSZXF1aXJlZFNoYSA9IDE7XG4gIHNoYS5zaGExID0gcmVxdWlyZV8xKCk7XG4gIHNoYS5zaGEyMjQgPSByZXF1aXJlXzIyNCgpO1xuICBzaGEuc2hhMjU2ID0gcmVxdWlyZV8yNTYoKTtcbiAgc2hhLnNoYTM4NCA9IHJlcXVpcmVfMzg0KCk7XG4gIHNoYS5zaGE1MTIgPSByZXF1aXJlXzUxMigpO1xuICByZXR1cm4gc2hhO1xufVxudmFyIHJpcGVtZCA9IHt9O1xudmFyIGhhc1JlcXVpcmVkUmlwZW1kO1xuZnVuY3Rpb24gcmVxdWlyZVJpcGVtZCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUmlwZW1kKSByZXR1cm4gcmlwZW1kO1xuICBoYXNSZXF1aXJlZFJpcGVtZCA9IDE7XG4gIHZhciB1dGlsczIgPSByZXF1aXJlVXRpbHMoKTtcbiAgdmFyIGNvbW1vbjIgPSByZXF1aXJlQ29tbW9uJDEoKTtcbiAgdmFyIHJvdGwzMiA9IHV0aWxzMi5yb3RsMzI7XG4gIHZhciBzdW0zMiA9IHV0aWxzMi5zdW0zMjtcbiAgdmFyIHN1bTMyXzMgPSB1dGlsczIuc3VtMzJfMztcbiAgdmFyIHN1bTMyXzQgPSB1dGlsczIuc3VtMzJfNDtcbiAgdmFyIEJsb2NrSGFzaCA9IGNvbW1vbjIuQmxvY2tIYXNoO1xuICBmdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuICAgIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaCA9IFsxNzMyNTg0MTkzLCA0MDIzMjMzNDE3LCAyNTYyMzgzMTAyLCAyNzE3MzM4NzgsIDMyODUzNzc1MjBdO1xuICAgIHRoaXMuZW5kaWFuID0gXCJsaXR0bGVcIjtcbiAgfVxuICB1dGlsczIuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuICByaXBlbWQucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuICBSSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuICBSSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcbiAgUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcbiAgUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuICBSSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICAgIHZhciBBID0gdGhpcy5oWzBdO1xuICAgIHZhciBCID0gdGhpcy5oWzFdO1xuICAgIHZhciBDID0gdGhpcy5oWzJdO1xuICAgIHZhciBEID0gdGhpcy5oWzNdO1xuICAgIHZhciBFID0gdGhpcy5oWzRdO1xuICAgIHZhciBBaCA9IEE7XG4gICAgdmFyIEJoID0gQjtcbiAgICB2YXIgQ2ggPSBDO1xuICAgIHZhciBEaCA9IEQ7XG4gICAgdmFyIEVoID0gRTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgIHZhciBUID0gc3VtMzIoXG4gICAgICAgIHJvdGwzMihcbiAgICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgICBzW2pdXG4gICAgICAgICksXG4gICAgICAgIEVcbiAgICAgICk7XG4gICAgICBBID0gRTtcbiAgICAgIEUgPSBEO1xuICAgICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgICBDID0gQjtcbiAgICAgIEIgPSBUO1xuICAgICAgVCA9IHN1bTMyKFxuICAgICAgICByb3RsMzIoXG4gICAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgICBzaFtqXVxuICAgICAgICApLFxuICAgICAgICBFaFxuICAgICAgKTtcbiAgICAgIEFoID0gRWg7XG4gICAgICBFaCA9IERoO1xuICAgICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICAgIENoID0gQmg7XG4gICAgICBCaCA9IFQ7XG4gICAgfVxuICAgIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICAgIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gICAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICAgIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gICAgdGhpcy5oWzBdID0gVDtcbiAgfTtcbiAgUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICAgIGlmIChlbmMgPT09IFwiaGV4XCIpXG4gICAgICByZXR1cm4gdXRpbHMyLnRvSGV4MzIodGhpcy5oLCBcImxpdHRsZVwiKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdXRpbHMyLnNwbGl0MzIodGhpcy5oLCBcImxpdHRsZVwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gICAgaWYgKGogPD0gMTUpXG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgICByZXR1cm4geCAmIHkgfCB+eCAmIHo7XG4gICAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICAgIHJldHVybiAoeCB8IH55KSBeIHo7XG4gICAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICAgIHJldHVybiB4ICYgeiB8IHkgJiB+ejtcbiAgICBlbHNlXG4gICAgICByZXR1cm4geCBeICh5IHwgfnopO1xuICB9XG4gIGZ1bmN0aW9uIEsoaikge1xuICAgIGlmIChqIDw9IDE1KVxuICAgICAgcmV0dXJuIDA7XG4gICAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICAgIHJldHVybiAxNTE4NTAwMjQ5O1xuICAgIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgICByZXR1cm4gMTg1OTc3NTM5MztcbiAgICBlbHNlIGlmIChqIDw9IDYzKVxuICAgICAgcmV0dXJuIDI0MDA5NTk3MDg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIDI4NDA4NTM4Mzg7XG4gIH1cbiAgZnVuY3Rpb24gS2goaikge1xuICAgIGlmIChqIDw9IDE1KVxuICAgICAgcmV0dXJuIDEzNTI4Mjk5MjY7XG4gICAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICAgIHJldHVybiAxNTQ4NjAzNjg0O1xuICAgIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgICByZXR1cm4gMTgzNjA3MjY5MTtcbiAgICBlbHNlIGlmIChqIDw9IDYzKVxuICAgICAgcmV0dXJuIDIwNTM5OTQyMTc7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHIgPSBbXG4gICAgMCxcbiAgICAxLFxuICAgIDIsXG4gICAgMyxcbiAgICA0LFxuICAgIDUsXG4gICAgNixcbiAgICA3LFxuICAgIDgsXG4gICAgOSxcbiAgICAxMCxcbiAgICAxMSxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxNCxcbiAgICAxNSxcbiAgICA3LFxuICAgIDQsXG4gICAgMTMsXG4gICAgMSxcbiAgICAxMCxcbiAgICA2LFxuICAgIDE1LFxuICAgIDMsXG4gICAgMTIsXG4gICAgMCxcbiAgICA5LFxuICAgIDUsXG4gICAgMixcbiAgICAxNCxcbiAgICAxMSxcbiAgICA4LFxuICAgIDMsXG4gICAgMTAsXG4gICAgMTQsXG4gICAgNCxcbiAgICA5LFxuICAgIDE1LFxuICAgIDgsXG4gICAgMSxcbiAgICAyLFxuICAgIDcsXG4gICAgMCxcbiAgICA2LFxuICAgIDEzLFxuICAgIDExLFxuICAgIDUsXG4gICAgMTIsXG4gICAgMSxcbiAgICA5LFxuICAgIDExLFxuICAgIDEwLFxuICAgIDAsXG4gICAgOCxcbiAgICAxMixcbiAgICA0LFxuICAgIDEzLFxuICAgIDMsXG4gICAgNyxcbiAgICAxNSxcbiAgICAxNCxcbiAgICA1LFxuICAgIDYsXG4gICAgMixcbiAgICA0LFxuICAgIDAsXG4gICAgNSxcbiAgICA5LFxuICAgIDcsXG4gICAgMTIsXG4gICAgMixcbiAgICAxMCxcbiAgICAxNCxcbiAgICAxLFxuICAgIDMsXG4gICAgOCxcbiAgICAxMSxcbiAgICA2LFxuICAgIDE1LFxuICAgIDEzXG4gIF07XG4gIHZhciByaCA9IFtcbiAgICA1LFxuICAgIDE0LFxuICAgIDcsXG4gICAgMCxcbiAgICA5LFxuICAgIDIsXG4gICAgMTEsXG4gICAgNCxcbiAgICAxMyxcbiAgICA2LFxuICAgIDE1LFxuICAgIDgsXG4gICAgMSxcbiAgICAxMCxcbiAgICAzLFxuICAgIDEyLFxuICAgIDYsXG4gICAgMTEsXG4gICAgMyxcbiAgICA3LFxuICAgIDAsXG4gICAgMTMsXG4gICAgNSxcbiAgICAxMCxcbiAgICAxNCxcbiAgICAxNSxcbiAgICA4LFxuICAgIDEyLFxuICAgIDQsXG4gICAgOSxcbiAgICAxLFxuICAgIDIsXG4gICAgMTUsXG4gICAgNSxcbiAgICAxLFxuICAgIDMsXG4gICAgNyxcbiAgICAxNCxcbiAgICA2LFxuICAgIDksXG4gICAgMTEsXG4gICAgOCxcbiAgICAxMixcbiAgICAyLFxuICAgIDEwLFxuICAgIDAsXG4gICAgNCxcbiAgICAxMyxcbiAgICA4LFxuICAgIDYsXG4gICAgNCxcbiAgICAxLFxuICAgIDMsXG4gICAgMTEsXG4gICAgMTUsXG4gICAgMCxcbiAgICA1LFxuICAgIDEyLFxuICAgIDIsXG4gICAgMTMsXG4gICAgOSxcbiAgICA3LFxuICAgIDEwLFxuICAgIDE0LFxuICAgIDEyLFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDQsXG4gICAgMSxcbiAgICA1LFxuICAgIDgsXG4gICAgNyxcbiAgICA2LFxuICAgIDIsXG4gICAgMTMsXG4gICAgMTQsXG4gICAgMCxcbiAgICAzLFxuICAgIDksXG4gICAgMTFcbiAgXTtcbiAgdmFyIHMgPSBbXG4gICAgMTEsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgMTIsXG4gICAgNSxcbiAgICA4LFxuICAgIDcsXG4gICAgOSxcbiAgICAxMSxcbiAgICAxMyxcbiAgICAxNCxcbiAgICAxNSxcbiAgICA2LFxuICAgIDcsXG4gICAgOSxcbiAgICA4LFxuICAgIDcsXG4gICAgNixcbiAgICA4LFxuICAgIDEzLFxuICAgIDExLFxuICAgIDksXG4gICAgNyxcbiAgICAxNSxcbiAgICA3LFxuICAgIDEyLFxuICAgIDE1LFxuICAgIDksXG4gICAgMTEsXG4gICAgNyxcbiAgICAxMyxcbiAgICAxMixcbiAgICAxMSxcbiAgICAxMyxcbiAgICA2LFxuICAgIDcsXG4gICAgMTQsXG4gICAgOSxcbiAgICAxMyxcbiAgICAxNSxcbiAgICAxNCxcbiAgICA4LFxuICAgIDEzLFxuICAgIDYsXG4gICAgNSxcbiAgICAxMixcbiAgICA3LFxuICAgIDUsXG4gICAgMTEsXG4gICAgMTIsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgMTQsXG4gICAgMTUsXG4gICAgOSxcbiAgICA4LFxuICAgIDksXG4gICAgMTQsXG4gICAgNSxcbiAgICA2LFxuICAgIDgsXG4gICAgNixcbiAgICA1LFxuICAgIDEyLFxuICAgIDksXG4gICAgMTUsXG4gICAgNSxcbiAgICAxMSxcbiAgICA2LFxuICAgIDgsXG4gICAgMTMsXG4gICAgMTIsXG4gICAgNSxcbiAgICAxMixcbiAgICAxMyxcbiAgICAxNCxcbiAgICAxMSxcbiAgICA4LFxuICAgIDUsXG4gICAgNlxuICBdO1xuICB2YXIgc2ggPSBbXG4gICAgOCxcbiAgICA5LFxuICAgIDksXG4gICAgMTEsXG4gICAgMTMsXG4gICAgMTUsXG4gICAgMTUsXG4gICAgNSxcbiAgICA3LFxuICAgIDcsXG4gICAgOCxcbiAgICAxMSxcbiAgICAxNCxcbiAgICAxNCxcbiAgICAxMixcbiAgICA2LFxuICAgIDksXG4gICAgMTMsXG4gICAgMTUsXG4gICAgNyxcbiAgICAxMixcbiAgICA4LFxuICAgIDksXG4gICAgMTEsXG4gICAgNyxcbiAgICA3LFxuICAgIDEyLFxuICAgIDcsXG4gICAgNixcbiAgICAxNSxcbiAgICAxMyxcbiAgICAxMSxcbiAgICA5LFxuICAgIDcsXG4gICAgMTUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA2LFxuICAgIDYsXG4gICAgMTQsXG4gICAgMTIsXG4gICAgMTMsXG4gICAgNSxcbiAgICAxNCxcbiAgICAxMyxcbiAgICAxMyxcbiAgICA3LFxuICAgIDUsXG4gICAgMTUsXG4gICAgNSxcbiAgICA4LFxuICAgIDExLFxuICAgIDE0LFxuICAgIDE0LFxuICAgIDYsXG4gICAgMTQsXG4gICAgNixcbiAgICA5LFxuICAgIDEyLFxuICAgIDksXG4gICAgMTIsXG4gICAgNSxcbiAgICAxNSxcbiAgICA4LFxuICAgIDgsXG4gICAgNSxcbiAgICAxMixcbiAgICA5LFxuICAgIDEyLFxuICAgIDUsXG4gICAgMTQsXG4gICAgNixcbiAgICA4LFxuICAgIDEzLFxuICAgIDYsXG4gICAgNSxcbiAgICAxNSxcbiAgICAxMyxcbiAgICAxMSxcbiAgICAxMVxuICBdO1xuICByZXR1cm4gcmlwZW1kO1xufVxudmFyIGhtYWM7XG52YXIgaGFzUmVxdWlyZWRIbWFjO1xuZnVuY3Rpb24gcmVxdWlyZUhtYWMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEhtYWMpIHJldHVybiBobWFjO1xuICBoYXNSZXF1aXJlZEhtYWMgPSAxO1xuICB2YXIgdXRpbHMyID0gcmVxdWlyZVV0aWxzKCk7XG4gIHZhciBhc3NlcnQgPSByZXF1aXJlTWluaW1hbGlzdGljQXNzZXJ0KCk7XG4gIGZ1bmN0aW9uIEhtYWMoaGFzaDIsIGtleSwgZW5jKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKVxuICAgICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gyLCBrZXksIGVuYyk7XG4gICAgdGhpcy5IYXNoID0gaGFzaDI7XG4gICAgdGhpcy5ibG9ja1NpemUgPSBoYXNoMi5ibG9ja1NpemUgLyA4O1xuICAgIHRoaXMub3V0U2l6ZSA9IGhhc2gyLm91dFNpemUgLyA4O1xuICAgIHRoaXMuaW5uZXIgPSBudWxsO1xuICAgIHRoaXMub3V0ZXIgPSBudWxsO1xuICAgIHRoaXMuX2luaXQodXRpbHMyLnRvQXJyYXkoa2V5LCBlbmMpKTtcbiAgfVxuICBobWFjID0gSG1hYztcbiAgSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAgIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gICAgYXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuICAgIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICAgIGtleS5wdXNoKDApO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAgICBrZXlbaV0gXj0gNTQ7XG4gICAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgICAga2V5W2ldIF49IDEwNjtcbiAgICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuICB9O1xuICBIbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbiAgfTtcbiAgcmV0dXJuIGhtYWM7XG59XG52YXIgaGFzUmVxdWlyZWRIYXNoO1xuZnVuY3Rpb24gcmVxdWlyZUhhc2goKSB7XG4gIGlmIChoYXNSZXF1aXJlZEhhc2gpIHJldHVybiBoYXNoJDE7XG4gIGhhc1JlcXVpcmVkSGFzaCA9IDE7XG4gIChmdW5jdGlvbihleHBvcnRzKSB7XG4gICAgdmFyIGhhc2gyID0gZXhwb3J0cztcbiAgICBoYXNoMi51dGlscyA9IHJlcXVpcmVVdGlscygpO1xuICAgIGhhc2gyLmNvbW1vbiA9IHJlcXVpcmVDb21tb24kMSgpO1xuICAgIGhhc2gyLnNoYSA9IHJlcXVpcmVTaGEoKTtcbiAgICBoYXNoMi5yaXBlbWQgPSByZXF1aXJlUmlwZW1kKCk7XG4gICAgaGFzaDIuaG1hYyA9IHJlcXVpcmVIbWFjKCk7XG4gICAgaGFzaDIuc2hhMSA9IGhhc2gyLnNoYS5zaGExO1xuICAgIGhhc2gyLnNoYTI1NiA9IGhhc2gyLnNoYS5zaGEyNTY7XG4gICAgaGFzaDIuc2hhMjI0ID0gaGFzaDIuc2hhLnNoYTIyNDtcbiAgICBoYXNoMi5zaGEzODQgPSBoYXNoMi5zaGEuc2hhMzg0O1xuICAgIGhhc2gyLnNoYTUxMiA9IGhhc2gyLnNoYS5zaGE1MTI7XG4gICAgaGFzaDIucmlwZW1kMTYwID0gaGFzaDIucmlwZW1kLnJpcGVtZDE2MDtcbiAgfSkoaGFzaCQxKTtcbiAgcmV0dXJuIGhhc2gkMTtcbn1cbnZhciBoYXNoRXhwb3J0cyA9IHJlcXVpcmVIYXNoKCk7XG5jb25zdCBoYXNoID0gLyogQF9fUFVSRV9fICovIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoaGFzaEV4cG9ydHMpO1xubGV0IHVybEFscGhhYmV0ID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSBcIlwiO1xuICAgIGxldCBpID0gc2l6ZSB8IDA7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWQgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCB8IDBdO1xuICAgIH1cbiAgICByZXR1cm4gaWQ7XG4gIH07XG59O1xubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplIHwgMDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0W01hdGgucmFuZG9tKCkgKiA2NCB8IDBdO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5jb25zdCBjb252ZXJ0TWlsbGltZXRlcnNUb1R3aXAgPSAobWlsbGltZXRlcnMpID0+IE1hdGguZmxvb3IobWlsbGltZXRlcnMgLyAyNS40ICogNzIgKiAyMCk7XG5jb25zdCBjb252ZXJ0SW5jaGVzVG9Ud2lwID0gKGluY2hlcykgPT4gTWF0aC5mbG9vcihpbmNoZXMgKiA3MiAqIDIwKTtcbmNvbnN0IHVuaXF1ZU51bWVyaWNJZENyZWF0b3IgPSAoaW5pdGlhbCA9IDApID0+IHtcbiAgbGV0IGN1cnJlbnRDb3VudCA9IGluaXRpYWw7XG4gIHJldHVybiAoKSA9PiArK2N1cnJlbnRDb3VudDtcbn07XG5jb25zdCBhYnN0cmFjdE51bVVuaXF1ZU51bWVyaWNJZEdlbiA9ICgpID0+IHVuaXF1ZU51bWVyaWNJZENyZWF0b3IoKTtcbmNvbnN0IGNvbmNyZXRlTnVtVW5pcXVlTnVtZXJpY0lkR2VuID0gKCkgPT4gdW5pcXVlTnVtZXJpY0lkQ3JlYXRvcigxKTtcbmNvbnN0IGRvY1Byb3BlcnRpZXNVbmlxdWVOdW1lcmljSWRHZW4gPSAoKSA9PiB1bmlxdWVOdW1lcmljSWRDcmVhdG9yKCk7XG5jb25zdCBib29rbWFya1VuaXF1ZU51bWVyaWNJZEdlbiA9ICgpID0+IHVuaXF1ZU51bWVyaWNJZENyZWF0b3IoKTtcbmNvbnN0IHVuaXF1ZUlkID0gKCkgPT4gbmFub2lkKCkudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGhhc2hlZElkID0gKGRhdGEpID0+IGhhc2guc2hhMSgpLnVwZGF0ZShkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShkYXRhKSA6IGRhdGEpLmRpZ2VzdChcImhleFwiKTtcbmNvbnN0IGdlbmVyYXRlVXVpZFBhcnQgPSAoY291bnQpID0+IGN1c3RvbUFscGhhYmV0KFwiMTIzNDU2Nzg5MGFiY2RlZlwiLCBjb3VudCkoKTtcbmNvbnN0IHVuaXF1ZVV1aWQgPSAoKSA9PiBgJHtnZW5lcmF0ZVV1aWRQYXJ0KDgpfS0ke2dlbmVyYXRlVXVpZFBhcnQoNCl9LSR7Z2VuZXJhdGVVdWlkUGFydCg0KX0tJHtnZW5lcmF0ZVV1aWRQYXJ0KDQpfS0ke2dlbmVyYXRlVXVpZFBhcnQoMTIpfWA7XG5jb25zdCBIb3Jpem9udGFsUG9zaXRpb25SZWxhdGl2ZUZyb20gPSB7XG4gIC8qKlxuICAgKiAjIyBDaGFyYWN0ZXJcbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIGhvcml6b250YWwgcG9zaXRpb25pbmcgc2hhbGwgYmUgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBhbmNob3Igd2l0aGluIGl0cyBydW4gY29udGVudC5cbiAgICovXG4gIENIQVJBQ1RFUjogXCJjaGFyYWN0ZXJcIixcbiAgLyoqXG4gICAqICMjIENvbHVtblxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgZXh0ZW50cyBvZiB0aGUgY29sdW1uIHdoaWNoIGNvbnRhaW5zIGl0cyBhbmNob3IuXG4gICAqL1xuICBDT0xVTU46IFwiY29sdW1uXCIsXG4gIC8qKlxuICAgKiAjIyBJbnNpZGUgTWFyZ2luXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBpbnNpZGUgbWFyZ2luIG9mIHRoZSBjdXJyZW50IHBhZ2UgKHRoZSBsZWZ0IG1hcmdpbiBvbiBvZGQgcGFnZXMsIHJpZ2h0IG9uIGV2ZW4gcGFnZXMpLlxuICAgKi9cbiAgSU5TSURFX01BUkdJTjogXCJpbnNpZGVNYXJnaW5cIixcbiAgLyoqXG4gICAqICMjIExlZnQgTWFyZ2luXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBsZWZ0IG1hcmdpbiBvZiB0aGUgcGFnZS5cbiAgICovXG4gIExFRlRfTUFSR0lOOiBcImxlZnRNYXJnaW5cIixcbiAgLyoqXG4gICAqICMjIFBhZ2UgTWFyZ2luXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBwYWdlIG1hcmdpbnMuXG4gICAqL1xuICBNQVJHSU46IFwibWFyZ2luXCIsXG4gIC8qKlxuICAgKiAjIyBPdXRzaWRlIE1hcmdpblxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgb3V0c2lkZSBtYXJnaW4gb2YgdGhlIGN1cnJlbnQgcGFnZSAodGhlIHJpZ2h0IG1hcmdpbiBvbiBvZGQgcGFnZXMsIGxlZnQgb24gZXZlbiBwYWdlcykuXG4gICAqL1xuICBPVVRTSURFX01BUkdJTjogXCJvdXRzaWRlTWFyZ2luXCIsXG4gIC8qKlxuICAgKiAjIyBQYWdlIEVkZ2VcbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIGhvcml6b250YWwgcG9zaXRpb25pbmcgc2hhbGwgYmUgcmVsYXRpdmUgdG8gdGhlIGVkZ2Ugb2YgdGhlIHBhZ2UuXG4gICAqL1xuICBQQUdFOiBcInBhZ2VcIixcbiAgLyoqXG4gICAqICMjIFJpZ2h0IE1hcmdpblxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgcmlnaHQgbWFyZ2luIG9mIHRoZSBwYWdlLlxuICAgKi9cbiAgUklHSFRfTUFSR0lOOiBcInJpZ2h0TWFyZ2luXCJcbn07XG5jb25zdCBWZXJ0aWNhbFBvc2l0aW9uUmVsYXRpdmVGcm9tID0ge1xuICAvKipcbiAgICogIyMgQm90dG9tIE1hcmdpblxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgdmVydGljYWwgcG9zaXRpb25pbmcgc2hhbGwgYmUgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBtYXJnaW4gb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICovXG4gIEJPVFRPTV9NQVJHSU46IFwiYm90dG9tTWFyZ2luXCIsXG4gIC8qKlxuICAgKiAjIyBJbnNpZGUgTWFyZ2luXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgaW5zaWRlIG1hcmdpbiBvZiB0aGUgY3VycmVudCBwYWdlLlxuICAgKi9cbiAgSU5TSURFX01BUkdJTjogXCJpbnNpZGVNYXJnaW5cIixcbiAgLyoqXG4gICAqICMjIExpbmVcbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHZlcnRpY2FsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhlIGFuY2hvciBjaGFyYWN0ZXIuXG4gICAqL1xuICBMSU5FOiBcImxpbmVcIixcbiAgLyoqXG4gICAqICMjIFBhZ2UgTWFyZ2luXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgcGFnZSBtYXJnaW5zLlxuICAgKi9cbiAgTUFSR0lOOiBcIm1hcmdpblwiLFxuICAvKipcbiAgICogIyMgT3V0c2lkZSBNYXJnaW5cbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHZlcnRpY2FsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBvdXRzaWRlIG1hcmdpbiBvZiB0aGUgY3VycmVudCBwYWdlLlxuICAgKi9cbiAgT1VUU0lERV9NQVJHSU46IFwib3V0c2lkZU1hcmdpblwiLFxuICAvKipcbiAgICogIyMgUGFnZSBFZGdlXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgZWRnZSBvZiB0aGUgcGFnZS5cbiAgICovXG4gIFBBR0U6IFwicGFnZVwiLFxuICAvKipcbiAgICogIyMgUGFyYWdyYXBoXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbmluZyBzaGFsbCBiZSByZWxhdGl2ZSB0byB0aGUgcGFyYWdyYXBoIHdoaWNoIGNvbnRhaW5zIHRoZSBkcmF3aW5nIGFuY2hvci5cbiAgICovXG4gIFBBUkFHUkFQSDogXCJwYXJhZ3JhcGhcIixcbiAgLyoqXG4gICAqICMjIFRvcCBNYXJnaW5cbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHZlcnRpY2FsIHBvc2l0aW9uaW5nIHNoYWxsIGJlIHJlbGF0aXZlIHRvIHRoZSB0b3AgbWFyZ2luIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAqL1xuICBUT1BfTUFSR0lOOiBcInRvcE1hcmdpblwiXG59O1xuY29uc3QgY3JlYXRlU2ltcGxlUG9zID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3cDpzaW1wbGVQb3NcIixcbiAgLy8gTk9URTogSXQncyBub3QgZnVsbHkgc3VwcG9ydGVkIGluIE1pY3Jvc29mdCBXb3JkLCBidXQgdGhpcyBlbGVtZW50IGlzIG5lZWRlZCBhbnl3YXlcbiAgYXR0cmlidXRlczoge1xuICAgIHg6IHsga2V5OiBcInhcIiwgdmFsdWU6IDAgfSxcbiAgICB5OiB7IGtleTogXCJ5XCIsIHZhbHVlOiAwIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVBbGlnbiA9ICh2YWx1ZSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3cDphbGlnblwiLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjaGlsZHJlbjogW3ZhbHVlXVxufSk7XG5jb25zdCBjcmVhdGVQb3NpdGlvbk9mZnNldCA9IChvZmZzZXRWYWx1ZSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3cDpwb3NPZmZzZXRcIixcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY2hpbGRyZW46IFtvZmZzZXRWYWx1ZS50b1N0cmluZygpXVxufSk7XG5jb25zdCBjcmVhdGVIb3Jpem9udGFsUG9zaXRpb24gPSAoeyByZWxhdGl2ZSwgYWxpZ24sIG9mZnNldCB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIndwOnBvc2l0aW9uSFwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgcmVsYXRpdmVGcm9tOiB7IGtleTogXCJyZWxhdGl2ZUZyb21cIiwgdmFsdWU6IHJlbGF0aXZlICE9IG51bGwgPyByZWxhdGl2ZSA6IEhvcml6b250YWxQb3NpdGlvblJlbGF0aXZlRnJvbS5QQUdFIH1cbiAgfSxcbiAgY2hpbGRyZW46IFtcbiAgICAoKCkgPT4ge1xuICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVBbGlnbihhbGlnbik7XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3NpdGlvbk9mZnNldChvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gY29uZmlndXJhdGlvbiBwcm92aWRlZCBmb3IgZmxvYXRpbmcgcG9zaXRpb24gKEFsaWduIG9yIG9mZnNldClcIik7XG4gICAgICB9XG4gICAgfSkoKVxuICBdXG59KTtcbmNvbnN0IGNyZWF0ZVZlcnRpY2FsUG9zaXRpb24gPSAoeyByZWxhdGl2ZSwgYWxpZ24sIG9mZnNldCB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIndwOnBvc2l0aW9uVlwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgcmVsYXRpdmVGcm9tOiB7IGtleTogXCJyZWxhdGl2ZUZyb21cIiwgdmFsdWU6IHJlbGF0aXZlICE9IG51bGwgPyByZWxhdGl2ZSA6IFZlcnRpY2FsUG9zaXRpb25SZWxhdGl2ZUZyb20uUEFHRSB9XG4gIH0sXG4gIGNoaWxkcmVuOiBbXG4gICAgKCgpID0+IHtcbiAgICAgIGlmIChhbGlnbikge1xuICAgICAgICByZXR1cm4gY3JlYXRlQWxpZ24oYWxpZ24pO1xuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9zaXRpb25PZmZzZXQob2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgZm9yIGZsb2F0aW5nIHBvc2l0aW9uIChBbGlnbiBvciBvZmZzZXQpXCIpO1xuICAgICAgfVxuICAgIH0pKClcbiAgXVxufSk7XG5jbGFzcyBHcmFwaGljRGF0YUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHVyaTogXCJ1cmlcIlxuICAgIH0pO1xuICB9XG59XG5jb25zdCBjcmVhdGVTdmdCbGlwID0gKG1lZGlhRGF0YSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhc3ZnOnN2Z0JsaXBcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGFzdmc6IHtcbiAgICAgIGtleTogXCJ4bWxuczphc3ZnXCIsXG4gICAgICB2YWx1ZTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvU1ZHL21haW5cIlxuICAgIH0sXG4gICAgZW1iZWQ6IHtcbiAgICAgIGtleTogXCJyOmVtYmVkXCIsXG4gICAgICB2YWx1ZTogYHJJZHske21lZGlhRGF0YS5maWxlTmFtZX19YFxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVFeHRlbnRpb24gPSAobWVkaWFEYXRhKSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcImE6ZXh0XCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB1cmk6IHtcbiAgICAgIGtleTogXCJ1cmlcIixcbiAgICAgIHZhbHVlOiBcIns5NkRBQzU0MS03QjdBLTQzRDMtOEI3OS0zN0Q2MzNCODQ2RjF9XCJcbiAgICB9XG4gIH0sXG4gIGNoaWxkcmVuOiBbY3JlYXRlU3ZnQmxpcChtZWRpYURhdGEpXVxufSk7XG5jb25zdCBjcmVhdGVFeHRlbnRpb25MaXN0ID0gKG1lZGlhRGF0YSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhOmV4dExzdFwiLFxuICBjaGlsZHJlbjogW2NyZWF0ZUV4dGVudGlvbihtZWRpYURhdGEpXVxufSk7XG5jb25zdCBjcmVhdGVCbGlwID0gKG1lZGlhRGF0YSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhOmJsaXBcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGVtYmVkOiB7XG4gICAgICBrZXk6IFwicjplbWJlZFwiLFxuICAgICAgdmFsdWU6IGBySWR7JHttZWRpYURhdGEudHlwZSA9PT0gXCJzdmdcIiA/IG1lZGlhRGF0YS5mYWxsYmFjay5maWxlTmFtZSA6IG1lZGlhRGF0YS5maWxlTmFtZX19YFxuICAgIH0sXG4gICAgY3N0YXRlOiB7XG4gICAgICBrZXk6IFwiY3N0YXRlXCIsXG4gICAgICB2YWx1ZTogXCJub25lXCJcbiAgICB9XG4gIH0sXG4gIGNoaWxkcmVuOiBtZWRpYURhdGEudHlwZSA9PT0gXCJzdmdcIiA/IFtjcmVhdGVFeHRlbnRpb25MaXN0KG1lZGlhRGF0YSldIDogW11cbn0pO1xuY2xhc3MgU291cmNlUmVjdGFuZ2xlIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJhOnNyY1JlY3RcIik7XG4gIH1cbn1cbmNsYXNzIEZpbGxSZWN0YW5nbGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImE6ZmlsbFJlY3RcIik7XG4gIH1cbn1cbmNsYXNzIFN0cmV0Y2ggZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImE6c3RyZXRjaFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRmlsbFJlY3RhbmdsZSgpKTtcbiAgfVxufVxuY2xhc3MgQmxpcEZpbGwgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihtZWRpYURhdGEpIHtcbiAgICBzdXBlcihcInBpYzpibGlwRmlsbFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVCbGlwKG1lZGlhRGF0YSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTb3VyY2VSZWN0YW5nbGUoKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmV0Y2goKSk7XG4gIH1cbn1cbmNsYXNzIFBpY0xvY2tzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgbm9DaGFuZ2VBc3BlY3Q6IFwibm9DaGFuZ2VBc3BlY3RcIixcbiAgICAgIG5vQ2hhbmdlQXJyb3doZWFkczogXCJub0NoYW5nZUFycm93aGVhZHNcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQaWNMb2NrcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYTpwaWNMb2Nrc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBQaWNMb2Nrc0F0dHJpYnV0ZXMoe1xuICAgICAgICBub0NoYW5nZUFzcGVjdDogMSxcbiAgICAgICAgbm9DaGFuZ2VBcnJvd2hlYWRzOiAxXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIENoaWxkTm9uVmlzdWFsUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwicGljOmNOdlBpY1ByXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBQaWNMb2NrcygpKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlSHlwZXJsaW5rQ2xpY2sgPSAobGlua0lkLCBoYXNYbWxOcykgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhOmhsaW5rQ2xpY2tcIixcbiAgYXR0cmlidXRlczogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgaGFzWG1sTnMgPyB7XG4gICAgeG1sbnM6IHtcbiAgICAgIGtleTogXCJ4bWxuczphXCIsXG4gICAgICB2YWx1ZTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvbWFpblwiXG4gICAgfVxuICB9IDoge30pLCB7XG4gICAgaWQ6IHtcbiAgICAgIGtleTogXCJyOmlkXCIsXG4gICAgICB2YWx1ZTogYHJJZCR7bGlua0lkfWBcbiAgICB9XG4gIH0pXG59KTtcbmNsYXNzIE5vblZpc3VhbFByb3BlcnRpZXNBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBpZDogXCJpZFwiLFxuICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICBkZXNjcjogXCJkZXNjclwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE5vblZpc3VhbFByb3BlcnRpZXMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInBpYzpjTnZQclwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBOb25WaXN1YWxQcm9wZXJ0aWVzQXR0cmlidXRlcyh7XG4gICAgICAgIGlkOiAwLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICBkZXNjcjogXCJcIlxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHByZXBGb3JYbWwoY29udGV4dCkge1xuICAgIGZvciAobGV0IGkgPSBjb250ZXh0LnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY29udGV4dC5zdGFja1tpXTtcbiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBDb25jcmV0ZUh5cGVybGluaykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVIeXBlcmxpbmtDbGljayhlbGVtZW50LmxpbmtJZCwgZmFsc2UpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHJlcEZvclhtbChjb250ZXh0KTtcbiAgfVxufVxuY2xhc3MgTm9uVmlzdWFsUGljUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwicGljOm52UGljUHJcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IE5vblZpc3VhbFByb3BlcnRpZXMoKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IENoaWxkTm9uVmlzdWFsUHJvcGVydGllcygpKTtcbiAgfVxufVxuY2xhc3MgUGljQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgeG1sbnM6IFwieG1sbnM6cGljXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRXh0ZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGN4OiBcImN4XCIsXG4gICAgICBjeTogXCJjeVwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEV4dGVudHMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgc3VwZXIoXCJhOmV4dFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXR0cmlidXRlc1wiKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgRXh0ZW50c0F0dHJpYnV0ZXMoe1xuICAgICAgY3g6IHgsXG4gICAgICBjeTogeVxuICAgIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMuYXR0cmlidXRlcyk7XG4gIH1cbn1cbmNsYXNzIE9mZnNldEF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHg6IFwieFwiLFxuICAgICAgeTogXCJ5XCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgT2Zmc2V0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJhOm9mZlwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBPZmZzZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBGb3JtQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgZmxpcFZlcnRpY2FsOiBcImZsaXBWXCIsXG4gICAgICBmbGlwSG9yaXpvbnRhbDogXCJmbGlwSFwiLFxuICAgICAgcm90YXRpb246IFwicm90XCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9ybSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN1cGVyKFwiYTp4ZnJtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJleHRlbnRzXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEZvcm1BdHRyaWJ1dGVzKHtcbiAgICAgICAgZmxpcFZlcnRpY2FsOiAoX2EgPSBvcHRpb25zLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfYS52ZXJ0aWNhbCxcbiAgICAgICAgZmxpcEhvcml6b250YWw6IChfYiA9IG9wdGlvbnMuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhvcml6b250YWwsXG4gICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5leHRlbnRzID0gbmV3IEV4dGVudHMob3B0aW9ucy5lbXVzLngsIG9wdGlvbnMuZW11cy55KTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgT2Zmc2V0KCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMuZXh0ZW50cyk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZU5vRmlsbCA9ICgpID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7IG5hbWU6IFwiYTpub0ZpbGxcIiB9KTtcbmNvbnN0IGNyZWF0ZVNvbGlkUmdiQ29sb3IgPSAob3B0aW9ucykgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhOnNyZ2JDbHJcIixcbiAgYXR0cmlidXRlczoge1xuICAgIHZhbHVlOiB7XG4gICAgICBrZXk6IFwidmFsXCIsXG4gICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVTY2hlbWVDb2xvciA9IChvcHRpb25zKSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcImE6c2NoZW1lQ2xyXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAga2V5OiBcInZhbFwiLFxuICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWVcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgY3JlYXRlU29saWRGaWxsID0gKG9wdGlvbnMpID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwiYTpzb2xpZEZpbGxcIixcbiAgY2hpbGRyZW46IFtvcHRpb25zLnR5cGUgPT09IFwicmdiXCIgPyBjcmVhdGVTb2xpZFJnYkNvbG9yKG9wdGlvbnMpIDogY3JlYXRlU2NoZW1lQ29sb3Iob3B0aW9ucyldXG59KTtcbmNvbnN0IGNyZWF0ZU91dGxpbmUgPSAob3B0aW9ucykgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJhOmxuXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB3aWR0aDoge1xuICAgICAga2V5OiBcIndcIixcbiAgICAgIHZhbHVlOiBvcHRpb25zLndpZHRoXG4gICAgfSxcbiAgICBjYXA6IHtcbiAgICAgIGtleTogXCJjYXBcIixcbiAgICAgIHZhbHVlOiBvcHRpb25zLmNhcFxuICAgIH0sXG4gICAgY29tcG91bmRMaW5lOiB7XG4gICAgICBrZXk6IFwiY21wZFwiLFxuICAgICAgdmFsdWU6IG9wdGlvbnMuY29tcG91bmRMaW5lXG4gICAgfSxcbiAgICBhbGlnbjoge1xuICAgICAga2V5OiBcImFsZ25cIixcbiAgICAgIHZhbHVlOiBvcHRpb25zLmFsaWduXG4gICAgfVxuICB9LFxuICBjaGlsZHJlbjogW1xuICAgIG9wdGlvbnMudHlwZSA9PT0gXCJub0ZpbGxcIiA/IGNyZWF0ZU5vRmlsbCgpIDogb3B0aW9ucy5zb2xpZEZpbGxUeXBlID09PSBcInJnYlwiID8gY3JlYXRlU29saWRGaWxsKHtcbiAgICAgIHR5cGU6IFwicmdiXCIsXG4gICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZVxuICAgIH0pIDogY3JlYXRlU29saWRGaWxsKHtcbiAgICAgIHR5cGU6IFwic2NoZW1lXCIsXG4gICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZVxuICAgIH0pXG4gIF1cbn0pO1xuY2xhc3MgQWRqdXN0bWVudFZhbHVlcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYTphdkxzdFwiKTtcbiAgfVxufVxuY2xhc3MgUHJlc2V0R2VvbWV0cnlBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBwcnN0OiBcInByc3RcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQcmVzZXRHZW9tZXRyeSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYTpwcnN0R2VvbVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBQcmVzZXRHZW9tZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICBwcnN0OiBcInJlY3RcIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBBZGp1c3RtZW50VmFsdWVzKCkpO1xuICB9XG59XG5jbGFzcyBTaGFwZVByb3BlcnRpZXNBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBid01vZGU6IFwiYndNb2RlXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgU2hhcGVQcm9wZXJ0aWVzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoeyBvdXRsaW5lLCB0cmFuc2Zvcm0gfSkge1xuICAgIHN1cGVyKFwicGljOnNwUHJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZvcm1cIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgU2hhcGVQcm9wZXJ0aWVzQXR0cmlidXRlcyh7XG4gICAgICAgIGJ3TW9kZTogXCJhdXRvXCJcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybSh0cmFuc2Zvcm0pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFByZXNldEdlb21ldHJ5KCkpO1xuICAgIGlmIChvdXRsaW5lKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVOb0ZpbGwoKSk7XG4gICAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVPdXRsaW5lKG91dGxpbmUpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBpYyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZWRpYURhdGEsXG4gICAgdHJhbnNmb3JtLFxuICAgIG91dGxpbmVcbiAgfSkge1xuICAgIHN1cGVyKFwicGljOnBpY1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBQaWNBdHRyaWJ1dGVzKHtcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L3BpY3R1cmVcIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOb25WaXN1YWxQaWNQcm9wZXJ0aWVzKCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCbGlwRmlsbChtZWRpYURhdGEpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU2hhcGVQcm9wZXJ0aWVzKHsgdHJhbnNmb3JtLCBvdXRsaW5lIH0pKTtcbiAgfVxufVxuY2xhc3MgR3JhcGhpY0RhdGEgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVkaWFEYXRhLFxuICAgIHRyYW5zZm9ybSxcbiAgICBvdXRsaW5lXG4gIH0pIHtcbiAgICBzdXBlcihcImE6Z3JhcGhpY0RhdGFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBpY1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBHcmFwaGljRGF0YUF0dHJpYnV0ZXMoe1xuICAgICAgICB1cmk6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L3BpY3R1cmVcIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucGljID0gbmV3IFBpYyh7IG1lZGlhRGF0YSwgdHJhbnNmb3JtLCBvdXRsaW5lIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucGljKTtcbiAgfVxufVxuY2xhc3MgR3JhcGhpY0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGE6IFwieG1sbnM6YVwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdyYXBoaWMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVkaWFEYXRhLFxuICAgIHRyYW5zZm9ybSxcbiAgICBvdXRsaW5lXG4gIH0pIHtcbiAgICBzdXBlcihcImE6Z3JhcGhpY1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGF0YVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBHcmFwaGljQXR0cmlidXRlcyh7XG4gICAgICAgIGE6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW5cIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBHcmFwaGljRGF0YSh7IG1lZGlhRGF0YSwgdHJhbnNmb3JtLCBvdXRsaW5lIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMuZGF0YSk7XG4gIH1cbn1cbmNvbnN0IFRleHRXcmFwcGluZ1R5cGUgPSB7XG4gIE5PTkU6IDAsXG4gIFNRVUFSRTogMSxcbiAgVElHSFQ6IDIsXG4gIFRPUF9BTkRfQk9UVE9NOiAzXG59O1xuY29uc3QgVGV4dFdyYXBwaW5nU2lkZSA9IHtcbiAgQk9USF9TSURFUzogXCJib3RoU2lkZXNcIixcbiAgTEVGVDogXCJsZWZ0XCIsXG4gIFJJR0hUOiBcInJpZ2h0XCIsXG4gIExBUkdFU1Q6IFwibGFyZ2VzdFwiXG59O1xuY2xhc3MgV3JhcE5vbmUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIndwOndyYXBOb25lXCIpO1xuICB9XG59XG5jbGFzcyBXcmFwU3F1YXJlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgZGlzdFQ6IFwiZGlzdFRcIixcbiAgICAgIGRpc3RCOiBcImRpc3RCXCIsXG4gICAgICBkaXN0TDogXCJkaXN0TFwiLFxuICAgICAgZGlzdFI6IFwiZGlzdFJcIixcbiAgICAgIHdyYXBUZXh0OiBcIndyYXBUZXh0XCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgV3JhcFNxdWFyZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHRXcmFwcGluZywgbWFyZ2lucyA9IHtcbiAgICB0b3A6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDBcbiAgfSkge1xuICAgIHN1cGVyKFwid3A6d3JhcFNxdWFyZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBXcmFwU3F1YXJlQXR0cmlidXRlcyh7XG4gICAgICAgIHdyYXBUZXh0OiB0ZXh0V3JhcHBpbmcuc2lkZSB8fCBUZXh0V3JhcHBpbmdTaWRlLkJPVEhfU0lERVMsXG4gICAgICAgIGRpc3RUOiBtYXJnaW5zLnRvcCxcbiAgICAgICAgZGlzdEI6IG1hcmdpbnMuYm90dG9tLFxuICAgICAgICBkaXN0TDogbWFyZ2lucy5sZWZ0LFxuICAgICAgICBkaXN0UjogbWFyZ2lucy5yaWdodFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBXcmFwVGlnaHRBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBkaXN0VDogXCJkaXN0VFwiLFxuICAgICAgZGlzdEI6IFwiZGlzdEJcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBXcmFwVGlnaHQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihtYXJnaW5zID0ge1xuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfSkge1xuICAgIHN1cGVyKFwid3A6d3JhcFRpZ2h0XCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFdyYXBUaWdodEF0dHJpYnV0ZXMoe1xuICAgICAgICBkaXN0VDogbWFyZ2lucy50b3AsXG4gICAgICAgIGRpc3RCOiBtYXJnaW5zLmJvdHRvbVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBXcmFwVG9wQW5kQm90dG9tQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgZGlzdFQ6IFwiZGlzdFRcIixcbiAgICAgIGRpc3RCOiBcImRpc3RCXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgV3JhcFRvcEFuZEJvdHRvbSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG1hcmdpbnMgPSB7XG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMFxuICB9KSB7XG4gICAgc3VwZXIoXCJ3cDp3cmFwVG9wQW5kQm90dG9tXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFdyYXBUb3BBbmRCb3R0b21BdHRyaWJ1dGVzKHtcbiAgICAgICAgZGlzdFQ6IG1hcmdpbnMudG9wLFxuICAgICAgICBkaXN0QjogbWFyZ2lucy5ib3R0b21cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgRG9jUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHsgbmFtZSwgZGVzY3JpcHRpb24sIHRpdGxlIH0gPSB7IG5hbWU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiLCB0aXRsZTogXCJcIiB9KSB7XG4gICAgc3VwZXIoXCJ3cDpkb2NQclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9jUHJvcGVydGllc1VuaXF1ZU51bWVyaWNJZFwiLCBkb2NQcm9wZXJ0aWVzVW5pcXVlTnVtZXJpY0lkR2VuKCkpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBrZXk6IFwiaWRcIixcbiAgICAgICAgdmFsdWU6IHRoaXMuZG9jUHJvcGVydGllc1VuaXF1ZU51bWVyaWNJZCgpXG4gICAgICB9LFxuICAgICAgbmFtZToge1xuICAgICAgICBrZXk6IFwibmFtZVwiLFxuICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIGF0dHJpYnV0ZXMuZGVzY3JpcHRpb24gPSB7XG4gICAgICAgIGtleTogXCJkZXNjclwiLFxuICAgICAgICB2YWx1ZTogZGVzY3JpcHRpb25cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLnRpdGxlID0ge1xuICAgICAgICBrZXk6IFwidGl0bGVcIixcbiAgICAgICAgdmFsdWU6IHRpdGxlXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTmV4dEF0dHJpYnV0ZUNvbXBvbmVudChhdHRyaWJ1dGVzKSk7XG4gIH1cbiAgcHJlcEZvclhtbChjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRleHQuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb250ZXh0LnN0YWNrW2ldO1xuICAgICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIENvbmNyZXRlSHlwZXJsaW5rKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZUh5cGVybGlua0NsaWNrKGVsZW1lbnQubGlua0lkLCB0cnVlKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnByZXBGb3JYbWwoY29udGV4dCk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUVmZmVjdEV4dGVudCA9ICh7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIndwOmVmZmVjdEV4dGVudFwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgdG9wOiB7XG4gICAgICBrZXk6IFwidFwiLFxuICAgICAgdmFsdWU6IHRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIGtleTogXCJyXCIsXG4gICAgICB2YWx1ZTogcmlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAga2V5OiBcImJcIixcbiAgICAgIHZhbHVlOiBib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIGtleTogXCJsXCIsXG4gICAgICB2YWx1ZTogbGVmdFxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVFeHRlbnQgPSAoeyB4LCB5IH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwid3A6ZXh0ZW50XCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB4OiB7IGtleTogXCJjeFwiLCB2YWx1ZTogeCB9LFxuICAgIHk6IHsga2V5OiBcImN5XCIsIHZhbHVlOiB5IH1cbiAgfVxufSk7XG5jbGFzcyBHcmFwaGljRnJhbWVMb2NrQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgeG1sbnM6IFwieG1sbnM6YVwiLFxuICAgICAgbm9DaGFuZ2VBc3BlY3Q6IFwibm9DaGFuZ2VBc3BlY3RcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHcmFwaGljRnJhbWVMb2NrcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiYTpncmFwaGljRnJhbWVMb2Nrc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBHcmFwaGljRnJhbWVMb2NrQXR0cmlidXRlcyh7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi9tYWluXCIsXG4gICAgICAgIG5vQ2hhbmdlQXNwZWN0OiAxXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUdyYXBoaWNGcmFtZVByb3BlcnRpZXMgPSAoKSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIndwOmNOdkdyYXBoaWNGcmFtZVByXCIsXG4gIGNoaWxkcmVuOiBbbmV3IEdyYXBoaWNGcmFtZUxvY2tzKCldXG59KTtcbmNsYXNzIEFuY2hvckF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGRpc3RUOiBcImRpc3RUXCIsXG4gICAgICBkaXN0QjogXCJkaXN0QlwiLFxuICAgICAgZGlzdEw6IFwiZGlzdExcIixcbiAgICAgIGRpc3RSOiBcImRpc3RSXCIsXG4gICAgICBhbGxvd092ZXJsYXA6IFwiYWxsb3dPdmVybGFwXCIsXG4gICAgICBiZWhpbmREb2M6IFwiYmVoaW5kRG9jXCIsXG4gICAgICBsYXlvdXRJbkNlbGw6IFwibGF5b3V0SW5DZWxsXCIsXG4gICAgICBsb2NrZWQ6IFwibG9ja2VkXCIsXG4gICAgICByZWxhdGl2ZUhlaWdodDogXCJyZWxhdGl2ZUhlaWdodFwiLFxuICAgICAgc2ltcGxlUG9zOiBcInNpbXBsZVBvc1wiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEFuY2hvciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZWRpYURhdGEsXG4gICAgdHJhbnNmb3JtLFxuICAgIGRyYXdpbmdPcHRpb25zXG4gIH0pIHtcbiAgICBzdXBlcihcIndwOmFuY2hvclwiKTtcbiAgICBjb25zdCBmbG9hdGluZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGFsbG93T3ZlcmxhcDogdHJ1ZSxcbiAgICAgIGJlaGluZERvY3VtZW50OiBmYWxzZSxcbiAgICAgIGxvY2tBbmNob3I6IGZhbHNlLFxuICAgICAgbGF5b3V0SW5DZWxsOiB0cnVlLFxuICAgICAgdmVydGljYWxQb3NpdGlvbjoge30sXG4gICAgICBob3Jpem9udGFsUG9zaXRpb246IHt9XG4gICAgfSwgZHJhd2luZ09wdGlvbnMuZmxvYXRpbmcpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEFuY2hvckF0dHJpYnV0ZXMoe1xuICAgICAgICBkaXN0VDogZmxvYXRpbmcubWFyZ2lucyA/IGZsb2F0aW5nLm1hcmdpbnMudG9wIHx8IDAgOiAwLFxuICAgICAgICBkaXN0QjogZmxvYXRpbmcubWFyZ2lucyA/IGZsb2F0aW5nLm1hcmdpbnMuYm90dG9tIHx8IDAgOiAwLFxuICAgICAgICBkaXN0TDogZmxvYXRpbmcubWFyZ2lucyA/IGZsb2F0aW5nLm1hcmdpbnMubGVmdCB8fCAwIDogMCxcbiAgICAgICAgZGlzdFI6IGZsb2F0aW5nLm1hcmdpbnMgPyBmbG9hdGluZy5tYXJnaW5zLnJpZ2h0IHx8IDAgOiAwLFxuICAgICAgICBzaW1wbGVQb3M6IFwiMFwiLFxuICAgICAgICAvLyBub3RlOiB3b3JkIGRvZXNuJ3QgZnVsbHkgc3VwcG9ydCAtIHNvIHdlIHVzZSAwXG4gICAgICAgIGFsbG93T3ZlcmxhcDogZmxvYXRpbmcuYWxsb3dPdmVybGFwID09PSB0cnVlID8gXCIxXCIgOiBcIjBcIixcbiAgICAgICAgYmVoaW5kRG9jOiBmbG9hdGluZy5iZWhpbmREb2N1bWVudCA9PT0gdHJ1ZSA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgIGxvY2tlZDogZmxvYXRpbmcubG9ja0FuY2hvciA9PT0gdHJ1ZSA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgIGxheW91dEluQ2VsbDogZmxvYXRpbmcubGF5b3V0SW5DZWxsID09PSB0cnVlID8gXCIxXCIgOiBcIjBcIixcbiAgICAgICAgcmVsYXRpdmVIZWlnaHQ6IGZsb2F0aW5nLnpJbmRleCA/IGZsb2F0aW5nLnpJbmRleCA6IHRyYW5zZm9ybS5lbXVzLnlcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVTaW1wbGVQb3MoKSk7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlSG9yaXpvbnRhbFBvc2l0aW9uKGZsb2F0aW5nLmhvcml6b250YWxQb3NpdGlvbikpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZVZlcnRpY2FsUG9zaXRpb24oZmxvYXRpbmcudmVydGljYWxQb3NpdGlvbikpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZUV4dGVudCh7IHg6IHRyYW5zZm9ybS5lbXVzLngsIHk6IHRyYW5zZm9ybS5lbXVzLnkgfSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZUVmZmVjdEV4dGVudCh7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9KSk7XG4gICAgaWYgKGRyYXdpbmdPcHRpb25zLmZsb2F0aW5nICE9PSB2b2lkIDAgJiYgZHJhd2luZ09wdGlvbnMuZmxvYXRpbmcud3JhcCAhPT0gdm9pZCAwKSB7XG4gICAgICBzd2l0Y2ggKGRyYXdpbmdPcHRpb25zLmZsb2F0aW5nLndyYXAudHlwZSkge1xuICAgICAgICBjYXNlIFRleHRXcmFwcGluZ1R5cGUuU1FVQVJFOlxuICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBXcmFwU3F1YXJlKGRyYXdpbmdPcHRpb25zLmZsb2F0aW5nLndyYXAsIGRyYXdpbmdPcHRpb25zLmZsb2F0aW5nLm1hcmdpbnMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUZXh0V3JhcHBpbmdUeXBlLlRJR0hUOlxuICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBXcmFwVGlnaHQoZHJhd2luZ09wdGlvbnMuZmxvYXRpbmcubWFyZ2lucykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRleHRXcmFwcGluZ1R5cGUuVE9QX0FORF9CT1RUT006XG4gICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFdyYXBUb3BBbmRCb3R0b20oZHJhd2luZ09wdGlvbnMuZmxvYXRpbmcubWFyZ2lucykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRleHRXcmFwcGluZ1R5cGUuTk9ORTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgV3JhcE5vbmUoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBXcmFwTm9uZSgpKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2gobmV3IERvY1Byb3BlcnRpZXMoZHJhd2luZ09wdGlvbnMuZG9jUHJvcGVydGllcykpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZUdyYXBoaWNGcmFtZVByb3BlcnRpZXMoKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IEdyYXBoaWMoeyBtZWRpYURhdGEsIHRyYW5zZm9ybSwgb3V0bGluZTogZHJhd2luZ09wdGlvbnMub3V0bGluZSB9KSk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZUlubGluZSA9ICh7IG1lZGlhRGF0YSwgdHJhbnNmb3JtLCBkb2NQcm9wZXJ0aWVzLCBvdXRsaW5lIH0pID0+IHtcbiAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICByZXR1cm4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgICBuYW1lOiBcIndwOmlubGluZVwiLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIGRpc3RhbmNlVG9wOiB7XG4gICAgICAgIGtleTogXCJkaXN0VFwiLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcbiAgICAgIGRpc3RhbmNlQm90dG9tOiB7XG4gICAgICAgIGtleTogXCJkaXN0QlwiLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSxcbiAgICAgIGRpc3RhbmNlTGVmdDoge1xuICAgICAgICBrZXk6IFwiZGlzdExcIixcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sXG4gICAgICBkaXN0YW5jZVJpZ2h0OiB7XG4gICAgICAgIGtleTogXCJkaXN0UlwiLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIGNyZWF0ZUV4dGVudCh7IHg6IHRyYW5zZm9ybS5lbXVzLngsIHk6IHRyYW5zZm9ybS5lbXVzLnkgfSksXG4gICAgICBjcmVhdGVFZmZlY3RFeHRlbnQoXG4gICAgICAgIG91dGxpbmUgPyB7XG4gICAgICAgICAgdG9wOiAoKF9hID0gb3V0bGluZS53aWR0aCkgIT0gbnVsbCA/IF9hIDogOTUyNSkgKiAyLFxuICAgICAgICAgIHJpZ2h0OiAoKF9iID0gb3V0bGluZS53aWR0aCkgIT0gbnVsbCA/IF9iIDogOTUyNSkgKiAyLFxuICAgICAgICAgIGJvdHRvbTogKChfYyA9IG91dGxpbmUud2lkdGgpICE9IG51bGwgPyBfYyA6IDk1MjUpICogMixcbiAgICAgICAgICBsZWZ0OiAoKF9kID0gb3V0bGluZS53aWR0aCkgIT0gbnVsbCA/IF9kIDogOTUyNSkgKiAyXG4gICAgICAgIH0gOiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9XG4gICAgICApLFxuICAgICAgbmV3IERvY1Byb3BlcnRpZXMoZG9jUHJvcGVydGllcyksXG4gICAgICBjcmVhdGVHcmFwaGljRnJhbWVQcm9wZXJ0aWVzKCksXG4gICAgICBuZXcgR3JhcGhpYyh7IG1lZGlhRGF0YSwgdHJhbnNmb3JtLCBvdXRsaW5lIH0pXG4gICAgXVxuICB9KTtcbn07XG5jbGFzcyBEcmF3aW5nIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoaW1hZ2VEYXRhLCBkcmF3aW5nT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoXCJ3OmRyYXdpbmdcIik7XG4gICAgaWYgKCFkcmF3aW5nT3B0aW9ucy5mbG9hdGluZykge1xuICAgICAgdGhpcy5yb290LnB1c2goXG4gICAgICAgIGNyZWF0ZUlubGluZSh7XG4gICAgICAgICAgbWVkaWFEYXRhOiBpbWFnZURhdGEsXG4gICAgICAgICAgdHJhbnNmb3JtOiBpbWFnZURhdGEudHJhbnNmb3JtYXRpb24sXG4gICAgICAgICAgZG9jUHJvcGVydGllczogZHJhd2luZ09wdGlvbnMuZG9jUHJvcGVydGllcyxcbiAgICAgICAgICBvdXRsaW5lOiBkcmF3aW5nT3B0aW9ucy5vdXRsaW5lXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQW5jaG9yKHsgbWVkaWFEYXRhOiBpbWFnZURhdGEsIHRyYW5zZm9ybTogaW1hZ2VEYXRhLnRyYW5zZm9ybWF0aW9uLCBkcmF3aW5nT3B0aW9ucyB9KSk7XG4gICAgfVxuICB9XG59XG5jb25zdCBjb252ZXJ0RGF0YVVSSVRvQmluYXJ5ID0gKGRhdGFVUkkpID0+IHtcbiAgaWYgKHR5cGVvZiBhdG9iID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBCQVNFNjRfTUFSS0VSID0gXCI7YmFzZTY0LFwiO1xuICAgIGNvbnN0IGJhc2U2NEluZGV4ID0gZGF0YVVSSS5pbmRleE9mKEJBU0U2NF9NQVJLRVIpO1xuICAgIGNvbnN0IGJhc2U2NEluZGV4V2l0aE9mZnNldCA9IGJhc2U2NEluZGV4ID09PSAtMSA/IDAgOiBiYXNlNjRJbmRleCArIEJBU0U2NF9NQVJLRVIubGVuZ3RoO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICAgIGF0b2IoZGF0YVVSSS5zdWJzdHJpbmcoYmFzZTY0SW5kZXhXaXRoT2Zmc2V0KSkuc3BsaXQoXCJcIikubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBiID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IGIuQnVmZmVyKGRhdGFVUkksIFwiYmFzZTY0XCIpO1xuICB9XG59O1xuY29uc3Qgc3RhbmRhcmRpemVEYXRhID0gKGRhdGEpID0+IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gY29udmVydERhdGFVUklUb0JpbmFyeShkYXRhKSA6IGRhdGE7XG5jb25zdCBjcmVhdGVJbWFnZURhdGEgPSAob3B0aW9ucywga2V5KSA9PiAoe1xuICBkYXRhOiBzdGFuZGFyZGl6ZURhdGEob3B0aW9ucy5kYXRhKSxcbiAgZmlsZU5hbWU6IGtleSxcbiAgdHJhbnNmb3JtYXRpb246IHtcbiAgICBwaXhlbHM6IHtcbiAgICAgIHg6IE1hdGgucm91bmQob3B0aW9ucy50cmFuc2Zvcm1hdGlvbi53aWR0aCksXG4gICAgICB5OiBNYXRoLnJvdW5kKG9wdGlvbnMudHJhbnNmb3JtYXRpb24uaGVpZ2h0KVxuICAgIH0sXG4gICAgZW11czoge1xuICAgICAgeDogTWF0aC5yb3VuZChvcHRpb25zLnRyYW5zZm9ybWF0aW9uLndpZHRoICogOTUyNSksXG4gICAgICB5OiBNYXRoLnJvdW5kKG9wdGlvbnMudHJhbnNmb3JtYXRpb24uaGVpZ2h0ICogOTUyNSlcbiAgICB9LFxuICAgIGZsaXA6IG9wdGlvbnMudHJhbnNmb3JtYXRpb24uZmxpcCxcbiAgICByb3RhdGlvbjogb3B0aW9ucy50cmFuc2Zvcm1hdGlvbi5yb3RhdGlvbiA/IG9wdGlvbnMudHJhbnNmb3JtYXRpb24ucm90YXRpb24gKiA2ZTQgOiB2b2lkIDBcbiAgfVxufSk7XG5jbGFzcyBJbWFnZVJ1biBleHRlbmRzIFJ1biB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImltYWdlRGF0YVwiKTtcbiAgICBjb25zdCBoYXNoMiA9IGhhc2hlZElkKG9wdGlvbnMuZGF0YSk7XG4gICAgY29uc3Qga2V5ID0gYCR7aGFzaDJ9LiR7b3B0aW9ucy50eXBlfWA7XG4gICAgdGhpcy5pbWFnZURhdGEgPSBvcHRpb25zLnR5cGUgPT09IFwic3ZnXCIgPyBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHR5cGU6IG9wdGlvbnMudHlwZVxuICAgIH0sIGNyZWF0ZUltYWdlRGF0YShvcHRpb25zLCBrZXkpKSwge1xuICAgICAgZmFsbGJhY2s6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZTogb3B0aW9ucy5mYWxsYmFjay50eXBlXG4gICAgICB9LCBjcmVhdGVJbWFnZURhdGEoXG4gICAgICAgIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMuZmFsbGJhY2spLCB7XG4gICAgICAgICAgdHJhbnNmb3JtYXRpb246IG9wdGlvbnMudHJhbnNmb3JtYXRpb25cbiAgICAgICAgfSksXG4gICAgICAgIGAke2hhc2hlZElkKG9wdGlvbnMuZmFsbGJhY2suZGF0YSl9LiR7b3B0aW9ucy5mYWxsYmFjay50eXBlfWBcbiAgICAgICkpXG4gICAgfSkgOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0eXBlOiBvcHRpb25zLnR5cGVcbiAgICB9LCBjcmVhdGVJbWFnZURhdGEob3B0aW9ucywga2V5KSk7XG4gICAgY29uc3QgZHJhd2luZyA9IG5ldyBEcmF3aW5nKHRoaXMuaW1hZ2VEYXRhLCB7XG4gICAgICBmbG9hdGluZzogb3B0aW9ucy5mbG9hdGluZyxcbiAgICAgIGRvY1Byb3BlcnRpZXM6IG9wdGlvbnMuYWx0VGV4dCxcbiAgICAgIG91dGxpbmU6IG9wdGlvbnMub3V0bGluZVxuICAgIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKGRyYXdpbmcpO1xuICB9XG4gIHByZXBGb3JYbWwoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsZS5NZWRpYS5hZGRJbWFnZSh0aGlzLmltYWdlRGF0YS5maWxlTmFtZSwgdGhpcy5pbWFnZURhdGEpO1xuICAgIGlmICh0aGlzLmltYWdlRGF0YS50eXBlID09PSBcInN2Z1wiKSB7XG4gICAgICBjb250ZXh0LmZpbGUuTWVkaWEuYWRkSW1hZ2UodGhpcy5pbWFnZURhdGEuZmFsbGJhY2suZmlsZU5hbWUsIHRoaXMuaW1hZ2VEYXRhLmZhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnByZXBGb3JYbWwoY29udGV4dCk7XG4gIH1cbn1cbmNsYXNzIFNlcXVlbnRpYWxJZGVudGlmaWVySW5zdHJ1Y3Rpb24gZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyKSB7XG4gICAgc3VwZXIoXCJ3Omluc3RyVGV4dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dEF0dHJpYnV0ZXMoeyBzcGFjZTogU3BhY2VUeXBlLlBSRVNFUlZFIH0pKTtcbiAgICB0aGlzLnJvb3QucHVzaChgU0VRICR7aWRlbnRpZmllcn1gKTtcbiAgfVxufVxuY2xhc3MgU2VxdWVudGlhbElkZW50aWZpZXIgZXh0ZW5kcyBSdW4ge1xuICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCZWdpbih0cnVlKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFNlcXVlbnRpYWxJZGVudGlmaWVySW5zdHJ1Y3Rpb24oaWRlbnRpZmllcikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTZXBhcmF0ZSgpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRW5kKCkpO1xuICB9XG59XG5jbGFzcyBGbGRTaW1wbGVBdHRycyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyBpbnN0cjogXCJ3Omluc3RyXCIgfSk7XG4gIH1cbn1cbmNsYXNzIFNpbXBsZUZpZWxkIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoaW5zdHJ1Y3Rpb24sIGNhY2hlZFZhbHVlKSB7XG4gICAgc3VwZXIoXCJ3OmZsZFNpbXBsZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRmxkU2ltcGxlQXR0cnMoeyBpbnN0cjogaW5zdHJ1Y3Rpb24gfSkpO1xuICAgIGlmIChjYWNoZWRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dFJ1bihjYWNoZWRWYWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgU2ltcGxlTWFpbE1lcmdlRmllbGQgZXh0ZW5kcyBTaW1wbGVGaWVsZCB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkTmFtZSkge1xuICAgIHN1cGVyKGAgTUVSR0VGSUVMRCAke2ZpZWxkTmFtZX0gYCwgYMKrJHtmaWVsZE5hbWV9wrtgKTtcbiAgfVxufVxuY2xhc3MgUmVsYXRpb25zaGlwc0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHhtbG5zOiBcInhtbG5zXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUmVsYXRpb25zaGlwQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgaWQ6IFwiSWRcIixcbiAgICAgIHR5cGU6IFwiVHlwZVwiLFxuICAgICAgdGFyZ2V0OiBcIlRhcmdldFwiLFxuICAgICAgdGFyZ2V0TW9kZTogXCJUYXJnZXRNb2RlXCJcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgVGFyZ2V0TW9kZVR5cGUgPSB7XG4gIEVYVEVSTkFMOiBcIkV4dGVybmFsXCJcbn07XG5jbGFzcyBSZWxhdGlvbnNoaXAgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihpZCwgdHlwZTIsIHRhcmdldCwgdGFyZ2V0TW9kZSkge1xuICAgIHN1cGVyKFwiUmVsYXRpb25zaGlwXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFJlbGF0aW9uc2hpcEF0dHJpYnV0ZXMoe1xuICAgICAgICBpZCxcbiAgICAgICAgdHlwZTogdHlwZTIsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdGFyZ2V0TW9kZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBSZWxhdGlvbnNoaXBzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJSZWxhdGlvbnNoaXBzXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFJlbGF0aW9uc2hpcHNBdHRyaWJ1dGVzKHtcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzXCJcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBjcmVhdGVSZWxhdGlvbnNoaXAoaWQsIHR5cGUyLCB0YXJnZXQsIHRhcmdldE1vZGUpIHtcbiAgICBjb25zdCByZWxhdGlvbnNoaXAgPSBuZXcgUmVsYXRpb25zaGlwKGBySWQke2lkfWAsIHR5cGUyLCB0YXJnZXQsIHRhcmdldE1vZGUpO1xuICAgIHRoaXMucm9vdC5wdXNoKHJlbGF0aW9uc2hpcCk7XG4gICAgcmV0dXJuIHJlbGF0aW9uc2hpcDtcbiAgfVxuICBnZXQgUmVsYXRpb25zaGlwQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5sZW5ndGggLSAxO1xuICB9XG59XG5jbGFzcyBDb21tZW50QXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyBpZDogXCJ3OmlkXCIsIGluaXRpYWxzOiBcInc6aW5pdGlhbHNcIiwgYXV0aG9yOiBcInc6YXV0aG9yXCIsIGRhdGU6IFwidzpkYXRlXCIgfSk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnRSYW5nZUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgaWQ6IFwidzppZFwiIH0pO1xuICB9XG59XG5jbGFzcyBSb290Q29tbWVudHNBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBcInhtbG5zOmN4XCI6IFwieG1sbnM6Y3hcIixcbiAgICAgIFwieG1sbnM6Y3gxXCI6IFwieG1sbnM6Y3gxXCIsXG4gICAgICBcInhtbG5zOmN4MlwiOiBcInhtbG5zOmN4MlwiLFxuICAgICAgXCJ4bWxuczpjeDNcIjogXCJ4bWxuczpjeDNcIixcbiAgICAgIFwieG1sbnM6Y3g0XCI6IFwieG1sbnM6Y3g0XCIsXG4gICAgICBcInhtbG5zOmN4NVwiOiBcInhtbG5zOmN4NVwiLFxuICAgICAgXCJ4bWxuczpjeDZcIjogXCJ4bWxuczpjeDZcIixcbiAgICAgIFwieG1sbnM6Y3g3XCI6IFwieG1sbnM6Y3g3XCIsXG4gICAgICBcInhtbG5zOmN4OFwiOiBcInhtbG5zOmN4OFwiLFxuICAgICAgXCJ4bWxuczptY1wiOiBcInhtbG5zOm1jXCIsXG4gICAgICBcInhtbG5zOmFpbmtcIjogXCJ4bWxuczphaW5rXCIsXG4gICAgICBcInhtbG5zOmFtM2RcIjogXCJ4bWxuczphbTNkXCIsXG4gICAgICBcInhtbG5zOm9cIjogXCJ4bWxuczpvXCIsXG4gICAgICBcInhtbG5zOnJcIjogXCJ4bWxuczpyXCIsXG4gICAgICBcInhtbG5zOm1cIjogXCJ4bWxuczptXCIsXG4gICAgICBcInhtbG5zOnZcIjogXCJ4bWxuczp2XCIsXG4gICAgICBcInhtbG5zOndwMTRcIjogXCJ4bWxuczp3cDE0XCIsXG4gICAgICBcInhtbG5zOndwXCI6IFwieG1sbnM6d3BcIixcbiAgICAgIFwieG1sbnM6dzEwXCI6IFwieG1sbnM6dzEwXCIsXG4gICAgICBcInhtbG5zOndcIjogXCJ4bWxuczp3XCIsXG4gICAgICBcInhtbG5zOncxNFwiOiBcInhtbG5zOncxNFwiLFxuICAgICAgXCJ4bWxuczp3MTVcIjogXCJ4bWxuczp3MTVcIixcbiAgICAgIFwieG1sbnM6dzE2Y2V4XCI6IFwieG1sbnM6dzE2Y2V4XCIsXG4gICAgICBcInhtbG5zOncxNmNpZFwiOiBcInhtbG5zOncxNmNpZFwiLFxuICAgICAgXCJ4bWxuczp3MTZcIjogXCJ4bWxuczp3MTZcIixcbiAgICAgIFwieG1sbnM6dzE2c2R0ZGhcIjogXCJ4bWxuczp3MTZzZHRkaFwiLFxuICAgICAgXCJ4bWxuczp3MTZzZVwiOiBcInhtbG5zOncxNnNlXCIsXG4gICAgICBcInhtbG5zOndwZ1wiOiBcInhtbG5zOndwZ1wiLFxuICAgICAgXCJ4bWxuczp3cGlcIjogXCJ4bWxuczp3cGlcIixcbiAgICAgIFwieG1sbnM6d25lXCI6IFwieG1sbnM6d25lXCIsXG4gICAgICBcInhtbG5zOndwc1wiOiBcInhtbG5zOndwc1wiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnRSYW5nZVN0YXJ0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICBzdXBlcihcInc6Y29tbWVudFJhbmdlU3RhcnRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IENvbW1lbnRSYW5nZUF0dHJpYnV0ZXMoeyBpZCB9KSk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnRSYW5nZUVuZCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoXCJ3OmNvbW1lbnRSYW5nZUVuZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQ29tbWVudFJhbmdlQXR0cmlidXRlcyh7IGlkIH0pKTtcbiAgfVxufVxuY2xhc3MgQ29tbWVudFJlZmVyZW5jZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoXCJ3OmNvbW1lbnRSZWZlcmVuY2VcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IENvbW1lbnRSYW5nZUF0dHJpYnV0ZXMoeyBpZCB9KSk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7IGlkLCBpbml0aWFscywgYXV0aG9yLCBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGNoaWxkcmVuIH0pIHtcbiAgICBzdXBlcihcInc6Y29tbWVudFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBDb21tZW50QXR0cmlidXRlcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBpbml0aWFscyxcbiAgICAgICAgYXV0aG9yLFxuICAgICAgICBkYXRlOiBkYXRlLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBDb21tZW50cyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHsgY2hpbGRyZW4gfSkge1xuICAgIHN1cGVyKFwidzpjb21tZW50c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVsYXRpb25zaGlwc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBSb290Q29tbWVudHNBdHRyaWJ1dGVzKHtcbiAgICAgICAgXCJ4bWxuczpjeFwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNC9jaGFydGV4XCIsXG4gICAgICAgIFwieG1sbnM6Y3gxXCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE1LzkvOC9jaGFydGV4XCIsXG4gICAgICAgIFwieG1sbnM6Y3gyXCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE1LzEwLzIxL2NoYXJ0ZXhcIixcbiAgICAgICAgXCJ4bWxuczpjeDNcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS85L2NoYXJ0ZXhcIixcbiAgICAgICAgXCJ4bWxuczpjeDRcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS8xMC9jaGFydGV4XCIsXG4gICAgICAgIFwieG1sbnM6Y3g1XCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTEvY2hhcnRleFwiLFxuICAgICAgICBcInhtbG5zOmN4NlwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNi81LzEyL2NoYXJ0ZXhcIixcbiAgICAgICAgXCJ4bWxuczpjeDdcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS8xMy9jaGFydGV4XCIsXG4gICAgICAgIFwieG1sbnM6Y3g4XCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTQvY2hhcnRleFwiLFxuICAgICAgICBcInhtbG5zOm1jXCI6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDZcIixcbiAgICAgICAgXCJ4bWxuczphaW5rXCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2L2lua1wiLFxuICAgICAgICBcInhtbG5zOmFtM2RcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTcvbW9kZWwzZFwiLFxuICAgICAgICBcInhtbG5zOm9cIjogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2VcIixcbiAgICAgICAgXCJ4bWxuczpyXCI6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiLFxuICAgICAgICBcInhtbG5zOm1cIjogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9tYXRoXCIsXG4gICAgICAgIFwieG1sbnM6dlwiOiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIsXG4gICAgICAgIFwieG1sbnM6d3AxNFwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgXCJ4bWxuczp3cFwiOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgXCJ4bWxuczp3MTBcIjogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTp3b3JkXCIsXG4gICAgICAgIFwieG1sbnM6d1wiOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy93b3JkcHJvY2Vzc2luZ21sLzIwMDYvbWFpblwiLFxuICAgICAgICBcInhtbG5zOncxNFwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkbWxcIixcbiAgICAgICAgXCJ4bWxuczp3MTVcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTIvd29yZG1sXCIsXG4gICAgICAgIFwieG1sbnM6dzE2Y2V4XCI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDE4L3dvcmRtbC9jZXhcIixcbiAgICAgICAgXCJ4bWxuczp3MTZjaWRcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTYvd29yZG1sL2NpZFwiLFxuICAgICAgICBcInhtbG5zOncxNlwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxOC93b3JkbWxcIixcbiAgICAgICAgXCJ4bWxuczp3MTZzZHRkaFwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAyMC93b3JkbWwvc2R0ZGF0YWhhc2hcIixcbiAgICAgICAgXCJ4bWxuczp3MTZzZVwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxNS93b3JkbWwvc3ltZXhcIixcbiAgICAgICAgXCJ4bWxuczp3cGdcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdHcm91cFwiLFxuICAgICAgICBcInhtbG5zOndwaVwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0lua1wiLFxuICAgICAgICBcInhtbG5zOnduZVwiOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAwNi93b3JkbWxcIixcbiAgICAgICAgXCJ4bWxuczp3cHNcIjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdTaGFwZVwiXG4gICAgICB9KVxuICAgICk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IENvbW1lbnQoY2hpbGQpKTtcbiAgICB9XG4gICAgdGhpcy5yZWxhdGlvbnNoaXBzID0gbmV3IFJlbGF0aW9uc2hpcHMoKTtcbiAgfVxuICBnZXQgUmVsYXRpb25zaGlwcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxhdGlvbnNoaXBzO1xuICB9XG59XG5jbGFzcyBOb0JyZWFrSHlwaGVuIGV4dGVuZHMgRW1wdHlFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3Om5vQnJlYWtIeXBoZW5cIik7XG4gIH1cbn1cbmNsYXNzIFNvZnRIeXBoZW4gZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6c29mdEh5cGhlblwiKTtcbiAgfVxufVxuY2xhc3MgRGF5U2hvcnQgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6ZGF5U2hvcnRcIik7XG4gIH1cbn1cbmNsYXNzIE1vbnRoU2hvcnQgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6bW9udGhTaG9ydFwiKTtcbiAgfVxufVxuY2xhc3MgWWVhclNob3J0IGV4dGVuZHMgRW1wdHlFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OnllYXJTaG9ydFwiKTtcbiAgfVxufVxuY2xhc3MgRGF5TG9uZyBleHRlbmRzIEVtcHR5RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpkYXlMb25nXCIpO1xuICB9XG59XG5jbGFzcyBNb250aExvbmcgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6bW9udGhMb25nXCIpO1xuICB9XG59XG5jbGFzcyBZZWFyTG9uZyBleHRlbmRzIEVtcHR5RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzp5ZWFyTG9uZ1wiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvblJlZmVyZW5jZSBleHRlbmRzIEVtcHR5RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzphbm5vdGF0aW9uUmVmXCIpO1xuICB9XG59XG5jbGFzcyBGb290bm90ZVJlZmVyZW5jZUVsZW1lbnQgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6Zm9vdG5vdGVSZWZcIik7XG4gIH1cbn1cbmNsYXNzIEVuZG5vdGVSZWZlcmVuY2UgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6ZW5kbm90ZVJlZlwiKTtcbiAgfVxufVxuY2xhc3MgU2VwYXJhdG9yIGV4dGVuZHMgRW1wdHlFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OnNlcGFyYXRvclwiKTtcbiAgfVxufVxuY2xhc3MgQ29udGludWF0aW9uU2VwYXJhdG9yIGV4dGVuZHMgRW1wdHlFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmNvbnRpbnVhdGlvblNlcGFyYXRvclwiKTtcbiAgfVxufVxuY2xhc3MgUGFnZU51bWJlckVsZW1lbnQgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6cGdOdW1cIik7XG4gIH1cbn1cbmNsYXNzIENhcnJpYWdlUmV0dXJuIGV4dGVuZHMgRW1wdHlFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmNyXCIpO1xuICB9XG59XG5jbGFzcyBUYWIgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6dGFiXCIpO1xuICB9XG59XG5jbGFzcyBMYXN0UmVuZGVyZWRQYWdlQnJlYWsgZXh0ZW5kcyBFbXB0eUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6bGFzdFJlbmRlcmVkUGFnZUJyZWFrXCIpO1xuICB9XG59XG5jb25zdCBQb3NpdGlvbmFsVGFiQWxpZ25tZW50ID0ge1xuICBMRUZUOiBcImxlZnRcIixcbiAgQ0VOVEVSOiBcImNlbnRlclwiLFxuICBSSUdIVDogXCJyaWdodFwiXG59O1xuY29uc3QgUG9zaXRpb25hbFRhYlJlbGF0aXZlVG8gPSB7XG4gIE1BUkdJTjogXCJtYXJnaW5cIixcbiAgSU5ERU5UOiBcImluZGVudFwiXG59O1xuY29uc3QgUG9zaXRpb25hbFRhYkxlYWRlciA9IHtcbiAgTk9ORTogXCJub25lXCIsXG4gIERPVDogXCJkb3RcIixcbiAgSFlQSEVOOiBcImh5cGhlblwiLFxuICBVTkRFUlNDT1JFOiBcInVuZGVyc2NvcmVcIixcbiAgTUlERExFX0RPVDogXCJtaWRkbGVEb3RcIlxufTtcbmNsYXNzIFBvc2l0aW9uYWxUYWIgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnB0YWJcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgTmV4dEF0dHJpYnV0ZUNvbXBvbmVudCh7XG4gICAgICAgIGFsaWdubWVudDoge1xuICAgICAgICAgIGtleTogXCJ3OmFsaWdubWVudFwiLFxuICAgICAgICAgIHZhbHVlOiBvcHRpb25zLmFsaWdubWVudFxuICAgICAgICB9LFxuICAgICAgICByZWxhdGl2ZVRvOiB7XG4gICAgICAgICAga2V5OiBcInc6cmVsYXRpdmVUb1wiLFxuICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnJlbGF0aXZlVG9cbiAgICAgICAgfSxcbiAgICAgICAgbGVhZGVyOiB7XG4gICAgICAgICAga2V5OiBcInc6bGVhZGVyXCIsXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbnMubGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgQnJlYWtUeXBlID0ge1xuICBDT0xVTU46IFwiY29sdW1uXCIsXG4gIFBBR0U6IFwicGFnZVwiXG4gIC8vIHRleHRXcmFwcGluZyBicmVha3MgYXJlIHRoZSBkZWZhdWx0IGFuZCBhbHJlYWR5IGV4cG9zZWQgdmlhIHRoZSBcIlJ1blwiIGNsYXNzXG59O1xuY2xhc3MgQnJlYWsyIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodHlwZTIpIHtcbiAgICBzdXBlcihcInc6YnJcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHR5cGU6IHR5cGUyXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIFBhZ2VCcmVhayBleHRlbmRzIFJ1biB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHt9KTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQnJlYWsyKEJyZWFrVHlwZS5QQUdFKSk7XG4gIH1cbn1cbmNsYXNzIENvbHVtbkJyZWFrIGV4dGVuZHMgUnVuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoe30pO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCcmVhazIoQnJlYWtUeXBlLkNPTFVNTikpO1xuICB9XG59XG5jbGFzcyBQYWdlQnJlYWtCZWZvcmUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6cGFnZUJyZWFrQmVmb3JlXCIpO1xuICB9XG59XG5jb25zdCBMaW5lUnVsZVR5cGUgPSB7XG4gIEFUX0xFQVNUOiBcImF0TGVhc3RcIixcbiAgRVhBQ1RMWTogXCJleGFjdGx5XCIsXG4gIEVYQUNUOiBcImV4YWN0XCIsXG4gIEFVVE86IFwiYXV0b1wiXG59O1xuY2xhc3MgU3BhY2luZ0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGFmdGVyOiBcInc6YWZ0ZXJcIixcbiAgICAgIGJlZm9yZTogXCJ3OmJlZm9yZVwiLFxuICAgICAgbGluZTogXCJ3OmxpbmVcIixcbiAgICAgIGxpbmVSdWxlOiBcInc6bGluZVJ1bGVcIixcbiAgICAgIGJlZm9yZUF1dG9TcGFjaW5nOiBcInc6YmVmb3JlQXV0b3NwYWNpbmdcIixcbiAgICAgIGFmdGVyQXV0b1NwYWNpbmc6IFwidzphZnRlckF1dG9zcGFjaW5nXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgU3BhY2luZyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6c3BhY2luZ1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU3BhY2luZ0F0dHJpYnV0ZXMob3B0aW9ucykpO1xuICB9XG59XG5jb25zdCBIZWFkaW5nTGV2ZWwgPSB7XG4gIEhFQURJTkdfMTogXCJIZWFkaW5nMVwiLFxuICBIRUFESU5HXzI6IFwiSGVhZGluZzJcIixcbiAgSEVBRElOR18zOiBcIkhlYWRpbmczXCIsXG4gIEhFQURJTkdfNDogXCJIZWFkaW5nNFwiLFxuICBIRUFESU5HXzU6IFwiSGVhZGluZzVcIixcbiAgSEVBRElOR182OiBcIkhlYWRpbmc2XCIsXG4gIFRJVExFOiBcIlRpdGxlXCJcbn07XG5sZXQgU3R5bGUkMSA9IGNsYXNzIFN0eWxlIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Ioc3R5bGVJZCkge1xuICAgIHN1cGVyKFwidzpwU3R5bGVcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogc3R5bGVJZFxuICAgICAgfSlcbiAgICApO1xuICB9XG59O1xuY2xhc3MgVGFiU3RvcCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRhYkRlZmluaXRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnRhYnNcIik7XG4gICAgZm9yIChjb25zdCB0YWJEZWZpbml0aW9uIG9mIHRhYkRlZmluaXRpb25zKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFiU3RvcEl0ZW0odGFiRGVmaW5pdGlvbikpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgVGFiU3RvcFR5cGUgPSB7XG4gIExFRlQ6IFwibGVmdFwiLFxuICBSSUdIVDogXCJyaWdodFwiLFxuICBDRU5URVI6IFwiY2VudGVyXCIsXG4gIEJBUjogXCJiYXJcIixcbiAgQ0xFQVI6IFwiY2xlYXJcIixcbiAgREVDSU1BTDogXCJkZWNpbWFsXCIsXG4gIEVORDogXCJlbmRcIixcbiAgTlVNOiBcIm51bVwiLFxuICBTVEFSVDogXCJzdGFydFwiXG59O1xuY29uc3QgTGVhZGVyVHlwZSA9IHtcbiAgRE9UOiBcImRvdFwiLFxuICBIWVBIRU46IFwiaHlwaGVuXCIsXG4gIE1JRERMRV9ET1Q6IFwibWlkZGxlRG90XCIsXG4gIE5PTkU6IFwibm9uZVwiLFxuICBVTkRFUlNDT1JFOiBcInVuZGVyc2NvcmVcIlxufTtcbmNvbnN0IFRhYlN0b3BQb3NpdGlvbiA9IHtcbiAgTUFYOiA5MDI2XG59O1xuY2xhc3MgVGFiQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB2YWw6IFwidzp2YWxcIiwgcG9zOiBcInc6cG9zXCIsIGxlYWRlcjogXCJ3OmxlYWRlclwiIH0pO1xuICB9XG59XG5jbGFzcyBUYWJTdG9wSXRlbSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHsgdHlwZTogdHlwZTIsIHBvc2l0aW9uLCBsZWFkZXIgfSkge1xuICAgIHN1cGVyKFwidzp0YWJcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgVGFiQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogdHlwZTIsXG4gICAgICAgIHBvczogcG9zaXRpb24sXG4gICAgICAgIGxlYWRlclxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBOdW1iZXJQcm9wZXJ0aWVzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobnVtYmVySWQsIGluZGVudExldmVsKSB7XG4gICAgc3VwZXIoXCJ3Om51bVByXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBJbmRlbnRMZXZlbChpbmRlbnRMZXZlbCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOdW1iZXJJZChudW1iZXJJZCkpO1xuICB9XG59XG5jbGFzcyBJbmRlbnRMZXZlbCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGxldmVsKSB7XG4gICAgc3VwZXIoXCJ3OmlsdmxcIik7XG4gICAgaWYgKGxldmVsID4gOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkxldmVsIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gOS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vYW5zd2Vycy5taWNyb3NvZnQuY29tL2VuLXVzL21zb2ZmaWNlL2ZvcnVtL2FsbC9kb2VzLXdvcmQtc3VwcG9ydC1tb3JlLXRoYW4tOS1saXN0LWxldmVscy9kMTMwZmRjZC0xNzgxLTQ0NmQtOGM4NC1jNmM3OTEyNGU0ZDdcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogbGV2ZWxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgTnVtYmVySWQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHN1cGVyKFwidzpudW1JZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiB0eXBlb2YgaWQgPT09IFwic3RyaW5nXCIgPyBgeyR7aWR9fWAgOiBpZFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBGaWxlQ2hpbGQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWxlQ2hpbGRcIiwgU3ltYm9sKCkpO1xuICB9XG59XG5jbGFzcyBIeXBlcmxpbmtBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBpZDogXCJyOmlkXCIsXG4gICAgICBoaXN0b3J5OiBcInc6aGlzdG9yeVwiLFxuICAgICAgYW5jaG9yOiBcInc6YW5jaG9yXCJcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSHlwZXJsaW5rVHlwZSA9IHtcbiAgSU5URVJOQUw6IFwiSU5URVJOQUxcIixcbiAgRVhURVJOQUw6IFwiRVhURVJOQUxcIlxufTtcbmNsYXNzIENvbmNyZXRlSHlwZXJsaW5rIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHJlbGF0aW9uc2hpcElkLCBhbmNob3IpIHtcbiAgICBzdXBlcihcInc6aHlwZXJsaW5rXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaW5rSWRcIik7XG4gICAgdGhpcy5saW5rSWQgPSByZWxhdGlvbnNoaXBJZDtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIGhpc3Rvcnk6IDEsXG4gICAgICBhbmNob3I6IGFuY2hvciA/IGFuY2hvciA6IHZvaWQgMCxcbiAgICAgIGlkOiAhYW5jaG9yID8gYHJJZCR7dGhpcy5saW5rSWR9YCA6IHZvaWQgMFxuICAgIH07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBIeXBlcmxpbmtBdHRyaWJ1dGVzKHByb3BzKTtcbiAgICB0aGlzLnJvb3QucHVzaChhdHRyaWJ1dGVzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgdGhpcy5yb290LnB1c2goY2hpbGQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBJbnRlcm5hbEh5cGVybGluayBleHRlbmRzIENvbmNyZXRlSHlwZXJsaW5rIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMuY2hpbGRyZW4sIHVuaXF1ZUlkKCksIG9wdGlvbnMuYW5jaG9yKTtcbiAgfVxufVxuY2xhc3MgRXh0ZXJuYWxIeXBlcmxpbmsgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OmV4dGVybmFsSHlwZXJsaW5rXCIpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbn1cbmNsYXNzIEJvb2ttYXJrU3RhcnRBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBpZDogXCJ3OmlkXCIsXG4gICAgICBuYW1lOiBcInc6bmFtZVwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEJvb2ttYXJrRW5kQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgaWQ6IFwidzppZFwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEJvb2ttYXJrIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJib29rbWFya1VuaXF1ZU51bWVyaWNJZFwiLCBib29rbWFya1VuaXF1ZU51bWVyaWNJZEdlbigpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhcnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNoaWxkcmVuXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmRcIik7XG4gICAgY29uc3QgbGlua0lkID0gdGhpcy5ib29rbWFya1VuaXF1ZU51bWVyaWNJZCgpO1xuICAgIHRoaXMuc3RhcnQgPSBuZXcgQm9va21hcmtTdGFydChvcHRpb25zLmlkLCBsaW5rSWQpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBvcHRpb25zLmNoaWxkcmVuO1xuICAgIHRoaXMuZW5kID0gbmV3IEJvb2ttYXJrRW5kKGxpbmtJZCk7XG4gIH1cbn1cbmNsYXNzIEJvb2ttYXJrU3RhcnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihpZCwgbGlua0lkKSB7XG4gICAgc3VwZXIoXCJ3OmJvb2ttYXJrU3RhcnRcIik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBCb29rbWFya1N0YXJ0QXR0cmlidXRlcyh7XG4gICAgICBuYW1lOiBpZCxcbiAgICAgIGlkOiBsaW5rSWRcbiAgICB9KTtcbiAgICB0aGlzLnJvb3QucHVzaChhdHRyaWJ1dGVzKTtcbiAgfVxufVxuY2xhc3MgQm9va21hcmtFbmQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihsaW5rSWQpIHtcbiAgICBzdXBlcihcInc6Ym9va21hcmtFbmRcIik7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBCb29rbWFya0VuZEF0dHJpYnV0ZXMoe1xuICAgICAgaWQ6IGxpbmtJZFxuICAgIH0pO1xuICAgIHRoaXMucm9vdC5wdXNoKGF0dHJpYnV0ZXMpO1xuICB9XG59XG5jbGFzcyBPdXRsaW5lTGV2ZWwgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihsZXZlbCkge1xuICAgIHN1cGVyKFwidzpvdXRsaW5lTHZsXCIpO1xuICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiBsZXZlbFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBQYWdlUmVmZXJlbmNlRmllbGRJbnN0cnVjdGlvbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGJvb2ttYXJrSWQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKFwidzppbnN0clRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgbGV0IGluc3RydWN0aW9uID0gYFBBR0VSRUYgJHtib29rbWFya0lkfWA7XG4gICAgaWYgKG9wdGlvbnMuaHlwZXJsaW5rKSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxcaGA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZVJlbGF0aXZlUG9zaXRpb24pIHtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFxwYDtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goaW5zdHJ1Y3Rpb24pO1xuICB9XG59XG5jbGFzcyBQYWdlUmVmZXJlbmNlIGV4dGVuZHMgUnVuIHtcbiAgY29uc3RydWN0b3IoYm9va21hcmtJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgY2hpbGRyZW46IFtuZXcgQmVnaW4odHJ1ZSksIG5ldyBQYWdlUmVmZXJlbmNlRmllbGRJbnN0cnVjdGlvbihib29rbWFya0lkLCBvcHRpb25zKSwgbmV3IEVuZCgpXVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBWZXJ0aWNhbEFsaWduVGFibGUgPSB7XG4gIFRPUDogXCJ0b3BcIixcbiAgQ0VOVEVSOiBcImNlbnRlclwiLFxuICBCT1RUT006IFwiYm90dG9tXCJcbn07XG5jb25zdCBWZXJ0aWNhbEFsaWduU2VjdGlvbiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIFZlcnRpY2FsQWxpZ25UYWJsZSksIHtcbiAgQk9USDogXCJib3RoXCJcbn0pO1xuY29uc3QgVmVydGljYWxBbGlnbjIgPSBWZXJ0aWNhbEFsaWduU2VjdGlvbjtcbmNsYXNzIFZlcnRpY2FsQWxpZ25BdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiBcInc6dmFsXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVmVydGljYWxBbGlnbkVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzp2QWxpZ25cIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFZlcnRpY2FsQWxpZ25BdHRyaWJ1dGVzKHsgdmVydGljYWxBbGlnbjogdmFsdWUgfSkpO1xuICB9XG59XG5jbGFzcyBDb2x1bW5zIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoeyBzcGFjZSwgY291bnQsIHNlcGFyYXRlLCBlcXVhbFdpZHRoLCBjaGlsZHJlbiB9KSB7XG4gICAgc3VwZXIoXCJ3OmNvbHNcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgTmV4dEF0dHJpYnV0ZUNvbXBvbmVudCh7XG4gICAgICAgIHNwYWNlOiB7IGtleTogXCJ3OnNwYWNlXCIsIHZhbHVlOiBzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHdpcHNNZWFzdXJlVmFsdWUoc3BhY2UpIH0sXG4gICAgICAgIGNvdW50OiB7IGtleTogXCJ3Om51bVwiLCB2YWx1ZTogY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlY2ltYWxOdW1iZXIoY291bnQpIH0sXG4gICAgICAgIHNlcGFyYXRlOiB7IGtleTogXCJ3OnNlcFwiLCB2YWx1ZTogc2VwYXJhdGUgfSxcbiAgICAgICAgZXF1YWxXaWR0aDogeyBrZXk6IFwidzplcXVhbFdpZHRoXCIsIHZhbHVlOiBlcXVhbFdpZHRoIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAoIWVxdWFsV2lkdGggJiYgY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNvbHVtbikgPT4gdGhpcy5hZGRDaGlsZEVsZW1lbnQoY29sdW1uKSk7XG4gICAgfVxuICB9XG59XG5jb25zdCBEb2N1bWVudEdyaWRUeXBlID0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoYXQgbm8gZG9jdW1lbnQgZ3JpZCBzaGFsbCBiZSBhcHBsaWVkIHRvIHRoZSBjb250ZW50cyBvZiB0aGUgY3VycmVudCBzZWN0aW9uIGluIHRoZSBkb2N1bWVudC5cbiAgICovXG4gIERFRkFVTFQ6IFwiZGVmYXVsdFwiLFxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoYXQgdGhlIHBhcmVudCBzZWN0aW9uIHNoYWxsIGhhdmUgYWRkaXRpb25hbCBsaW5lIHBpdGNoIGFkZGVkIHRvIGVhY2ggbGluZSB3aXRoaW4gaXQgKGFzIHNwZWNpZmllZCBvbiB0aGUgPGRvY0dyaWQ+IGVsZW1lbnQgKMKnMi42LjUpKSBpbiBvcmRlciB0byBtYWludGFpbiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBsaW5lcyBwZXIgcGFnZS5cbiAgICovXG4gIExJTkVTOiBcImxpbmVzXCIsXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhhdCB0aGUgcGFyZW50IHNlY3Rpb24gc2hhbGwgaGF2ZSBib3RoIHRoZSBhZGRpdGlvbmFsIGxpbmUgcGl0Y2ggYW5kIGNoYXJhY3RlciBwaXRjaCBhZGRlZCB0byBlYWNoIGxpbmUgYW5kIGNoYXJhY3RlciB3aXRoaW4gaXQgKGFzIHNwZWNpZmllZCBvbiB0aGUgPGRvY0dyaWQ+IGVsZW1lbnQgKMKnMi42LjUpKSBpbiBvcmRlciB0byBtYWludGFpbiBhIHNwZWNpZmljIG51bWJlciBvZiBsaW5lcyBwZXIgcGFnZSBhbmQgY2hhcmFjdGVycyBwZXIgbGluZS5cbiAgICpcbiAgICogV2hlbiB0aGlzIHZhbHVlIGlzIHNldCwgdGhlIGlucHV0IHNwZWNpZmllZCB2aWEgdGhlIHVzZXIgaW50ZXJmYWNlIG1heSBiZSBhbGxvd2VkIGluIGV4YWN0IG51bWJlciBvZiBsaW5lL2NoYXJhY3RlciBwaXRjaCB1bml0cy4gKi9cbiAgTElORVNfQU5EX0NIQVJTOiBcImxpbmVzQW5kQ2hhcnNcIixcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGF0IHRoZSBwYXJlbnQgc2VjdGlvbiBzaGFsbCBoYXZlIGJvdGggdGhlIGFkZGl0aW9uYWwgbGluZSBwaXRjaCBhbmQgY2hhcmFjdGVyIHBpdGNoIGFkZGVkIHRvIGVhY2ggbGluZSBhbmQgY2hhcmFjdGVyIHdpdGhpbiBpdCAoYXMgc3BlY2lmaWVkIG9uIHRoZSA8ZG9jR3JpZD4gZWxlbWVudCAowqcyLjYuNSkpIGluIG9yZGVyIHRvIG1haW50YWluIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGxpbmVzIHBlciBwYWdlIGFuZCBjaGFyYWN0ZXJzIHBlciBsaW5lLlxuICAgKlxuICAgKiBXaGVuIHRoaXMgdmFsdWUgaXMgc2V0LCB0aGUgaW5wdXQgc3BlY2lmaWVkIHZpYSB0aGUgdXNlciBpbnRlcmZhY2UgbWF5IGJlIHJlc3RyaWN0ZWQgdG8gdGhlIG51bWJlciBvZiBsaW5lcyBwZXIgcGFnZSBhbmQgY2hhcmFjdGVycyBwZXIgbGluZSwgd2l0aCB0aGUgY29uc3VtZXIgb3IgcHJvZHVjZXIgdHJhbnNsYXRpbmcgdGhpcyBpbmZvcm1hdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBmb250IGRhdGEgdG8gZ2V0IHRoZSByZXN1bHRpbmcgbGluZSBhbmQgY2hhcmFjdGVyIHBpdGNoIHZhbHVlc1xuICAgKi9cbiAgU05BUF9UT19DSEFSUzogXCJzbmFwVG9DaGFyc1wiXG59O1xuY29uc3QgY3JlYXRlRG9jdW1lbnRHcmlkID0gKHsgdHlwZTogdHlwZTIsIGxpbmVQaXRjaCwgY2hhclNwYWNlIH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwidzpkb2NHcmlkXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB0eXBlOiB7IGtleTogXCJ3OnR5cGVcIiwgdmFsdWU6IHR5cGUyIH0sXG4gICAgbGluZVBpdGNoOiB7IGtleTogXCJ3OmxpbmVQaXRjaFwiLCB2YWx1ZTogZGVjaW1hbE51bWJlcihsaW5lUGl0Y2gpIH0sXG4gICAgY2hhclNwYWNlOiB7IGtleTogXCJ3OmNoYXJTcGFjZVwiLCB2YWx1ZTogY2hhclNwYWNlID8gZGVjaW1hbE51bWJlcihjaGFyU3BhY2UpIDogdm9pZCAwIH1cbiAgfVxufSk7XG5jb25zdCBIZWFkZXJGb290ZXJSZWZlcmVuY2VUeXBlID0ge1xuICAvKiogU3BlY2lmaWVzIHRoYXQgdGhpcyBoZWFkZXIgb3IgZm9vdGVyIHNoYWxsIGFwcGVhciBvbiBldmVyeSBwYWdlIGluIHRoaXMgc2VjdGlvbiB3aGljaCBpcyBub3Qgb3ZlcnJpZGRlbiB3aXRoIGEgc3BlY2lmaWMgYGV2ZW5gIG9yIGBmaXJzdGAgcGFnZSBoZWFkZXIvZm9vdGVyLiBJbiBhIHNlY3Rpb24gd2l0aCBhbGwgdGhyZWUgdHlwZXMgc3BlY2lmaWVkLCB0aGlzIHR5cGUgc2hhbGwgYmUgdXNlZCBvbiBhbGwgb2RkIG51bWJlcmVkIHBhZ2VzIChjb3VudGluZyBmcm9tIHRoZSBgZmlyc3RgIHBhZ2UgaW4gdGhlIHNlY3Rpb24sIG5vdCB0aGUgc2VjdGlvbiBudW1iZXJpbmcpLiAqL1xuICBERUZBVUxUOiBcImRlZmF1bHRcIixcbiAgLyoqIFNwZWNpZmllcyB0aGF0IHRoaXMgaGVhZGVyIG9yIGZvb3RlciBzaGFsbCBhcHBlYXIgb24gdGhlIGZpcnN0IHBhZ2UgaW4gdGhpcyBzZWN0aW9uLiBUaGUgYXBwZWFyYW5jZSBvZiB0aGlzIGhlYWRlciBvciBmb290ZXIgaXMgY29udGluZ2VudCBvbiB0aGUgc2V0dGluZyBvZiB0aGUgYHRpdGxlUGdgIGVsZW1lbnQgKMKnMi4xMC42KS4gKi9cbiAgRklSU1Q6IFwiZmlyc3RcIixcbiAgLyoqIFNwZWNpZmllcyB0aGF0IHRoaXMgaGVhZGVyIG9yIGZvb3RlciBzaGFsbCBhcHBlYXIgb24gYWxsIGV2ZW4gbnVtYmVyZWQgcGFnZXMgaW4gdGhpcyBzZWN0aW9uIChjb3VudGluZyBmcm9tIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBzZWN0aW9uLCBub3QgdGhlIHNlY3Rpb24gbnVtYmVyaW5nKS4gVGhlIGFwcGVhcmFuY2Ugb2YgdGhpcyBoZWFkZXIgb3IgZm9vdGVyIGlzIGNvbnRpbmdlbnQgb24gdGhlIHNldHRpbmcgb2YgdGhlIGBldmVuQW5kT2RkSGVhZGVyc2AgZWxlbWVudCAowqcyLjEwLjEpLiAqL1xuICBFVkVOOiBcImV2ZW5cIlxufTtcbmNsYXNzIEZvb3RlclJlZmVyZW5jZUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHR5cGU6IFwidzp0eXBlXCIsXG4gICAgICBpZDogXCJyOmlkXCJcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgSGVhZGVyRm9vdGVyVHlwZSA9IHtcbiAgSEVBREVSOiBcInc6aGVhZGVyUmVmZXJlbmNlXCIsXG4gIEZPT1RFUjogXCJ3OmZvb3RlclJlZmVyZW5jZVwiXG59O1xuY2xhc3MgSGVhZGVyRm9vdGVyUmVmZXJlbmNlIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodHlwZTIsIG9wdGlvbnMpIHtcbiAgICBzdXBlcih0eXBlMik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgRm9vdGVyUmVmZXJlbmNlQXR0cmlidXRlcyh7XG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSB8fCBIZWFkZXJGb290ZXJSZWZlcmVuY2VUeXBlLkRFRkFVTFQsXG4gICAgICAgIGlkOiBgcklkJHtvcHRpb25zLmlkfWBcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgTGluZU51bWJlclJlc3RhcnRGb3JtYXQgPSB7XG4gIC8qKlxuICAgKiAjIyBSZXN0YXJ0IExpbmUgTnVtYmVyaW5nIG9uIEVhY2ggUGFnZVxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCBsaW5lIG51bWJlcmluZyBmb3IgdGhlIHBhcmVudCBzZWN0aW9uIHNoYWxsIHJlc3RhcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlIHdoZW5ldmVyIGEgbmV3IHBhZ2UgaXMgZGlzcGxheWVkLlxuICAgKi9cbiAgTkVXX1BBR0U6IFwibmV3UGFnZVwiLFxuICAvKipcbiAgICogIyMgUmVzdGFydCBMaW5lIE51bWJlcmluZyBmb3IgRWFjaCBTZWN0aW9uXG4gICAqXG4gICAqIFNwZWNpZmllcyB0aGF0IGxpbmUgbnVtYmVyaW5nIGZvciB0aGUgcGFyZW50IHNlY3Rpb24gc2hhbGwgcmVzdGFydCB0byB0aGUgc3RhcnRpbmcgdmFsdWUgd2hlbmV2ZXIgdGhlIHBhcmVudCBiZWdpbnMuXG4gICAqL1xuICBORVdfU0VDVElPTjogXCJuZXdTZWN0aW9uXCIsXG4gIC8qKlxuICAgKiAjIyBDb250aW51ZSBMaW5lIE51bWJlcmluZyBGcm9tIFByZXZpb3VzIFNlY3Rpb25cbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgbGluZSBudW1iZXJpbmcgZm9yIHRoZSBwYXJlbnQgc2VjdGlvbiBzaGFsbCBjb250aW51ZSBmcm9tIHRoZSBsaW5lIG51bWJlcmluZyBmcm9tIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHNlY3Rpb24sIGlmIGFueS5cbiAgICovXG4gIENPTlRJTlVPVVM6IFwiY29udGludW91c1wiXG59O1xuY29uc3QgY3JlYXRlTGluZU51bWJlclR5cGUgPSAoeyBjb3VudEJ5LCBzdGFydCwgcmVzdGFydCwgZGlzdGFuY2UgfSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3OmxuTnVtVHlwZVwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgY291bnRCeTogeyBrZXk6IFwidzpjb3VudEJ5XCIsIHZhbHVlOiBjb3VudEJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNpbWFsTnVtYmVyKGNvdW50QnkpIH0sXG4gICAgc3RhcnQ6IHsga2V5OiBcInc6c3RhcnRcIiwgdmFsdWU6IHN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNpbWFsTnVtYmVyKHN0YXJ0KSB9LFxuICAgIHJlc3RhcnQ6IHsga2V5OiBcInc6cmVzdGFydFwiLCB2YWx1ZTogcmVzdGFydCB9LFxuICAgIGRpc3RhbmNlOiB7XG4gICAgICBrZXk6IFwidzpkaXN0YW5jZVwiLFxuICAgICAgdmFsdWU6IGRpc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0d2lwc01lYXN1cmVWYWx1ZShkaXN0YW5jZSlcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgUGFnZUJvcmRlckRpc3BsYXkgPSB7XG4gIEFMTF9QQUdFUzogXCJhbGxQYWdlc1wiLFxuICBGSVJTVF9QQUdFOiBcImZpcnN0UGFnZVwiLFxuICBOT1RfRklSU1RfUEFHRTogXCJub3RGaXJzdFBhZ2VcIlxufTtcbmNvbnN0IFBhZ2VCb3JkZXJPZmZzZXRGcm9tID0ge1xuICBQQUdFOiBcInBhZ2VcIixcbiAgVEVYVDogXCJ0ZXh0XCJcbn07XG5jb25zdCBQYWdlQm9yZGVyWk9yZGVyID0ge1xuICBCQUNLOiBcImJhY2tcIixcbiAgRlJPTlQ6IFwiZnJvbnRcIlxufTtcbmNsYXNzIFBhZ2VCb3JkZXJzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgZGlzcGxheTogXCJ3OmRpc3BsYXlcIixcbiAgICAgIG9mZnNldEZyb206IFwidzpvZmZzZXRGcm9tXCIsXG4gICAgICB6T3JkZXI6IFwidzp6T3JkZXJcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQYWdlQm9yZGVycyBleHRlbmRzIElnbm9yZUlmRW1wdHlYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnBnQm9yZGVyc1wiKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYWdlQm9yZGVycykge1xuICAgICAgdGhpcy5yb290LnB1c2goXG4gICAgICAgIG5ldyBQYWdlQm9yZGVyc0F0dHJpYnV0ZXMoe1xuICAgICAgICAgIGRpc3BsYXk6IG9wdGlvbnMucGFnZUJvcmRlcnMuZGlzcGxheSxcbiAgICAgICAgICBvZmZzZXRGcm9tOiBvcHRpb25zLnBhZ2VCb3JkZXJzLm9mZnNldEZyb20sXG4gICAgICAgICAgek9yZGVyOiBvcHRpb25zLnBhZ2VCb3JkZXJzLnpPcmRlclxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFBhZ2VCb3JkZXJzQXR0cmlidXRlcyh7fSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYWdlQm9yZGVyVG9wKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6dG9wXCIsIG9wdGlvbnMucGFnZUJvcmRlclRvcCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYWdlQm9yZGVyTGVmdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmxlZnRcIiwgb3B0aW9ucy5wYWdlQm9yZGVyTGVmdCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYWdlQm9yZGVyQm90dG9tKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6Ym90dG9tXCIsIG9wdGlvbnMucGFnZUJvcmRlckJvdHRvbSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYWdlQm9yZGVyUmlnaHQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzpyaWdodFwiLCBvcHRpb25zLnBhZ2VCb3JkZXJSaWdodCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUGFnZU1hcmdpbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgaGVhZGVyLCBmb290ZXIsIGd1dHRlcikge1xuICAgIHN1cGVyKFwidzpwZ01hclwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBOZXh0QXR0cmlidXRlQ29tcG9uZW50KHtcbiAgICAgICAgdG9wOiB7IGtleTogXCJ3OnRvcFwiLCB2YWx1ZTogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUodG9wKSB9LFxuICAgICAgICByaWdodDogeyBrZXk6IFwidzpyaWdodFwiLCB2YWx1ZTogdHdpcHNNZWFzdXJlVmFsdWUocmlnaHQpIH0sXG4gICAgICAgIGJvdHRvbTogeyBrZXk6IFwidzpib3R0b21cIiwgdmFsdWU6IHNpZ25lZFR3aXBzTWVhc3VyZVZhbHVlKGJvdHRvbSkgfSxcbiAgICAgICAgbGVmdDogeyBrZXk6IFwidzpsZWZ0XCIsIHZhbHVlOiB0d2lwc01lYXN1cmVWYWx1ZShsZWZ0KSB9LFxuICAgICAgICBoZWFkZXI6IHsga2V5OiBcInc6aGVhZGVyXCIsIHZhbHVlOiB0d2lwc01lYXN1cmVWYWx1ZShoZWFkZXIpIH0sXG4gICAgICAgIGZvb3RlcjogeyBrZXk6IFwidzpmb290ZXJcIiwgdmFsdWU6IHR3aXBzTWVhc3VyZVZhbHVlKGZvb3RlcikgfSxcbiAgICAgICAgZ3V0dGVyOiB7IGtleTogXCJ3Omd1dHRlclwiLCB2YWx1ZTogdHdpcHNNZWFzdXJlVmFsdWUoZ3V0dGVyKSB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFBhZ2VOdW1iZXJTZXBhcmF0b3IgPSB7XG4gIEhZUEhFTjogXCJoeXBoZW5cIixcbiAgUEVSSU9EOiBcInBlcmlvZFwiLFxuICBDT0xPTjogXCJjb2xvblwiLFxuICBFTV9EQVNIOiBcImVtRGFzaFwiLFxuICBFTl9EQVNIOiBcImVuZGFzaFwiXG59O1xuY2xhc3MgUGFnZU51bWJlclR5cGVBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBzdGFydDogXCJ3OnN0YXJ0XCIsXG4gICAgICBmb3JtYXRUeXBlOiBcInc6Zm10XCIsXG4gICAgICBzZXBhcmF0b3I6IFwidzpjaGFwU2VwXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUGFnZU51bWJlclR5cGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7IHN0YXJ0LCBmb3JtYXRUeXBlLCBzZXBhcmF0b3IgfSkge1xuICAgIHN1cGVyKFwidzpwZ051bVR5cGVcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgUGFnZU51bWJlclR5cGVBdHRyaWJ1dGVzKHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWNpbWFsTnVtYmVyKHN0YXJ0KSxcbiAgICAgICAgZm9ybWF0VHlwZSxcbiAgICAgICAgc2VwYXJhdG9yXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFBhZ2VPcmllbnRhdGlvbiA9IHtcbiAgLyoqXG4gICAqICMjIFBvcnRyYWl0IE1vZGVcbiAgICpcbiAgICogU3BlY2lmaWVzIHRoYXQgcGFnZXMgaW4gdGhpcyBzZWN0aW9uIHNoYWxsIGJlIHByaW50ZWQgaW4gcG9ydHJhaXQgbW9kZS5cbiAgICovXG4gIFBPUlRSQUlUOiBcInBvcnRyYWl0XCIsXG4gIC8qKlxuICAgKiAjIyBMYW5kc2NhcGUgTW9kZVxuICAgKlxuICAgKiBTcGVjaWZpZXMgdGhhdCBwYWdlcyBpbiB0aGlzIHNlY3Rpb24gc2hhbGwgYmUgcHJpbnRlZCBpbiBsYW5kc2NhcGUgbW9kZSwgd2hpY2ggcHJpbnRzIHRoZSBwYWdlIGNvbnRlbnRzIHdpdGggYSA5MCBkZWdyZWUgcm90YXRpb24gd2l0aCByZXNwZWN0IHRvIHRoZSBub3JtYWwgcGFnZSBvcmllbnRhdGlvbi5cbiAgICovXG4gIExBTkRTQ0FQRTogXCJsYW5kc2NhcGVcIlxufTtcbmNvbnN0IGNyZWF0ZVBhZ2VTaXplID0gKHsgd2lkdGgsIGhlaWdodCwgb3JpZW50YXRpb24sIGNvZGUgfSkgPT4ge1xuICBjb25zdCB3aWR0aFR3aXBzID0gdHdpcHNNZWFzdXJlVmFsdWUod2lkdGgpO1xuICBjb25zdCBoZWlnaHRUd2lwcyA9IHR3aXBzTWVhc3VyZVZhbHVlKGhlaWdodCk7XG4gIHJldHVybiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICAgIG5hbWU6IFwidzpwZ1N6XCIsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgd2lkdGg6IHsga2V5OiBcInc6d1wiLCB2YWx1ZTogb3JpZW50YXRpb24gPT09IFBhZ2VPcmllbnRhdGlvbi5MQU5EU0NBUEUgPyBoZWlnaHRUd2lwcyA6IHdpZHRoVHdpcHMgfSxcbiAgICAgIGhlaWdodDogeyBrZXk6IFwidzpoXCIsIHZhbHVlOiBvcmllbnRhdGlvbiA9PT0gUGFnZU9yaWVudGF0aW9uLkxBTkRTQ0FQRSA/IHdpZHRoVHdpcHMgOiBoZWlnaHRUd2lwcyB9LFxuICAgICAgb3JpZW50YXRpb246IHsga2V5OiBcInc6b3JpZW50XCIsIHZhbHVlOiBvcmllbnRhdGlvbiB9LFxuICAgICAgY29kZTogeyBrZXk6IFwidzpjb2RlXCIsIHZhbHVlOiBjb2RlIH1cbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IFBhZ2VUZXh0RGlyZWN0aW9uVHlwZSA9IHtcbiAgTEVGVF9UT19SSUdIVF9UT1BfVE9fQk9UVE9NOiBcImxyVGJcIixcbiAgVE9QX1RPX0JPVFRPTV9SSUdIVF9UT19MRUZUOiBcInRiUmxcIlxufTtcbmNsYXNzIFBhZ2VUZXh0RGlyZWN0aW9uQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB2YWw6IFwidzp2YWxcIiB9KTtcbiAgfVxufVxuY2xhc3MgUGFnZVRleHREaXJlY3Rpb24gZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzp0ZXh0RGlyZWN0aW9uXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFBhZ2VUZXh0RGlyZWN0aW9uQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgU2VjdGlvblR5cGUgPSB7XG4gIE5FWFRfUEFHRTogXCJuZXh0UGFnZVwiLFxuICBORVhUX0NPTFVNTjogXCJuZXh0Q29sdW1uXCIsXG4gIENPTlRJTlVPVVM6IFwiY29udGludW91c1wiLFxuICBFVkVOX1BBR0U6IFwiZXZlblBhZ2VcIixcbiAgT0REX1BBR0U6IFwib2RkUGFnZVwiXG59O1xuY2xhc3MgU2VjdGlvblR5cGVBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICB2YWw6IFwidzp2YWxcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBUeXBlIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcInc6dHlwZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU2VjdGlvblR5cGVBdHRyaWJ1dGVzKHsgdmFsOiB2YWx1ZSB9KSk7XG4gIH1cbn1cbmNvbnN0IHNlY3Rpb25NYXJnaW5EZWZhdWx0cyA9IHtcbiAgVE9QOiAxNDQwLFxuICBSSUdIVDogMTQ0MCxcbiAgQk9UVE9NOiAxNDQwLFxuICBMRUZUOiAxNDQwLFxuICBIRUFERVI6IDcwOCxcbiAgRk9PVEVSOiA3MDgsXG4gIEdVVFRFUjogMFxufTtcbmNvbnN0IHNlY3Rpb25QYWdlU2l6ZURlZmF1bHRzID0ge1xuICBXSURUSDogMTE5MDYsXG4gIEhFSUdIVDogMTY4MzgsXG4gIE9SSUVOVEFUSU9OOiBQYWdlT3JpZW50YXRpb24uUE9SVFJBSVRcbn07XG5jbGFzcyBTZWN0aW9uUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYWdlOiB7XG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoID0gc2VjdGlvblBhZ2VTaXplRGVmYXVsdHMuV0lEVEgsXG4gICAgICAgIGhlaWdodCA9IHNlY3Rpb25QYWdlU2l6ZURlZmF1bHRzLkhFSUdIVCxcbiAgICAgICAgb3JpZW50YXRpb24gPSBzZWN0aW9uUGFnZVNpemVEZWZhdWx0cy5PUklFTlRBVElPTlxuICAgICAgfSA9IHt9LFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcCA9IHNlY3Rpb25NYXJnaW5EZWZhdWx0cy5UT1AsXG4gICAgICAgIHJpZ2h0ID0gc2VjdGlvbk1hcmdpbkRlZmF1bHRzLlJJR0hULFxuICAgICAgICBib3R0b20gPSBzZWN0aW9uTWFyZ2luRGVmYXVsdHMuQk9UVE9NLFxuICAgICAgICBsZWZ0ID0gc2VjdGlvbk1hcmdpbkRlZmF1bHRzLkxFRlQsXG4gICAgICAgIGhlYWRlciA9IHNlY3Rpb25NYXJnaW5EZWZhdWx0cy5IRUFERVIsXG4gICAgICAgIGZvb3RlciA9IHNlY3Rpb25NYXJnaW5EZWZhdWx0cy5GT09URVIsXG4gICAgICAgIGd1dHRlciA9IHNlY3Rpb25NYXJnaW5EZWZhdWx0cy5HVVRURVJcbiAgICAgIH0gPSB7fSxcbiAgICAgIHBhZ2VOdW1iZXJzID0ge30sXG4gICAgICBib3JkZXJzLFxuICAgICAgdGV4dERpcmVjdGlvblxuICAgIH0gPSB7fSxcbiAgICBncmlkOiB7IGxpbmVQaXRjaCA9IDM2MCwgY2hhclNwYWNlLCB0eXBlOiBncmlkVHlwZSB9ID0ge30sXG4gICAgaGVhZGVyV3JhcHBlckdyb3VwID0ge30sXG4gICAgZm9vdGVyV3JhcHBlckdyb3VwID0ge30sXG4gICAgbGluZU51bWJlcnMsXG4gICAgdGl0bGVQYWdlLFxuICAgIHZlcnRpY2FsQWxpZ24sXG4gICAgY29sdW1uLFxuICAgIHR5cGU6IHR5cGUyXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKFwidzpzZWN0UHJcIik7XG4gICAgdGhpcy5hZGRIZWFkZXJGb290ZXJHcm91cChIZWFkZXJGb290ZXJUeXBlLkhFQURFUiwgaGVhZGVyV3JhcHBlckdyb3VwKTtcbiAgICB0aGlzLmFkZEhlYWRlckZvb3Rlckdyb3VwKEhlYWRlckZvb3RlclR5cGUuRk9PVEVSLCBmb290ZXJXcmFwcGVyR3JvdXApO1xuICAgIGlmICh0eXBlMikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFR5cGUodHlwZTIpKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlUGFnZVNpemUoeyB3aWR0aCwgaGVpZ2h0LCBvcmllbnRhdGlvbiB9KSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFBhZ2VNYXJnaW4odG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBoZWFkZXIsIGZvb3RlciwgZ3V0dGVyKSk7XG4gICAgaWYgKGJvcmRlcnMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBQYWdlQm9yZGVycyhib3JkZXJzKSk7XG4gICAgfVxuICAgIGlmIChsaW5lTnVtYmVycykge1xuICAgICAgdGhpcy5yb290LnB1c2goY3JlYXRlTGluZU51bWJlclR5cGUobGluZU51bWJlcnMpKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFBhZ2VOdW1iZXJUeXBlKHBhZ2VOdW1iZXJzKSk7XG4gICAgaWYgKGNvbHVtbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IENvbHVtbnMoY29sdW1uKSk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVmVydGljYWxBbGlnbkVsZW1lbnQodmVydGljYWxBbGlnbikpO1xuICAgIH1cbiAgICBpZiAodGl0bGVQYWdlICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnRpdGxlUGdcIiwgdGl0bGVQYWdlKSk7XG4gICAgfVxuICAgIGlmICh0ZXh0RGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgUGFnZVRleHREaXJlY3Rpb24odGV4dERpcmVjdGlvbikpO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVEb2N1bWVudEdyaWQoeyBsaW5lUGl0Y2gsIGNoYXJTcGFjZSwgdHlwZTogZ3JpZFR5cGUgfSkpO1xuICB9XG4gIGFkZEhlYWRlckZvb3Rlckdyb3VwKHR5cGUyLCBncm91cCkge1xuICAgIGlmIChncm91cC5kZWZhdWx0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgICAgbmV3IEhlYWRlckZvb3RlclJlZmVyZW5jZSh0eXBlMiwge1xuICAgICAgICAgIHR5cGU6IEhlYWRlckZvb3RlclJlZmVyZW5jZVR5cGUuREVGQVVMVCxcbiAgICAgICAgICBpZDogZ3JvdXAuZGVmYXVsdC5WaWV3LlJlZmVyZW5jZUlkXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuZmlyc3QpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgICBuZXcgSGVhZGVyRm9vdGVyUmVmZXJlbmNlKHR5cGUyLCB7XG4gICAgICAgICAgdHlwZTogSGVhZGVyRm9vdGVyUmVmZXJlbmNlVHlwZS5GSVJTVCxcbiAgICAgICAgICBpZDogZ3JvdXAuZmlyc3QuVmlldy5SZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmV2ZW4pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgICBuZXcgSGVhZGVyRm9vdGVyUmVmZXJlbmNlKHR5cGUyLCB7XG4gICAgICAgICAgdHlwZTogSGVhZGVyRm9vdGVyUmVmZXJlbmNlVHlwZS5FVkVOLFxuICAgICAgICAgIGlkOiBncm91cC5ldmVuLlZpZXcuUmVmZXJlbmNlSWRcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCb2R5IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmJvZHlcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2VjdGlvbnNcIiwgW10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIG5ldyBzZWN0aW9uIHByb3BlcnRpZXMuXG4gICAqIE5vdGU6IFByZXZpb3VzIHNlY3Rpb24gaXMgY3JlYXRlZCBpbiBwYXJhZ3JhcGggYWZ0ZXIgdGhlIGN1cnJlbnQgZWxlbWVudCwgYW5kIHRoZW4gbmV3IHNlY3Rpb24gd2lsbCBiZSBhZGRlZC5cbiAgICogVGhlIHNwZWMgc2F5czpcbiAgICogIC0gc2VjdGlvbiBlbGVtZW50IHNob3VsZCBiZSBpbiB0aGUgbGFzdCBwYXJhZ3JhcGggb2YgdGhlIHNlY3Rpb25cbiAgICogIC0gbGFzdCBzZWN0aW9uIHNob3VsZCBiZSBkaXJlY3QgY2hpbGQgb2YgYm9keVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBuZXcgc2VjdGlvbiBvcHRpb25zXG4gICAqL1xuICBhZGRTZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBjdXJyZW50U2VjdGlvbiA9IHRoaXMuc2VjdGlvbnMucG9wKCk7XG4gICAgdGhpcy5yb290LnB1c2godGhpcy5jcmVhdGVTZWN0aW9uUGFyYWdyYXBoKGN1cnJlbnRTZWN0aW9uKSk7XG4gICAgdGhpcy5zZWN0aW9ucy5wdXNoKG5ldyBTZWN0aW9uUHJvcGVydGllcyhvcHRpb25zKSk7XG4gIH1cbiAgcHJlcEZvclhtbChjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnJvb3Quc3BsaWNlKDAsIDEpO1xuICAgICAgdGhpcy5yb290LnB1c2godGhpcy5zZWN0aW9ucy5wb3AoKSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wcmVwRm9yWG1sKGNvbnRleHQpO1xuICB9XG4gIHB1c2goY29tcG9uZW50KSB7XG4gICAgdGhpcy5yb290LnB1c2goY29tcG9uZW50KTtcbiAgfVxuICBjcmVhdGVTZWN0aW9uUGFyYWdyYXBoKHNlY3Rpb24pIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBuZXcgUGFyYWdyYXBoKHt9KTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbmV3IFBhcmFncmFwaFByb3BlcnRpZXMoe30pO1xuICAgIHByb3BlcnRpZXMucHVzaChzZWN0aW9uKTtcbiAgICBwYXJhZ3JhcGguYWRkQ2hpbGRFbGVtZW50KHByb3BlcnRpZXMpO1xuICAgIHJldHVybiBwYXJhZ3JhcGg7XG4gIH1cbn1cbmNsYXNzIENvbHVtbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHsgd2lkdGgsIHNwYWNlIH0pIHtcbiAgICBzdXBlcihcInc6Y29sXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IE5leHRBdHRyaWJ1dGVDb21wb25lbnQoe1xuICAgICAgICB3aWR0aDogeyBrZXk6IFwidzp3XCIsIHZhbHVlOiB0d2lwc01lYXN1cmVWYWx1ZSh3aWR0aCkgfSxcbiAgICAgICAgc3BhY2U6IHsga2V5OiBcInc6c3BhY2VcIiwgdmFsdWU6IHNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0d2lwc01lYXN1cmVWYWx1ZShzcGFjZSkgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jb25zdCBEb2N1bWVudEF0dHJpYnV0ZU5hbWVzcGFjZXMgPSB7XG4gIHdwYzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdDYW52YXNcIixcbiAgbWM6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDZcIixcbiAgbzogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2VcIixcbiAgcjogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIsXG4gIG06IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvbWF0aFwiLFxuICB2OiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sXCIsXG4gIHdwMTQ6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEwL3dvcmRwcm9jZXNzaW5nRHJhd2luZ1wiLFxuICB3cDogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvZHJhd2luZ21sLzIwMDYvd29yZHByb2Nlc3NpbmdEcmF3aW5nXCIsXG4gIHcxMDogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTp3b3JkXCIsXG4gIHc6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3dvcmRwcm9jZXNzaW5nbWwvMjAwNi9tYWluXCIsXG4gIHcxNDogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZG1sXCIsXG4gIHcxNTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTIvd29yZG1sXCIsXG4gIHdwZzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdHcm91cFwiLFxuICB3cGk6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEwL3dvcmRwcm9jZXNzaW5nSW5rXCIsXG4gIHduZTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMDYvd29yZG1sXCIsXG4gIHdwczogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdTaGFwZVwiLFxuICBjcDogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L21ldGFkYXRhL2NvcmUtcHJvcGVydGllc1wiLFxuICBkYzogXCJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xL1wiLFxuICBkY3Rlcm1zOiBcImh0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9cIixcbiAgZGNtaXR5cGU6IFwiaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1wiLFxuICB4c2k6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEtaW5zdGFuY2VcIixcbiAgY3g6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE0L2NoYXJ0ZXhcIixcbiAgY3gxOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNS85LzgvY2hhcnRleFwiLFxuICBjeDI6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE1LzEwLzIxL2NoYXJ0ZXhcIixcbiAgY3gzOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNi81LzkvY2hhcnRleFwiLFxuICBjeDQ6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTAvY2hhcnRleFwiLFxuICBjeDU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTEvY2hhcnRleFwiLFxuICBjeDY6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTIvY2hhcnRleFwiLFxuICBjeDc6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTMvY2hhcnRleFwiLFxuICBjeDg6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTQvY2hhcnRleFwiLFxuICBhaW5rOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNi9pbmtcIixcbiAgYW0zZDogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTcvbW9kZWwzZFwiLFxuICB3MTZjZXg6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDE4L3dvcmRtbC9jZXhcIixcbiAgdzE2Y2lkOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxNi93b3JkbWwvY2lkXCIsXG4gIHcxNjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTgvd29yZG1sXCIsXG4gIHcxNnNkdGRoOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAyMC93b3JkbWwvc2R0ZGF0YWhhc2hcIixcbiAgdzE2c2U6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDE1L3dvcmRtbC9zeW1leFwiXG59O1xuY2xhc3MgRG9jdW1lbnRBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobnMsIElnbm9yYWJsZSkge1xuICAgIHN1cGVyKF9fc3ByZWFkVmFsdWVzKHsgSWdub3JhYmxlIH0sIE9iamVjdC5mcm9tRW50cmllcyhucy5tYXAoKG4pID0+IFtuLCBEb2N1bWVudEF0dHJpYnV0ZU5hbWVzcGFjZXNbbl1dKSkpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBJZ25vcmFibGU6IFwibWM6SWdub3JhYmxlXCJcbiAgICB9LCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoRG9jdW1lbnRBdHRyaWJ1dGVOYW1lc3BhY2VzKS5tYXAoKGtleSkgPT4gW2tleSwgYHhtbG5zOiR7a2V5fWBdKSkpKTtcbiAgfVxufVxuY2xhc3MgRG9jdW1lbnRCYWNrZ3JvdW5kQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgY29sb3I6IFwidzpjb2xvclwiLFxuICAgICAgdGhlbWVDb2xvcjogXCJ3OnRoZW1lQ29sb3JcIixcbiAgICAgIHRoZW1lU2hhZGU6IFwidzp0aGVtZVNoYWRlXCIsXG4gICAgICB0aGVtZVRpbnQ6IFwidzp0aGVtZVRpbnRcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBEb2N1bWVudEJhY2tncm91bmQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OmJhY2tncm91bmRcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgRG9jdW1lbnRCYWNrZ3JvdW5kQXR0cmlidXRlcyh7XG4gICAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZXhDb2xvclZhbHVlKG9wdGlvbnMuY29sb3IpLFxuICAgICAgICB0aGVtZUNvbG9yOiBvcHRpb25zLnRoZW1lQ29sb3IsXG4gICAgICAgIHRoZW1lU2hhZGU6IG9wdGlvbnMudGhlbWVTaGFkZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdUNoYXJIZXhOdW1iZXIob3B0aW9ucy50aGVtZVNoYWRlKSxcbiAgICAgICAgdGhlbWVUaW50OiBvcHRpb25zLnRoZW1lVGludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdUNoYXJIZXhOdW1iZXIob3B0aW9ucy50aGVtZVRpbnQpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIERvY3VtZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzpkb2N1bWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYm9keVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBEb2N1bWVudEF0dHJpYnV0ZXMoXG4gICAgICAgIFtcbiAgICAgICAgICBcIndwY1wiLFxuICAgICAgICAgIFwibWNcIixcbiAgICAgICAgICBcIm9cIixcbiAgICAgICAgICBcInJcIixcbiAgICAgICAgICBcIm1cIixcbiAgICAgICAgICBcInZcIixcbiAgICAgICAgICBcIndwMTRcIixcbiAgICAgICAgICBcIndwXCIsXG4gICAgICAgICAgXCJ3MTBcIixcbiAgICAgICAgICBcIndcIixcbiAgICAgICAgICBcIncxNFwiLFxuICAgICAgICAgIFwidzE1XCIsXG4gICAgICAgICAgXCJ3cGdcIixcbiAgICAgICAgICBcIndwaVwiLFxuICAgICAgICAgIFwid25lXCIsXG4gICAgICAgICAgXCJ3cHNcIixcbiAgICAgICAgICBcImN4XCIsXG4gICAgICAgICAgXCJjeDFcIixcbiAgICAgICAgICBcImN4MlwiLFxuICAgICAgICAgIFwiY3gzXCIsXG4gICAgICAgICAgXCJjeDRcIixcbiAgICAgICAgICBcImN4NVwiLFxuICAgICAgICAgIFwiY3g2XCIsXG4gICAgICAgICAgXCJjeDdcIixcbiAgICAgICAgICBcImN4OFwiLFxuICAgICAgICAgIFwiYWlua1wiLFxuICAgICAgICAgIFwiYW0zZFwiLFxuICAgICAgICAgIFwidzE2Y2V4XCIsXG4gICAgICAgICAgXCJ3MTZjaWRcIixcbiAgICAgICAgICBcIncxNlwiLFxuICAgICAgICAgIFwidzE2c2R0ZGhcIixcbiAgICAgICAgICBcIncxNnNlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJ3MTQgdzE1IHdwMTRcIlxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5ib2R5ID0gbmV3IEJvZHkoKTtcbiAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgRG9jdW1lbnRCYWNrZ3JvdW5kKG9wdGlvbnMuYmFja2dyb3VuZCkpO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaCh0aGlzLmJvZHkpO1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgdGhpcy5ib2R5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IEJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9keTtcbiAgfVxufVxuY2xhc3MgRG9jdW1lbnRXcmFwcGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb2N1bWVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVsYXRpb25zaGlwc1wiKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gbmV3IERvY3VtZW50KG9wdGlvbnMpO1xuICAgIHRoaXMucmVsYXRpb25zaGlwcyA9IG5ldyBSZWxhdGlvbnNoaXBzKCk7XG4gIH1cbiAgZ2V0IFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQ7XG4gIH1cbiAgZ2V0IFJlbGF0aW9uc2hpcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXRpb25zaGlwcztcbiAgfVxufVxuY2xhc3MgV29yZFdyYXBBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7IHZhbDogXCJ3OnZhbFwiIH0pO1xuICB9XG59XG5jbGFzcyBXb3JkV3JhcCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzp3b3JkV3JhcFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgV29yZFdyYXBBdHRyaWJ1dGVzKHsgdmFsOiAwIH0pKTtcbiAgfVxufVxuY29uc3QgRHJvcENhcFR5cGUgPSB7XG4gIE5PTkU6IFwibm9uZVwiLFxuICBEUk9QOiBcImRyb3BcIixcbiAgTUFSR0lOOiBcIm1hcmdpblwiXG59O1xuY29uc3QgRnJhbWVBbmNob3JUeXBlID0ge1xuICBNQVJHSU46IFwibWFyZ2luXCIsXG4gIFBBR0U6IFwicGFnZVwiLFxuICBURVhUOiBcInRleHRcIlxufTtcbmNvbnN0IEZyYW1lV3JhcCA9IHtcbiAgQVJPVU5EOiBcImFyb3VuZFwiLFxuICBBVVRPOiBcImF1dG9cIixcbiAgTk9ORTogXCJub25lXCIsXG4gIE5PVF9CRVNJREU6IFwibm90QmVzaWRlXCIsXG4gIFRIUk9VR0g6IFwidGhyb3VnaFwiLFxuICBUSUdIVDogXCJ0aWdodFwiXG59O1xuY29uc3QgY3JlYXRlRnJhbWVQcm9wZXJ0aWVzID0gKG9wdGlvbnMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gICAgbmFtZTogXCJ3OmZyYW1lUHJcIixcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICBhbmNob3JMb2NrOiB7XG4gICAgICAgIGtleTogXCJ3OmFuY2hvckxvY2tcIixcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMuYW5jaG9yTG9ja1xuICAgICAgfSxcbiAgICAgIGRyb3BDYXA6IHtcbiAgICAgICAga2V5OiBcInc6ZHJvcENhcFwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5kcm9wQ2FwXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAga2V5OiBcInc6d1wiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy53aWR0aFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBrZXk6IFwidzpoXCIsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLmhlaWdodFxuICAgICAgfSxcbiAgICAgIHg6IHtcbiAgICAgICAga2V5OiBcInc6eFwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5wb3NpdGlvbiA/IG9wdGlvbnMucG9zaXRpb24ueCA6IHZvaWQgMFxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAga2V5OiBcInc6eVwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5wb3NpdGlvbiA/IG9wdGlvbnMucG9zaXRpb24ueSA6IHZvaWQgMFxuICAgICAgfSxcbiAgICAgIGFuY2hvckhvcml6b250YWw6IHtcbiAgICAgICAga2V5OiBcInc6aEFuY2hvclwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5hbmNob3IuaG9yaXpvbnRhbFxuICAgICAgfSxcbiAgICAgIGFuY2hvclZlcnRpY2FsOiB7XG4gICAgICAgIGtleTogXCJ3OnZBbmNob3JcIixcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMuYW5jaG9yLnZlcnRpY2FsXG4gICAgICB9LFxuICAgICAgc3BhY2VIb3Jpem9udGFsOiB7XG4gICAgICAgIGtleTogXCJ3OmhTcGFjZVwiLFxuICAgICAgICB2YWx1ZTogKF9hID0gb3B0aW9ucy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhvcml6b250YWxcbiAgICAgIH0sXG4gICAgICBzcGFjZVZlcnRpY2FsOiB7XG4gICAgICAgIGtleTogXCJ3OnZTcGFjZVwiLFxuICAgICAgICB2YWx1ZTogKF9iID0gb3B0aW9ucy5zcGFjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZlcnRpY2FsXG4gICAgICB9LFxuICAgICAgcnVsZToge1xuICAgICAgICBrZXk6IFwidzpoUnVsZVwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5ydWxlXG4gICAgICB9LFxuICAgICAgYWxpZ25tZW50WDoge1xuICAgICAgICBrZXk6IFwidzp4QWxpZ25cIixcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMuYWxpZ25tZW50ID8gb3B0aW9ucy5hbGlnbm1lbnQueCA6IHZvaWQgMFxuICAgICAgfSxcbiAgICAgIGFsaWdubWVudFk6IHtcbiAgICAgICAga2V5OiBcInc6eUFsaWduXCIsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLmFsaWdubWVudCA/IG9wdGlvbnMuYWxpZ25tZW50LnkgOiB2b2lkIDBcbiAgICAgIH0sXG4gICAgICBsaW5lczoge1xuICAgICAgICBrZXk6IFwidzpsaW5lc1wiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5saW5lc1xuICAgICAgfSxcbiAgICAgIHdyYXA6IHtcbiAgICAgICAga2V5OiBcInc6d3JhcFwiLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy53cmFwXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5jbGFzcyBQYXJhZ3JhcGhQcm9wZXJ0aWVzIGV4dGVuZHMgSWdub3JlSWZFbXB0eVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHN1cGVyKFwidzpwUHJcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibnVtYmVyaW5nUmVmZXJlbmNlc1wiLCBbXSk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVhZGluZykge1xuICAgICAgdGhpcy5wdXNoKG5ldyBTdHlsZSQxKG9wdGlvbnMuaGVhZGluZykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5idWxsZXQpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgU3R5bGUkMShcIkxpc3RQYXJhZ3JhcGhcIikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5udW1iZXJpbmcpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zdHlsZSAmJiAhb3B0aW9ucy5oZWFkaW5nKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5udW1iZXJpbmcuY3VzdG9tKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKG5ldyBTdHlsZSQxKFwiTGlzdFBhcmFncmFwaFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgU3R5bGUkMShvcHRpb25zLnN0eWxlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmtlZXBOZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzprZWVwTmV4dFwiLCBvcHRpb25zLmtlZXBOZXh0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6a2VlcExpbmVzXCIsIG9wdGlvbnMua2VlcExpbmVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnBhZ2VCcmVha0JlZm9yZSkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBQYWdlQnJlYWtCZWZvcmUoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZyYW1lKSB7XG4gICAgICB0aGlzLnB1c2goY3JlYXRlRnJhbWVQcm9wZXJ0aWVzKG9wdGlvbnMuZnJhbWUpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2lkb3dDb250cm9sICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp3aWRvd0NvbnRyb2xcIiwgb3B0aW9ucy53aWRvd0NvbnRyb2wpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYnVsbGV0KSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE51bWJlclByb3BlcnRpZXMoMSwgb3B0aW9ucy5idWxsZXQubGV2ZWwpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubnVtYmVyaW5nKSB7XG4gICAgICB0aGlzLm51bWJlcmluZ1JlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgIHJlZmVyZW5jZTogb3B0aW9ucy5udW1iZXJpbmcucmVmZXJlbmNlLFxuICAgICAgICBpbnN0YW5jZTogKF9hID0gb3B0aW9ucy5udW1iZXJpbmcuaW5zdGFuY2UpICE9IG51bGwgPyBfYSA6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wdXNoKG5ldyBOdW1iZXJQcm9wZXJ0aWVzKGAke29wdGlvbnMubnVtYmVyaW5nLnJlZmVyZW5jZX0tJHsoX2IgPSBvcHRpb25zLm51bWJlcmluZy5pbnN0YW5jZSkgIT0gbnVsbCA/IF9iIDogMH1gLCBvcHRpb25zLm51bWJlcmluZy5sZXZlbCkpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5udW1iZXJpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE51bWJlclByb3BlcnRpZXMoMCwgMCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ib3JkZXIpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgQm9yZGVyKG9wdGlvbnMuYm9yZGVyKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRoZW1hdGljQnJlYWspIHtcbiAgICAgIHRoaXMucHVzaChuZXcgVGhlbWF0aWNCcmVhaygpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2hhZGluZykge1xuICAgICAgdGhpcy5wdXNoKG5ldyBTaGFkaW5nKG9wdGlvbnMuc2hhZGluZykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53b3JkV3JhcCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBXb3JkV3JhcCgpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3ZlcmZsb3dQdW5jdHVhdGlvbikge1xuICAgICAgdGhpcy5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3Om92ZXJmbG93UHVuY3RcIiwgb3B0aW9ucy5vdmVyZmxvd1B1bmN0dWF0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IHRhYkRlZmluaXRpb25zID0gW1xuICAgICAgLi4ub3B0aW9ucy5yaWdodFRhYlN0b3AgIT09IHZvaWQgMCA/IFt7IHR5cGU6IFRhYlN0b3BUeXBlLlJJR0hULCBwb3NpdGlvbjogb3B0aW9ucy5yaWdodFRhYlN0b3AgfV0gOiBbXSxcbiAgICAgIC4uLm9wdGlvbnMudGFiU3RvcHMgPyBvcHRpb25zLnRhYlN0b3BzIDogW10sXG4gICAgICAuLi5vcHRpb25zLmxlZnRUYWJTdG9wICE9PSB2b2lkIDAgPyBbeyB0eXBlOiBUYWJTdG9wVHlwZS5MRUZULCBwb3NpdGlvbjogb3B0aW9ucy5sZWZ0VGFiU3RvcCB9XSA6IFtdXG4gICAgXTtcbiAgICBpZiAodGFiRGVmaW5pdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBUYWJTdG9wKHRhYkRlZmluaXRpb25zKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJpZGlyZWN0aW9uYWwgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmJpZGlcIiwgb3B0aW9ucy5iaWRpcmVjdGlvbmFsKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNwYWNpbmcpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgU3BhY2luZyhvcHRpb25zLnNwYWNpbmcpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICB0aGlzLnB1c2gobmV3IEluZGVudChvcHRpb25zLmluZGVudCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jb250ZXh0dWFsU3BhY2luZyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6Y29udGV4dHVhbFNwYWNpbmdcIiwgb3B0aW9ucy5jb250ZXh0dWFsU3BhY2luZykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnQpIHtcbiAgICAgIHRoaXMucHVzaChuZXcgQWxpZ25tZW50KG9wdGlvbnMuYWxpZ25tZW50KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm91dGxpbmVMZXZlbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IE91dGxpbmVMZXZlbChvcHRpb25zLm91dGxpbmVMZXZlbCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdXBwcmVzc0xpbmVOdW1iZXJzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpzdXBwcmVzc0xpbmVOdW1iZXJzXCIsIG9wdGlvbnMuc3VwcHJlc3NMaW5lTnVtYmVycykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdXRvU3BhY2VFYXN0QXNpYW5UZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphdXRvU3BhY2VETlwiLCBvcHRpb25zLmF1dG9TcGFjZUVhc3RBc2lhblRleHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucnVuKSB7XG4gICAgICB0aGlzLnB1c2gobmV3IFJ1blByb3BlcnRpZXMob3B0aW9ucy5ydW4pKTtcbiAgICB9XG4gIH1cbiAgcHVzaChpdGVtKSB7XG4gICAgdGhpcy5yb290LnB1c2goaXRlbSk7XG4gIH1cbiAgcHJlcEZvclhtbChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQudmlld1dyYXBwZXIgaW5zdGFuY2VvZiBEb2N1bWVudFdyYXBwZXIpIHtcbiAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlIG9mIHRoaXMubnVtYmVyaW5nUmVmZXJlbmNlcykge1xuICAgICAgICBjb250ZXh0LmZpbGUuTnVtYmVyaW5nLmNyZWF0ZUNvbmNyZXRlTnVtYmVyaW5nSW5zdGFuY2UocmVmZXJlbmNlLnJlZmVyZW5jZSwgcmVmZXJlbmNlLmluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnByZXBGb3JYbWwoY29udGV4dCk7XG4gIH1cbn1cbmNsYXNzIFBhcmFncmFwaCBleHRlbmRzIEZpbGVDaGlsZCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6cFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvcGVydGllc1wiKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBQYXJhZ3JhcGhQcm9wZXJ0aWVzKHt9KTtcbiAgICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucHJvcGVydGllcyk7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dFJ1bihvcHRpb25zKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IFBhcmFncmFwaFByb3BlcnRpZXMob3B0aW9ucyk7XG4gICAgdGhpcy5yb290LnB1c2godGhpcy5wcm9wZXJ0aWVzKTtcbiAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dFJ1bihvcHRpb25zLnRleHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygb3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBCb29rbWFyaykge1xuICAgICAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkLnN0YXJ0KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRleHRSdW4gb2YgY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKHRleHRSdW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJvb3QucHVzaChjaGlsZC5lbmQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJlcEZvclhtbChjb250ZXh0KSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMucm9vdCkge1xuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBFeHRlcm5hbEh5cGVybGluaykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucm9vdC5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBjb25jcmV0ZUh5cGVybGluayA9IG5ldyBDb25jcmV0ZUh5cGVybGluayhlbGVtZW50Lm9wdGlvbnMuY2hpbGRyZW4sIHVuaXF1ZUlkKCkpO1xuICAgICAgICBjb250ZXh0LnZpZXdXcmFwcGVyLlJlbGF0aW9uc2hpcHMuY3JlYXRlUmVsYXRpb25zaGlwKFxuICAgICAgICAgIGNvbmNyZXRlSHlwZXJsaW5rLmxpbmtJZCxcbiAgICAgICAgICBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvaHlwZXJsaW5rXCIsXG4gICAgICAgICAgZWxlbWVudC5vcHRpb25zLmxpbmssXG4gICAgICAgICAgVGFyZ2V0TW9kZVR5cGUuRVhURVJOQUxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5yb290W2luZGV4XSA9IGNvbmNyZXRlSHlwZXJsaW5rO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHJlcEZvclhtbChjb250ZXh0KTtcbiAgfVxuICBhZGRSdW5Ub0Zyb250KHJ1bikge1xuICAgIHRoaXMucm9vdC5zcGxpY2UoMSwgMCwgcnVuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxubGV0IE1hdGgkMSA9IGNsYXNzIE1hdGgyIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwibTpvTWF0aFwiKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbn07XG5jbGFzcyBNYXRoVGV4dCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICBzdXBlcihcIm06dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaCh0ZXh0KTtcbiAgfVxufVxuY2xhc3MgTWF0aFJ1biBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICBzdXBlcihcIm06clwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aFRleHQodGV4dCkpO1xuICB9XG59XG5jbGFzcyBNYXRoRGVub21pbmF0b3IgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHN1cGVyKFwibTpkZW5cIik7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgdGhpcy5yb290LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgTWF0aE51bWVyYXRvciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgc3VwZXIoXCJtOm51bVwiKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBNYXRoRnJhY3Rpb24gZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJtOmZcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IE1hdGhOdW1lcmF0b3Iob3B0aW9ucy5udW1lcmF0b3IpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aERlbm9taW5hdG9yKG9wdGlvbnMuZGVub21pbmF0b3IpKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlTWF0aEFjY2VudENoYXJhY3RlciA9ICh7IGFjY2VudCB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIm06Y2hyXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhY2NlbnQ6IHsga2V5OiBcIm06dmFsXCIsIHZhbHVlOiBhY2NlbnQgfVxuICB9XG59KTtcbmNvbnN0IGNyZWF0ZU1hdGhCYXNlID0gKHsgY2hpbGRyZW4gfSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOmVcIixcbiAgY2hpbGRyZW5cbn0pO1xuY29uc3QgY3JlYXRlTWF0aExpbWl0TG9jYXRpb24gPSAoeyB2YWx1ZSB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIm06bGltTG9jXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICB2YWx1ZTogeyBrZXk6IFwibTp2YWxcIiwgdmFsdWU6IHZhbHVlIHx8IFwidW5kT3ZyXCIgfVxuICB9XG59KTtcbmNvbnN0IGNyZWF0ZU1hdGhTdWJTY3JpcHRIaWRlID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnN1YkhpZGVcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGhpZGU6IHsga2V5OiBcIm06dmFsXCIsIHZhbHVlOiAxIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVNYXRoU3VwZXJTY3JpcHRIaWRlID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnN1cEhpZGVcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGhpZGU6IHsga2V5OiBcIm06dmFsXCIsIHZhbHVlOiAxIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVNYXRoTkFyeVByb3BlcnRpZXMgPSAoe1xuICBhY2NlbnQsXG4gIGhhc1N1cGVyU2NyaXB0LFxuICBoYXNTdWJTY3JpcHQsXG4gIGxpbWl0TG9jYXRpb25WYWxcbn0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwibTpuYXJ5UHJcIixcbiAgY2hpbGRyZW46IFtcbiAgICAuLi4hIWFjY2VudCA/IFtjcmVhdGVNYXRoQWNjZW50Q2hhcmFjdGVyKHsgYWNjZW50IH0pXSA6IFtdLFxuICAgIGNyZWF0ZU1hdGhMaW1pdExvY2F0aW9uKHsgdmFsdWU6IGxpbWl0TG9jYXRpb25WYWwgfSksXG4gICAgLi4uIWhhc1N1cGVyU2NyaXB0ID8gW2NyZWF0ZU1hdGhTdXBlclNjcmlwdEhpZGUoKV0gOiBbXSxcbiAgICAuLi4haGFzU3ViU2NyaXB0ID8gW2NyZWF0ZU1hdGhTdWJTY3JpcHRIaWRlKCldIDogW11cbiAgXVxufSk7XG5jb25zdCBjcmVhdGVNYXRoU3ViU2NyaXB0RWxlbWVudCA9ICh7IGNoaWxkcmVuIH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwibTpzdWJcIixcbiAgY2hpbGRyZW5cbn0pO1xuY29uc3QgY3JlYXRlTWF0aFN1cGVyU2NyaXB0RWxlbWVudCA9ICh7IGNoaWxkcmVuIH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwibTpzdXBcIixcbiAgY2hpbGRyZW5cbn0pO1xuY2xhc3MgTWF0aFN1bSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06bmFyeVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIGNyZWF0ZU1hdGhOQXJ5UHJvcGVydGllcyh7XG4gICAgICAgIGFjY2VudDogXCLiiJFcIixcbiAgICAgICAgaGFzU3VwZXJTY3JpcHQ6ICEhb3B0aW9ucy5zdXBlclNjcmlwdCxcbiAgICAgICAgaGFzU3ViU2NyaXB0OiAhIW9wdGlvbnMuc3ViU2NyaXB0XG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKCEhb3B0aW9ucy5zdWJTY3JpcHQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhTdWJTY3JpcHRFbGVtZW50KHsgY2hpbGRyZW46IG9wdGlvbnMuc3ViU2NyaXB0IH0pKTtcbiAgICB9XG4gICAgaWYgKCEhb3B0aW9ucy5zdXBlclNjcmlwdCkge1xuICAgICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aFN1cGVyU2NyaXB0RWxlbWVudCh7IGNoaWxkcmVuOiBvcHRpb25zLnN1cGVyU2NyaXB0IH0pKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbjogb3B0aW9ucy5jaGlsZHJlbiB9KSk7XG4gIH1cbn1cbmNsYXNzIE1hdGhJbnRlZ3JhbCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06bmFyeVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIGNyZWF0ZU1hdGhOQXJ5UHJvcGVydGllcyh7XG4gICAgICAgIGFjY2VudDogXCJcIixcbiAgICAgICAgaGFzU3VwZXJTY3JpcHQ6ICEhb3B0aW9ucy5zdXBlclNjcmlwdCxcbiAgICAgICAgaGFzU3ViU2NyaXB0OiAhIW9wdGlvbnMuc3ViU2NyaXB0LFxuICAgICAgICBsaW1pdExvY2F0aW9uVmFsOiBcInN1YlN1cFwiXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKCEhb3B0aW9ucy5zdWJTY3JpcHQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhTdWJTY3JpcHRFbGVtZW50KHsgY2hpbGRyZW46IG9wdGlvbnMuc3ViU2NyaXB0IH0pKTtcbiAgICB9XG4gICAgaWYgKCEhb3B0aW9ucy5zdXBlclNjcmlwdCkge1xuICAgICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aFN1cGVyU2NyaXB0RWxlbWVudCh7IGNoaWxkcmVuOiBvcHRpb25zLnN1cGVyU2NyaXB0IH0pKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbjogb3B0aW9ucy5jaGlsZHJlbiB9KSk7XG4gIH1cbn1cbmNsYXNzIE1hdGhMaW1pdCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgc3VwZXIoXCJtOmxpbVwiKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBNYXRoTGltaXRVcHBlciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06bGltVXBwXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBNYXRoTGltaXQob3B0aW9ucy5saW1pdCkpO1xuICB9XG59XG5jbGFzcyBNYXRoTGltaXRMb3dlciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06bGltTG93XCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBNYXRoTGltaXQob3B0aW9ucy5saW1pdCkpO1xuICB9XG59XG5jb25zdCBjcmVhdGVNYXRoU3VwZXJTY3JpcHRQcm9wZXJ0aWVzID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnNTdXBQclwiXG59KTtcbmNsYXNzIE1hdGhTdXBlclNjcmlwdCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06c1N1cFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVNYXRoU3VwZXJTY3JpcHRQcm9wZXJ0aWVzKCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhTdXBlclNjcmlwdEVsZW1lbnQoeyBjaGlsZHJlbjogb3B0aW9ucy5zdXBlclNjcmlwdCB9KSk7XG4gIH1cbn1cbmNvbnN0IGNyZWF0ZU1hdGhTdWJTY3JpcHRQcm9wZXJ0aWVzID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnNTdWJQclwiXG59KTtcbmNsYXNzIE1hdGhTdWJTY3JpcHQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJtOnNTdWJcIik7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aFN1YlNjcmlwdFByb3BlcnRpZXMoKSk7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbjogb3B0aW9ucy5jaGlsZHJlbiB9KSk7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aFN1YlNjcmlwdEVsZW1lbnQoeyBjaGlsZHJlbjogb3B0aW9ucy5zdWJTY3JpcHQgfSkpO1xuICB9XG59XG5jb25zdCBjcmVhdGVNYXRoU3ViU3VwZXJTY3JpcHRQcm9wZXJ0aWVzID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnNTdWJTdXBQclwiXG59KTtcbmNsYXNzIE1hdGhTdWJTdXBlclNjcmlwdCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06c1N1YlN1cFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVNYXRoU3ViU3VwZXJTY3JpcHRQcm9wZXJ0aWVzKCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhTdWJTY3JpcHRFbGVtZW50KHsgY2hpbGRyZW46IG9wdGlvbnMuc3ViU2NyaXB0IH0pKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVNYXRoU3VwZXJTY3JpcHRFbGVtZW50KHsgY2hpbGRyZW46IG9wdGlvbnMuc3VwZXJTY3JpcHQgfSkpO1xuICB9XG59XG5jb25zdCBjcmVhdGVNYXRoUHJlU3ViU3VwZXJTY3JpcHRQcm9wZXJ0aWVzID0gKCkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOnNQcmVQclwiXG59KTtcbmNsYXNzIE1hdGhQcmVTdWJTdXBlclNjcmlwdCBleHRlbmRzIEJ1aWxkZXJFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoeyBjaGlsZHJlbiwgc3ViU2NyaXB0LCBzdXBlclNjcmlwdCB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogXCJtOnNQcmVcIixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIGNyZWF0ZU1hdGhQcmVTdWJTdXBlclNjcmlwdFByb3BlcnRpZXMoKSxcbiAgICAgICAgY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbiB9KSxcbiAgICAgICAgY3JlYXRlTWF0aFN1YlNjcmlwdEVsZW1lbnQoeyBjaGlsZHJlbjogc3ViU2NyaXB0IH0pLFxuICAgICAgICBjcmVhdGVNYXRoU3VwZXJTY3JpcHRFbGVtZW50KHsgY2hpbGRyZW46IHN1cGVyU2NyaXB0IH0pXG4gICAgICBdXG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFdPUktBUk9VTkQ0ID0gXCJcIjtcbmNsYXNzIE1hdGhEZWdyZWUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHN1cGVyKFwibTpkZWdcIik7XG4gICAgaWYgKCEhY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5yb290LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgTWF0aERlZ3JlZUhpZGVBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7IGhpZGU6IFwibTp2YWxcIiB9KTtcbiAgfVxufVxuY2xhc3MgTWF0aERlZ3JlZUhpZGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIm06ZGVnSGlkZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aERlZ3JlZUhpZGVBdHRyaWJ1dGVzKHsgaGlkZTogMSB9KSk7XG4gIH1cbn1cbmNsYXNzIE1hdGhSYWRpY2FsUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGhhc0RlZ3JlZSkge1xuICAgIHN1cGVyKFwibTpyYWRQclwiKTtcbiAgICBpZiAoIWhhc0RlZ3JlZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE1hdGhEZWdyZWVIaWRlKCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgTWF0aFJhZGljYWwgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJtOnJhZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aFJhZGljYWxQcm9wZXJ0aWVzKCEhb3B0aW9ucy5kZWdyZWUpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aERlZ3JlZShvcHRpb25zLmRlZ3JlZSkpO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICB9XG59XG5jbGFzcyBNYXRoRnVuY3Rpb25OYW1lIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICBzdXBlcihcIm06Zk5hbWVcIik7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgdGhpcy5yb290LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgTWF0aEZ1bmN0aW9uUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwibTpmdW5jUHJcIik7XG4gIH1cbn1cbmNsYXNzIE1hdGhGdW5jdGlvbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06ZnVuY1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aEZ1bmN0aW9uUHJvcGVydGllcygpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTWF0aEZ1bmN0aW9uTmFtZShvcHRpb25zLm5hbWUpKTtcbiAgICB0aGlzLnJvb3QucHVzaChjcmVhdGVNYXRoQmFzZSh7IGNoaWxkcmVuOiBvcHRpb25zLmNoaWxkcmVuIH0pKTtcbiAgfVxufVxuY29uc3QgY3JlYXRlTWF0aEJlZ2lubmluZ0NoYXJhY3RlciA9ICh7IGNoYXJhY3RlciB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcIm06YmVnQ2hyXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBjaGFyYWN0ZXI6IHsga2V5OiBcIm06dmFsXCIsIHZhbHVlOiBjaGFyYWN0ZXIgfVxuICB9XG59KTtcbmNvbnN0IGNyZWF0ZU1hdGhFbmRpbmdDaGFyYWN0ZXIgPSAoeyBjaGFyYWN0ZXIgfSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJtOmVuZENoclwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgY2hhcmFjdGVyOiB7IGtleTogXCJtOnZhbFwiLCB2YWx1ZTogY2hhcmFjdGVyIH1cbiAgfVxufSk7XG5jb25zdCBjcmVhdGVNYXRoQnJhY2tldFByb3BlcnRpZXMgPSAoeyBjaGFyYWN0ZXJzIH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwibTpkUHJcIixcbiAgY2hpbGRyZW46ICEhY2hhcmFjdGVycyA/IFtcbiAgICBjcmVhdGVNYXRoQmVnaW5uaW5nQ2hhcmFjdGVyKHsgY2hhcmFjdGVyOiBjaGFyYWN0ZXJzLmJlZ2lubmluZ0NoYXJhY3RlciB9KSxcbiAgICBjcmVhdGVNYXRoRW5kaW5nQ2hhcmFjdGVyKHsgY2hhcmFjdGVyOiBjaGFyYWN0ZXJzLmVuZGluZ0NoYXJhY3RlciB9KVxuICBdIDogW11cbn0pO1xuY2xhc3MgTWF0aFJvdW5kQnJhY2tldHMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJtOmRcIik7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJyYWNrZXRQcm9wZXJ0aWVzKHt9KSk7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbjogb3B0aW9ucy5jaGlsZHJlbiB9KSk7XG4gIH1cbn1cbmNsYXNzIE1hdGhTcXVhcmVCcmFja2V0cyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06ZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIGNyZWF0ZU1hdGhCcmFja2V0UHJvcGVydGllcyh7XG4gICAgICAgIGNoYXJhY3RlcnM6IHtcbiAgICAgICAgICBiZWdpbm5pbmdDaGFyYWN0ZXI6IFwiW1wiLFxuICAgICAgICAgIGVuZGluZ0NoYXJhY3RlcjogXCJdXCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICB9XG59XG5jbGFzcyBNYXRoQ3VybHlCcmFja2V0cyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcIm06ZFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIGNyZWF0ZU1hdGhCcmFja2V0UHJvcGVydGllcyh7XG4gICAgICAgIGNoYXJhY3RlcnM6IHtcbiAgICAgICAgICBiZWdpbm5pbmdDaGFyYWN0ZXI6IFwie1wiLFxuICAgICAgICAgIGVuZGluZ0NoYXJhY3RlcjogXCJ9XCJcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKGNyZWF0ZU1hdGhCYXNlKHsgY2hpbGRyZW46IG9wdGlvbnMuY2hpbGRyZW4gfSkpO1xuICB9XG59XG5jbGFzcyBNYXRoQW5nbGVkQnJhY2tldHMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJtOmRcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBjcmVhdGVNYXRoQnJhY2tldFByb3BlcnRpZXMoe1xuICAgICAgICBjaGFyYWN0ZXJzOiB7XG4gICAgICAgICAgYmVnaW5uaW5nQ2hhcmFjdGVyOiBcIuKMqVwiLFxuICAgICAgICAgIGVuZGluZ0NoYXJhY3RlcjogXCLijKpcIlxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5yb290LnB1c2goY3JlYXRlTWF0aEJhc2UoeyBjaGlsZHJlbjogb3B0aW9ucy5jaGlsZHJlbiB9KSk7XG4gIH1cbn1cbmNsYXNzIFRhYmxlR3JpZCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHdpZHRocykge1xuICAgIHN1cGVyKFwidzp0YmxHcmlkXCIpO1xuICAgIGZvciAoY29uc3Qgd2lkdGggb2Ygd2lkdGhzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgR3JpZENvbCh3aWR0aCkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR3JpZENvbCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgc3VwZXIoXCJ3OmdyaWRDb2xcIik7XG4gICAgaWYgKHdpZHRoICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgICBuZXcgTmV4dEF0dHJpYnV0ZUNvbXBvbmVudCh7XG4gICAgICAgICAgd2lkdGg6IHsga2V5OiBcInc6d1wiLCB2YWx1ZTogdHdpcHNNZWFzdXJlVmFsdWUod2lkdGgpIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5jb25zdCBUYWJsZUNlbGxNYXJnaW5FbGVtZW50VHlwZSA9IHtcbiAgVEFCTEU6IFwidzp0YmxDZWxsTWFyXCIsXG4gIFRBQkxFX0NFTEw6IFwidzp0Y01hclwiXG59O1xuY2xhc3MgVGFibGVDZWxsTWFyZ2luIGV4dGVuZHMgSWdub3JlSWZFbXB0eVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUyLCB7IG1hcmdpblVuaXRUeXBlID0gV2lkdGhUeXBlLkRYQSwgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0pIHtcbiAgICBzdXBlcih0eXBlMik7XG4gICAgaWYgKHRvcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVXaWR0aEVsZW1lbnQoXCJ3OnRvcFwiLCB7IHR5cGU6IG1hcmdpblVuaXRUeXBlLCBzaXplOiB0b3AgfSkpO1xuICAgIH1cbiAgICBpZiAobGVmdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVXaWR0aEVsZW1lbnQoXCJ3OmxlZnRcIiwgeyB0eXBlOiBtYXJnaW5Vbml0VHlwZSwgc2l6ZTogbGVmdCB9KSk7XG4gICAgfVxuICAgIGlmIChib3R0b20gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFRhYmxlV2lkdGhFbGVtZW50KFwidzpib3R0b21cIiwgeyB0eXBlOiBtYXJnaW5Vbml0VHlwZSwgc2l6ZTogYm90dG9tIH0pKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUYWJsZVdpZHRoRWxlbWVudChcInc6cmlnaHRcIiwgeyB0eXBlOiBtYXJnaW5Vbml0VHlwZSwgc2l6ZTogcmlnaHQgfSkpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgV2lkdGhUeXBlID0ge1xuICAvKiogQXV0by4gKi9cbiAgQVVUTzogXCJhdXRvXCIsXG4gIC8qKiBWYWx1ZSBpcyBpbiB0d2VudGlldGhzIG9mIGEgcG9pbnQgKi9cbiAgRFhBOiBcImR4YVwiLFxuICAvKiogTm8gKGVtcHR5KSB2YWx1ZS4gKi9cbiAgTklMOiBcIm5pbFwiLFxuICAvKiogVmFsdWUgaXMgaW4gcGVyY2VudGFnZS4gKi9cbiAgUEVSQ0VOVEFHRTogXCJwY3RcIlxufTtcbmNsYXNzIFRhYmxlV2lkdGhFbGVtZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobmFtZSwgeyB0eXBlOiB0eXBlMiA9IFdpZHRoVHlwZS5BVVRPLCBzaXplIH0pIHtcbiAgICBzdXBlcihuYW1lKTtcbiAgICBsZXQgdGFibGVXaWR0aFZhbHVlID0gc2l6ZTtcbiAgICBpZiAodHlwZTIgPT09IFdpZHRoVHlwZS5QRVJDRU5UQUdFICYmIHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0YWJsZVdpZHRoVmFsdWUgPSBgJHtzaXplfSVgO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBOZXh0QXR0cmlidXRlQ29tcG9uZW50KHtcbiAgICAgICAgdHlwZTogeyBrZXk6IFwidzp0eXBlXCIsIHZhbHVlOiB0eXBlMiB9LFxuICAgICAgICBzaXplOiB7IGtleTogXCJ3OndcIiwgdmFsdWU6IG1lYXN1cmVtZW50T3JQZXJjZW50VmFsdWUodGFibGVXaWR0aFZhbHVlKSB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIFRhYmxlQ2VsbEJvcmRlcnMgZXh0ZW5kcyBJZ25vcmVJZkVtcHR5WG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzp0Y0JvcmRlcnNcIik7XG4gICAgaWYgKG9wdGlvbnMudG9wKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6dG9wXCIsIG9wdGlvbnMudG9wKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6c3RhcnRcIiwgb3B0aW9ucy5zdGFydCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZWZ0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6bGVmdFwiLCBvcHRpb25zLmxlZnQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYm90dG9tKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6Ym90dG9tXCIsIG9wdGlvbnMuYm90dG9tKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmVuZFwiLCBvcHRpb25zLmVuZCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yaWdodCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OnJpZ2h0XCIsIG9wdGlvbnMucmlnaHQpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdyaWRTcGFuQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB2YWw6IFwidzp2YWxcIiB9KTtcbiAgfVxufVxuY2xhc3MgR3JpZFNwYW4gZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzpncmlkU3BhblwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBHcmlkU3BhbkF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IGRlY2ltYWxOdW1iZXIodmFsdWUpXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IFZlcnRpY2FsTWVyZ2VUeXBlID0ge1xuICAvKipcbiAgICogQ2VsbCB0aGF0IGlzIG1lcmdlZCB3aXRoIHVwcGVyIG9uZS5cbiAgICovXG4gIENPTlRJTlVFOiBcImNvbnRpbnVlXCIsXG4gIC8qKlxuICAgKiBDZWxsIHRoYXQgaXMgc3RhcnRpbmcgdGhlIHZlcnRpY2FsIG1lcmdlLlxuICAgKi9cbiAgUkVTVEFSVDogXCJyZXN0YXJ0XCJcbn07XG5jbGFzcyBWZXJ0aWNhbE1lcmdlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB2YWw6IFwidzp2YWxcIiB9KTtcbiAgfVxufVxuY2xhc3MgVmVydGljYWxNZXJnZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoXCJ3OnZNZXJnZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBWZXJ0aWNhbE1lcmdlQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY29uc3QgVGV4dERpcmVjdGlvbiA9IHtcbiAgQk9UVE9NX1RPX1RPUF9MRUZUX1RPX1JJR0hUOiBcImJ0THJcIixcbiAgTEVGVF9UT19SSUdIVF9UT1BfVE9fQk9UVE9NOiBcImxyVGJcIixcbiAgVE9QX1RPX0JPVFRPTV9SSUdIVF9UT19MRUZUOiBcInRiUmxcIlxufTtcbmNsYXNzIFREaXJlY3Rpb25BdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7IHZhbDogXCJ3OnZhbFwiIH0pO1xuICB9XG59XG5jbGFzcyBURGlyZWN0aW9uIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcInc6dGV4dERpcmVjdGlvblwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBURGlyZWN0aW9uQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgVGFibGVDZWxsUHJvcGVydGllcyBleHRlbmRzIElnbm9yZUlmRW1wdHlYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnRjUHJcIik7XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUYWJsZVdpZHRoRWxlbWVudChcInc6dGNXXCIsIG9wdGlvbnMud2lkdGgpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY29sdW1uU3Bhbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEdyaWRTcGFuKG9wdGlvbnMuY29sdW1uU3BhbikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbE1lcmdlKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVmVydGljYWxNZXJnZShvcHRpb25zLnZlcnRpY2FsTWVyZ2UpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucm93U3BhbiAmJiBvcHRpb25zLnJvd1NwYW4gPiAxKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVmVydGljYWxNZXJnZShWZXJ0aWNhbE1lcmdlVHlwZS5SRVNUQVJUKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJvcmRlcnMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUYWJsZUNlbGxCb3JkZXJzKG9wdGlvbnMuYm9yZGVycykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaGFkaW5nKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgU2hhZGluZyhvcHRpb25zLnNoYWRpbmcpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWFyZ2lucykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFRhYmxlQ2VsbE1hcmdpbihUYWJsZUNlbGxNYXJnaW5FbGVtZW50VHlwZS5UQUJMRV9DRUxMLCBvcHRpb25zLm1hcmdpbnMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGV4dERpcmVjdGlvbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFREaXJlY3Rpb24ob3B0aW9ucy50ZXh0RGlyZWN0aW9uKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBWZXJ0aWNhbEFsaWduRWxlbWVudChvcHRpb25zLnZlcnRpY2FsQWxpZ24pKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6dGNcIik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVDZWxsUHJvcGVydGllcyhvcHRpb25zKSk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBvcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHByZXBGb3JYbWwoY29udGV4dCkge1xuICAgIGlmICghKHRoaXMucm9vdFt0aGlzLnJvb3QubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBQYXJhZ3JhcGgpKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgUGFyYWdyYXBoKHt9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wcmVwRm9yWG1sKGNvbnRleHQpO1xuICB9XG59XG5jb25zdCBOT05FX0JPUkRFUiA9IHtcbiAgc3R5bGU6IEJvcmRlclN0eWxlLk5PTkUsXG4gIHNpemU6IDAsXG4gIGNvbG9yOiBcImF1dG9cIlxufTtcbmNvbnN0IERFRkFVTFRfQk9SREVSID0ge1xuICBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLFxuICBzaXplOiA0LFxuICBjb2xvcjogXCJhdXRvXCJcbn07XG5jbGFzcyBUYWJsZUJvcmRlcnMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnRibEJvcmRlcnNcIik7XG4gICAgaWYgKG9wdGlvbnMudG9wKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6dG9wXCIsIG9wdGlvbnMudG9wKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzp0b3BcIiwgREVGQVVMVF9CT1JERVIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVmdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmxlZnRcIiwgb3B0aW9ucy5sZWZ0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzpsZWZ0XCIsIERFRkFVTFRfQk9SREVSKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJvdHRvbSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3OmJvdHRvbVwiLCBvcHRpb25zLmJvdHRvbSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6Ym90dG9tXCIsIERFRkFVTFRfQk9SREVSKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJpZ2h0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6cmlnaHRcIiwgb3B0aW9ucy5yaWdodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6cmlnaHRcIiwgREVGQVVMVF9CT1JERVIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5zaWRlSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IEJvcmRlckVsZW1lbnQoXCJ3Omluc2lkZUhcIiwgb3B0aW9ucy5pbnNpZGVIb3Jpem9udGFsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzppbnNpZGVIXCIsIERFRkFVTFRfQk9SREVSKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluc2lkZVZlcnRpY2FsKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgQm9yZGVyRWxlbWVudChcInc6aW5zaWRlVlwiLCBvcHRpb25zLmluc2lkZVZlcnRpY2FsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCb3JkZXJFbGVtZW50KFwidzppbnNpZGVWXCIsIERFRkFVTFRfQk9SREVSKSk7XG4gICAgfVxuICB9XG59XG5fX3B1YmxpY0ZpZWxkKFRhYmxlQm9yZGVycywgXCJOT05FXCIsIHtcbiAgdG9wOiBOT05FX0JPUkRFUixcbiAgYm90dG9tOiBOT05FX0JPUkRFUixcbiAgbGVmdDogTk9ORV9CT1JERVIsXG4gIHJpZ2h0OiBOT05FX0JPUkRFUixcbiAgaW5zaWRlSG9yaXpvbnRhbDogTk9ORV9CT1JERVIsXG4gIGluc2lkZVZlcnRpY2FsOiBOT05FX0JPUkRFUlxufSk7XG5jb25zdCBUYWJsZUFuY2hvclR5cGUgPSB7XG4gIE1BUkdJTjogXCJtYXJnaW5cIixcbiAgUEFHRTogXCJwYWdlXCIsXG4gIFRFWFQ6IFwidGV4dFwiXG59O1xuY29uc3QgUmVsYXRpdmVIb3Jpem9udGFsUG9zaXRpb24gPSB7XG4gIENFTlRFUjogXCJjZW50ZXJcIixcbiAgSU5TSURFOiBcImluc2lkZVwiLFxuICBMRUZUOiBcImxlZnRcIixcbiAgT1VUU0lERTogXCJvdXRzaWRlXCIsXG4gIFJJR0hUOiBcInJpZ2h0XCJcbn07XG5jb25zdCBSZWxhdGl2ZVZlcnRpY2FsUG9zaXRpb24gPSB7XG4gIENFTlRFUjogXCJjZW50ZXJcIixcbiAgSU5TSURFOiBcImluc2lkZVwiLFxuICBCT1RUT006IFwiYm90dG9tXCIsXG4gIE9VVFNJREU6IFwib3V0c2lkZVwiLFxuICBJTkxJTkU6IFwiaW5saW5lXCIsXG4gIFRPUDogXCJ0b3BcIlxufTtcbmNvbnN0IE92ZXJsYXBUeXBlID0ge1xuICBORVZFUjogXCJuZXZlclwiLFxuICBPVkVSTEFQOiBcIm92ZXJsYXBcIlxufTtcbmNsYXNzIFRhYmxlRmxvYXRQcm9wZXJ0aWVzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGhvcml6b250YWxBbmNob3IsXG4gICAgdmVydGljYWxBbmNob3IsXG4gICAgYWJzb2x1dGVIb3Jpem9udGFsUG9zaXRpb24sXG4gICAgcmVsYXRpdmVIb3Jpem9udGFsUG9zaXRpb24sXG4gICAgYWJzb2x1dGVWZXJ0aWNhbFBvc2l0aW9uLFxuICAgIHJlbGF0aXZlVmVydGljYWxQb3NpdGlvbixcbiAgICBib3R0b21Gcm9tVGV4dCxcbiAgICB0b3BGcm9tVGV4dCxcbiAgICBsZWZ0RnJvbVRleHQsXG4gICAgcmlnaHRGcm9tVGV4dCxcbiAgICBvdmVybGFwXG4gIH0pIHtcbiAgICBzdXBlcihcInc6dGJscFByXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IE5leHRBdHRyaWJ1dGVDb21wb25lbnQoe1xuICAgICAgICBsZWZ0RnJvbVRleHQ6IHtcbiAgICAgICAgICBrZXk6IFwidzpsZWZ0RnJvbVRleHRcIixcbiAgICAgICAgICB2YWx1ZTogbGVmdEZyb21UZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0d2lwc01lYXN1cmVWYWx1ZShsZWZ0RnJvbVRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0RnJvbVRleHQ6IHtcbiAgICAgICAgICBrZXk6IFwidzpyaWdodEZyb21UZXh0XCIsXG4gICAgICAgICAgdmFsdWU6IHJpZ2h0RnJvbVRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR3aXBzTWVhc3VyZVZhbHVlKHJpZ2h0RnJvbVRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHRvcEZyb21UZXh0OiB7XG4gICAgICAgICAga2V5OiBcInc6dG9wRnJvbVRleHRcIixcbiAgICAgICAgICB2YWx1ZTogdG9wRnJvbVRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR3aXBzTWVhc3VyZVZhbHVlKHRvcEZyb21UZXh0KVxuICAgICAgICB9LFxuICAgICAgICBib3R0b21Gcm9tVGV4dDoge1xuICAgICAgICAgIGtleTogXCJ3OmJvdHRvbUZyb21UZXh0XCIsXG4gICAgICAgICAgdmFsdWU6IGJvdHRvbUZyb21UZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0d2lwc01lYXN1cmVWYWx1ZShib3R0b21Gcm9tVGV4dClcbiAgICAgICAgfSxcbiAgICAgICAgYWJzb2x1dGVIb3Jpem9udGFsUG9zaXRpb246IHtcbiAgICAgICAgICBrZXk6IFwidzp0YmxwWFwiLFxuICAgICAgICAgIHZhbHVlOiBhYnNvbHV0ZUhvcml6b250YWxQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUoYWJzb2x1dGVIb3Jpem9udGFsUG9zaXRpb24pXG4gICAgICAgIH0sXG4gICAgICAgIGFic29sdXRlVmVydGljYWxQb3NpdGlvbjoge1xuICAgICAgICAgIGtleTogXCJ3OnRibHBZXCIsXG4gICAgICAgICAgdmFsdWU6IGFic29sdXRlVmVydGljYWxQb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmVkVHdpcHNNZWFzdXJlVmFsdWUoYWJzb2x1dGVWZXJ0aWNhbFBvc2l0aW9uKVxuICAgICAgICB9LFxuICAgICAgICBob3Jpem9udGFsQW5jaG9yOiB7XG4gICAgICAgICAga2V5OiBcInc6aG9yekFuY2hvclwiLFxuICAgICAgICAgIHZhbHVlOiBob3Jpem9udGFsQW5jaG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBob3Jpem9udGFsQW5jaG9yXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlSG9yaXpvbnRhbFBvc2l0aW9uOiB7XG4gICAgICAgICAga2V5OiBcInc6dGJscFhTcGVjXCIsXG4gICAgICAgICAgdmFsdWU6IHJlbGF0aXZlSG9yaXpvbnRhbFBvc2l0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIHJlbGF0aXZlVmVydGljYWxQb3NpdGlvbjoge1xuICAgICAgICAgIGtleTogXCJ3OnRibHBZU3BlY1wiLFxuICAgICAgICAgIHZhbHVlOiByZWxhdGl2ZVZlcnRpY2FsUG9zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxBbmNob3I6IHtcbiAgICAgICAgICBrZXk6IFwidzp2ZXJ0QW5jaG9yXCIsXG4gICAgICAgICAgdmFsdWU6IHZlcnRpY2FsQW5jaG9yXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAob3ZlcmxhcCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ0VudW1WYWx1ZUVsZW1lbnQoXCJ3OnRibE92ZXJsYXBcIiwgb3ZlcmxhcCkpO1xuICAgIH1cbiAgfVxufVxuY29uc3QgVGFibGVMYXlvdXRUeXBlID0ge1xuICBBVVRPRklUOiBcImF1dG9maXRcIixcbiAgRklYRUQ6IFwiZml4ZWRcIlxufTtcbmNsYXNzIFRhYmxlTGF5b3V0QXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB0eXBlOiBcInc6dHlwZVwiIH0pO1xuICB9XG59XG5jbGFzcyBUYWJsZUxheW91dCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUyKSB7XG4gICAgc3VwZXIoXCJ3OnRibExheW91dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVMYXlvdXRBdHRyaWJ1dGVzKHsgdHlwZTogdHlwZTIgfSkpO1xuICB9XG59XG5jb25zdCBDZWxsU3BhY2luZ1R5cGUgPSB7XG4gIC8qKiBWYWx1ZSBpcyBpbiB0d2VudGlldGhzIG9mIGEgcG9pbnQgKi9cbiAgRFhBOiBcImR4YVwiXG59O1xuY2xhc3MgVGFibGVDZWxsU3BhY2luZ0VsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih7IHR5cGU6IHR5cGUyID0gQ2VsbFNwYWNpbmdUeXBlLkRYQSwgdmFsdWUgfSkge1xuICAgIHN1cGVyKFwidzp0YmxDZWxsU3BhY2luZ1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBOZXh0QXR0cmlidXRlQ29tcG9uZW50KHtcbiAgICAgICAgdHlwZTogeyBrZXk6IFwidzp0eXBlXCIsIHZhbHVlOiB0eXBlMiB9LFxuICAgICAgICB2YWx1ZTogeyBrZXk6IFwidzp3XCIsIHZhbHVlOiBtZWFzdXJlbWVudE9yUGVyY2VudFZhbHVlKHZhbHVlKSB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIFRhYmxlUHJvcGVydGllcyBleHRlbmRzIElnbm9yZUlmRW1wdHlYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OnRibFByXCIpO1xuICAgIGlmIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgU3RyaW5nVmFsdWVFbGVtZW50KFwidzp0YmxTdHlsZVwiLCBvcHRpb25zLnN0eWxlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZsb2F0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVGbG9hdFByb3BlcnRpZXMob3B0aW9ucy5mbG9hdCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52aXN1YWxseVJpZ2h0VG9MZWZ0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmJpZGlWaXN1YWxcIiwgb3B0aW9ucy52aXN1YWxseVJpZ2h0VG9MZWZ0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVXaWR0aEVsZW1lbnQoXCJ3OnRibFdcIiwgb3B0aW9ucy53aWR0aCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBBbGlnbm1lbnQob3B0aW9ucy5hbGlnbm1lbnQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVXaWR0aEVsZW1lbnQoXCJ3OnRibEluZFwiLCBvcHRpb25zLmluZGVudCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVCb3JkZXJzKG9wdGlvbnMuYm9yZGVycykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaGFkaW5nKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgU2hhZGluZyhvcHRpb25zLnNoYWRpbmcpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVMYXlvdXQob3B0aW9ucy5sYXlvdXQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VsbE1hcmdpbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFRhYmxlQ2VsbE1hcmdpbihUYWJsZUNlbGxNYXJnaW5FbGVtZW50VHlwZS5UQUJMRSwgb3B0aW9ucy5jZWxsTWFyZ2luKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNlbGxTcGFjaW5nKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVDZWxsU3BhY2luZ0VsZW1lbnQob3B0aW9ucy5jZWxsU3BhY2luZykpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgVGFibGUgZXh0ZW5kcyBGaWxlQ2hpbGQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcm93cyxcbiAgICB3aWR0aCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxuICAgIGNvbHVtbldpZHRocyA9IEFycmF5KE1hdGgubWF4KC4uLnJvd3MubWFwKChyb3cpID0+IHJvdy5DZWxsQ291bnQpKSkuZmlsbCgxMDApLFxuICAgIG1hcmdpbnMsXG4gICAgaW5kZW50LFxuICAgIGZsb2F0LFxuICAgIGxheW91dCxcbiAgICBzdHlsZSxcbiAgICBib3JkZXJzLFxuICAgIGFsaWdubWVudCxcbiAgICB2aXN1YWxseVJpZ2h0VG9MZWZ0LFxuICAgIGNlbGxTcGFjaW5nXG4gIH0pIHtcbiAgICBzdXBlcihcInc6dGJsXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFRhYmxlUHJvcGVydGllcyh7XG4gICAgICAgIGJvcmRlcnM6IGJvcmRlcnMgIT0gbnVsbCA/IGJvcmRlcnMgOiB7fSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICE9IG51bGwgPyB3aWR0aCA6IHsgc2l6ZTogMTAwIH0sXG4gICAgICAgIGluZGVudCxcbiAgICAgICAgZmxvYXQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgY2VsbE1hcmdpbjogbWFyZ2lucyxcbiAgICAgICAgdmlzdWFsbHlSaWdodFRvTGVmdCxcbiAgICAgICAgY2VsbFNwYWNpbmdcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVHcmlkKGNvbHVtbldpZHRocykpO1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKHJvdyk7XG4gICAgfVxuICAgIHJvd3MuZm9yRWFjaCgocm93LCByb3dJbmRleCkgPT4ge1xuICAgICAgaWYgKHJvd0luZGV4ID09PSByb3dzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNvbHVtbkluZGV4ID0gMDtcbiAgICAgIHJvdy5jZWxscy5mb3JFYWNoKChjZWxsKSA9PiB7XG4gICAgICAgIGlmIChjZWxsLm9wdGlvbnMucm93U3BhbiAmJiBjZWxsLm9wdGlvbnMucm93U3BhbiA+IDEpIHtcbiAgICAgICAgICBjb25zdCBjb250aW51ZUNlbGwgPSBuZXcgVGFibGVDZWxsKHtcbiAgICAgICAgICAgIC8vIHRoZSBpbnNlcnRlZCBDT05USU5VRSBjZWxsIGhhcyByb3dTcGFuLCBhbmQgd2lsbCBiZSBoYW5kbGVkIHdoZW4gcHJvY2VzcyB0aGUgbmV4dCByb3dcbiAgICAgICAgICAgIHJvd1NwYW46IGNlbGwub3B0aW9ucy5yb3dTcGFuIC0gMSxcbiAgICAgICAgICAgIGNvbHVtblNwYW46IGNlbGwub3B0aW9ucy5jb2x1bW5TcGFuLFxuICAgICAgICAgICAgYm9yZGVyczogY2VsbC5vcHRpb25zLmJvcmRlcnMsXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICB2ZXJ0aWNhbE1lcmdlOiBWZXJ0aWNhbE1lcmdlVHlwZS5DT05USU5VRVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJvd3Nbcm93SW5kZXggKyAxXS5hZGRDZWxsVG9Db2x1bW5JbmRleChjb250aW51ZUNlbGwsIGNvbHVtbkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb2x1bW5JbmRleCArPSBjZWxsLm9wdGlvbnMuY29sdW1uU3BhbiB8fCAxO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEhlaWdodFJ1bGUgPSB7XG4gIC8qKiBIZWlnaHQgaXMgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aGUgY29udGVudCwgc28gdmFsdWUgaXMgaWdub3JlZC4gKi9cbiAgQVVUTzogXCJhdXRvXCIsXG4gIC8qKiBBdCBsZWFzdCB0aGUgdmFsdWUgc3BlY2lmaWVkICovXG4gIEFUTEVBU1Q6IFwiYXRMZWFzdFwiLFxuICAvKiogRXhhY3RseSB0aGUgdmFsdWUgc3BlY2lmaWVkICovXG4gIEVYQUNUOiBcImV4YWN0XCJcbn07XG5jbGFzcyBUYWJsZVJvd0hlaWdodEF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgdmFsdWU6IFwidzp2YWxcIiwgcnVsZTogXCJ3OmhSdWxlXCIgfSk7XG4gIH1cbn1cbmNsYXNzIFRhYmxlUm93SGVpZ2h0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodmFsdWUsIHJ1bGUpIHtcbiAgICBzdXBlcihcInc6dHJIZWlnaHRcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgVGFibGVSb3dIZWlnaHRBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsdWU6IHR3aXBzTWVhc3VyZVZhbHVlKHZhbHVlKSxcbiAgICAgICAgcnVsZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBUYWJsZVJvd1Byb3BlcnRpZXMgZXh0ZW5kcyBJZ25vcmVJZkVtcHR5WG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzp0clByXCIpO1xuICAgIGlmIChvcHRpb25zLmNhbnRTcGxpdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpjYW50U3BsaXRcIiwgb3B0aW9ucy5jYW50U3BsaXQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGFibGVIZWFkZXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dGJsSGVhZGVyXCIsIG9wdGlvbnMudGFibGVIZWFkZXIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVSb3dIZWlnaHQob3B0aW9ucy5oZWlnaHQudmFsdWUsIG9wdGlvbnMuaGVpZ2h0LnJ1bGUpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VsbFNwYWNpbmcpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBUYWJsZUNlbGxTcGFjaW5nRWxlbWVudChvcHRpb25zLmNlbGxTcGFjaW5nKSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBUYWJsZVJvdyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6dHJcIik7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGFibGVSb3dQcm9wZXJ0aWVzKG9wdGlvbnMpKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IENlbGxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNoaWxkcmVuLmxlbmd0aDtcbiAgfVxuICBnZXQgY2VsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5maWx0ZXIoKHhtbENvbXBvbmVudCkgPT4geG1sQ29tcG9uZW50IGluc3RhbmNlb2YgVGFibGVDZWxsKTtcbiAgfVxuICBhZGRDZWxsVG9JbmRleChjZWxsLCBpbmRleCkge1xuICAgIHRoaXMucm9vdC5zcGxpY2UoaW5kZXggKyAxLCAwLCBjZWxsKTtcbiAgfVxuICBhZGRDZWxsVG9Db2x1bW5JbmRleChjZWxsLCBjb2x1bW5JbmRleCkge1xuICAgIGNvbnN0IHJvb3RJbmRleCA9IHRoaXMuY29sdW1uSW5kZXhUb1Jvb3RJbmRleChjb2x1bW5JbmRleCwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRDZWxsVG9JbmRleChjZWxsLCByb290SW5kZXggLSAxKTtcbiAgfVxuICByb290SW5kZXhUb0NvbHVtbkluZGV4KHJvb3RJbmRleCkge1xuICAgIGlmIChyb290SW5kZXggPCAxIHx8IHJvb3RJbmRleCA+PSB0aGlzLnJvb3QubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNlbGwgJ3Jvb3RJbmRleCcgc2hvdWxkIGJldHdlZW4gMSB0byAke3RoaXMucm9vdC5sZW5ndGggLSAxfWApO1xuICAgIH1cbiAgICBsZXQgY29sSWR4ID0gMDtcbiAgICBmb3IgKGxldCByb290SWR4ID0gMTsgcm9vdElkeCA8IHJvb3RJbmRleDsgcm9vdElkeCsrKSB7XG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5yb290W3Jvb3RJZHhdO1xuICAgICAgY29sSWR4ICs9IGNlbGwub3B0aW9ucy5jb2x1bW5TcGFuIHx8IDE7XG4gICAgfVxuICAgIHJldHVybiBjb2xJZHg7XG4gIH1cbiAgY29sdW1uSW5kZXhUb1Jvb3RJbmRleChjb2x1bW5JbmRleCwgYWxsb3dFbmROZXdDZWxsID0gZmFsc2UpIHtcbiAgICBpZiAoY29sdW1uSW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNlbGwgJ2NvbHVtbkluZGV4JyBzaG91bGQgbm90IGxlc3MgdGhhbiB6ZXJvYCk7XG4gICAgfVxuICAgIGxldCBjb2xJZHggPSAwO1xuICAgIGxldCByb290SWR4ID0gMTtcbiAgICB3aGlsZSAoY29sSWR4IDw9IGNvbHVtbkluZGV4KSB7XG4gICAgICBpZiAocm9vdElkeCA+PSB0aGlzLnJvb3QubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhbGxvd0VuZE5ld0NlbGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yb290Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNlbGwgJ2NvbHVtbkluZGV4JyBzaG91bGQgbm90IGdyZWF0IHRoYW4gJHtjb2xJZHggLSAxfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5yb290W3Jvb3RJZHhdO1xuICAgICAgcm9vdElkeCArPSAxO1xuICAgICAgY29sSWR4ICs9IGNlbGwgJiYgY2VsbC5vcHRpb25zLmNvbHVtblNwYW4gfHwgMTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RJZHggLSAxO1xuICB9XG59XG5jbGFzcyBBcHBQcm9wZXJ0aWVzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgIHZ0OiBcInhtbG5zOnZ0XCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQXBwUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiUHJvcGVydGllc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBcHBQcm9wZXJ0aWVzQXR0cmlidXRlcyh7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2V4dGVuZGVkLXByb3BlcnRpZXNcIixcbiAgICAgICAgdnQ6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvZG9jUHJvcHNWVHlwZXNcIlxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBDb250ZW50VHlwZUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHhtbG5zOiBcInhtbG5zXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRGVmYXVsdEF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcIkNvbnRlbnRUeXBlXCIsXG4gICAgICBleHRlbnNpb246IFwiRXh0ZW5zaW9uXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRGVmYXVsdCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbnRlbnRUeXBlLCBleHRlbnNpb24pIHtcbiAgICBzdXBlcihcIkRlZmF1bHRcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgRGVmYXVsdEF0dHJpYnV0ZXMoe1xuICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgZXh0ZW5zaW9uXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE92ZXJyaWRlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwiQ29udGVudFR5cGVcIixcbiAgICAgIHBhcnROYW1lOiBcIlBhcnROYW1lXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgT3ZlcnJpZGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihjb250ZW50VHlwZSwgcGFydE5hbWUpIHtcbiAgICBzdXBlcihcIk92ZXJyaWRlXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IE92ZXJyaWRlQXR0cmlidXRlcyh7XG4gICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICBwYXJ0TmFtZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBDb250ZW50VHlwZXMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlR5cGVzXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IENvbnRlbnRUeXBlQXR0cmlidXRlcyh7XG4gICAgICAgIHhtbG5zOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvY29udGVudC10eXBlc1wiXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IERlZmF1bHQoXCJpbWFnZS9wbmdcIiwgXCJwbmdcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWZhdWx0KFwiaW1hZ2UvanBlZ1wiLCBcImpwZWdcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWZhdWx0KFwiaW1hZ2UvanBlZ1wiLCBcImpwZ1wiKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IERlZmF1bHQoXCJpbWFnZS9ibXBcIiwgXCJibXBcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWZhdWx0KFwiaW1hZ2UvZ2lmXCIsIFwiZ2lmXCIpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRGVmYXVsdChcImltYWdlL3N2Zyt4bWxcIiwgXCJzdmdcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWZhdWx0KFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UucmVsYXRpb25zaGlwcyt4bWxcIiwgXCJyZWxzXCIpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRGVmYXVsdChcImFwcGxpY2F0aW9uL3htbFwiLCBcInhtbFwiKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IERlZmF1bHQoXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQub2JmdXNjYXRlZEZvbnRcIiwgXCJvZHR0ZlwiKSk7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgT3ZlcnJpZGUoXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudC5tYWluK3htbFwiLCBcIi93b3JkL2RvY3VtZW50LnhtbFwiKVxuICAgICk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IE92ZXJyaWRlKFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuc3R5bGVzK3htbFwiLCBcIi93b3JkL3N0eWxlcy54bWxcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmNvcmUtcHJvcGVydGllcyt4bWxcIiwgXCIvZG9jUHJvcHMvY29yZS54bWxcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5jdXN0b20tcHJvcGVydGllcyt4bWxcIiwgXCIvZG9jUHJvcHMvY3VzdG9tLnhtbFwiKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IE92ZXJyaWRlKFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmV4dGVuZGVkLXByb3BlcnRpZXMreG1sXCIsIFwiL2RvY1Byb3BzL2FwcC54bWxcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLm51bWJlcmluZyt4bWxcIiwgXCIvd29yZC9udW1iZXJpbmcueG1sXCIpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgT3ZlcnJpZGUoXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290bm90ZXMreG1sXCIsIFwiL3dvcmQvZm9vdG5vdGVzLnhtbFwiKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IE92ZXJyaWRlKFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuc2V0dGluZ3MreG1sXCIsIFwiL3dvcmQvc2V0dGluZ3MueG1sXCIpKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgT3ZlcnJpZGUoXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5jb21tZW50cyt4bWxcIiwgXCIvd29yZC9jb21tZW50cy54bWxcIikpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvbnRUYWJsZSt4bWxcIiwgXCIvd29yZC9mb250VGFibGUueG1sXCIpKTtcbiAgfVxuICBhZGRGb290ZXIoaW5kZXgpIHtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rlcit4bWxcIiwgYC93b3JkL2Zvb3RlciR7aW5kZXh9LnhtbGApXG4gICAgKTtcbiAgfVxuICBhZGRIZWFkZXIoaW5kZXgpIHtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBPdmVycmlkZShcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmhlYWRlcit4bWxcIiwgYC93b3JkL2hlYWRlciR7aW5kZXh9LnhtbGApXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgQ29yZVByb3BlcnRpZXMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJjcDpjb3JlUHJvcGVydGllc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgRG9jdW1lbnRBdHRyaWJ1dGVzKFtcImNwXCIsIFwiZGNcIiwgXCJkY3Rlcm1zXCIsIFwiZGNtaXR5cGVcIiwgXCJ4c2lcIl0pKTtcbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ0NvbnRhaW5lcihcImRjOnRpdGxlXCIsIG9wdGlvbnMudGl0bGUpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3ViamVjdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ0NvbnRhaW5lcihcImRjOnN1YmplY3RcIiwgb3B0aW9ucy5zdWJqZWN0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNyZWF0b3IpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdHJpbmdDb250YWluZXIoXCJkYzpjcmVhdG9yXCIsIG9wdGlvbnMuY3JlYXRvcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5rZXl3b3Jkcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ0NvbnRhaW5lcihcImNwOmtleXdvcmRzXCIsIG9wdGlvbnMua2V5d29yZHMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGVzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdHJpbmdDb250YWluZXIoXCJkYzpkZXNjcmlwdGlvblwiLCBvcHRpb25zLmRlc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhc3RNb2RpZmllZEJ5KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgU3RyaW5nQ29udGFpbmVyKFwiY3A6bGFzdE1vZGlmaWVkQnlcIiwgb3B0aW9ucy5sYXN0TW9kaWZpZWRCeSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXZpc2lvbikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ0NvbnRhaW5lcihcImNwOnJldmlzaW9uXCIsIFN0cmluZyhvcHRpb25zLnJldmlzaW9uKSkpO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGltZXN0YW1wRWxlbWVudChcImRjdGVybXM6Y3JlYXRlZFwiKSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRpbWVzdGFtcEVsZW1lbnQoXCJkY3Rlcm1zOm1vZGlmaWVkXCIpKTtcbiAgfVxufVxuY2xhc3MgVGltZXN0YW1wRWxlbWVudFByb3BlcnRpZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgdHlwZTogXCJ4c2k6dHlwZVwiIH0pO1xuICB9XG59XG5jbGFzcyBUaW1lc3RhbXBFbGVtZW50IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKG5hbWUpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IFRpbWVzdGFtcEVsZW1lbnRQcm9wZXJ0aWVzKHtcbiAgICAgICAgdHlwZTogXCJkY3Rlcm1zOlczQ0RURlwiXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5yb290LnB1c2goZGF0ZVRpbWVWYWx1ZSgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkpO1xuICB9XG59XG5jbGFzcyBDdXN0b21Qcm9wZXJ0aWVzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgeG1sbnM6IFwieG1sbnNcIixcbiAgICAgIHZ0OiBcInhtbG5zOnZ0XCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ3VzdG9tUHJvcGVydHlBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICBmbXRpZDogXCJmbXRpZFwiLFxuICAgICAgcGlkOiBcInBpZFwiLFxuICAgICAgbmFtZTogXCJuYW1lXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgQ3VzdG9tUHJvcGVydHkgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihpZCwgcHJvcGVydGllcykge1xuICAgIHN1cGVyKFwicHJvcGVydHlcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQ3VzdG9tUHJvcGVydHlBdHRyaWJ1dGVzKHtcbiAgICAgICAgZm10aWQ6IFwie0Q1Q0RENTA1LTJFOUMtMTAxQi05Mzk3LTA4MDAyQjJDRjlBRX1cIixcbiAgICAgICAgcGlkOiBpZC50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBwcm9wZXJ0aWVzLm5hbWVcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQ3VzdG9tUHJvcGVydHlWYWx1ZShwcm9wZXJ0aWVzLnZhbHVlKSk7XG4gIH1cbn1cbmNsYXNzIEN1c3RvbVByb3BlcnR5VmFsdWUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidnQ6bHB3c3RyXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKHZhbHVlKTtcbiAgfVxufVxuY2xhc3MgQ3VzdG9tUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihcIlByb3BlcnRpZXNcIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmV4dElkXCIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL3ByZWZlci1yZWFkb25seS10eXBlXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb3BlcnRpZXNcIiwgW10pO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEN1c3RvbVByb3BlcnRpZXNBdHRyaWJ1dGVzKHtcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvY3VzdG9tLXByb3BlcnRpZXNcIixcbiAgICAgICAgdnQ6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvZG9jUHJvcHNWVHlwZXNcIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMubmV4dElkID0gMjtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuYWRkQ3VzdG9tUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cbiAgfVxuICBwcmVwRm9yWG1sKGNvbnRleHQpIHtcbiAgICB0aGlzLnByb3BlcnRpZXMuZm9yRWFjaCgoeCkgPT4gdGhpcy5yb290LnB1c2goeCkpO1xuICAgIHJldHVybiBzdXBlci5wcmVwRm9yWG1sKGNvbnRleHQpO1xuICB9XG4gIGFkZEN1c3RvbVByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgdGhpcy5wcm9wZXJ0aWVzLnB1c2gobmV3IEN1c3RvbVByb3BlcnR5KHRoaXMubmV4dElkKyssIHByb3BlcnR5KSk7XG4gIH1cbn1cbmNvbnN0IENoYXJhY3RlclNldCA9IHtcbiAgQU5TSTogXCIwMFwiLFxuICBERUZBVUxUOiBcIjAxXCIsXG4gIFNZTUJPTDogXCIwMlwiLFxuICBNQUM6IFwiNERcIixcbiAgSklTOiBcIjgwXCIsXG4gIEhBTkdVTDogXCI4MVwiLFxuICBKT0hBQjogXCI4MlwiLFxuICBHQl8yMzEyOiBcIjg2XCIsXG4gIENISU5FU0VCSUc1OiBcIjg4XCIsXG4gIEdSRUVLOiBcIkExXCIsXG4gIFRVUktJU0g6IFwiQTJcIixcbiAgVklFVE5BTUVTRTogXCJBM1wiLFxuICBIRUJSRVc6IFwiQjFcIixcbiAgQVJBQklDOiBcIkIyXCIsXG4gIEJBTFRJQzogXCJCQVwiLFxuICBSVVNTSUFOOiBcIkNDXCIsXG4gIFRIQUk6IFwiREVcIixcbiAgRUFTVEVVUk9QRTogXCJFRVwiLFxuICBPRU06IFwiRkZcIlxufTtcbmNvbnN0IGNyZWF0ZUZvbnRSZWxhdGlvbnNoaXAgPSAoeyBpZCwgZm9udEtleSwgc3Vic2V0dGVkIH0sIG5hbWUpID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWUsXG4gIGF0dHJpYnV0ZXM6IF9fc3ByZWFkVmFsdWVzKHtcbiAgICBpZDogeyBrZXk6IFwicjppZFwiLCB2YWx1ZTogaWQgfVxuICB9LCBmb250S2V5ID8geyBmb250S2V5OiB7IGtleTogXCJ3OmZvbnRLZXlcIiwgdmFsdWU6IGB7JHtmb250S2V5fX1gIH0gfSA6IHt9KSxcbiAgY2hpbGRyZW46IFsuLi5zdWJzZXR0ZWQgPyBbbmV3IE9uT2ZmRWxlbWVudChcInc6c3Vic2V0dGVkXCIsIHN1YnNldHRlZCldIDogW11dXG59KTtcbmNvbnN0IGNyZWF0ZUZvbnQgPSAoe1xuICBuYW1lLFxuICBhbHROYW1lLFxuICBwYW5vc2UxLFxuICBjaGFyc2V0LFxuICBmYW1pbHksXG4gIG5vdFRydWVUeXBlLFxuICBwaXRjaCxcbiAgc2lnLFxuICBlbWJlZFJlZ3VsYXIsXG4gIGVtYmVkQm9sZCxcbiAgZW1iZWRJdGFsaWMsXG4gIGVtYmVkQm9sZEl0YWxpY1xufSkgPT4gKFxuICAvLyBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2Utd19mb250LTEuaHRtbFxuICBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICAgIG5hbWU6IFwidzpmb250XCIsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgbmFtZTogeyBrZXk6IFwidzpuYW1lXCIsIHZhbHVlOiBuYW1lIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvLyBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2Utd19hbHROYW1lLTEuaHRtbFxuICAgICAgLi4uYWx0TmFtZSA/IFtjcmVhdGVTdHJpbmdFbGVtZW50KFwidzphbHROYW1lXCIsIGFsdE5hbWUpXSA6IFtdLFxuICAgICAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfcGFub3NlMS0xLmh0bWxcbiAgICAgIC4uLnBhbm9zZTEgPyBbY3JlYXRlU3RyaW5nRWxlbWVudChcInc6cGFub3NlMVwiLCBwYW5vc2UxKV0gOiBbXSxcbiAgICAgIC8vIGh0dHA6Ly93d3cuZGF0eXBpYy5jb20vc2Mvb294bWwvZS13X2NoYXJzZXQtMS5odG1sXG4gICAgICAuLi5jaGFyc2V0ID8gW2NyZWF0ZVN0cmluZ0VsZW1lbnQoXCJ3OmNoYXJzZXRcIiwgY2hhcnNldCldIDogW10sXG4gICAgICAvLyBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2Utd19mYW1pbHktMS5odG1sXG4gICAgICAuLi5bY3JlYXRlU3RyaW5nRWxlbWVudChcInc6ZmFtaWx5XCIsIGZhbWlseSldLFxuICAgICAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfbm90VHJ1ZVR5cGUtMS5odG1sXG4gICAgICAuLi5ub3RUcnVlVHlwZSA/IFtuZXcgT25PZmZFbGVtZW50KFwidzpub3RUcnVlVHlwZVwiLCBub3RUcnVlVHlwZSldIDogW10sXG4gICAgICAuLi5bY3JlYXRlU3RyaW5nRWxlbWVudChcInc6cGl0Y2hcIiwgcGl0Y2gpXSxcbiAgICAgIC8vIGh0dHA6Ly93d3cuZGF0eXBpYy5jb20vc2Mvb294bWwvZS13X3NpZy0xLmh0bWxcbiAgICAgIC4uLnNpZyA/IFtcbiAgICAgICAgbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgICAgICAgICBuYW1lOiBcInc6c2lnXCIsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgdXNiMDogeyBrZXk6IFwidzp1c2IwXCIsIHZhbHVlOiBzaWcudXNiMCB9LFxuICAgICAgICAgICAgdXNiMTogeyBrZXk6IFwidzp1c2IxXCIsIHZhbHVlOiBzaWcudXNiMSB9LFxuICAgICAgICAgICAgdXNiMjogeyBrZXk6IFwidzp1c2IyXCIsIHZhbHVlOiBzaWcudXNiMiB9LFxuICAgICAgICAgICAgdXNiMzogeyBrZXk6IFwidzp1c2IzXCIsIHZhbHVlOiBzaWcudXNiMyB9LFxuICAgICAgICAgICAgY3NiMDogeyBrZXk6IFwidzpjc2IwXCIsIHZhbHVlOiBzaWcuY3NiMCB9LFxuICAgICAgICAgICAgY3NiMTogeyBrZXk6IFwidzpjc2IxXCIsIHZhbHVlOiBzaWcuY3NiMSB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgXSA6IFtdLFxuICAgICAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfZW1iZWRSZWd1bGFyLTEuaHRtbFxuICAgICAgLi4uZW1iZWRSZWd1bGFyID8gW2NyZWF0ZUZvbnRSZWxhdGlvbnNoaXAoZW1iZWRSZWd1bGFyLCBcInc6ZW1iZWRSZWd1bGFyXCIpXSA6IFtdLFxuICAgICAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfZW1iZWRCb2xkLTEuaHRtbFxuICAgICAgLi4uZW1iZWRCb2xkID8gW2NyZWF0ZUZvbnRSZWxhdGlvbnNoaXAoZW1iZWRCb2xkLCBcInc6ZW1iZWRCb2xkXCIpXSA6IFtdLFxuICAgICAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfZW1iZWRJdGFsaWMtMS5odG1sXG4gICAgICAuLi5lbWJlZEl0YWxpYyA/IFtjcmVhdGVGb250UmVsYXRpb25zaGlwKGVtYmVkSXRhbGljLCBcInc6ZW1iZWRJdGFsaWNcIildIDogW10sXG4gICAgICAvLyBodHRwOi8vd3d3LmRhdHlwaWMuY29tL3NjL29veG1sL2Utd19lbWJlZEJvbGRJdGFsaWMtMS5odG1sXG4gICAgICAuLi5lbWJlZEJvbGRJdGFsaWMgPyBbY3JlYXRlRm9udFJlbGF0aW9uc2hpcChlbWJlZEJvbGRJdGFsaWMsIFwidzplbWJlZEJvbGRJdGFsaWNcIildIDogW11cbiAgICBdXG4gIH0pXG4pO1xuY29uc3QgY3JlYXRlUmVndWxhckZvbnQgPSAoe1xuICBuYW1lLFxuICBpbmRleCxcbiAgZm9udEtleSxcbiAgY2hhcmFjdGVyU2V0XG59KSA9PiBjcmVhdGVGb250KHtcbiAgbmFtZSxcbiAgc2lnOiB7XG4gICAgdXNiMDogXCJFMDAwMkFGRlwiLFxuICAgIHVzYjE6IFwiQzAwMDI0N0JcIixcbiAgICB1c2IyOiBcIjAwMDAwMDA5XCIsXG4gICAgdXNiMzogXCIwMDAwMDAwMFwiLFxuICAgIGNzYjA6IFwiMDAwMDAxRkZcIixcbiAgICBjc2IxOiBcIjAwMDAwMDAwXCJcbiAgfSxcbiAgY2hhcnNldDogY2hhcmFjdGVyU2V0LFxuICBmYW1pbHk6IFwiYXV0b1wiLFxuICBwaXRjaDogXCJ2YXJpYWJsZVwiLFxuICBlbWJlZFJlZ3VsYXI6IHtcbiAgICBmb250S2V5LFxuICAgIGlkOiBgcklkJHtpbmRleH1gXG4gIH1cbn0pO1xuY29uc3QgY3JlYXRlRm9udFRhYmxlID0gKGZvbnRzKSA9PiAoXG4gIC8vIGh0dHBzOi8vYy1yZXgubmV0L3Byb2plY3RzL3NhbXBsZXMvb294bWwvZTEvUGFydDQvT09YTUxfUDRfRE9DWF9Gb250X3RvcGljX0lEMEVSTkNVLmh0bWxcbiAgLy8gaHR0cDovL3d3dy5kYXR5cGljLmNvbS9zYy9vb3htbC9lLXdfZm9udHMuaHRtbFxuICBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICAgIG5hbWU6IFwidzpmb250c1wiLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIG1jOiB7IGtleTogXCJ4bWxuczptY1wiLCB2YWx1ZTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiIH0sXG4gICAgICByOiB7IGtleTogXCJ4bWxuczpyXCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIiB9LFxuICAgICAgdzogeyBrZXk6IFwieG1sbnM6d1wiLCB2YWx1ZTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvd29yZHByb2Nlc3NpbmdtbC8yMDA2L21haW5cIiB9LFxuICAgICAgdzE0OiB7IGtleTogXCJ4bWxuczp3MTRcIiwgdmFsdWU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEwL3dvcmRtbFwiIH0sXG4gICAgICB3MTU6IHsga2V5OiBcInhtbG5zOncxNVwiLCB2YWx1ZTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTIvd29yZG1sXCIgfSxcbiAgICAgIHcxNmNleDogeyBrZXk6IFwieG1sbnM6dzE2Y2V4XCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxOC93b3JkbWwvY2V4XCIgfSxcbiAgICAgIHcxNmNpZDogeyBrZXk6IFwieG1sbnM6dzE2Y2lkXCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxNi93b3JkbWwvY2lkXCIgfSxcbiAgICAgIHcxNjogeyBrZXk6IFwieG1sbnM6dzE2XCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxOC93b3JkbWxcIiB9LFxuICAgICAgdzE2c2R0ZGg6IHsga2V5OiBcInhtbG5zOncxNnNkdGRoXCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAyMC93b3JkbWwvc2R0ZGF0YWhhc2hcIiB9LFxuICAgICAgdzE2c2U6IHsga2V5OiBcInhtbG5zOncxNnNlXCIsIHZhbHVlOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxNS93b3JkbWwvc3ltZXhcIiB9LFxuICAgICAgSWdub3JhYmxlOiB7IGtleTogXCJtYzpJZ25vcmFibGVcIiwgdmFsdWU6IFwidzE0IHcxNSB3MTZzZSB3MTZjaWQgdzE2IHcxNmNleCB3MTZzZHRkaFwiIH1cbiAgICB9LFxuICAgIGNoaWxkcmVuOiBmb250cy5tYXAoXG4gICAgICAoZm9udCwgaSkgPT4gY3JlYXRlUmVndWxhckZvbnQoe1xuICAgICAgICBuYW1lOiBmb250Lm5hbWUsXG4gICAgICAgIGluZGV4OiBpICsgMSxcbiAgICAgICAgZm9udEtleTogZm9udC5mb250S2V5XG4gICAgICB9KVxuICAgIClcbiAgfSlcbik7XG5jbGFzcyBGb250V3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZm9udFRhYmxlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWxhdGlvbnNoaXBzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmb250T3B0aW9uc1dpdGhLZXlcIiwgW10pO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb250T3B0aW9uc1dpdGhLZXkgPSBvcHRpb25zLm1hcCgobykgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbyksIHsgZm9udEtleTogdW5pcXVlVXVpZCgpIH0pKTtcbiAgICB0aGlzLmZvbnRUYWJsZSA9IGNyZWF0ZUZvbnRUYWJsZSh0aGlzLmZvbnRPcHRpb25zV2l0aEtleSk7XG4gICAgdGhpcy5yZWxhdGlvbnNoaXBzID0gbmV3IFJlbGF0aW9uc2hpcHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAgIGkgKyAxLFxuICAgICAgICBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvZm9udFwiLFxuICAgICAgICBgZm9udHMvJHtvcHRpb25zW2ldLm5hbWV9Lm9kdHRmYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZ2V0IFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9udFRhYmxlO1xuICB9XG4gIGdldCBSZWxhdGlvbnNoaXBzKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGF0aW9uc2hpcHM7XG4gIH1cbn1cbmNsYXNzIEZvb3RlckF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHdwYzogXCJ4bWxuczp3cGNcIixcbiAgICAgIG1jOiBcInhtbG5zOm1jXCIsXG4gICAgICBvOiBcInhtbG5zOm9cIixcbiAgICAgIHI6IFwieG1sbnM6clwiLFxuICAgICAgbTogXCJ4bWxuczptXCIsXG4gICAgICB2OiBcInhtbG5zOnZcIixcbiAgICAgIHdwMTQ6IFwieG1sbnM6d3AxNFwiLFxuICAgICAgd3A6IFwieG1sbnM6d3BcIixcbiAgICAgIHcxMDogXCJ4bWxuczp3MTBcIixcbiAgICAgIHc6IFwieG1sbnM6d1wiLFxuICAgICAgdzE0OiBcInhtbG5zOncxNFwiLFxuICAgICAgdzE1OiBcInhtbG5zOncxNVwiLFxuICAgICAgd3BnOiBcInhtbG5zOndwZ1wiLFxuICAgICAgd3BpOiBcInhtbG5zOndwaVwiLFxuICAgICAgd25lOiBcInhtbG5zOnduZVwiLFxuICAgICAgd3BzOiBcInhtbG5zOndwc1wiLFxuICAgICAgY3A6IFwieG1sbnM6Y3BcIixcbiAgICAgIGRjOiBcInhtbG5zOmRjXCIsXG4gICAgICBkY3Rlcm1zOiBcInhtbG5zOmRjdGVybXNcIixcbiAgICAgIGRjbWl0eXBlOiBcInhtbG5zOmRjbWl0eXBlXCIsXG4gICAgICB4c2k6IFwieG1sbnM6eHNpXCIsXG4gICAgICB0eXBlOiBcInhzaTp0eXBlXCJcbiAgICB9KTtcbiAgfVxufVxubGV0IEZvb3RlciQxID0gY2xhc3MgRm9vdGVyIGV4dGVuZHMgSW5pdGlhbGl6YWJsZVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJlZmVyZW5jZU51bWJlciwgaW5pdENvbnRlbnQpIHtcbiAgICBzdXBlcihcInc6ZnRyXCIsIGluaXRDb250ZW50KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmSWRcIik7XG4gICAgdGhpcy5yZWZJZCA9IHJlZmVyZW5jZU51bWJlcjtcbiAgICBpZiAoIWluaXRDb250ZW50KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgICAgbmV3IEZvb3RlckF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHdwYzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdDYW52YXNcIixcbiAgICAgICAgICBtYzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiLFxuICAgICAgICAgIG86IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlXCIsXG4gICAgICAgICAgcjogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIsXG4gICAgICAgICAgbTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9tYXRoXCIsXG4gICAgICAgICAgdjogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiLFxuICAgICAgICAgIHdwMTQ6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEwL3dvcmRwcm9jZXNzaW5nRHJhd2luZ1wiLFxuICAgICAgICAgIHdwOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgICB3MTA6IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6d29yZFwiLFxuICAgICAgICAgIHc6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3dvcmRwcm9jZXNzaW5nbWwvMjAwNi9tYWluXCIsXG4gICAgICAgICAgdzE0OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkbWxcIixcbiAgICAgICAgICB3MTU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEyL3dvcmRtbFwiLFxuICAgICAgICAgIHdwZzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdHcm91cFwiLFxuICAgICAgICAgIHdwaTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdJbmtcIixcbiAgICAgICAgICB3bmU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDA2L3dvcmRtbFwiLFxuICAgICAgICAgIHdwczogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdTaGFwZVwiXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBnZXQgUmVmZXJlbmNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmSWQ7XG4gIH1cbiAgYWRkKGl0ZW0pIHtcbiAgICB0aGlzLnJvb3QucHVzaChpdGVtKTtcbiAgfVxufTtcbmNsYXNzIEZvb3RlcldyYXBwZXIge1xuICBjb25zdHJ1Y3RvcihtZWRpYSwgcmVmZXJlbmNlSWQsIGluaXRDb250ZW50KSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZvb3RlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVsYXRpb25zaGlwc1wiKTtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mb290ZXIgPSBuZXcgRm9vdGVyJDEocmVmZXJlbmNlSWQsIGluaXRDb250ZW50KTtcbiAgICB0aGlzLnJlbGF0aW9uc2hpcHMgPSBuZXcgUmVsYXRpb25zaGlwcygpO1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgdGhpcy5mb290ZXIuYWRkKGl0ZW0pO1xuICB9XG4gIGFkZENoaWxkRWxlbWVudChjaGlsZEVsZW1lbnQpIHtcbiAgICB0aGlzLmZvb3Rlci5hZGRDaGlsZEVsZW1lbnQoY2hpbGRFbGVtZW50KTtcbiAgfVxuICBnZXQgVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5mb290ZXI7XG4gIH1cbiAgZ2V0IFJlbGF0aW9uc2hpcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXRpb25zaGlwcztcbiAgfVxuICBnZXQgTWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWE7XG4gIH1cbn1cbmNsYXNzIEZvb3Rub3RlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgdHlwZTogXCJ3OnR5cGVcIixcbiAgICAgIGlkOiBcInc6aWRcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb290bm90ZVJlZiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpmb290bm90ZVJlZlwiKTtcbiAgfVxufVxuY2xhc3MgRm9vdG5vdGVSZWZSdW4gZXh0ZW5kcyBSdW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICBzdHlsZTogXCJGb290bm90ZVJlZmVyZW5jZVwiXG4gICAgfSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IEZvb3Rub3RlUmVmKCkpO1xuICB9XG59XG5jb25zdCBGb290bm90ZVR5cGUgPSB7XG4gIFNFUEVSQVRPUjogXCJzZXBhcmF0b3JcIixcbiAgQ09OVElOVUFUSU9OX1NFUEVSQVRPUjogXCJjb250aW51YXRpb25TZXBhcmF0b3JcIlxufTtcbmNsYXNzIEZvb3Rub3RlIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzpmb290bm90ZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBGb290bm90ZUF0dHJpYnV0ZXMoe1xuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgICAgIGlkOiBvcHRpb25zLmlkXG4gICAgICB9KVxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG9wdGlvbnMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjaGlsZC5hZGRSdW5Ub0Zyb250KG5ldyBGb290bm90ZVJlZlJ1bigpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIENvbnRpbnVhdGlvblNlcGVyYXRvciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpjb250aW51YXRpb25TZXBhcmF0b3JcIik7XG4gIH1cbn1cbmNsYXNzIENvbnRpbnVhdGlvblNlcGVyYXRvclJ1biBleHRlbmRzIFJ1biB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHt9KTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQ29udGludWF0aW9uU2VwZXJhdG9yKCkpO1xuICB9XG59XG5jbGFzcyBTZXBlcmF0b3IgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6c2VwYXJhdG9yXCIpO1xuICB9XG59XG5jbGFzcyBTZXBlcmF0b3JSdW4gZXh0ZW5kcyBSdW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7fSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFNlcGVyYXRvcigpKTtcbiAgfVxufVxuY2xhc3MgRm9vdG5vdGVzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgd3BjOiBcInhtbG5zOndwY1wiLFxuICAgICAgbWM6IFwieG1sbnM6bWNcIixcbiAgICAgIG86IFwieG1sbnM6b1wiLFxuICAgICAgcjogXCJ4bWxuczpyXCIsXG4gICAgICBtOiBcInhtbG5zOm1cIixcbiAgICAgIHY6IFwieG1sbnM6dlwiLFxuICAgICAgd3AxNDogXCJ4bWxuczp3cDE0XCIsXG4gICAgICB3cDogXCJ4bWxuczp3cFwiLFxuICAgICAgdzEwOiBcInhtbG5zOncxMFwiLFxuICAgICAgdzogXCJ4bWxuczp3XCIsXG4gICAgICB3MTQ6IFwieG1sbnM6dzE0XCIsXG4gICAgICB3MTU6IFwieG1sbnM6dzE1XCIsXG4gICAgICB3cGc6IFwieG1sbnM6d3BnXCIsXG4gICAgICB3cGk6IFwieG1sbnM6d3BpXCIsXG4gICAgICB3bmU6IFwieG1sbnM6d25lXCIsXG4gICAgICB3cHM6IFwieG1sbnM6d3BzXCIsXG4gICAgICBJZ25vcmFibGU6IFwibWM6SWdub3JhYmxlXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9vdE5vdGVzIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmZvb3Rub3Rlc1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBGb290bm90ZXNBdHRyaWJ1dGVzKHtcbiAgICAgICAgd3BjOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0NhbnZhc1wiLFxuICAgICAgICBtYzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiLFxuICAgICAgICBvOiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZVwiLFxuICAgICAgICByOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIixcbiAgICAgICAgbTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9tYXRoXCIsXG4gICAgICAgIHY6IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIixcbiAgICAgICAgd3AxNDogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdEcmF3aW5nXCIsXG4gICAgICAgIHdwOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgdzEwOiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOndvcmRcIixcbiAgICAgICAgdzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvd29yZHByb2Nlc3NpbmdtbC8yMDA2L21haW5cIixcbiAgICAgICAgdzE0OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkbWxcIixcbiAgICAgICAgdzE1OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMi93b3JkbWxcIixcbiAgICAgICAgd3BnOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0dyb3VwXCIsXG4gICAgICAgIHdwaTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdJbmtcIixcbiAgICAgICAgd25lOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAwNi93b3JkbWxcIixcbiAgICAgICAgd3BzOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ1NoYXBlXCIsXG4gICAgICAgIElnbm9yYWJsZTogXCJ3MTQgdzE1IHdwMTRcIlxuICAgICAgfSlcbiAgICApO1xuICAgIGNvbnN0IGJlZ2luID0gbmV3IEZvb3Rub3RlKHtcbiAgICAgIGlkOiAtMSxcbiAgICAgIHR5cGU6IEZvb3Rub3RlVHlwZS5TRVBFUkFUT1IsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICBhZnRlcjogMCxcbiAgICAgICAgICAgIGxpbmU6IDI0MCxcbiAgICAgICAgICAgIGxpbmVSdWxlOiBMaW5lUnVsZVR5cGUuQVVUT1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IFtuZXcgU2VwZXJhdG9yUnVuKCldXG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgfSk7XG4gICAgdGhpcy5yb290LnB1c2goYmVnaW4pO1xuICAgIGNvbnN0IHNwYWNpbmcgPSBuZXcgRm9vdG5vdGUoe1xuICAgICAgaWQ6IDAsXG4gICAgICB0eXBlOiBGb290bm90ZVR5cGUuQ09OVElOVUFUSU9OX1NFUEVSQVRPUixcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgICAgbGluZTogMjQwLFxuICAgICAgICAgICAgbGluZVJ1bGU6IExpbmVSdWxlVHlwZS5BVVRPXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogW25ldyBDb250aW51YXRpb25TZXBlcmF0b3JSdW4oKV1cbiAgICAgICAgfSlcbiAgICAgIF1cbiAgICB9KTtcbiAgICB0aGlzLnJvb3QucHVzaChzcGFjaW5nKTtcbiAgfVxuICBjcmVhdGVGb290Tm90ZShpZCwgcGFyYWdyYXBoKSB7XG4gICAgY29uc3QgZm9vdG5vdGUgPSBuZXcgRm9vdG5vdGUoe1xuICAgICAgaWQsXG4gICAgICBjaGlsZHJlbjogcGFyYWdyYXBoXG4gICAgfSk7XG4gICAgdGhpcy5yb290LnB1c2goZm9vdG5vdGUpO1xuICB9XG59XG5jbGFzcyBGb290bm90ZXNXcmFwcGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZvb3Rub3Rlc3NcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbGF0aW9uc2hpcHNcIik7XG4gICAgdGhpcy5mb290bm90ZXNzID0gbmV3IEZvb3ROb3RlcygpO1xuICAgIHRoaXMucmVsYXRpb25zaGlwcyA9IG5ldyBSZWxhdGlvbnNoaXBzKCk7XG4gIH1cbiAgZ2V0IFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9vdG5vdGVzcztcbiAgfVxuICBnZXQgUmVsYXRpb25zaGlwcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxhdGlvbnNoaXBzO1xuICB9XG59XG5jbGFzcyBIZWFkZXJBdHRyaWJ1dGVzIGV4dGVuZHMgWG1sQXR0cmlidXRlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwieG1sS2V5c1wiLCB7XG4gICAgICB3cGM6IFwieG1sbnM6d3BjXCIsXG4gICAgICBtYzogXCJ4bWxuczptY1wiLFxuICAgICAgbzogXCJ4bWxuczpvXCIsXG4gICAgICByOiBcInhtbG5zOnJcIixcbiAgICAgIG06IFwieG1sbnM6bVwiLFxuICAgICAgdjogXCJ4bWxuczp2XCIsXG4gICAgICB3cDE0OiBcInhtbG5zOndwMTRcIixcbiAgICAgIHdwOiBcInhtbG5zOndwXCIsXG4gICAgICB3MTA6IFwieG1sbnM6dzEwXCIsXG4gICAgICB3OiBcInhtbG5zOndcIixcbiAgICAgIHcxNDogXCJ4bWxuczp3MTRcIixcbiAgICAgIHcxNTogXCJ4bWxuczp3MTVcIixcbiAgICAgIHdwZzogXCJ4bWxuczp3cGdcIixcbiAgICAgIHdwaTogXCJ4bWxuczp3cGlcIixcbiAgICAgIHduZTogXCJ4bWxuczp3bmVcIixcbiAgICAgIHdwczogXCJ4bWxuczp3cHNcIixcbiAgICAgIGNwOiBcInhtbG5zOmNwXCIsXG4gICAgICBkYzogXCJ4bWxuczpkY1wiLFxuICAgICAgZGN0ZXJtczogXCJ4bWxuczpkY3Rlcm1zXCIsXG4gICAgICBkY21pdHlwZTogXCJ4bWxuczpkY21pdHlwZVwiLFxuICAgICAgeHNpOiBcInhtbG5zOnhzaVwiLFxuICAgICAgdHlwZTogXCJ4c2k6dHlwZVwiLFxuICAgICAgY3g6IFwieG1sbnM6Y3hcIixcbiAgICAgIGN4MTogXCJ4bWxuczpjeDFcIixcbiAgICAgIGN4MjogXCJ4bWxuczpjeDJcIixcbiAgICAgIGN4MzogXCJ4bWxuczpjeDNcIixcbiAgICAgIGN4NDogXCJ4bWxuczpjeDRcIixcbiAgICAgIGN4NTogXCJ4bWxuczpjeDVcIixcbiAgICAgIGN4NjogXCJ4bWxuczpjeDZcIixcbiAgICAgIGN4NzogXCJ4bWxuczpjeDdcIixcbiAgICAgIGN4ODogXCJ4bWxuczpjeDhcIixcbiAgICAgIHcxNmNpZDogXCJ4bWxuczp3MTZjaWRcIixcbiAgICAgIHcxNnNlOiBcInhtbG5zOncxNnNlXCJcbiAgICB9KTtcbiAgfVxufVxubGV0IEhlYWRlciQxID0gY2xhc3MgSGVhZGVyIGV4dGVuZHMgSW5pdGlhbGl6YWJsZVhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHJlZmVyZW5jZU51bWJlciwgaW5pdENvbnRlbnQpIHtcbiAgICBzdXBlcihcInc6aGRyXCIsIGluaXRDb250ZW50KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmSWRcIik7XG4gICAgdGhpcy5yZWZJZCA9IHJlZmVyZW5jZU51bWJlcjtcbiAgICBpZiAoIWluaXRDb250ZW50KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgICAgbmV3IEhlYWRlckF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHdwYzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdDYW52YXNcIixcbiAgICAgICAgICBtYzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiLFxuICAgICAgICAgIG86IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlXCIsXG4gICAgICAgICAgcjogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzXCIsXG4gICAgICAgICAgbTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9tYXRoXCIsXG4gICAgICAgICAgdjogXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiLFxuICAgICAgICAgIHdwMTQ6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEwL3dvcmRwcm9jZXNzaW5nRHJhd2luZ1wiLFxuICAgICAgICAgIHdwOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgICB3MTA6IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6d29yZFwiLFxuICAgICAgICAgIHc6IFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3dvcmRwcm9jZXNzaW5nbWwvMjAwNi9tYWluXCIsXG4gICAgICAgICAgdzE0OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkbWxcIixcbiAgICAgICAgICB3MTU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDEyL3dvcmRtbFwiLFxuICAgICAgICAgIHdwZzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdHcm91cFwiLFxuICAgICAgICAgIHdwaTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdJbmtcIixcbiAgICAgICAgICB3bmU6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDA2L3dvcmRtbFwiLFxuICAgICAgICAgIHdwczogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdTaGFwZVwiLFxuICAgICAgICAgIGN4OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNC9jaGFydGV4XCIsXG4gICAgICAgICAgY3gxOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNS85LzgvY2hhcnRleFwiLFxuICAgICAgICAgIGN4MjogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTUvMTAvMjEvY2hhcnRleFwiLFxuICAgICAgICAgIGN4MzogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS85L2NoYXJ0ZXhcIixcbiAgICAgICAgICBjeDQ6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTAvY2hhcnRleFwiLFxuICAgICAgICAgIGN4NTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS8xMS9jaGFydGV4XCIsXG4gICAgICAgICAgY3g2OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL2RyYXdpbmcvMjAxNi81LzEyL2NoYXJ0ZXhcIixcbiAgICAgICAgICBjeDc6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2UvZHJhd2luZy8yMDE2LzUvMTMvY2hhcnRleFwiLFxuICAgICAgICAgIGN4ODogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9kcmF3aW5nLzIwMTYvNS8xNC9jaGFydGV4XCIsXG4gICAgICAgICAgdzE2Y2lkOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxNi93b3JkbWwvY2lkXCIsXG4gICAgICAgICAgdzE2c2U6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZC8yMDE1L3dvcmRtbC9zeW1leFwiXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBnZXQgUmVmZXJlbmNlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmSWQ7XG4gIH1cbiAgYWRkKGl0ZW0pIHtcbiAgICB0aGlzLnJvb3QucHVzaChpdGVtKTtcbiAgfVxufTtcbmNsYXNzIEhlYWRlcldyYXBwZXIge1xuICBjb25zdHJ1Y3RvcihtZWRpYSwgcmVmZXJlbmNlSWQsIGluaXRDb250ZW50KSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhlYWRlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVsYXRpb25zaGlwc1wiKTtcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyJDEocmVmZXJlbmNlSWQsIGluaXRDb250ZW50KTtcbiAgICB0aGlzLnJlbGF0aW9uc2hpcHMgPSBuZXcgUmVsYXRpb25zaGlwcygpO1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgdGhpcy5oZWFkZXIuYWRkKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZENoaWxkRWxlbWVudChjaGlsZEVsZW1lbnQpIHtcbiAgICB0aGlzLmhlYWRlci5hZGRDaGlsZEVsZW1lbnQoY2hpbGRFbGVtZW50KTtcbiAgfVxuICBnZXQgVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXI7XG4gIH1cbiAgZ2V0IFJlbGF0aW9uc2hpcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXRpb25zaGlwcztcbiAgfVxuICBnZXQgTWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWE7XG4gIH1cbn1cbmNsYXNzIE1lZGlhIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvcHJlZmVyLXJlYWRvbmx5LXR5cGVcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFwXCIpO1xuICAgIHRoaXMubWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGRJbWFnZShrZXksIG1lZGlhRGF0YSkge1xuICAgIHRoaXMubWFwLnNldChrZXksIG1lZGlhRGF0YSk7XG4gIH1cbiAgZ2V0IEFycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKTtcbiAgfVxufVxuY29uc3QgV09SS0FST1VORDIgPSBcIlwiO1xuY29uc3QgTGV2ZWxGb3JtYXQgPSB7XG4gIERFQ0lNQUw6IFwiZGVjaW1hbFwiLFxuICBVUFBFUl9ST01BTjogXCJ1cHBlclJvbWFuXCIsXG4gIExPV0VSX1JPTUFOOiBcImxvd2VyUm9tYW5cIixcbiAgVVBQRVJfTEVUVEVSOiBcInVwcGVyTGV0dGVyXCIsXG4gIExPV0VSX0xFVFRFUjogXCJsb3dlckxldHRlclwiLFxuICBPUkRJTkFMOiBcIm9yZGluYWxcIixcbiAgQ0FSRElOQUxfVEVYVDogXCJjYXJkaW5hbFRleHRcIixcbiAgT1JESU5BTF9URVhUOiBcIm9yZGluYWxUZXh0XCIsXG4gIEhFWDogXCJoZXhcIixcbiAgQ0hJQ0FHTzogXCJjaGljYWdvXCIsXG4gIElERU9HUkFQSF9fRElHSVRBTDogXCJpZGVvZ3JhcGhEaWdpdGFsXCIsXG4gIEpBUEFORVNFX0NPVU5USU5HOiBcImphcGFuZXNlQ291bnRpbmdcIixcbiAgQUlVRU86IFwiYWl1ZW9cIixcbiAgSVJPSEE6IFwiaXJvaGFcIixcbiAgREVDSU1BTF9GVUxMX1dJRFRIOiBcImRlY2ltYWxGdWxsV2lkdGhcIixcbiAgREVDSU1BTF9IQUxGX1dJRFRIOiBcImRlY2ltYWxIYWxmV2lkdGhcIixcbiAgSkFQQU5FU0VfTEVHQUw6IFwiamFwYW5lc2VMZWdhbFwiLFxuICBKQVBBTkVTRV9ESUdJVEFMX1RFTl9USE9VU0FORDogXCJqYXBhbmVzZURpZ2l0YWxUZW5UaG91c2FuZFwiLFxuICBERUNJTUFMX0VOQ0xPU0VEX0NJUkNMRTogXCJkZWNpbWFsRW5jbG9zZWRDaXJjbGVcIixcbiAgREVDSU1BTF9GVUxMX1dJRFRIMjogXCJkZWNpbWFsRnVsbFdpZHRoMlwiLFxuICBBSVVFT19GVUxMX1dJRFRIOiBcImFpdWVvRnVsbFdpZHRoXCIsXG4gIElST0hBX0ZVTExfV0lEVEg6IFwiaXJvaGFGdWxsV2lkdGhcIixcbiAgREVDSU1BTF9aRVJPOiBcImRlY2ltYWxaZXJvXCIsXG4gIEJVTExFVDogXCJidWxsZXRcIixcbiAgR0FOQURBOiBcImdhbmFkYVwiLFxuICBDSE9TVU5HOiBcImNob3N1bmdcIixcbiAgREVDSU1BTF9FTkNMT1NFRF9GVUxMU1RPUDogXCJkZWNpbWFsRW5jbG9zZWRGdWxsc3RvcFwiLFxuICBERUNJTUFMX0VOQ0xPU0VEX1BBUkVOVEhFU0VTOiBcImRlY2ltYWxFbmNsb3NlZFBhcmVuXCIsXG4gIERFQ0lNQUxfRU5DTE9TRURfQ0lSQ0xFX0NISU5FU0U6IFwiZGVjaW1hbEVuY2xvc2VkQ2lyY2xlQ2hpbmVzZVwiLFxuICBJREVPR1JBUEhfRU5DTE9TRURfQ0lSQ0xFOiBcImlkZW9ncmFwaEVuY2xvc2VkQ2lyY2xlXCIsXG4gIElERU9HUkFQSF9UUkFESVRJT05BTDogXCJpZGVvZ3JhcGhUcmFkaXRpb25hbFwiLFxuICBJREVPR1JBUEhfWk9ESUFDOiBcImlkZW9ncmFwaFpvZGlhY1wiLFxuICBJREVPR1JBUEhfWk9ESUFDX1RSQURJVElPTkFMOiBcImlkZW9ncmFwaFpvZGlhY1RyYWRpdGlvbmFsXCIsXG4gIFRBSVdBTkVTRV9DT1VOVElORzogXCJ0YWl3YW5lc2VDb3VudGluZ1wiLFxuICBJREVPR1JBUEhfTEVHQUxfVFJBRElUSU9OQUw6IFwiaWRlb2dyYXBoTGVnYWxUcmFkaXRpb25hbFwiLFxuICBUQUlXQU5FU0VfQ09VTlRJTkdfVEhPVVNBTkQ6IFwidGFpd2FuZXNlQ291bnRpbmdUaG91c2FuZFwiLFxuICBUQUlXQU5FU0VfRElHSVRBTDogXCJ0YWl3YW5lc2VEaWdpdGFsXCIsXG4gIENISU5FU0VfQ09VTlRJTkc6IFwiY2hpbmVzZUNvdW50aW5nXCIsXG4gIENISU5FU0VfTEVHQUxfU0lNUExJRklFRDogXCJjaGluZXNlTGVnYWxTaW1wbGlmaWVkXCIsXG4gIENISU5FU0VfQ09VTlRJTkdfVEhPVVNBTkQ6IFwiY2hpbmVzZUNvdW50aW5nVGhvdXNhbmRcIixcbiAgS09SRUFOX0RJR0lUQUw6IFwia29yZWFuRGlnaXRhbFwiLFxuICBLT1JFQU5fQ09VTlRJTkc6IFwia29yZWFuQ291bnRpbmdcIixcbiAgS09SRUFOX0xFR0FMOiBcImtvcmVhbkxlZ2FsXCIsXG4gIEtPUkVBTl9ESUdJVEFMMjogXCJrb3JlYW5EaWdpdGFsMlwiLFxuICBWSUVUTkFNRVNFX0NPVU5USU5HOiBcInZpZXRuYW1lc2VDb3VudGluZ1wiLFxuICBSVVNTSUFOX0xPV0VSOiBcInJ1c3NpYW5Mb3dlclwiLFxuICBSVVNTSUFOX1VQUEVSOiBcInJ1c3NpYW5VcHBlclwiLFxuICBOT05FOiBcIm5vbmVcIixcbiAgTlVNQkVSX0lOX0RBU0g6IFwibnVtYmVySW5EYXNoXCIsXG4gIEhFQlJFVzE6IFwiaGVicmV3MVwiLFxuICBIRUJSRVcyOiBcImhlYnJldzJcIixcbiAgQVJBQklDX0FMUEhBOiBcImFyYWJpY0FscGhhXCIsXG4gIEFSQUJJQ19BQkpBRDogXCJhcmFiaWNBYmphZFwiLFxuICBISU5ESV9WT1dFTFM6IFwiaGluZGlWb3dlbHNcIixcbiAgSElORElfQ09OU09OQU5UUzogXCJoaW5kaUNvbnNvbmFudHNcIixcbiAgSElORElfTlVNQkVSUzogXCJoaW5kaU51bWJlcnNcIixcbiAgSElORElfQ09VTlRJTkc6IFwiaGluZGlDb3VudGluZ1wiLFxuICBUSEFJX0xFVFRFUlM6IFwidGhhaUxldHRlcnNcIixcbiAgVEhBSV9OVU1CRVJTOiBcInRoYWlOdW1iZXJzXCIsXG4gIFRIQUlfQ09VTlRJTkc6IFwidGhhaUNvdW50aW5nXCIsXG4gIEJBSFRfVEVYVDogXCJiYWh0VGV4dFwiLFxuICBET0xMQVJfVEVYVDogXCJkb2xsYXJUZXh0XCIsXG4gIENVU1RPTTogXCJjdXN0b21cIlxufTtcbmNsYXNzIExldmVsQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgaWx2bDogXCJ3OmlsdmxcIixcbiAgICAgIHRlbnRhdGl2ZTogXCJ3MTU6dGVudGF0aXZlXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTnVtYmVyRm9ybWF0IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcInc6bnVtRm10XCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIExldmVsVGV4dCBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoXCJ3Omx2bFRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQXR0cmlidXRlcyh7XG4gICAgICAgIHZhbDogdmFsdWVcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgTGV2ZWxKYyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoXCJ3Omx2bEpjXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNvbnN0IExldmVsU3VmZml4ID0ge1xuICBOT1RISU5HOiBcIm5vdGhpbmdcIixcbiAgU1BBQ0U6IFwic3BhY2VcIixcbiAgVEFCOiBcInRhYlwiXG59O1xuY2xhc3MgU3VmZml4IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcInc6c3VmZlwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBJc0xlZ2FsTnVtYmVyaW5nU3R5bGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6aXNMZ2xcIik7XG4gIH1cbn1cbmNsYXNzIExldmVsQmFzZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBsZXZlbCxcbiAgICBmb3JtYXQsXG4gICAgdGV4dCxcbiAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLlNUQVJULFxuICAgIHN0YXJ0ID0gMSxcbiAgICBzdHlsZSxcbiAgICBzdWZmaXgsXG4gICAgaXNMZWdhbE51bWJlcmluZ1N0eWxlXG4gIH0pIHtcbiAgICBzdXBlcihcInc6bHZsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJhZ3JhcGhQcm9wZXJ0aWVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJydW5Qcm9wZXJ0aWVzXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOdW1iZXJWYWx1ZUVsZW1lbnQoXCJ3OnN0YXJ0XCIsIGRlY2ltYWxOdW1iZXIoc3RhcnQpKSk7XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE51bWJlckZvcm1hdChmb3JtYXQpKTtcbiAgICB9XG4gICAgaWYgKHN1ZmZpeCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN1ZmZpeChzdWZmaXgpKTtcbiAgICB9XG4gICAgaWYgKGlzTGVnYWxOdW1iZXJpbmdTdHlsZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IElzTGVnYWxOdW1iZXJpbmdTdHlsZSgpKTtcbiAgICB9XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBMZXZlbFRleHQodGV4dCkpO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTGV2ZWxKYyhhbGlnbm1lbnQpKTtcbiAgICB0aGlzLnBhcmFncmFwaFByb3BlcnRpZXMgPSBuZXcgUGFyYWdyYXBoUHJvcGVydGllcyhzdHlsZSAmJiBzdHlsZS5wYXJhZ3JhcGgpO1xuICAgIHRoaXMucnVuUHJvcGVydGllcyA9IG5ldyBSdW5Qcm9wZXJ0aWVzKHN0eWxlICYmIHN0eWxlLnJ1bik7XG4gICAgdGhpcy5yb290LnB1c2godGhpcy5wYXJhZ3JhcGhQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLnJvb3QucHVzaCh0aGlzLnJ1blByb3BlcnRpZXMpO1xuICAgIGlmIChsZXZlbCA+IDkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJMZXZlbCBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuIDkuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL2Fuc3dlcnMubWljcm9zb2Z0LmNvbS9lbi11cy9tc29mZmljZS9mb3J1bS9hbGwvZG9lcy13b3JkLXN1cHBvcnQtbW9yZS10aGFuLTktbGlzdC1sZXZlbHMvZDEzMGZkY2QtMTc4MS00NDZkLThjODQtYzZjNzkxMjRlNGQ3XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IExldmVsQXR0cmlidXRlcyh7XG4gICAgICAgIGlsdmw6IGRlY2ltYWxOdW1iZXIobGV2ZWwpLFxuICAgICAgICB0ZW50YXRpdmU6IDFcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgTGV2ZWwgZXh0ZW5kcyBMZXZlbEJhc2Uge1xuICAvLyBUaGlzIGlzIHRoZSBsZXZlbCB0aGF0IHNpdHMgdW5kZXIgYWJzdHJhY3ROdW0uIFdlIG1ha2UgYVxuICAvLyBoYW5kZnVsIG9mIHByb3BlcnRpZXMgcmVxdWlyZWRcbn1cbmNsYXNzIExldmVsRm9yT3ZlcnJpZGUgZXh0ZW5kcyBMZXZlbEJhc2Uge1xufVxuY2xhc3MgTXVsdGlMZXZlbFR5cGUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzptdWx0aUxldmVsVHlwZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBBdHRyaWJ1dGVzKHtcbiAgICAgICAgdmFsOiB2YWx1ZVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5jbGFzcyBBYnN0cmFjdE51bWJlcmluZ0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGFic3RyYWN0TnVtSWQ6IFwidzphYnN0cmFjdE51bUlkXCIsXG4gICAgICByZXN0YXJ0TnVtYmVyaW5nQWZ0ZXJCcmVhazogXCJ3MTU6cmVzdGFydE51bWJlcmluZ0FmdGVyQnJlYWtcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBBYnN0cmFjdE51bWJlcmluZyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGlkLCBsZXZlbE9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6YWJzdHJhY3ROdW1cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlkXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEFic3RyYWN0TnVtYmVyaW5nQXR0cmlidXRlcyh7XG4gICAgICAgIGFic3RyYWN0TnVtSWQ6IGRlY2ltYWxOdW1iZXIoaWQpLFxuICAgICAgICByZXN0YXJ0TnVtYmVyaW5nQWZ0ZXJCcmVhazogMFxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBNdWx0aUxldmVsVHlwZShcImh5YnJpZE11bHRpbGV2ZWxcIikpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBsZXZlbE9wdGlvbnMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBMZXZlbChvcHRpb24pKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFic3RyYWN0TnVtSWQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzphYnN0cmFjdE51bUlkXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEF0dHJpYnV0ZXMoe1xuICAgICAgICB2YWw6IHZhbHVlXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE51bUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgbnVtSWQ6IFwidzpudW1JZFwiIH0pO1xuICB9XG59XG5jbGFzcyBDb25jcmV0ZU51bWJlcmluZyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6bnVtXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJudW1JZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmZXJlbmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbnN0YW5jZVwiKTtcbiAgICB0aGlzLm51bUlkID0gb3B0aW9ucy5udW1JZDtcbiAgICB0aGlzLnJlZmVyZW5jZSA9IG9wdGlvbnMucmVmZXJlbmNlO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBvcHRpb25zLmluc3RhbmNlO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IE51bUF0dHJpYnV0ZXMoe1xuICAgICAgICBudW1JZDogZGVjaW1hbE51bWJlcihvcHRpb25zLm51bUlkKVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBBYnN0cmFjdE51bUlkKGRlY2ltYWxOdW1iZXIob3B0aW9ucy5hYnN0cmFjdE51bUlkKSkpO1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlTGV2ZWxzICYmIG9wdGlvbnMub3ZlcnJpZGVMZXZlbHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxldmVsIG9mIG9wdGlvbnMub3ZlcnJpZGVMZXZlbHMpIHtcbiAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IExldmVsT3ZlcnJpZGUobGV2ZWwubnVtLCBsZXZlbC5zdGFydCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgTGV2ZWxPdmVycmlkZUF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgaWx2bDogXCJ3OmlsdmxcIiB9KTtcbiAgfVxufVxuY2xhc3MgTGV2ZWxPdmVycmlkZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGxldmVsTnVtLCBzdGFydCkge1xuICAgIHN1cGVyKFwidzpsdmxPdmVycmlkZVwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgTGV2ZWxPdmVycmlkZUF0dHJpYnV0ZXMoeyBpbHZsOiBsZXZlbE51bSB9KSk7XG4gICAgaWYgKHN0YXJ0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdGFydE92ZXJyaWRlKHN0YXJ0KSk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBTdGFydE92ZXJyaWRlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwgeyB2YWw6IFwidzp2YWxcIiB9KTtcbiAgfVxufVxuY2xhc3MgU3RhcnRPdmVycmlkZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0KSB7XG4gICAgc3VwZXIoXCJ3OnN0YXJ0T3ZlcnJpZGVcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFN0YXJ0T3ZlcnJpZGVBdHRyaWJ1dGVzKHsgdmFsOiBzdGFydCB9KSk7XG4gIH1cbn1cbmNsYXNzIE51bWJlcmluZyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6bnVtYmVyaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhYnN0cmFjdE51bWJlcmluZ01hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uY3JldGVOdW1iZXJpbmdNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVmZXJlbmNlQ29uZmlnTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhYnN0cmFjdE51bVVuaXF1ZU51bWVyaWNJZFwiLCBhYnN0cmFjdE51bVVuaXF1ZU51bWVyaWNJZEdlbigpKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uY3JldGVOdW1VbmlxdWVOdW1lcmljSWRcIiwgY29uY3JldGVOdW1VbmlxdWVOdW1lcmljSWRHZW4oKSk7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgRG9jdW1lbnRBdHRyaWJ1dGVzKFxuICAgICAgICBbXCJ3cGNcIiwgXCJtY1wiLCBcIm9cIiwgXCJyXCIsIFwibVwiLCBcInZcIiwgXCJ3cDE0XCIsIFwid3BcIiwgXCJ3MTBcIiwgXCJ3XCIsIFwidzE0XCIsIFwidzE1XCIsIFwid3BnXCIsIFwid3BpXCIsIFwid25lXCIsIFwid3BzXCJdLFxuICAgICAgICBcIncxNCB3MTUgd3AxNFwiXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBhYnN0cmFjdE51bWJlcmluZyA9IG5ldyBBYnN0cmFjdE51bWJlcmluZyh0aGlzLmFic3RyYWN0TnVtVW5pcXVlTnVtZXJpY0lkKCksIFtcbiAgICAgIHtcbiAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgIGZvcm1hdDogTGV2ZWxGb3JtYXQuQlVMTEVULFxuICAgICAgICB0ZXh0OiBcIuKXj1wiLFxuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuTEVGVCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuNSksIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIGZvcm1hdDogTGV2ZWxGb3JtYXQuQlVMTEVULFxuICAgICAgICB0ZXh0OiBcIuKXi1wiLFxuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuTEVGVCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDEpLCBoYW5naW5nOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuMjUpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxldmVsOiAyLFxuICAgICAgICBmb3JtYXQ6IExldmVsRm9ybWF0LkJVTExFVCxcbiAgICAgICAgdGV4dDogXCLilqBcIixcbiAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkxFRlQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICBpbmRlbnQ6IHsgbGVmdDogMjE2MCwgaGFuZ2luZzogY29udmVydEluY2hlc1RvVHdpcCgwLjI1KSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsZXZlbDogMyxcbiAgICAgICAgZm9ybWF0OiBMZXZlbEZvcm1hdC5CVUxMRVQsXG4gICAgICAgIHRleHQ6IFwi4pePXCIsXG4gICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5MRUZULFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgaW5kZW50OiB7IGxlZnQ6IDI4ODAsIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGV2ZWw6IDQsXG4gICAgICAgIGZvcm1hdDogTGV2ZWxGb3JtYXQuQlVMTEVULFxuICAgICAgICB0ZXh0OiBcIuKXi1wiLFxuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuTEVGVCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiAzNjAwLCBoYW5naW5nOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuMjUpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxldmVsOiA1LFxuICAgICAgICBmb3JtYXQ6IExldmVsRm9ybWF0LkJVTExFVCxcbiAgICAgICAgdGV4dDogXCLilqBcIixcbiAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkxFRlQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICBpbmRlbnQ6IHsgbGVmdDogNDMyMCwgaGFuZ2luZzogY29udmVydEluY2hlc1RvVHdpcCgwLjI1KSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsZXZlbDogNixcbiAgICAgICAgZm9ybWF0OiBMZXZlbEZvcm1hdC5CVUxMRVQsXG4gICAgICAgIHRleHQ6IFwi4pePXCIsXG4gICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5MRUZULFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgaW5kZW50OiB7IGxlZnQ6IDUwNDAsIGhhbmdpbmc6IGNvbnZlcnRJbmNoZXNUb1R3aXAoMC4yNSkgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbGV2ZWw6IDcsXG4gICAgICAgIGZvcm1hdDogTGV2ZWxGb3JtYXQuQlVMTEVULFxuICAgICAgICB0ZXh0OiBcIuKXj1wiLFxuICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuTEVGVCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiA1NzYwLCBoYW5naW5nOiBjb252ZXJ0SW5jaGVzVG9Ud2lwKDAuMjUpIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxldmVsOiA4LFxuICAgICAgICBmb3JtYXQ6IExldmVsRm9ybWF0LkJVTExFVCxcbiAgICAgICAgdGV4dDogXCLil49cIixcbiAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkxFRlQsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICBpbmRlbnQ6IHsgbGVmdDogNjQ4MCwgaGFuZ2luZzogY29udmVydEluY2hlc1RvVHdpcCgwLjI1KSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5jb25jcmV0ZU51bWJlcmluZ01hcC5zZXQoXG4gICAgICBcImRlZmF1bHQtYnVsbGV0LW51bWJlcmluZ1wiLFxuICAgICAgbmV3IENvbmNyZXRlTnVtYmVyaW5nKHtcbiAgICAgICAgbnVtSWQ6IDEsXG4gICAgICAgIGFic3RyYWN0TnVtSWQ6IGFic3RyYWN0TnVtYmVyaW5nLmlkLFxuICAgICAgICByZWZlcmVuY2U6IFwiZGVmYXVsdC1idWxsZXQtbnVtYmVyaW5nXCIsXG4gICAgICAgIGluc3RhbmNlOiAwLFxuICAgICAgICBvdmVycmlkZUxldmVsczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG51bTogMCxcbiAgICAgICAgICAgIHN0YXJ0OiAxXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5hYnN0cmFjdE51bWJlcmluZ01hcC5zZXQoXCJkZWZhdWx0LWJ1bGxldC1udW1iZXJpbmdcIiwgYWJzdHJhY3ROdW1iZXJpbmcpO1xuICAgIGZvciAoY29uc3QgY29uIG9mIG9wdGlvbnMuY29uZmlnKSB7XG4gICAgICB0aGlzLmFic3RyYWN0TnVtYmVyaW5nTWFwLnNldChjb24ucmVmZXJlbmNlLCBuZXcgQWJzdHJhY3ROdW1iZXJpbmcodGhpcy5hYnN0cmFjdE51bVVuaXF1ZU51bWVyaWNJZCgpLCBjb24ubGV2ZWxzKSk7XG4gICAgICB0aGlzLnJlZmVyZW5jZUNvbmZpZ01hcC5zZXQoY29uLnJlZmVyZW5jZSwgY29uLmxldmVscyk7XG4gICAgfVxuICB9XG4gIHByZXBGb3JYbWwoY29udGV4dCkge1xuICAgIGZvciAoY29uc3QgbnVtYmVyaW5nIG9mIHRoaXMuYWJzdHJhY3ROdW1iZXJpbmdNYXAudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG51bWJlcmluZyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbnVtYmVyaW5nIG9mIHRoaXMuY29uY3JldGVOdW1iZXJpbmdNYXAudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG51bWJlcmluZyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wcmVwRm9yWG1sKGNvbnRleHQpO1xuICB9XG4gIGNyZWF0ZUNvbmNyZXRlTnVtYmVyaW5nSW5zdGFuY2UocmVmZXJlbmNlLCBpbnN0YW5jZSkge1xuICAgIGNvbnN0IGFic3RyYWN0TnVtYmVyaW5nID0gdGhpcy5hYnN0cmFjdE51bWJlcmluZ01hcC5nZXQocmVmZXJlbmNlKTtcbiAgICBpZiAoIWFic3RyYWN0TnVtYmVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZ1bGxSZWZlcmVuY2UgPSBgJHtyZWZlcmVuY2V9LSR7aW5zdGFuY2V9YDtcbiAgICBpZiAodGhpcy5jb25jcmV0ZU51bWJlcmluZ01hcC5oYXMoZnVsbFJlZmVyZW5jZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVmZXJlbmNlQ29uZmlnTGV2ZWxzID0gdGhpcy5yZWZlcmVuY2VDb25maWdNYXAuZ2V0KHJlZmVyZW5jZSk7XG4gICAgY29uc3QgZmlyc3RMZXZlbFN0YXJ0TnVtYmVyID0gcmVmZXJlbmNlQ29uZmlnTGV2ZWxzICYmIHJlZmVyZW5jZUNvbmZpZ0xldmVsc1swXS5zdGFydDtcbiAgICBjb25zdCBjb25jcmV0ZU51bWJlcmluZ1NldHRpbmdzID0ge1xuICAgICAgbnVtSWQ6IHRoaXMuY29uY3JldGVOdW1VbmlxdWVOdW1lcmljSWQoKSxcbiAgICAgIGFic3RyYWN0TnVtSWQ6IGFic3RyYWN0TnVtYmVyaW5nLmlkLFxuICAgICAgcmVmZXJlbmNlLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICBvdmVycmlkZUxldmVsczogW1xuICAgICAgICBmaXJzdExldmVsU3RhcnROdW1iZXIgJiYgTnVtYmVyLmlzSW50ZWdlcihmaXJzdExldmVsU3RhcnROdW1iZXIpID8ge1xuICAgICAgICAgIG51bTogMCxcbiAgICAgICAgICBzdGFydDogZmlyc3RMZXZlbFN0YXJ0TnVtYmVyXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgbnVtOiAwLFxuICAgICAgICAgIHN0YXJ0OiAxXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHRoaXMuY29uY3JldGVOdW1iZXJpbmdNYXAuc2V0KGZ1bGxSZWZlcmVuY2UsIG5ldyBDb25jcmV0ZU51bWJlcmluZyhjb25jcmV0ZU51bWJlcmluZ1NldHRpbmdzKSk7XG4gIH1cbiAgZ2V0IENvbmNyZXRlTnVtYmVyaW5nKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29uY3JldGVOdW1iZXJpbmdNYXAudmFsdWVzKCkpO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGdldCBSZWZlcmVuY2VDb25maWcoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWZlcmVuY2VDb25maWdNYXAudmFsdWVzKCkpO1xuICB9XG59XG5jbGFzcyBDb21wYXRpYmlsaXR5U2V0dGluZ0F0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIHZlcnNpb246IFwidzp2YWxcIixcbiAgICAgIG5hbWU6IFwidzpuYW1lXCIsXG4gICAgICB1cmk6IFwidzp1cmlcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDb21wYXRpYmlsaXR5U2V0dGluZyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcbiAgICBzdXBlcihcInc6Y29tcGF0U2V0dGluZ1wiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBDb21wYXRpYmlsaXR5U2V0dGluZ0F0dHJpYnV0ZXMoe1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICB1cmk6IFwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvd29yZFwiLFxuICAgICAgICBuYW1lOiBcImNvbXBhdGliaWxpdHlNb2RlXCJcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgQ29tcGF0aWJpbGl0eSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6Y29tcGF0XCIpO1xuICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDb21wYXRpYmlsaXR5U2V0dGluZyhvcHRpb25zLnZlcnNpb24pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXNlU2luZ2xlQm9yZGVyZm9yQ29udGlndW91c0NlbGxzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp1c2VTaW5nbGVCb3JkZXJmb3JDb250aWd1b3VzQ2VsbHNcIiwgb3B0aW9ucy51c2VTaW5nbGVCb3JkZXJmb3JDb250aWd1b3VzQ2VsbHMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud29yZFBlcmZlY3RKdXN0aWZpY2F0aW9uKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp3cEp1c3RpZmljYXRpb25cIiwgb3B0aW9ucy53b3JkUGVyZmVjdEp1c3RpZmljYXRpb24pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubm9UYWJTdG9wRm9ySGFuZ2luZ0luZGVudCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bm9UYWJIYW5nSW5kXCIsIG9wdGlvbnMubm9UYWJTdG9wRm9ySGFuZ2luZ0luZGVudCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub0xlYWRpbmcpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3Om5vTGVhZGluZ1wiLCBvcHRpb25zLm5vTGVhZGluZykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGFjZUZvclVuZGVybGluZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3BhY2VGb3JVTFwiLCBvcHRpb25zLnNwYWNlRm9yVW5kZXJsaW5lKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5vQ29sdW1uQmFsYW5jZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bm9Db2x1bW5CYWxhbmNlXCIsIG9wdGlvbnMubm9Db2x1bW5CYWxhbmNlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJhbGFuY2VTaW5nbGVCeXRlRG91YmxlQnl0ZVdpZHRoKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpiYWxhbmNlU2luZ2xlQnl0ZURvdWJsZUJ5dGVXaWR0aFwiLCBvcHRpb25zLmJhbGFuY2VTaW5nbGVCeXRlRG91YmxlQnl0ZVdpZHRoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5vRXh0cmFMaW5lU3BhY2luZykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bm9FeHRyYUxpbmVTcGFjaW5nXCIsIG9wdGlvbnMubm9FeHRyYUxpbmVTcGFjaW5nKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvTm90TGVhdmVCYWNrc2xhc2hBbG9uZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RMZWF2ZUJhY2tzbGFzaEFsb25lXCIsIG9wdGlvbnMuZG9Ob3RMZWF2ZUJhY2tzbGFzaEFsb25lKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuZGVybGluZVRyYWlsaW5nU3BhY2VzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp1bFRyYWlsU3BhY2VcIiwgb3B0aW9ucy51bmRlcmxpbmVUcmFpbGluZ1NwYWNlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdEV4cGFuZFNoaWZ0UmV0dXJuKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpkb05vdEV4cGFuZFNoaWZ0UmV0dXJuXCIsIG9wdGlvbnMuZG9Ob3RFeHBhbmRTaGlmdFJldHVybikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGFjaW5nSW5XaG9sZVBvaW50cykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3BhY2luZ0luV2hvbGVQb2ludHNcIiwgb3B0aW9ucy5zcGFjaW5nSW5XaG9sZVBvaW50cykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW5lV3JhcExpa2VXb3JkNikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bGluZVdyYXBMaWtlV29yZDZcIiwgb3B0aW9ucy5saW5lV3JhcExpa2VXb3JkNikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmludEJvZHlUZXh0QmVmb3JlSGVhZGVyKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpwcmludEJvZHlUZXh0QmVmb3JlSGVhZGVyXCIsIG9wdGlvbnMucHJpbnRCb2R5VGV4dEJlZm9yZUhlYWRlcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmludENvbG9yc0JsYWNrKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpwcmludENvbEJsYWNrXCIsIG9wdGlvbnMucHJpbnRDb2xvcnNCbGFjaykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGFjZVdpZHRoKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp3cFNwYWNlV2lkdGhcIiwgb3B0aW9ucy5zcGFjZVdpZHRoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNob3dCcmVha3NJbkZyYW1lcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c2hvd0JyZWFrc0luRnJhbWVzXCIsIG9wdGlvbnMuc2hvd0JyZWFrc0luRnJhbWVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1YkZvbnRCeVNpemUpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnN1YkZvbnRCeVNpemVcIiwgb3B0aW9ucy5zdWJGb250QnlTaXplKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cHByZXNzQm90dG9tU3BhY2luZykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3VwcHJlc3NCb3R0b21TcGFjaW5nXCIsIG9wdGlvbnMuc3VwcHJlc3NCb3R0b21TcGFjaW5nKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cHByZXNzVG9wU3BhY2luZykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3VwcHJlc3NUb3BTcGFjaW5nXCIsIG9wdGlvbnMuc3VwcHJlc3NUb3BTcGFjaW5nKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cHByZXNzU3BhY2luZ0F0VG9wT2ZQYWdlKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpzdXBwcmVzc1NwYWNpbmdBdFRvcE9mUGFnZVwiLCBvcHRpb25zLnN1cHByZXNzU3BhY2luZ0F0VG9wT2ZQYWdlKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cHByZXNzVG9wU3BhY2luZ1dQKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpzdXBwcmVzc1RvcFNwYWNpbmdXUFwiLCBvcHRpb25zLnN1cHByZXNzVG9wU3BhY2luZ1dQKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN1cHByZXNzU3BCZkFmdGVyUGdCcmspIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnN1cHByZXNzU3BCZkFmdGVyUGdCcmtcIiwgb3B0aW9ucy5zdXBwcmVzc1NwQmZBZnRlclBnQnJrKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN3YXBCb3JkZXJzRmFjaW5nUGFnZXMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnN3YXBCb3JkZXJzRmFjaW5nUGFnZXNcIiwgb3B0aW9ucy5zd2FwQm9yZGVyc0ZhY2luZ1BhZ2VzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvbnZlcnRNYWlsTWVyZ2VFc2MpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmNvbnZNYWlsTWVyZ2VFc2NcIiwgb3B0aW9ucy5jb252ZXJ0TWFpbE1lcmdlRXNjKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRydW5jYXRlRm9udEhlaWdodHNMaWtlV1A2KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp0cnVuY2F0ZUZvbnRIZWlnaHRzTGlrZVdQNlwiLCBvcHRpb25zLnRydW5jYXRlRm9udEhlaWdodHNMaWtlV1A2KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1hY1dvcmRTbWFsbENhcHMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3Om13U21hbGxDYXBzXCIsIG9wdGlvbnMubWFjV29yZFNtYWxsQ2FwcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VQcmludGVyTWV0cmljcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dXNlUHJpbnRlck1ldHJpY3NcIiwgb3B0aW9ucy51c2VQcmludGVyTWV0cmljcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdFN1cHByZXNzUGFyYWdyYXBoQm9yZGVycykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RTdXBwcmVzc1BhcmFncmFwaEJvcmRlcnNcIiwgb3B0aW9ucy5kb05vdFN1cHByZXNzUGFyYWdyYXBoQm9yZGVycykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53cmFwVHJhaWxTcGFjZXMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OndyYXBUcmFpbFNwYWNlc1wiLCBvcHRpb25zLndyYXBUcmFpbFNwYWNlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb290bm90ZUxheW91dExpa2VXVzgpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmZvb3Rub3RlTGF5b3V0TGlrZVdXOFwiLCBvcHRpb25zLmZvb3Rub3RlTGF5b3V0TGlrZVdXOCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaGFwZUxheW91dExpa2VXVzgpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnNoYXBlTGF5b3V0TGlrZVdXOFwiLCBvcHRpb25zLnNoYXBlTGF5b3V0TGlrZVdXOCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGlnblRhYmxlc1Jvd0J5Um93KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphbGlnblRhYmxlc1Jvd0J5Um93XCIsIG9wdGlvbnMuYWxpZ25UYWJsZXNSb3dCeVJvdykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb3JnZXRMYXN0VGFiQWxpZ25tZW50KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpmb3JnZXRMYXN0VGFiQWxpZ25tZW50XCIsIG9wdGlvbnMuZm9yZ2V0TGFzdFRhYkFsaWdubWVudCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hZGp1c3RMaW5lSGVpZ2h0SW5UYWJsZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6YWRqdXN0TGluZUhlaWdodEluVGFibGVcIiwgb3B0aW9ucy5hZGp1c3RMaW5lSGVpZ2h0SW5UYWJsZSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdXRvU3BhY2VMaWtlV29yZDk1KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphdXRvU3BhY2VMaWtlV29yZDk1XCIsIG9wdGlvbnMuYXV0b1NwYWNlTGlrZVdvcmQ5NSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ub1NwYWNlUmFpc2VMb3dlcikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bm9TcGFjZVJhaXNlTG93ZXJcIiwgb3B0aW9ucy5ub1NwYWNlUmFpc2VMb3dlcikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdFVzZUhUTUxQYXJhZ3JhcGhBdXRvU3BhY2luZykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RVc2VIVE1MUGFyYWdyYXBoQXV0b1NwYWNpbmdcIiwgb3B0aW9ucy5kb05vdFVzZUhUTUxQYXJhZ3JhcGhBdXRvU3BhY2luZykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYXlvdXRSYXdUYWJsZVdpZHRoKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpsYXlvdXRSYXdUYWJsZVdpZHRoXCIsIG9wdGlvbnMubGF5b3V0UmF3VGFibGVXaWR0aCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sYXlvdXRUYWJsZVJvd3NBcGFydCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6bGF5b3V0VGFibGVSb3dzQXBhcnRcIiwgb3B0aW9ucy5sYXlvdXRUYWJsZVJvd3NBcGFydCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51c2VXb3JkOTdMaW5lQnJlYWtSdWxlcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dXNlV29yZDk3TGluZUJyZWFrUnVsZXNcIiwgb3B0aW9ucy51c2VXb3JkOTdMaW5lQnJlYWtSdWxlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdEJyZWFrV3JhcHBlZFRhYmxlcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RCcmVha1dyYXBwZWRUYWJsZXNcIiwgb3B0aW9ucy5kb05vdEJyZWFrV3JhcHBlZFRhYmxlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdFNuYXBUb0dyaWRJbkNlbGwpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmRvTm90U25hcFRvR3JpZEluQ2VsbFwiLCBvcHRpb25zLmRvTm90U25hcFRvR3JpZEluQ2VsbCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZWxlY3RGaWVsZFdpdGhGaXJzdE9yTGFzdENoYXJhY3Rlcikge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c2VsZWN0RmxkV2l0aEZpcnN0T3JMYXN0Q2hhclwiLCBvcHRpb25zLnNlbGVjdEZpZWxkV2l0aEZpcnN0T3JMYXN0Q2hhcmFjdGVyKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFwcGx5QnJlYWtpbmdSdWxlcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6YXBwbHlCcmVha2luZ1J1bGVzXCIsIG9wdGlvbnMuYXBwbHlCcmVha2luZ1J1bGVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvTm90V3JhcFRleHRXaXRoUHVuY3R1YXRpb24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmRvTm90V3JhcFRleHRXaXRoUHVuY3RcIiwgb3B0aW9ucy5kb05vdFdyYXBUZXh0V2l0aFB1bmN0dWF0aW9uKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvTm90VXNlRWFzdEFzaWFuQnJlYWtSdWxlcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RVc2VFYXN0QXNpYW5CcmVha1J1bGVzXCIsIG9wdGlvbnMuZG9Ob3RVc2VFYXN0QXNpYW5CcmVha1J1bGVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZVdvcmQyMDAyVGFibGVTdHlsZVJ1bGVzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp1c2VXb3JkMjAwMlRhYmxlU3R5bGVSdWxlc1wiLCBvcHRpb25zLnVzZVdvcmQyMDAyVGFibGVTdHlsZVJ1bGVzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdyb3dBdXRvZml0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpncm93QXV0b2ZpdFwiLCBvcHRpb25zLmdyb3dBdXRvZml0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZUZFTGF5b3V0KSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp1c2VGRUxheW91dFwiLCBvcHRpb25zLnVzZUZFTGF5b3V0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZU5vcm1hbFN0eWxlRm9yTGlzdCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dXNlTm9ybWFsU3R5bGVGb3JMaXN0XCIsIG9wdGlvbnMudXNlTm9ybWFsU3R5bGVGb3JMaXN0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvTm90VXNlSW5kZW50QXNOdW1iZXJpbmdUYWJTdG9wKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpkb05vdFVzZUluZGVudEFzTnVtYmVyaW5nVGFiU3RvcFwiLCBvcHRpb25zLmRvTm90VXNlSW5kZW50QXNOdW1iZXJpbmdUYWJTdG9wKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVzZUFsdGVybmF0ZUVhc3RBc2lhbkxpbmVCcmVha1J1bGVzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzp1c2VBbHRLaW5zb2t1TGluZUJyZWFrUnVsZXNcIiwgb3B0aW9ucy51c2VBbHRlcm5hdGVFYXN0QXNpYW5MaW5lQnJlYWtSdWxlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd1NwYWNlT2ZTYW1lU3R5bGVJblRhYmxlKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphbGxvd1NwYWNlT2ZTYW1lU3R5bGVJblRhYmxlXCIsIG9wdGlvbnMuYWxsb3dTcGFjZU9mU2FtZVN0eWxlSW5UYWJsZSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdFN1cHByZXNzSW5kZW50YXRpb24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmRvTm90U3VwcHJlc3NJbmRlbnRhdGlvblwiLCBvcHRpb25zLmRvTm90U3VwcHJlc3NJbmRlbnRhdGlvbikpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdEF1dG9maXRDb25zdHJhaW5lZFRhYmxlcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RBdXRvZml0Q29uc3RyYWluZWRUYWJsZXNcIiwgb3B0aW9ucy5kb05vdEF1dG9maXRDb25zdHJhaW5lZFRhYmxlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdXRvZml0VG9GaXJzdEZpeGVkV2lkdGhDZWxsKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphdXRvZml0VG9GaXJzdEZpeGVkV2lkdGhDZWxsXCIsIG9wdGlvbnMuYXV0b2ZpdFRvRmlyc3RGaXhlZFdpZHRoQ2VsbCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51bmRlcmxpbmVUYWJJbk51bWJlcmluZ0xpc3QpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnVuZGVybGluZVRhYkluTnVtTGlzdFwiLCBvcHRpb25zLnVuZGVybGluZVRhYkluTnVtYmVyaW5nTGlzdCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5SGFuZ3VsRml4ZWRXaWR0aCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZGlzcGxheUhhbmd1bEZpeGVkV2lkdGhcIiwgb3B0aW9ucy5kaXNwbGF5SGFuZ3VsRml4ZWRXaWR0aCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcGxpdFBnQnJlYWtBbmRQYXJhTWFyaykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c3BsaXRQZ0JyZWFrQW5kUGFyYU1hcmtcIiwgb3B0aW9ucy5zcGxpdFBnQnJlYWtBbmRQYXJhTWFyaykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdFZlcnRpY2FsbHlBbGlnbkNlbGxXaXRoU3ApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmRvTm90VmVydEFsaWduQ2VsbFdpdGhTcFwiLCBvcHRpb25zLmRvTm90VmVydGljYWxseUFsaWduQ2VsbFdpdGhTcCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb05vdEJyZWFrQ29uc3RyYWluZWRGb3JjZWRUYWJsZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZG9Ob3RCcmVha0NvbnN0cmFpbmVkRm9yY2VkVGFibGVcIiwgb3B0aW9ucy5kb05vdEJyZWFrQ29uc3RyYWluZWRGb3JjZWRUYWJsZSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pZ25vcmVWZXJ0aWNhbEFsaWdubWVudEluVGV4dGJveGVzKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpkb05vdFZlcnRBbGlnbkluVHhieFwiLCBvcHRpb25zLmlnbm9yZVZlcnRpY2FsQWxpZ25tZW50SW5UZXh0Ym94ZXMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXNlQW5zaUtlcm5pbmdQYWlycykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dXNlQW5zaUtlcm5pbmdQYWlyc1wiLCBvcHRpb25zLnVzZUFuc2lLZXJuaW5nUGFpcnMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2FjaGVkQ29sdW1uQmFsYW5jZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6Y2FjaGVkQ29sQmFsYW5jZVwiLCBvcHRpb25zLmNhY2hlZENvbHVtbkJhbGFuY2UpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFNldHRpbmdzQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgd3BjOiBcInhtbG5zOndwY1wiLFxuICAgICAgbWM6IFwieG1sbnM6bWNcIixcbiAgICAgIG86IFwieG1sbnM6b1wiLFxuICAgICAgcjogXCJ4bWxuczpyXCIsXG4gICAgICBtOiBcInhtbG5zOm1cIixcbiAgICAgIHY6IFwieG1sbnM6dlwiLFxuICAgICAgd3AxNDogXCJ4bWxuczp3cDE0XCIsXG4gICAgICB3cDogXCJ4bWxuczp3cFwiLFxuICAgICAgdzEwOiBcInhtbG5zOncxMFwiLFxuICAgICAgdzogXCJ4bWxuczp3XCIsXG4gICAgICB3MTQ6IFwieG1sbnM6dzE0XCIsXG4gICAgICB3MTU6IFwieG1sbnM6dzE1XCIsXG4gICAgICB3cGc6IFwieG1sbnM6d3BnXCIsXG4gICAgICB3cGk6IFwieG1sbnM6d3BpXCIsXG4gICAgICB3bmU6IFwieG1sbnM6d25lXCIsXG4gICAgICB3cHM6IFwieG1sbnM6d3BzXCIsXG4gICAgICBJZ25vcmFibGU6IFwibWM6SWdub3JhYmxlXCJcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICBzdXBlcihcInc6c2V0dGluZ3NcIik7XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgU2V0dGluZ3NBdHRyaWJ1dGVzKHtcbiAgICAgICAgd3BjOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0NhbnZhc1wiLFxuICAgICAgICBtYzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiLFxuICAgICAgICBvOiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOm9mZmljZVwiLFxuICAgICAgICByOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHNcIixcbiAgICAgICAgbTogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9tYXRoXCIsXG4gICAgICAgIHY6IFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWxcIixcbiAgICAgICAgd3AxNDogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdEcmF3aW5nXCIsXG4gICAgICAgIHdwOiBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9kcmF3aW5nbWwvMjAwNi93b3JkcHJvY2Vzc2luZ0RyYXdpbmdcIixcbiAgICAgICAgdzEwOiBcInVybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206b2ZmaWNlOndvcmRcIixcbiAgICAgICAgdzogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvd29yZHByb2Nlc3NpbmdtbC8yMDA2L21haW5cIixcbiAgICAgICAgdzE0OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkbWxcIixcbiAgICAgICAgdzE1OiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMi93b3JkbWxcIixcbiAgICAgICAgd3BnOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ0dyb3VwXCIsXG4gICAgICAgIHdwaTogXCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS93b3JkLzIwMTAvd29yZHByb2Nlc3NpbmdJbmtcIixcbiAgICAgICAgd25lOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAwNi93b3JkbWxcIixcbiAgICAgICAgd3BzOiBcImh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3dvcmQvMjAxMC93b3JkcHJvY2Vzc2luZ1NoYXBlXCIsXG4gICAgICAgIElnbm9yYWJsZTogXCJ3MTQgdzE1IHdwMTRcIlxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OmRpc3BsYXlCYWNrZ3JvdW5kU2hhcGVcIiwgdHJ1ZSkpO1xuICAgIGlmIChvcHRpb25zLnRyYWNrUmV2aXNpb25zICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBPbk9mZkVsZW1lbnQoXCJ3OnRyYWNrUmV2aXNpb25zXCIsIG9wdGlvbnMudHJhY2tSZXZpc2lvbnMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZXZlbkFuZE9kZEhlYWRlcnMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6ZXZlbkFuZE9kZEhlYWRlcnNcIiwgb3B0aW9ucy5ldmVuQW5kT2RkSGVhZGVycykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy51cGRhdGVGaWVsZHMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dXBkYXRlRmllbGRzXCIsIG9wdGlvbnMudXBkYXRlRmllbGRzKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlZmF1bHRUYWJTdG9wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBOdW1iZXJWYWx1ZUVsZW1lbnQoXCJ3OmRlZmF1bHRUYWJTdG9wXCIsIG9wdGlvbnMuZGVmYXVsdFRhYlN0b3ApKTtcbiAgICB9XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zLmh5cGhlbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYXV0b0h5cGhlbmF0aW9uKSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzphdXRvSHlwaGVuYXRpb25cIiwgb3B0aW9ucy5oeXBoZW5hdGlvbi5hdXRvSHlwaGVuYXRpb24pKTtcbiAgICB9XG4gICAgaWYgKCgoX2IgPSBvcHRpb25zLmh5cGhlbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaHlwaGVuYXRpb25ab25lKSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgTnVtYmVyVmFsdWVFbGVtZW50KFwidzpoeXBoZW5hdGlvblpvbmVcIiwgb3B0aW9ucy5oeXBoZW5hdGlvbi5oeXBoZW5hdGlvblpvbmUpKTtcbiAgICB9XG4gICAgaWYgKCgoX2MgPSBvcHRpb25zLmh5cGhlbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY29uc2VjdXRpdmVIeXBoZW5MaW1pdCkgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE51bWJlclZhbHVlRWxlbWVudChcInc6Y29uc2VjdXRpdmVIeXBoZW5MaW1pdFwiLCBvcHRpb25zLmh5cGhlbmF0aW9uLmNvbnNlY3V0aXZlSHlwaGVuTGltaXQpKTtcbiAgICB9XG4gICAgaWYgKCgoX2QgPSBvcHRpb25zLmh5cGhlbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZG9Ob3RIeXBoZW5hdGVDYXBzKSAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpkb05vdEh5cGhlbmF0ZUNhcHNcIiwgb3B0aW9ucy5oeXBoZW5hdGlvbi5kb05vdEh5cGhlbmF0ZUNhcHMpKTtcbiAgICB9XG4gICAgdGhpcy5yb290LnB1c2goXG4gICAgICBuZXcgQ29tcGF0aWJpbGl0eShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCAoX2UgPSBvcHRpb25zLmNvbXBhdGliaWxpdHkpICE9IG51bGwgPyBfZSA6IHt9KSwge1xuICAgICAgICB2ZXJzaW9uOiAoX2ggPSAoX2cgPSAoX2YgPSBvcHRpb25zLmNvbXBhdGliaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBfZi52ZXJzaW9uKSAhPSBudWxsID8gX2cgOiBvcHRpb25zLmNvbXBhdGliaWxpdHlNb2RlVmVyc2lvbikgIT0gbnVsbCA/IF9oIDogMTVcbiAgICAgIH0pKVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIENvbXBvbmVudEF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHsgdmFsOiBcInc6dmFsXCIgfSk7XG4gIH1cbn1cbmNsYXNzIE5hbWUgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzpuYW1lXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDb21wb25lbnRBdHRyaWJ1dGVzKHsgdmFsOiB2YWx1ZSB9KSk7XG4gIH1cbn1cbmNsYXNzIFVpUHJpb3JpdHkgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKFwidzp1aVByaW9yaXR5XCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDb21wb25lbnRBdHRyaWJ1dGVzKHsgdmFsOiBkZWNpbWFsTnVtYmVyKHZhbHVlKSB9KSk7XG4gIH1cbn1cbmNsYXNzIFN0eWxlQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgdHlwZTogXCJ3OnR5cGVcIixcbiAgICAgIHN0eWxlSWQ6IFwidzpzdHlsZUlkXCIsXG4gICAgICBkZWZhdWx0OiBcInc6ZGVmYXVsdFwiLFxuICAgICAgY3VzdG9tU3R5bGU6IFwidzpjdXN0b21TdHlsZVwiXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFN0eWxlMiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6c3R5bGVcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFN0eWxlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSk7XG4gICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE5hbWUob3B0aW9ucy5uYW1lKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJhc2VkT24pIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdHJpbmdWYWx1ZUVsZW1lbnQoXCJ3OmJhc2VkT25cIiwgb3B0aW9ucy5iYXNlZE9uKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5leHQpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdHJpbmdWYWx1ZUVsZW1lbnQoXCJ3Om5leHRcIiwgb3B0aW9ucy5uZXh0KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTdHJpbmdWYWx1ZUVsZW1lbnQoXCJ3OmxpbmtcIiwgb3B0aW9ucy5saW5rKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVpUHJpb3JpdHkgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFVpUHJpb3JpdHkob3B0aW9ucy51aVByaW9yaXR5KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlbWlIaWRkZW4gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6c2VtaUhpZGRlblwiLCBvcHRpb25zLnNlbWlIaWRkZW4pKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudW5oaWRlV2hlblVzZWQgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IE9uT2ZmRWxlbWVudChcInc6dW5oaWRlV2hlblVzZWRcIiwgb3B0aW9ucy51bmhpZGVXaGVuVXNlZCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5xdWlja0Zvcm1hdCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJvb3QucHVzaChuZXcgT25PZmZFbGVtZW50KFwidzpxRm9ybWF0XCIsIG9wdGlvbnMucXVpY2tGb3JtYXQpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFN0eWxlRm9yUGFyYWdyYXBoIGV4dGVuZHMgU3R5bGUyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHsgdHlwZTogXCJwYXJhZ3JhcGhcIiwgc3R5bGVJZDogb3B0aW9ucy5pZCB9LCBvcHRpb25zKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFyYWdyYXBoUHJvcGVydGllc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicnVuUHJvcGVydGllc1wiKTtcbiAgICB0aGlzLnBhcmFncmFwaFByb3BlcnRpZXMgPSBuZXcgUGFyYWdyYXBoUHJvcGVydGllcyhvcHRpb25zLnBhcmFncmFwaCk7XG4gICAgdGhpcy5ydW5Qcm9wZXJ0aWVzID0gbmV3IFJ1blByb3BlcnRpZXMob3B0aW9ucy5ydW4pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucGFyYWdyYXBoUHJvcGVydGllcyk7XG4gICAgdGhpcy5yb290LnB1c2godGhpcy5ydW5Qcm9wZXJ0aWVzKTtcbiAgfVxufVxuY2xhc3MgU3R5bGVGb3JDaGFyYWN0ZXIgZXh0ZW5kcyBTdHlsZTIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXG4gICAgICB7IHR5cGU6IFwiY2hhcmFjdGVyXCIsIHN0eWxlSWQ6IG9wdGlvbnMuaWQgfSxcbiAgICAgIF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdWlQcmlvcml0eTogOTksXG4gICAgICAgIHVuaGlkZVdoZW5Vc2VkOiB0cnVlXG4gICAgICB9LCBvcHRpb25zKVxuICAgICk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJ1blByb3BlcnRpZXNcIik7XG4gICAgdGhpcy5ydW5Qcm9wZXJ0aWVzID0gbmV3IFJ1blByb3BlcnRpZXMob3B0aW9ucy5ydW4pO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucnVuUHJvcGVydGllcyk7XG4gIH1cbn1cbmNsYXNzIEhlYWRpbmdTdHlsZSBleHRlbmRzIFN0eWxlRm9yUGFyYWdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGJhc2VkT246IFwiTm9ybWFsXCIsXG4gICAgICBuZXh0OiBcIk5vcm1hbFwiLFxuICAgICAgcXVpY2tGb3JtYXQ6IHRydWVcbiAgICB9LCBvcHRpb25zKSk7XG4gIH1cbn1cbmNsYXNzIFRpdGxlU3R5bGUgZXh0ZW5kcyBIZWFkaW5nU3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaWQ6IFwiVGl0bGVcIixcbiAgICAgIG5hbWU6IFwiVGl0bGVcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzFTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nMVwiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDFcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzJTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nMlwiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDJcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzNTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nM1wiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDNcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzRTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nNFwiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDRcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzVTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nNVwiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDVcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSGVhZGluZzZTdHlsZSBleHRlbmRzIEhlYWRpbmdTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIZWFkaW5nNlwiLFxuICAgICAgbmFtZTogXCJIZWFkaW5nIDZcIlxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgU3Ryb25nU3R5bGUgZXh0ZW5kcyBIZWFkaW5nU3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaWQ6IFwiU3Ryb25nXCIsXG4gICAgICBuYW1lOiBcIlN0cm9uZ1wiXG4gICAgfSwgb3B0aW9ucykpO1xuICB9XG59XG5jbGFzcyBMaXN0UGFyYWdyYXBoIGV4dGVuZHMgU3R5bGVGb3JQYXJhZ3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaWQ6IFwiTGlzdFBhcmFncmFwaFwiLFxuICAgICAgbmFtZTogXCJMaXN0IFBhcmFncmFwaFwiLFxuICAgICAgYmFzZWRPbjogXCJOb3JtYWxcIixcbiAgICAgIHF1aWNrRm9ybWF0OiB0cnVlXG4gICAgfSwgb3B0aW9ucykpO1xuICB9XG59XG5jbGFzcyBGb290bm90ZVRleHQgZXh0ZW5kcyBTdHlsZUZvclBhcmFncmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJGb290bm90ZVRleHRcIixcbiAgICAgIG5hbWU6IFwiZm9vdG5vdGUgdGV4dFwiLFxuICAgICAgbGluazogXCJGb290bm90ZVRleHRDaGFyXCIsXG4gICAgICBiYXNlZE9uOiBcIk5vcm1hbFwiLFxuICAgICAgdWlQcmlvcml0eTogOTksXG4gICAgICBzZW1pSGlkZGVuOiB0cnVlLFxuICAgICAgdW5oaWRlV2hlblVzZWQ6IHRydWUsXG4gICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgIGxpbmU6IDI0MCxcbiAgICAgICAgICBsaW5lUnVsZTogTGluZVJ1bGVUeXBlLkFVVE9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJ1bjoge1xuICAgICAgICBzaXplOiAyMFxuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgRm9vdG5vdGVSZWZlcmVuY2VTdHlsZSBleHRlbmRzIFN0eWxlRm9yQ2hhcmFjdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGlkOiBcIkZvb3Rub3RlUmVmZXJlbmNlXCIsXG4gICAgICBuYW1lOiBcImZvb3Rub3RlIHJlZmVyZW5jZVwiLFxuICAgICAgYmFzZWRPbjogXCJEZWZhdWx0UGFyYWdyYXBoRm9udFwiLFxuICAgICAgc2VtaUhpZGRlbjogdHJ1ZSxcbiAgICAgIHJ1bjoge1xuICAgICAgICBzdXBlclNjcmlwdDogdHJ1ZVxuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgRm9vdG5vdGVUZXh0Q2hhciBleHRlbmRzIFN0eWxlRm9yQ2hhcmFjdGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGlkOiBcIkZvb3Rub3RlVGV4dENoYXJcIixcbiAgICAgIG5hbWU6IFwiRm9vdG5vdGUgVGV4dCBDaGFyXCIsXG4gICAgICBiYXNlZE9uOiBcIkRlZmF1bHRQYXJhZ3JhcGhGb250XCIsXG4gICAgICBsaW5rOiBcIkZvb3Rub3RlVGV4dFwiLFxuICAgICAgc2VtaUhpZGRlbjogdHJ1ZSxcbiAgICAgIHJ1bjoge1xuICAgICAgICBzaXplOiAyMFxuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxufVxuY2xhc3MgSHlwZXJsaW5rU3R5bGUgZXh0ZW5kcyBTdHlsZUZvckNoYXJhY3RlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpZDogXCJIeXBlcmxpbmtcIixcbiAgICAgIG5hbWU6IFwiSHlwZXJsaW5rXCIsXG4gICAgICBiYXNlZE9uOiBcIkRlZmF1bHRQYXJhZ3JhcGhGb250XCIsXG4gICAgICBydW46IHtcbiAgICAgICAgY29sb3I6IFwiMDU2M0MxXCIsXG4gICAgICAgIHVuZGVybGluZToge1xuICAgICAgICAgIHR5cGU6IFVuZGVybGluZVR5cGUuU0lOR0xFXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKSk7XG4gIH1cbn1cbmNsYXNzIFN0eWxlcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6c3R5bGVzXCIpO1xuICAgIGlmIChvcHRpb25zLmluaXRpYWxTdHlsZXMpIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG9wdGlvbnMuaW5pdGlhbFN0eWxlcyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmltcG9ydGVkU3R5bGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIG9wdGlvbnMuaW1wb3J0ZWRTdHlsZXMpIHtcbiAgICAgICAgdGhpcy5yb290LnB1c2goc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXJhZ3JhcGhTdHlsZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygb3B0aW9ucy5wYXJhZ3JhcGhTdHlsZXMpIHtcbiAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0eWxlRm9yUGFyYWdyYXBoKHN0eWxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNoYXJhY3RlclN0eWxlcykge1xuICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiBvcHRpb25zLmNoYXJhY3RlclN0eWxlcykge1xuICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgU3R5bGVGb3JDaGFyYWN0ZXIoc3R5bGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBhcmFncmFwaFByb3BlcnRpZXNEZWZhdWx0cyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6cFByRGVmYXVsdFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgUGFyYWdyYXBoUHJvcGVydGllcyhvcHRpb25zKSk7XG4gIH1cbn1cbmNsYXNzIFJ1blByb3BlcnRpZXNEZWZhdWx0cyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6clByRGVmYXVsdFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgUnVuUHJvcGVydGllcyhvcHRpb25zKSk7XG4gIH1cbn1cbmNsYXNzIERvY3VtZW50RGVmYXVsdHMgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJ3OmRvY0RlZmF1bHRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJydW5Qcm9wZXJ0aWVzRGVmYXVsdHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcmFncmFwaFByb3BlcnRpZXNEZWZhdWx0c1wiKTtcbiAgICB0aGlzLnJ1blByb3BlcnRpZXNEZWZhdWx0cyA9IG5ldyBSdW5Qcm9wZXJ0aWVzRGVmYXVsdHMob3B0aW9ucy5ydW4pO1xuICAgIHRoaXMucGFyYWdyYXBoUHJvcGVydGllc0RlZmF1bHRzID0gbmV3IFBhcmFncmFwaFByb3BlcnRpZXNEZWZhdWx0cyhvcHRpb25zLnBhcmFncmFwaCk7XG4gICAgdGhpcy5yb290LnB1c2godGhpcy5ydW5Qcm9wZXJ0aWVzRGVmYXVsdHMpO1xuICAgIHRoaXMucm9vdC5wdXNoKHRoaXMucGFyYWdyYXBoUHJvcGVydGllc0RlZmF1bHRzKTtcbiAgfVxufVxuY2xhc3MgRXh0ZXJuYWxTdHlsZXNGYWN0b3J5IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IFN0eWxlIGJhc2VkIG9uIHRoZSBnaXZlbiBzdHlsZXMuXG4gICAqIFBhcnNlcyB0aGUgc3R5bGVzIGFuZCBjb252ZXJ0IHRoZW0gdG8gWG1sQ29tcG9uZW50LlxuICAgKiBFeGFtcGxlIGNvbnRlbnQgZnJvbSBzdHlsZXMueG1sOlxuICAgKiA8P3htbCB2ZXJzaW9uPVwiMS4wXCI+XG4gICAqIDx3OnN0eWxlcyB4bWxuczptYz1cInNvbWUgc2NoZW1hXCIgLi4uPlxuICAgKlxuICAgKiAgIDx3OnN0eWxlIHc6dHlwZT1cInBhcmFncmFwaFwiIHc6c3R5bGVJZD1cIkhlYWRpbmcxXCI+XG4gICAqICAgICAgICAgICA8dzpuYW1lIHc6dmFsPVwiaGVhZGluZyAxXCIvPlxuICAgKiAgICAgICAgICAgLi4uLi5cbiAgICogICA8L3c6c3R5bGU+XG4gICAqXG4gICAqICAgPHc6c3R5bGUgdzp0eXBlPVwicGFyYWdyYXBoXCIgdzpzdHlsZUlkPVwiSGVhZGluZzJcIj5cbiAgICogICAgICAgICAgIDx3Om5hbWUgdzp2YWw9XCJoZWFkaW5nIDJcIi8+XG4gICAqICAgICAgICAgICAuLi4uLlxuICAgKiAgIDwvdzpzdHlsZT5cbiAgICpcbiAgICogICA8dzpkb2NEZWZhdWx0cz5PciBhbnkgb3RoZXIgZWxlbWVudCB3aWxsIGJlIHBhcnNlZCB0bzwvdzpkb2NEZWZhdWx0cz5cbiAgICpcbiAgICogPC93OnN0eWxlcz5cbiAgICpcbiAgICogQHBhcmFtIGV4dGVybmFsU3R5bGVzIGNvbnRleHQgZnJvbSBzdHlsZXMueG1sXG4gICAqL1xuICBuZXdJbnN0YW5jZSh4bWxEYXRhKSB7XG4gICAgY29uc3QgeG1sT2JqID0gbGliRXhwb3J0cy54bWwyanMoeG1sRGF0YSwgeyBjb21wYWN0OiBmYWxzZSB9KTtcbiAgICBsZXQgc3R5bGVzWG1sRWxlbWVudDtcbiAgICBmb3IgKGNvbnN0IHhtbEVsbSBvZiB4bWxPYmouZWxlbWVudHMgfHwgW10pIHtcbiAgICAgIGlmICh4bWxFbG0ubmFtZSA9PT0gXCJ3OnN0eWxlc1wiKSB7XG4gICAgICAgIHN0eWxlc1htbEVsZW1lbnQgPSB4bWxFbG07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZXNYbWxFbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbiBub3QgZmluZCBzdHlsZXMgZWxlbWVudFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVzRWxlbWVudHMgPSBzdHlsZXNYbWxFbGVtZW50LmVsZW1lbnRzIHx8IFtdO1xuICAgIGNvbnN0IGltcG9ydGVkU3R5bGUgPSBuZXcgU3R5bGVzKHtcbiAgICAgIGluaXRpYWxTdHlsZXM6IG5ldyBJbXBvcnRlZFJvb3RFbGVtZW50QXR0cmlidXRlcyhzdHlsZXNYbWxFbGVtZW50LmF0dHJpYnV0ZXMpLFxuICAgICAgaW1wb3J0ZWRTdHlsZXM6IHN0eWxlc0VsZW1lbnRzLm1hcCgoY2hpbGRFbG0pID0+IGNvbnZlcnRUb1htbENvbXBvbmVudChjaGlsZEVsbSkpXG4gICAgfSk7XG4gICAgcmV0dXJuIGltcG9ydGVkU3R5bGU7XG4gIH1cbn1cbmNsYXNzIERlZmF1bHRTdHlsZXNGYWN0b3J5IHtcbiAgbmV3SW5zdGFuY2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGRvY3VtZW50QXR0cmlidXRlcyA9IG5ldyBEb2N1bWVudEF0dHJpYnV0ZXMoW1wibWNcIiwgXCJyXCIsIFwid1wiLCBcIncxNFwiLCBcIncxNVwiXSwgXCJ3MTQgdzE1XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0aWFsU3R5bGVzOiBkb2N1bWVudEF0dHJpYnV0ZXMsXG4gICAgICBpbXBvcnRlZFN0eWxlczogW1xuICAgICAgICBuZXcgRG9jdW1lbnREZWZhdWx0cygoX2EgPSBvcHRpb25zLmRvY3VtZW50KSAhPSBudWxsID8gX2EgOiB7fSksXG4gICAgICAgIG5ldyBUaXRsZVN0eWxlKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgIHNpemU6IDU2XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLnRpdGxlKSksXG4gICAgICAgIG5ldyBIZWFkaW5nMVN0eWxlKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIjJFNzRCNVwiLFxuICAgICAgICAgICAgc2l6ZTogMzJcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuaGVhZGluZzEpKSxcbiAgICAgICAgbmV3IEhlYWRpbmcyU3R5bGUoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgY29sb3I6IFwiMkU3NEI1XCIsXG4gICAgICAgICAgICBzaXplOiAyNlxuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkaW5nMikpLFxuICAgICAgICBuZXcgSGVhZGluZzNTdHlsZShfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIxRjRENzhcIixcbiAgICAgICAgICAgIHNpemU6IDI0XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLmhlYWRpbmczKSksXG4gICAgICAgIG5ldyBIZWFkaW5nNFN0eWxlKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgIGNvbG9yOiBcIjJFNzRCNVwiLFxuICAgICAgICAgICAgaXRhbGljczogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkaW5nNCkpLFxuICAgICAgICBuZXcgSGVhZGluZzVTdHlsZShfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIyRTc0QjVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkaW5nNSkpLFxuICAgICAgICBuZXcgSGVhZGluZzZTdHlsZShfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICBjb2xvcjogXCIxRjRENzhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkaW5nNikpLFxuICAgICAgICBuZXcgU3Ryb25nU3R5bGUoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgYm9sZDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgb3B0aW9ucy5zdHJvbmcpKSxcbiAgICAgICAgbmV3IExpc3RQYXJhZ3JhcGgob3B0aW9ucy5saXN0UGFyYWdyYXBoIHx8IHt9KSxcbiAgICAgICAgbmV3IEh5cGVybGlua1N0eWxlKG9wdGlvbnMuaHlwZXJsaW5rIHx8IHt9KSxcbiAgICAgICAgbmV3IEZvb3Rub3RlUmVmZXJlbmNlU3R5bGUob3B0aW9ucy5mb290bm90ZVJlZmVyZW5jZSB8fCB7fSksXG4gICAgICAgIG5ldyBGb290bm90ZVRleHQob3B0aW9ucy5mb290bm90ZVRleHQgfHwge30pLFxuICAgICAgICBuZXcgRm9vdG5vdGVUZXh0Q2hhcihvcHRpb25zLmZvb3Rub3RlVGV4dENoYXIgfHwge30pXG4gICAgICBdXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgRmlsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjdXJyZW50UmVsYXRpb25zaGlwSWRcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvY3VtZW50V3JhcHBlclwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFkZXJzXCIsIFtdKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9wcmVmZXItcmVhZG9ubHktdHlwZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmb290ZXJzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29yZVByb3BlcnRpZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm51bWJlcmluZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWVkaWFcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpbGVSZWxhdGlvbnNoaXBzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmb290bm90ZXNXcmFwcGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXR0aW5nc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29udGVudFR5cGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjdXN0b21Qcm9wZXJ0aWVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcHBQcm9wZXJ0aWVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbW1lbnRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmb250V3JhcHBlclwiKTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbDtcbiAgICB0aGlzLmNvcmVQcm9wZXJ0aWVzID0gbmV3IENvcmVQcm9wZXJ0aWVzKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICBjcmVhdG9yOiAoX2EgPSBvcHRpb25zLmNyZWF0b3IpICE9IG51bGwgPyBfYSA6IFwiVW4tbmFtZWRcIixcbiAgICAgIHJldmlzaW9uOiAoX2IgPSBvcHRpb25zLnJldmlzaW9uKSAhPSBudWxsID8gX2IgOiAxLFxuICAgICAgbGFzdE1vZGlmaWVkQnk6IChfYyA9IG9wdGlvbnMubGFzdE1vZGlmaWVkQnkpICE9IG51bGwgPyBfYyA6IFwiVW4tbmFtZWRcIlxuICAgIH0pKTtcbiAgICB0aGlzLm51bWJlcmluZyA9IG5ldyBOdW1iZXJpbmcob3B0aW9ucy5udW1iZXJpbmcgPyBvcHRpb25zLm51bWJlcmluZyA6IHsgY29uZmlnOiBbXSB9KTtcbiAgICB0aGlzLmNvbW1lbnRzID0gbmV3IENvbW1lbnRzKChfZCA9IG9wdGlvbnMuY29tbWVudHMpICE9IG51bGwgPyBfZCA6IHsgY2hpbGRyZW46IFtdIH0pO1xuICAgIHRoaXMuZmlsZVJlbGF0aW9uc2hpcHMgPSBuZXcgUmVsYXRpb25zaGlwcygpO1xuICAgIHRoaXMuY3VzdG9tUHJvcGVydGllcyA9IG5ldyBDdXN0b21Qcm9wZXJ0aWVzKChfZSA9IG9wdGlvbnMuY3VzdG9tUHJvcGVydGllcykgIT0gbnVsbCA/IF9lIDogW10pO1xuICAgIHRoaXMuYXBwUHJvcGVydGllcyA9IG5ldyBBcHBQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5mb290bm90ZXNXcmFwcGVyID0gbmV3IEZvb3Rub3Rlc1dyYXBwZXIoKTtcbiAgICB0aGlzLmNvbnRlbnRUeXBlcyA9IG5ldyBDb250ZW50VHlwZXMoKTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlciA9IG5ldyBEb2N1bWVudFdyYXBwZXIoeyBiYWNrZ3JvdW5kOiBvcHRpb25zLmJhY2tncm91bmQgfSk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyh7XG4gICAgICBjb21wYXRpYmlsaXR5TW9kZVZlcnNpb246IG9wdGlvbnMuY29tcGF0YWJpbGl0eU1vZGVWZXJzaW9uLFxuICAgICAgY29tcGF0aWJpbGl0eTogb3B0aW9ucy5jb21wYXRpYmlsaXR5LFxuICAgICAgZXZlbkFuZE9kZEhlYWRlcnM6IG9wdGlvbnMuZXZlbkFuZE9kZEhlYWRlckFuZEZvb3RlcnMgPyB0cnVlIDogZmFsc2UsXG4gICAgICB0cmFja1JldmlzaW9uczogKF9mID0gb3B0aW9ucy5mZWF0dXJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRyYWNrUmV2aXNpb25zLFxuICAgICAgdXBkYXRlRmllbGRzOiAoX2cgPSBvcHRpb25zLmZlYXR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2cudXBkYXRlRmllbGRzLFxuICAgICAgZGVmYXVsdFRhYlN0b3A6IG9wdGlvbnMuZGVmYXVsdFRhYlN0b3AsXG4gICAgICBoeXBoZW5hdGlvbjoge1xuICAgICAgICBhdXRvSHlwaGVuYXRpb246IChfaCA9IG9wdGlvbnMuaHlwaGVuYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfaC5hdXRvSHlwaGVuYXRpb24sXG4gICAgICAgIGh5cGhlbmF0aW9uWm9uZTogKF9pID0gb3B0aW9ucy5oeXBoZW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmh5cGhlbmF0aW9uWm9uZSxcbiAgICAgICAgY29uc2VjdXRpdmVIeXBoZW5MaW1pdDogKF9qID0gb3B0aW9ucy5oeXBoZW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9qLmNvbnNlY3V0aXZlSHlwaGVuTGltaXQsXG4gICAgICAgIGRvTm90SHlwaGVuYXRlQ2FwczogKF9rID0gb3B0aW9ucy5oeXBoZW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmRvTm90SHlwaGVuYXRlQ2Fwc1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubWVkaWEgPSBuZXcgTWVkaWEoKTtcbiAgICBpZiAob3B0aW9ucy5leHRlcm5hbFN0eWxlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBzdHlsZXNGYWN0b3J5ID0gbmV3IEV4dGVybmFsU3R5bGVzRmFjdG9yeSgpO1xuICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXNGYWN0b3J5Lm5ld0luc3RhbmNlKG9wdGlvbnMuZXh0ZXJuYWxTdHlsZXMpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHlsZXMpIHtcbiAgICAgIGNvbnN0IHN0eWxlc0ZhY3RvcnkgPSBuZXcgRGVmYXVsdFN0eWxlc0ZhY3RvcnkoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRTdHlsZXMgPSBzdHlsZXNGYWN0b3J5Lm5ld0luc3RhbmNlKG9wdGlvbnMuc3R5bGVzLmRlZmF1bHQpO1xuICAgICAgdGhpcy5zdHlsZXMgPSBuZXcgU3R5bGVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0U3R5bGVzKSwgb3B0aW9ucy5zdHlsZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3R5bGVzRmFjdG9yeSA9IG5ldyBEZWZhdWx0U3R5bGVzRmFjdG9yeSgpO1xuICAgICAgdGhpcy5zdHlsZXMgPSBuZXcgU3R5bGVzKHN0eWxlc0ZhY3RvcnkubmV3SW5zdGFuY2UoKSk7XG4gICAgfVxuICAgIHRoaXMuYWRkRGVmYXVsdFJlbGF0aW9uc2hpcHMoKTtcbiAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2Ygb3B0aW9ucy5zZWN0aW9ucykge1xuICAgICAgdGhpcy5hZGRTZWN0aW9uKHNlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mb290bm90ZXMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuZm9vdG5vdGVzKSB7XG4gICAgICAgIHRoaXMuZm9vdG5vdGVzV3JhcHBlci5WaWV3LmNyZWF0ZUZvb3ROb3RlKHBhcnNlRmxvYXQoa2V5KSwgb3B0aW9ucy5mb290bm90ZXNba2V5XS5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZm9udFdyYXBwZXIgPSBuZXcgRm9udFdyYXBwZXIoKF9sID0gb3B0aW9ucy5mb250cykgIT0gbnVsbCA/IF9sIDogW10pO1xuICB9XG4gIGFkZFNlY3Rpb24oeyBoZWFkZXJzID0ge30sIGZvb3RlcnMgPSB7fSwgY2hpbGRyZW4sIHByb3BlcnRpZXMgfSkge1xuICAgIHRoaXMuZG9jdW1lbnRXcmFwcGVyLlZpZXcuQm9keS5hZGRTZWN0aW9uKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHByb3BlcnRpZXMpLCB7XG4gICAgICBoZWFkZXJXcmFwcGVyR3JvdXA6IHtcbiAgICAgICAgZGVmYXVsdDogaGVhZGVycy5kZWZhdWx0ID8gdGhpcy5jcmVhdGVIZWFkZXIoaGVhZGVycy5kZWZhdWx0KSA6IHZvaWQgMCxcbiAgICAgICAgZmlyc3Q6IGhlYWRlcnMuZmlyc3QgPyB0aGlzLmNyZWF0ZUhlYWRlcihoZWFkZXJzLmZpcnN0KSA6IHZvaWQgMCxcbiAgICAgICAgZXZlbjogaGVhZGVycy5ldmVuID8gdGhpcy5jcmVhdGVIZWFkZXIoaGVhZGVycy5ldmVuKSA6IHZvaWQgMFxuICAgICAgfSxcbiAgICAgIGZvb3RlcldyYXBwZXJHcm91cDoge1xuICAgICAgICBkZWZhdWx0OiBmb290ZXJzLmRlZmF1bHQgPyB0aGlzLmNyZWF0ZUZvb3Rlcihmb290ZXJzLmRlZmF1bHQpIDogdm9pZCAwLFxuICAgICAgICBmaXJzdDogZm9vdGVycy5maXJzdCA/IHRoaXMuY3JlYXRlRm9vdGVyKGZvb3RlcnMuZmlyc3QpIDogdm9pZCAwLFxuICAgICAgICBldmVuOiBmb290ZXJzLmV2ZW4gPyB0aGlzLmNyZWF0ZUZvb3Rlcihmb290ZXJzLmV2ZW4pIDogdm9pZCAwXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRXcmFwcGVyLlZpZXcuYWRkKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlSGVhZGVyKGhlYWRlcikge1xuICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgSGVhZGVyV3JhcHBlcih0aGlzLm1lZGlhLCB0aGlzLmN1cnJlbnRSZWxhdGlvbnNoaXBJZCsrKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGhlYWRlci5vcHRpb25zLmNoaWxkcmVuKSB7XG4gICAgICB3cmFwcGVyLmFkZChjaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuYWRkSGVhZGVyVG9Eb2N1bWVudCh3cmFwcGVyKTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuICBjcmVhdGVGb290ZXIoZm9vdGVyKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBGb290ZXJXcmFwcGVyKHRoaXMubWVkaWEsIHRoaXMuY3VycmVudFJlbGF0aW9uc2hpcElkKyspO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZm9vdGVyLm9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIHdyYXBwZXIuYWRkKGNoaWxkKTtcbiAgICB9XG4gICAgdGhpcy5hZGRGb290ZXJUb0RvY3VtZW50KHdyYXBwZXIpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG4gIGFkZEhlYWRlclRvRG9jdW1lbnQoaGVhZGVyLCB0eXBlMiA9IEhlYWRlckZvb3RlclJlZmVyZW5jZVR5cGUuREVGQVVMVCkge1xuICAgIHRoaXMuaGVhZGVycy5wdXNoKHsgaGVhZGVyLCB0eXBlOiB0eXBlMiB9KTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlci5SZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIGhlYWRlci5WaWV3LlJlZmVyZW5jZUlkLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2hlYWRlclwiLFxuICAgICAgYGhlYWRlciR7dGhpcy5oZWFkZXJzLmxlbmd0aH0ueG1sYFxuICAgICk7XG4gICAgdGhpcy5jb250ZW50VHlwZXMuYWRkSGVhZGVyKHRoaXMuaGVhZGVycy5sZW5ndGgpO1xuICB9XG4gIGFkZEZvb3RlclRvRG9jdW1lbnQoZm9vdGVyLCB0eXBlMiA9IEhlYWRlckZvb3RlclJlZmVyZW5jZVR5cGUuREVGQVVMVCkge1xuICAgIHRoaXMuZm9vdGVycy5wdXNoKHsgZm9vdGVyLCB0eXBlOiB0eXBlMiB9KTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlci5SZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIGZvb3Rlci5WaWV3LlJlZmVyZW5jZUlkLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2Zvb3RlclwiLFxuICAgICAgYGZvb3RlciR7dGhpcy5mb290ZXJzLmxlbmd0aH0ueG1sYFxuICAgICk7XG4gICAgdGhpcy5jb250ZW50VHlwZXMuYWRkRm9vdGVyKHRoaXMuZm9vdGVycy5sZW5ndGgpO1xuICB9XG4gIGFkZERlZmF1bHRSZWxhdGlvbnNoaXBzKCkge1xuICAgIHRoaXMuZmlsZVJlbGF0aW9uc2hpcHMuY3JlYXRlUmVsYXRpb25zaGlwKFxuICAgICAgMSxcbiAgICAgIFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiLFxuICAgICAgXCJ3b3JkL2RvY3VtZW50LnhtbFwiXG4gICAgKTtcbiAgICB0aGlzLmZpbGVSZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIDIsXG4gICAgICBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwcy9tZXRhZGF0YS9jb3JlLXByb3BlcnRpZXNcIixcbiAgICAgIFwiZG9jUHJvcHMvY29yZS54bWxcIlxuICAgICk7XG4gICAgdGhpcy5maWxlUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAzLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2V4dGVuZGVkLXByb3BlcnRpZXNcIixcbiAgICAgIFwiZG9jUHJvcHMvYXBwLnhtbFwiXG4gICAgKTtcbiAgICB0aGlzLmZpbGVSZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIDQsXG4gICAgICBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvY3VzdG9tLXByb3BlcnRpZXNcIixcbiAgICAgIFwiZG9jUHJvcHMvY3VzdG9tLnhtbFwiXG4gICAgKTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlci5SZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXG4gICAgICB0aGlzLmN1cnJlbnRSZWxhdGlvbnNoaXBJZCsrLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3N0eWxlc1wiLFxuICAgICAgXCJzdHlsZXMueG1sXCJcbiAgICApO1xuICAgIHRoaXMuZG9jdW1lbnRXcmFwcGVyLlJlbGF0aW9uc2hpcHMuY3JlYXRlUmVsYXRpb25zaGlwKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmN0aW9uYWwvaW1tdXRhYmxlLWRhdGFcbiAgICAgIHRoaXMuY3VycmVudFJlbGF0aW9uc2hpcElkKyssXG4gICAgICBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvbnVtYmVyaW5nXCIsXG4gICAgICBcIm51bWJlcmluZy54bWxcIlxuICAgICk7XG4gICAgdGhpcy5kb2N1bWVudFdyYXBwZXIuUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuY3Rpb25hbC9pbW11dGFibGUtZGF0YVxuICAgICAgdGhpcy5jdXJyZW50UmVsYXRpb25zaGlwSWQrKyxcbiAgICAgIFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9mb290bm90ZXNcIixcbiAgICAgIFwiZm9vdG5vdGVzLnhtbFwiXG4gICAgKTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlci5SZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXG4gICAgICB0aGlzLmN1cnJlbnRSZWxhdGlvbnNoaXBJZCsrLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3NldHRpbmdzXCIsXG4gICAgICBcInNldHRpbmdzLnhtbFwiXG4gICAgKTtcbiAgICB0aGlzLmRvY3VtZW50V3JhcHBlci5SZWxhdGlvbnNoaXBzLmNyZWF0ZVJlbGF0aW9uc2hpcChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jdGlvbmFsL2ltbXV0YWJsZS1kYXRhXG4gICAgICB0aGlzLmN1cnJlbnRSZWxhdGlvbnNoaXBJZCsrLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2NvbW1lbnRzXCIsXG4gICAgICBcImNvbW1lbnRzLnhtbFwiXG4gICAgKTtcbiAgfVxuICBnZXQgRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRXcmFwcGVyO1xuICB9XG4gIGdldCBTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xuICB9XG4gIGdldCBDb3JlUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb3JlUHJvcGVydGllcztcbiAgfVxuICBnZXQgTnVtYmVyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm51bWJlcmluZztcbiAgfVxuICBnZXQgTWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVkaWE7XG4gIH1cbiAgZ2V0IEZpbGVSZWxhdGlvbnNoaXBzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVSZWxhdGlvbnNoaXBzO1xuICB9XG4gIGdldCBIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnMubWFwKChpdGVtKSA9PiBpdGVtLmhlYWRlcik7XG4gIH1cbiAgZ2V0IEZvb3RlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9vdGVycy5tYXAoKGl0ZW0pID0+IGl0ZW0uZm9vdGVyKTtcbiAgfVxuICBnZXQgQ29udGVudFR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRUeXBlcztcbiAgfVxuICBnZXQgQ3VzdG9tUHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0b21Qcm9wZXJ0aWVzO1xuICB9XG4gIGdldCBBcHBQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLmFwcFByb3BlcnRpZXM7XG4gIH1cbiAgZ2V0IEZvb3ROb3RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5mb290bm90ZXNXcmFwcGVyO1xuICB9XG4gIGdldCBTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncztcbiAgfVxuICBnZXQgQ29tbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWVudHM7XG4gIH1cbiAgZ2V0IEZvbnRUYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250V3JhcHBlcjtcbiAgfVxufVxuY2xhc3MgRmllbGRJbnN0cnVjdGlvbiBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMgPSB7fSkge1xuICAgIHN1cGVyKFwidzppbnN0clRleHRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb3BlcnRpZXNcIik7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dEF0dHJpYnV0ZXMoeyBzcGFjZTogU3BhY2VUeXBlLlBSRVNFUlZFIH0pKTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb24gPSBcIlRPQ1wiO1xuICAgIGlmICh0aGlzLnByb3BlcnRpZXMuY2FwdGlvbkxhYmVsKSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxcYSBcIiR7dGhpcy5wcm9wZXJ0aWVzLmNhcHRpb25MYWJlbH1cImA7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMuZW50cmllc0Zyb21Cb29rbWFyaykge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXGIgXCIke3RoaXMucHJvcGVydGllcy5lbnRyaWVzRnJvbUJvb2ttYXJrfVwiYDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5jYXB0aW9uTGFiZWxJbmNsdWRpbmdOdW1iZXJzKSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxcYyBcIiR7dGhpcy5wcm9wZXJ0aWVzLmNhcHRpb25MYWJlbEluY2x1ZGluZ051bWJlcnN9XCJgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnNlcXVlbmNlQW5kUGFnZU51bWJlcnNTZXBhcmF0b3IpIHtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFxkIFwiJHt0aGlzLnByb3BlcnRpZXMuc2VxdWVuY2VBbmRQYWdlTnVtYmVyc1NlcGFyYXRvcn1cImA7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMudGNGaWVsZElkZW50aWZpZXIpIHtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFxmIFwiJHt0aGlzLnByb3BlcnRpZXMudGNGaWVsZElkZW50aWZpZXJ9XCJgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmh5cGVybGluaykge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXGhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnRjRmllbGRMZXZlbFJhbmdlKSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxcbCBcIiR7dGhpcy5wcm9wZXJ0aWVzLnRjRmllbGRMZXZlbFJhbmdlfVwiYDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5wYWdlTnVtYmVyc0VudHJ5TGV2ZWxzUmFuZ2UpIHtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFxuIFwiJHt0aGlzLnByb3BlcnRpZXMucGFnZU51bWJlcnNFbnRyeUxldmVsc1JhbmdlfVwiYDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5oZWFkaW5nU3R5bGVSYW5nZSkge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXG8gXCIke3RoaXMucHJvcGVydGllcy5oZWFkaW5nU3R5bGVSYW5nZX1cImA7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMuZW50cnlBbmRQYWdlTnVtYmVyU2VwYXJhdG9yKSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxccCBcIiR7dGhpcy5wcm9wZXJ0aWVzLmVudHJ5QW5kUGFnZU51bWJlclNlcGFyYXRvcn1cImA7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMuc2VxRmllbGRJZGVudGlmaWVyRm9yUHJlZml4KSB7XG4gICAgICBpbnN0cnVjdGlvbiA9IGAke2luc3RydWN0aW9ufSBcXFxccyBcIiR7dGhpcy5wcm9wZXJ0aWVzLnNlcUZpZWxkSWRlbnRpZmllckZvclByZWZpeH1cImA7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BlcnRpZXMuc3R5bGVzV2l0aExldmVscyAmJiB0aGlzLnByb3BlcnRpZXMuc3R5bGVzV2l0aExldmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMucHJvcGVydGllcy5zdHlsZXNXaXRoTGV2ZWxzLm1hcCgoc2wpID0+IGAke3NsLnN0eWxlTmFtZX0sJHtzbC5sZXZlbH1gKS5qb2luKFwiLFwiKTtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFx0IFwiJHtzdHlsZXN9XCJgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnVzZUFwcGxpZWRQYXJhZ3JhcGhPdXRsaW5lTGV2ZWwpIHtcbiAgICAgIGluc3RydWN0aW9uID0gYCR7aW5zdHJ1Y3Rpb259IFxcXFx1YDtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5wcmVzZXJ2ZVRhYkluRW50cmllcykge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXHdgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLnByZXNlcnZlTmV3TGluZUluRW50cmllcykge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLmhpZGVUYWJBbmRQYWdlTnVtYmVyc0luV2ViVmlldykge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBgJHtpbnN0cnVjdGlvbn0gXFxcXHpgO1xuICAgIH1cbiAgICB0aGlzLnJvb3QucHVzaChpbnN0cnVjdGlvbik7XG4gIH1cbn1cbmNsYXNzIFN0cnVjdHVyZWREb2N1bWVudFRhZ0NvbnRlbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcInc6c2R0Q29udGVudFwiKTtcbiAgfVxufVxuY2xhc3MgU3RydWN0dXJlZERvY3VtZW50VGFnUHJvcGVydGllcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGFsaWFzKSB7XG4gICAgc3VwZXIoXCJ3OnNkdFByXCIpO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IFN0cmluZ1ZhbHVlRWxlbWVudChcInc6YWxpYXNcIiwgYWxpYXMpKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFRhYmxlT2ZDb250ZW50cyBleHRlbmRzIEZpbGVDaGlsZCB7XG4gIGNvbnN0cnVjdG9yKGFsaWFzID0gXCJUYWJsZSBvZiBDb250ZW50c1wiLCBwcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIoXCJ3OnNkdFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgU3RydWN0dXJlZERvY3VtZW50VGFnUHJvcGVydGllcyhhbGlhcykpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBuZXcgU3RydWN0dXJlZERvY3VtZW50VGFnQ29udGVudCgpO1xuICAgIGNvbnN0IGJlZ2luUGFyYWdyYXBoID0gbmV3IFBhcmFncmFwaCh7XG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICBuZXcgUnVuKHtcbiAgICAgICAgICBjaGlsZHJlbjogW25ldyBCZWdpbih0cnVlKSwgbmV3IEZpZWxkSW5zdHJ1Y3Rpb24ocHJvcGVydGllcyksIG5ldyBTZXBhcmF0ZSgpXVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnRlbnQuYWRkQ2hpbGRFbGVtZW50KGJlZ2luUGFyYWdyYXBoKTtcbiAgICBjb25zdCBlbmRQYXJhZ3JhcGggPSBuZXcgUGFyYWdyYXBoKHtcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIG5ldyBSdW4oe1xuICAgICAgICAgIGNoaWxkcmVuOiBbbmV3IEVuZCgpXVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnRlbnQuYWRkQ2hpbGRFbGVtZW50KGVuZFBhcmFncmFwaCk7XG4gICAgdGhpcy5yb290LnB1c2goY29udGVudCk7XG4gIH1cbn1cbmNsYXNzIFN0eWxlTGV2ZWwge1xuICBjb25zdHJ1Y3RvcihzdHlsZU5hbWUsIGxldmVsKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlTmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGV2ZWxcIik7XG4gICAgdGhpcy5zdHlsZU5hbWUgPSBzdHlsZU5hbWU7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICB9XG59XG5jbGFzcyBIZWFkZXIyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgY2hpbGRyZW46IFtdIH0pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0aW9uc1wiKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG59XG5jbGFzcyBGb290ZXIyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHsgY2hpbGRyZW46IFtdIH0pIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3B0aW9uc1wiKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG59XG5jbGFzcyBGb290Tm90ZVJlZmVyZW5jZVJ1bkF0dHJpYnV0ZXMgZXh0ZW5kcyBYbWxBdHRyaWJ1dGVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ4bWxLZXlzXCIsIHtcbiAgICAgIGlkOiBcInc6aWRcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb290bm90ZVJlZmVyZW5jZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGlkKSB7XG4gICAgc3VwZXIoXCJ3OmZvb3Rub3RlUmVmZXJlbmNlXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IEZvb3ROb3RlUmVmZXJlbmNlUnVuQXR0cmlidXRlcyh7XG4gICAgICAgIGlkXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIEZvb3Rub3RlUmVmZXJlbmNlUnVuIGV4dGVuZHMgUnVuIHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICBzdXBlcih7IHN0eWxlOiBcIkZvb3Rub3RlUmVmZXJlbmNlXCIgfSk7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IEZvb3Rub3RlUmVmZXJlbmNlKGlkKSk7XG4gIH1cbn1cbmNsYXNzIEluc2VydGVkVGV4dFJ1biBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6aW5zXCIpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgbmV3IENoYW5nZUF0dHJpYnV0ZXMoe1xuICAgICAgICBpZDogb3B0aW9ucy5pZCxcbiAgICAgICAgYXV0aG9yOiBvcHRpb25zLmF1dGhvcixcbiAgICAgICAgZGF0ZTogb3B0aW9ucy5kYXRlXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5hZGRDaGlsZEVsZW1lbnQobmV3IFRleHRSdW4ob3B0aW9ucykpO1xuICB9XG59XG5jbGFzcyBEZWxldGVkUGFnZSBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpkZWxJbnN0clRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgdGhpcy5yb290LnB1c2goXCJQQUdFXCIpO1xuICB9XG59XG5jbGFzcyBEZWxldGVkTnVtYmVyT2ZQYWdlcyBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwidzpkZWxJbnN0clRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgdGhpcy5yb290LnB1c2goXCJOVU1QQUdFU1wiKTtcbiAgfVxufVxuY2xhc3MgRGVsZXRlZE51bWJlck9mUGFnZXNTZWN0aW9uIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJ3OmRlbEluc3RyVGV4dFwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgVGV4dEF0dHJpYnV0ZXMoeyBzcGFjZTogU3BhY2VUeXBlLlBSRVNFUlZFIH0pKTtcbiAgICB0aGlzLnJvb3QucHVzaChcIlNFQ1RJT05QQUdFU1wiKTtcbiAgfVxufVxuY2xhc3MgRGVsZXRlZFRleHQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgc3VwZXIoXCJ3OmRlbFRleHRcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFRleHRBdHRyaWJ1dGVzKHsgc3BhY2U6IFNwYWNlVHlwZS5QUkVTRVJWRSB9KSk7XG4gICAgdGhpcy5yb290LnB1c2godGV4dCk7XG4gIH1cbn1cbmNsYXNzIERlbGV0ZWRUZXh0UnVuIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKFwidzpkZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlbGV0ZWRUZXh0UnVuV3JhcHBlclwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChcbiAgICAgIG5ldyBDaGFuZ2VBdHRyaWJ1dGVzKHtcbiAgICAgICAgaWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgIGF1dGhvcjogb3B0aW9ucy5hdXRob3IsXG4gICAgICAgIGRhdGU6IG9wdGlvbnMuZGF0ZVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuZGVsZXRlZFRleHRSdW5XcmFwcGVyID0gbmV3IERlbGV0ZWRUZXh0UnVuV3JhcHBlcihvcHRpb25zKTtcbiAgICB0aGlzLmFkZENoaWxkRWxlbWVudCh0aGlzLmRlbGV0ZWRUZXh0UnVuV3JhcHBlcik7XG4gIH1cbn1cbmNsYXNzIERlbGV0ZWRUZXh0UnVuV3JhcHBlciBleHRlbmRzIFhtbENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihcInc6clwiKTtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgUnVuUHJvcGVydGllcyhvcHRpb25zKSk7XG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygb3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3dpdGNoIChjaGlsZCkge1xuICAgICAgICAgICAgY2FzZSBQYWdlTnVtYmVyLkNVUlJFTlQ6XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBCZWdpbigpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IERlbGV0ZWRQYWdlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgU2VwYXJhdGUoKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBFbmQoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYWdlTnVtYmVyLlRPVEFMX1BBR0VTOlxuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgQmVnaW4oKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWxldGVkTnVtYmVyT2ZQYWdlcygpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IFNlcGFyYXRlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgRW5kKCkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFnZU51bWJlci5UT1RBTF9QQUdFU19JTl9TRUNUSU9OOlxuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgQmVnaW4oKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBEZWxldGVkTnVtYmVyT2ZQYWdlc1NlY3Rpb24oKSk7XG4gICAgICAgICAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBTZXBhcmF0ZSgpKTtcbiAgICAgICAgICAgICAgdGhpcy5yb290LnB1c2gobmV3IEVuZCgpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aGlzLnJvb3QucHVzaChuZXcgRGVsZXRlZFRleHQoY2hpbGQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGV4dCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IERlbGV0ZWRUZXh0KG9wdGlvbnMudGV4dCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5icmVhaykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmJyZWFrOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb290LnNwbGljZSgxLCAwLCBuZXcgQnJlYWskMSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNsYXNzIENoZWNrYm94U3ltYm9sQXR0cmlidXRlcyBleHRlbmRzIFhtbEF0dHJpYnV0ZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInhtbEtleXNcIiwge1xuICAgICAgdmFsOiBcIncxNDp2YWxcIixcbiAgICAgIHN5bWJvbGZvbnQ6IFwidzE0OmZvbnRcIlxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja0JveFN5bWJvbEVsZW1lbnQgZXh0ZW5kcyBYbWxDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwsIGZvbnQpIHtcbiAgICBzdXBlcihuYW1lKTtcbiAgICBpZiAoZm9udCkge1xuICAgICAgdGhpcy5yb290LnB1c2gobmV3IENoZWNrYm94U3ltYm9sQXR0cmlidXRlcyh7IHZhbDogc2hvcnRIZXhOdW1iZXIodmFsKSwgc3ltYm9sZm9udDogZm9udCB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDaGVja2JveFN5bWJvbEF0dHJpYnV0ZXMoeyB2YWwgfSkpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQ2hlY2tCb3hVdGlsIGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgc3VwZXIoXCJ3MTQ6Y2hlY2tib3hcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIkRFRkFVTFRfVU5DSEVDS0VEX1NZTUJPTFwiLCBcIjI2MTBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIkRFRkFVTFRfQ0hFQ0tFRF9TWU1CT0xcIiwgXCIyNjEyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJERUZBVUxUX0ZPTlRcIiwgXCJNUyBHb3RoaWNcIik7XG4gICAgY29uc3QgdmFsdWUgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jaGVja2VkKSA/IFwiMVwiIDogXCIwXCI7XG4gICAgbGV0IHN5bWJvbDtcbiAgICBsZXQgZm9udDtcbiAgICB0aGlzLnJvb3QucHVzaChuZXcgQ2hlY2tCb3hTeW1ib2xFbGVtZW50KFwidzE0OmNoZWNrZWRcIiwgdmFsdWUpKTtcbiAgICBzeW1ib2wgPSAoKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jaGVja2VkU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZSkgPyAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNoZWNrZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlIDogdGhpcy5ERUZBVUxUX0NIRUNLRURfU1lNQk9MO1xuICAgIGZvbnQgPSAoKF9jID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jaGVja2VkU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5mb250KSA/IChfZCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hlY2tlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZm9udCA6IHRoaXMuREVGQVVMVF9GT05UO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDaGVja0JveFN5bWJvbEVsZW1lbnQoXCJ3MTQ6Y2hlY2tlZFN0YXRlXCIsIHN5bWJvbCwgZm9udCkpO1xuICAgIHN5bWJvbCA9ICgoX2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVuY2hlY2tlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2UudmFsdWUpID8gKF9mID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51bmNoZWNrZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnZhbHVlIDogdGhpcy5ERUZBVUxUX1VOQ0hFQ0tFRF9TWU1CT0w7XG4gICAgZm9udCA9ICgoX2cgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVuY2hlY2tlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2cuZm9udCkgPyAoX2ggPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVuY2hlY2tlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2guZm9udCA6IHRoaXMuREVGQVVMVF9GT05UO1xuICAgIHRoaXMucm9vdC5wdXNoKG5ldyBDaGVja0JveFN5bWJvbEVsZW1lbnQoXCJ3MTQ6dW5jaGVja2VkU3RhdGVcIiwgc3ltYm9sLCBmb250KSk7XG4gIH1cbn1cbmNsYXNzIENoZWNrQm94IGV4dGVuZHMgWG1sQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBzdXBlcihcInc6c2R0XCIpO1xuICAgIC8vIGRlZmF1bHQgdmFsdWVzIHBlciBNaWNyb3NvZnRcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiREVGQVVMVF9VTkNIRUNLRURfU1lNQk9MXCIsIFwiMjYxMFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiREVGQVVMVF9DSEVDS0VEX1NZTUJPTFwiLCBcIjI2MTJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIkRFRkFVTFRfRk9OVFwiLCBcIk1TIEdvdGhpY1wiKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbmV3IFN0cnVjdHVyZWREb2N1bWVudFRhZ1Byb3BlcnRpZXMob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5hbGlhcyk7XG4gICAgcHJvcGVydGllcy5hZGRDaGlsZEVsZW1lbnQobmV3IENoZWNrQm94VXRpbChvcHRpb25zKSk7XG4gICAgdGhpcy5yb290LnB1c2gocHJvcGVydGllcyk7XG4gICAgY29uc3QgY29udGVudCA9IG5ldyBTdHJ1Y3R1cmVkRG9jdW1lbnRUYWdDb250ZW50KCk7XG4gICAgY29uc3QgY2hlY2tlZEZvbnQgPSAoX2EgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNoZWNrZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvbnQ7XG4gICAgY29uc3QgY2hlY2tlZFRleHQgPSAoX2IgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNoZWNrZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlO1xuICAgIGNvbnN0IHVuY2hlY2tlZEZvbnQgPSAoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVuY2hlY2tlZFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuZm9udDtcbiAgICBjb25zdCB1bmNoZWNrZWRUZXh0ID0gKF9kID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy51bmNoZWNrZWRTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnZhbHVlO1xuICAgIGxldCBzeW1ib2xGb250O1xuICAgIGxldCBjaGFyO1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNoZWNrZWQpIHtcbiAgICAgIHN5bWJvbEZvbnQgPSBjaGVja2VkRm9udCA/IGNoZWNrZWRGb250IDogdGhpcy5ERUZBVUxUX0ZPTlQ7XG4gICAgICBjaGFyID0gY2hlY2tlZFRleHQgPyBjaGVja2VkVGV4dCA6IHRoaXMuREVGQVVMVF9DSEVDS0VEX1NZTUJPTDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ltYm9sRm9udCA9IHVuY2hlY2tlZEZvbnQgPyB1bmNoZWNrZWRGb250IDogdGhpcy5ERUZBVUxUX0ZPTlQ7XG4gICAgICBjaGFyID0gdW5jaGVja2VkVGV4dCA/IHVuY2hlY2tlZFRleHQgOiB0aGlzLkRFRkFVTFRfVU5DSEVDS0VEX1NZTUJPTDtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbFJlbmRlcmVkQ2hhciA9IG5ldyBTeW1ib2xSdW4oe1xuICAgICAgY2hhcixcbiAgICAgIHN5bWJvbGZvbnQ6IHN5bWJvbEZvbnRcbiAgICB9KTtcbiAgICBjb250ZW50LmFkZENoaWxkRWxlbWVudChpbml0aWFsUmVuZGVyZWRDaGFyKTtcbiAgICB0aGlzLnJvb3QucHVzaChjb250ZW50KTtcbiAgfVxufVxuY29uc3QgY3JlYXRlUGljdEVsZW1lbnQgPSAoeyBzaGFwZSB9KSA9PiBuZXcgQnVpbGRlckVsZW1lbnQoe1xuICBuYW1lOiBcInc6cGljdFwiLFxuICBjaGlsZHJlbjogW3NoYXBlXVxufSk7XG5jb25zdCBjcmVhdGVUZXh0Ym94Q29udGVudCA9ICh7IGNoaWxkcmVuID0gW10gfSkgPT4gbmV3IEJ1aWxkZXJFbGVtZW50KHtcbiAgbmFtZTogXCJ3OnR4YnhDb250ZW50XCIsXG4gIGNoaWxkcmVuXG59KTtcbmNvbnN0IGNyZWF0ZVZtbFRleHRib3ggPSAoeyBzdHlsZSwgY2hpbGRyZW4sIGluc2V0IH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwidjp0ZXh0Ym94XCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBzdHlsZToge1xuICAgICAga2V5OiBcInN0eWxlXCIsXG4gICAgICB2YWx1ZTogc3R5bGVcbiAgICB9LFxuICAgIGluc2V0TW9kZToge1xuICAgICAga2V5OiBcImluc2V0bW9kZVwiLFxuICAgICAgdmFsdWU6IGluc2V0ID8gXCJjdXN0b21cIiA6IFwiYXV0b1wiXG4gICAgfSxcbiAgICBpbnNldDoge1xuICAgICAga2V5OiBcImluc2V0XCIsXG4gICAgICB2YWx1ZTogaW5zZXQgPyBgJHtpbnNldC5sZWZ0fSwgJHtpbnNldC50b3B9LCAke2luc2V0LnJpZ2h0fSwgJHtpbnNldC5ib3R0b219YCA6IHZvaWQgMFxuICAgIH1cbiAgfSxcbiAgY2hpbGRyZW46IFtjcmVhdGVUZXh0Ym94Q29udGVudCh7IGNoaWxkcmVuIH0pXVxufSk7XG5jb25zdCBTSEFQRV9UWVBFID0gXCIjX3gwMDAwX3QyMDJcIjtcbmNvbnN0IHN0eWxlVG9LZXlNYXAgPSB7XG4gIGZsaXA6IFwiZmxpcFwiLFxuICBoZWlnaHQ6IFwiaGVpZ2h0XCIsXG4gIGxlZnQ6IFwibGVmdFwiLFxuICBtYXJnaW5Cb3R0b206IFwibWFyZ2luLWJvdHRvbVwiLFxuICBtYXJnaW5MZWZ0OiBcIm1hcmdpbi1sZWZ0XCIsXG4gIG1hcmdpblJpZ2h0OiBcIm1hcmdpbi1yaWdodFwiLFxuICBtYXJnaW5Ub3A6IFwibWFyZ2luLXRvcFwiLFxuICBwb3NpdGlvbkhvcml6b250YWw6IFwibXNvLXBvc2l0aW9uLWhvcml6b250YWxcIixcbiAgcG9zaXRpb25Ib3Jpem9udGFsUmVsYXRpdmU6IFwibXNvLXBvc2l0aW9uLWhvcml6b250YWwtcmVsYXRpdmVcIixcbiAgcG9zaXRpb25WZXJ0aWNhbDogXCJtc28tcG9zaXRpb24tdmVydGljYWxcIixcbiAgcG9zaXRpb25WZXJ0aWNhbFJlbGF0aXZlOiBcIm1zby1wb3NpdGlvbi12ZXJ0aWNhbC1yZWxhdGl2ZVwiLFxuICB3cmFwRGlzdGFuY2VCb3R0b206IFwibXNvLXdyYXAtZGlzdGFuY2UtYm90dG9tXCIsXG4gIHdyYXBEaXN0YW5jZUxlZnQ6IFwibXNvLXdyYXAtZGlzdGFuY2UtbGVmdFwiLFxuICB3cmFwRGlzdGFuY2VSaWdodDogXCJtc28td3JhcC1kaXN0YW5jZS1yaWdodFwiLFxuICB3cmFwRGlzdGFuY2VUb3A6IFwibXNvLXdyYXAtZGlzdGFuY2UtdG9wXCIsXG4gIHdyYXBFZGl0ZWQ6IFwibXNvLXdyYXAtZWRpdGVkXCIsXG4gIHdyYXBTdHlsZTogXCJtc28td3JhcC1zdHlsZVwiLFxuICBwb3NpdGlvbjogXCJwb3NpdGlvblwiLFxuICByb3RhdGlvbjogXCJyb3RhdGlvblwiLFxuICB0b3A6IFwidG9wXCIsXG4gIHZpc2liaWxpdHk6IFwidmlzaWJpbGl0eVwiLFxuICB3aWR0aDogXCJ3aWR0aFwiLFxuICB6SW5kZXg6IFwiei1pbmRleFwiXG59O1xuY29uc3QgZm9ybWF0U2hhcGVTdHlsZSA9IChzdHlsZSkgPT4gc3R5bGUgPyBPYmplY3QuZW50cmllcyhzdHlsZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke3N0eWxlVG9LZXlNYXBba2V5XX06JHt2YWx1ZX1gKS5qb2luKFwiO1wiKSA6IHZvaWQgMDtcbmNvbnN0IGNyZWF0ZVNoYXBlID0gKHsgaWQsIGNoaWxkcmVuLCB0eXBlOiB0eXBlMiA9IFNIQVBFX1RZUEUsIHN0eWxlIH0pID0+IG5ldyBCdWlsZGVyRWxlbWVudCh7XG4gIG5hbWU6IFwidjpzaGFwZVwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgaWQ6IHtcbiAgICAgIGtleTogXCJpZFwiLFxuICAgICAgdmFsdWU6IGlkXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBrZXk6IFwidHlwZVwiLFxuICAgICAgdmFsdWU6IHR5cGUyXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAga2V5OiBcInN0eWxlXCIsXG4gICAgICB2YWx1ZTogZm9ybWF0U2hhcGVTdHlsZShzdHlsZSlcbiAgICB9XG4gIH0sXG4gIGNoaWxkcmVuOiBbY3JlYXRlVm1sVGV4dGJveCh7IHN0eWxlOiBcIm1zby1maXQtc2hhcGUtdG8tdGV4dDp0O1wiLCBjaGlsZHJlbiB9KV1cbn0pO1xuY2xhc3MgVGV4dGJveCBleHRlbmRzIEZpbGVDaGlsZCB7XG4gIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgdmFyIF9iID0gX2EsIHsgc3R5bGUsIGNoaWxkcmVuIH0gPSBfYiwgcmVzdCA9IF9fb2JqUmVzdChfYiwgW1wic3R5bGVcIiwgXCJjaGlsZHJlblwiXSk7XG4gICAgc3VwZXIoXCJ3OnBcIik7XG4gICAgdGhpcy5yb290LnB1c2gobmV3IFBhcmFncmFwaFByb3BlcnRpZXMocmVzdCkpO1xuICAgIHRoaXMucm9vdC5wdXNoKFxuICAgICAgY3JlYXRlUGljdEVsZW1lbnQoe1xuICAgICAgICBzaGFwZTogY3JlYXRlU2hhcGUoe1xuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIGlkOiB1bmlxdWVJZCgpLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbnZhciBzdHJlYW1Ccm93c2VyaWZ5RXhwb3J0cyA9IHJlcXVpcmVTdHJlYW1Ccm93c2VyaWZ5KCk7XG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUocGF0aCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHBhdGggKyAnXCIuIFBsZWFzZSBjb25maWd1cmUgdGhlIGR5bmFtaWNSZXF1aXJlVGFyZ2V0cyBvci9hbmQgaWdub3JlRHluYW1pY1JlcXVpcmVzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byB3b3JrLicpO1xufVxudmFyIGpzemlwX21pbiA9IHsgZXhwb3J0czoge30gfTtcbnZhciBoYXNSZXF1aXJlZEpzemlwX21pbjtcbmZ1bmN0aW9uIHJlcXVpcmVKc3ppcF9taW4oKSB7XG4gIGlmIChoYXNSZXF1aXJlZEpzemlwX21pbikgcmV0dXJuIGpzemlwX21pbi5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEpzemlwX21pbiA9IDE7XG4gIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAhZnVuY3Rpb24oZSkge1xuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBlKCk7XG4gICAgfShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzKGEsIG8sIGgpIHtcbiAgICAgICAgZnVuY3Rpb24gdShyLCBlMikge1xuICAgICAgICAgIGlmICghb1tyXSkge1xuICAgICAgICAgICAgaWYgKCFhW3JdKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBjb21tb25qc1JlcXVpcmUgJiYgY29tbW9uanNSZXF1aXJlO1xuICAgICAgICAgICAgICBpZiAoIWUyICYmIHQpIHJldHVybiB0KHIsIHRydWUpO1xuICAgICAgICAgICAgICBpZiAobCkgcmV0dXJuIGwociwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBuID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHIgKyBcIidcIik7XG4gICAgICAgICAgICAgIHRocm93IG4uY29kZSA9IFwiTU9EVUxFX05PVF9GT1VORFwiLCBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGkgPSBvW3JdID0geyBleHBvcnRzOiB7fSB9O1xuICAgICAgICAgICAgYVtyXVswXS5jYWxsKGkuZXhwb3J0cywgZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgICAgdmFyIHQyID0gYVtyXVsxXVtlM107XG4gICAgICAgICAgICAgIHJldHVybiB1KHQyIHx8IGUzKTtcbiAgICAgICAgICAgIH0sIGksIGkuZXhwb3J0cywgcywgYSwgbywgaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvW3JdLmV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgY29tbW9uanNSZXF1aXJlICYmIGNvbW1vbmpzUmVxdWlyZSwgZSA9IDA7IGUgPCBoLmxlbmd0aDsgZSsrKSB1KGhbZV0pO1xuICAgICAgICByZXR1cm4gdTtcbiAgICAgIH0oeyAxOiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgZCA9IGUoXCIuL3V0aWxzXCIpLCBjID0gZShcIi4vc3VwcG9ydFwiKSwgcCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICAgICAgci5lbmNvZGUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGZvciAodmFyIHQyLCByMiwgbiwgaSwgcywgYSwgbywgaCA9IFtdLCB1ID0gMCwgbCA9IGUyLmxlbmd0aCwgZiA9IGwsIGMyID0gXCJzdHJpbmdcIiAhPT0gZC5nZXRUeXBlT2YoZTIpOyB1IDwgZTIubGVuZ3RoOyApIGYgPSBsIC0gdSwgbiA9IGMyID8gKHQyID0gZTJbdSsrXSwgcjIgPSB1IDwgbCA/IGUyW3UrK10gOiAwLCB1IDwgbCA/IGUyW3UrK10gOiAwKSA6ICh0MiA9IGUyLmNoYXJDb2RlQXQodSsrKSwgcjIgPSB1IDwgbCA/IGUyLmNoYXJDb2RlQXQodSsrKSA6IDAsIHUgPCBsID8gZTIuY2hhckNvZGVBdCh1KyspIDogMCksIGkgPSB0MiA+PiAyLCBzID0gKDMgJiB0MikgPDwgNCB8IHIyID4+IDQsIGEgPSAxIDwgZiA/ICgxNSAmIHIyKSA8PCAyIHwgbiA+PiA2IDogNjQsIG8gPSAyIDwgZiA/IDYzICYgbiA6IDY0LCBoLnB1c2gocC5jaGFyQXQoaSkgKyBwLmNoYXJBdChzKSArIHAuY2hhckF0KGEpICsgcC5jaGFyQXQobykpO1xuICAgICAgICAgIHJldHVybiBoLmpvaW4oXCJcIik7XG4gICAgICAgIH0sIHIuZGVjb2RlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgdDIsIHIyLCBuLCBpLCBzLCBhLCBvID0gMCwgaCA9IDAsIHUgPSBcImRhdGE6XCI7XG4gICAgICAgICAgaWYgKGUyLnN1YnN0cigwLCB1Lmxlbmd0aCkgPT09IHUpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBpdCBsb29rcyBsaWtlIGEgZGF0YSB1cmwuXCIpO1xuICAgICAgICAgIHZhciBsLCBmID0gMyAqIChlMiA9IGUyLnJlcGxhY2UoL1teQS1aYS16MC05Ky89XS9nLCBcIlwiKSkubGVuZ3RoIC8gNDtcbiAgICAgICAgICBpZiAoZTIuY2hhckF0KGUyLmxlbmd0aCAtIDEpID09PSBwLmNoYXJBdCg2NCkgJiYgZi0tLCBlMi5jaGFyQXQoZTIubGVuZ3RoIC0gMikgPT09IHAuY2hhckF0KDY0KSAmJiBmLS0sIGYgJSAxICE9IDApIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgICAgICAgIGZvciAobCA9IGMudWludDhhcnJheSA/IG5ldyBVaW50OEFycmF5KDAgfCBmKSA6IG5ldyBBcnJheSgwIHwgZik7IG8gPCBlMi5sZW5ndGg7ICkgdDIgPSBwLmluZGV4T2YoZTIuY2hhckF0KG8rKykpIDw8IDIgfCAoaSA9IHAuaW5kZXhPZihlMi5jaGFyQXQobysrKSkpID4+IDQsIHIyID0gKDE1ICYgaSkgPDwgNCB8IChzID0gcC5pbmRleE9mKGUyLmNoYXJBdChvKyspKSkgPj4gMiwgbiA9ICgzICYgcykgPDwgNiB8IChhID0gcC5pbmRleE9mKGUyLmNoYXJBdChvKyspKSksIGxbaCsrXSA9IHQyLCA2NCAhPT0gcyAmJiAobFtoKytdID0gcjIpLCA2NCAhPT0gYSAmJiAobFtoKytdID0gbik7XG4gICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH07XG4gICAgICB9LCB7IFwiLi9zdXBwb3J0XCI6IDMwLCBcIi4vdXRpbHNcIjogMzIgfV0sIDI6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vZXh0ZXJuYWxcIiksIGkgPSBlKFwiLi9zdHJlYW0vRGF0YVdvcmtlclwiKSwgcyA9IGUoXCIuL3N0cmVhbS9DcmMzMlByb2JlXCIpLCBhID0gZShcIi4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZVwiKTtcbiAgICAgICAgZnVuY3Rpb24gbyhlMiwgdDIsIHIyLCBuMiwgaTIpIHtcbiAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZTIsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHQyLCB0aGlzLmNyYzMyID0gcjIsIHRoaXMuY29tcHJlc3Npb24gPSBuMiwgdGhpcy5jb21wcmVzc2VkQ29udGVudCA9IGkyO1xuICAgICAgICB9XG4gICAgICAgIG8ucHJvdG90eXBlID0geyBnZXRDb250ZW50V29ya2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIgPSBuZXcgaShuLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSkucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSkucGlwZShuZXcgYShcImRhdGFfbGVuZ3RoXCIpKSwgdDIgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBlMi5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUluZm8uZGF0YV9sZW5ndGggIT09IHQyLnVuY29tcHJlc3NlZFNpemUpIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgfSksIGUyO1xuICAgICAgICB9LCBnZXRDb21wcmVzc2VkV29ya2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGkobi5Qcm9taXNlLnJlc29sdmUodGhpcy5jb21wcmVzc2VkQ29udGVudCkpLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSkud2l0aFN0cmVhbUluZm8oXCJ1bmNvbXByZXNzZWRTaXplXCIsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSkud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCB0aGlzLmNyYzMyKS53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pO1xuICAgICAgICB9IH0sIG8uY3JlYXRlV29ya2VyRnJvbSA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICByZXR1cm4gZTIucGlwZShuZXcgcygpKS5waXBlKG5ldyBhKFwidW5jb21wcmVzc2VkU2l6ZVwiKSkucGlwZSh0Mi5jb21wcmVzc1dvcmtlcihyMikpLnBpcGUobmV3IGEoXCJjb21wcmVzc2VkU2l6ZVwiKSkud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLCB0Mik7XG4gICAgICAgIH0sIHQuZXhwb3J0cyA9IG87XG4gICAgICB9LCB7IFwiLi9leHRlcm5hbFwiOiA2LCBcIi4vc3RyZWFtL0NyYzMyUHJvYmVcIjogMjUsIFwiLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlXCI6IDI2LCBcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIjogMjcgfV0sIDM6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG4gICAgICAgIHIuU1RPUkUgPSB7IG1hZ2ljOiBcIlxcMFxcMFwiLCBjb21wcmVzc1dvcmtlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBuKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgICAgIH0sIHVuY29tcHJlc3NXb3JrZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgbihcIlNUT1JFIGRlY29tcHJlc3Npb25cIik7XG4gICAgICAgIH0gfSwgci5ERUZMQVRFID0gZShcIi4vZmxhdGVcIik7XG4gICAgICB9LCB7IFwiLi9mbGF0ZVwiOiA3LCBcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIjogMjggfV0sIDQ6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vdXRpbHNcIik7XG4gICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgZTIsIHQyID0gW10sIHIyID0gMDsgcjIgPCAyNTY7IHIyKyspIHtcbiAgICAgICAgICAgIGUyID0gcjI7XG4gICAgICAgICAgICBmb3IgKHZhciBuMiA9IDA7IG4yIDwgODsgbjIrKykgZTIgPSAxICYgZTIgPyAzOTg4MjkyMzg0IF4gZTIgPj4+IDEgOiBlMiA+Pj4gMTtcbiAgICAgICAgICAgIHQyW3IyXSA9IGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdDI7XG4gICAgICAgIH0oKTtcbiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gZTIgJiYgZTIubGVuZ3RoID8gXCJzdHJpbmdcIiAhPT0gbi5nZXRUeXBlT2YoZTIpID8gZnVuY3Rpb24oZTMsIHQzLCByMiwgbjIpIHtcbiAgICAgICAgICAgIHZhciBpID0gbywgcyA9IG4yICsgcjI7XG4gICAgICAgICAgICBlMyBePSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBuMjsgYSA8IHM7IGErKykgZTMgPSBlMyA+Pj4gOCBeIGlbMjU1ICYgKGUzIF4gdDNbYV0pXTtcbiAgICAgICAgICAgIHJldHVybiAtMSBeIGUzO1xuICAgICAgICAgIH0oMCB8IHQyLCBlMiwgZTIubGVuZ3RoLCAwKSA6IGZ1bmN0aW9uKGUzLCB0MywgcjIsIG4yKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG8sIHMgPSBuMiArIHIyO1xuICAgICAgICAgICAgZTMgXj0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gbjI7IGEgPCBzOyBhKyspIGUzID0gZTMgPj4+IDggXiBpWzI1NSAmIChlMyBeIHQzLmNoYXJDb2RlQXQoYSkpXTtcbiAgICAgICAgICAgIHJldHVybiAtMSBeIGUzO1xuICAgICAgICAgIH0oMCB8IHQyLCBlMiwgZTIubGVuZ3RoLCAwKSA6IDA7XG4gICAgICAgIH07XG4gICAgICB9LCB7IFwiLi91dGlsc1wiOiAzMiB9XSwgNTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgci5iYXNlNjQgPSBmYWxzZSwgci5iaW5hcnkgPSBmYWxzZSwgci5kaXIgPSBmYWxzZSwgci5jcmVhdGVGb2xkZXJzID0gdHJ1ZSwgci5kYXRlID0gbnVsbCwgci5jb21wcmVzc2lvbiA9IG51bGwsIHIuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbCwgci5jb21tZW50ID0gbnVsbCwgci51bml4UGVybWlzc2lvbnMgPSBudWxsLCByLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiAgICAgIH0sIHt9XSwgNjogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBudWxsO1xuICAgICAgICBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUHJvbWlzZSA/IFByb21pc2UgOiBlKFwibGllXCIpLCB0LmV4cG9ydHMgPSB7IFByb21pc2U6IG4gfTtcbiAgICAgIH0sIHsgbGllOiAzNyB9XSwgNzogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBVaW50OEFycmF5ICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFVpbnQxNkFycmF5ICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFVpbnQzMkFycmF5LCBpID0gZShcInBha29cIiksIHMgPSBlKFwiLi91dGlsc1wiKSwgYSA9IGUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpLCBvID0gbiA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuICAgICAgICBmdW5jdGlvbiBoKGUyLCB0Mikge1xuICAgICAgICAgIGEuY2FsbCh0aGlzLCBcIkZsYXRlV29ya2VyL1wiICsgZTIpLCB0aGlzLl9wYWtvID0gbnVsbCwgdGhpcy5fcGFrb0FjdGlvbiA9IGUyLCB0aGlzLl9wYWtvT3B0aW9ucyA9IHQyLCB0aGlzLm1ldGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByLm1hZ2ljID0gXCJcXGJcXDBcIiwgcy5pbmhlcml0cyhoLCBhKSwgaC5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLm1ldGEgPSBlMi5tZXRhLCBudWxsID09PSB0aGlzLl9wYWtvICYmIHRoaXMuX2NyZWF0ZVBha28oKSwgdGhpcy5fcGFrby5wdXNoKHMudHJhbnNmb3JtVG8obywgZTIuZGF0YSksIGZhbHNlKTtcbiAgICAgICAgfSwgaC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpLCBudWxsID09PSB0aGlzLl9wYWtvICYmIHRoaXMuX2NyZWF0ZVBha28oKSwgdGhpcy5fcGFrby5wdXNoKFtdLCB0cnVlKTtcbiAgICAgICAgfSwgaC5wcm90b3R5cGUuY2xlYW5VcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGEucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKSwgdGhpcy5fcGFrbyA9IG51bGw7XG4gICAgICAgIH0sIGgucHJvdG90eXBlLl9jcmVhdGVQYWtvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5fcGFrbyA9IG5ldyBpW3RoaXMuX3Bha29BY3Rpb25dKHsgcmF3OiB0cnVlLCBsZXZlbDogdGhpcy5fcGFrb09wdGlvbnMubGV2ZWwgfHwgLTEgfSk7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9wYWtvLm9uRGF0YSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgICB0Mi5wdXNoKHsgZGF0YTogZTIsIG1ldGE6IHQyLm1ldGEgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgci5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBoKFwiRGVmbGF0ZVwiLCBlMik7XG4gICAgICAgIH0sIHIudW5jb21wcmVzc1dvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgaChcIkluZmxhdGVcIiwge30pO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIjogMjgsIFwiLi91dGlsc1wiOiAzMiwgcGFrbzogMzggfV0sIDg6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIGZ1bmN0aW9uIEEoZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMiA9IFwiXCI7XG4gICAgICAgICAgZm9yIChyMiA9IDA7IHIyIDwgdDI7IHIyKyspIG4yICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgZTIpLCBlMiA+Pj49IDg7XG4gICAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG4oZTIsIHQyLCByMiwgbjIsIGkyLCBzMikge1xuICAgICAgICAgIHZhciBhLCBvLCBoID0gZTIuZmlsZSwgdSA9IGUyLmNvbXByZXNzaW9uLCBsID0gczIgIT09IE8udXRmOGVuY29kZSwgZiA9IEkudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgczIoaC5uYW1lKSksIGMgPSBJLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIE8udXRmOGVuY29kZShoLm5hbWUpKSwgZCA9IGguY29tbWVudCwgcCA9IEkudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgczIoZCkpLCBtID0gSS50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBPLnV0ZjhlbmNvZGUoZCkpLCBfID0gYy5sZW5ndGggIT09IGgubmFtZS5sZW5ndGgsIGcgPSBtLmxlbmd0aCAhPT0gZC5sZW5ndGgsIGIgPSBcIlwiLCB2ID0gXCJcIiwgeSA9IFwiXCIsIHcgPSBoLmRpciwgayA9IGguZGF0ZSwgeCA9IHsgY3JjMzI6IDAsIGNvbXByZXNzZWRTaXplOiAwLCB1bmNvbXByZXNzZWRTaXplOiAwIH07XG4gICAgICAgICAgdDIgJiYgIXIyIHx8ICh4LmNyYzMyID0gZTIuY3JjMzIsIHguY29tcHJlc3NlZFNpemUgPSBlMi5jb21wcmVzc2VkU2l6ZSwgeC51bmNvbXByZXNzZWRTaXplID0gZTIudW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgICAgdmFyIFMgPSAwO1xuICAgICAgICAgIHQyICYmIChTIHw9IDgpLCBsIHx8ICFfICYmICFnIHx8IChTIHw9IDIwNDgpO1xuICAgICAgICAgIHZhciB6ID0gMCwgQyA9IDA7XG4gICAgICAgICAgdyAmJiAoeiB8PSAxNiksIFwiVU5JWFwiID09PSBpMiA/IChDID0gNzk4LCB6IHw9IGZ1bmN0aW9uKGUzLCB0Mykge1xuICAgICAgICAgICAgdmFyIHIzID0gZTM7XG4gICAgICAgICAgICByZXR1cm4gZTMgfHwgKHIzID0gdDMgPyAxNjg5MyA6IDMzMjA0KSwgKDY1NTM1ICYgcjMpIDw8IDE2O1xuICAgICAgICAgIH0oaC51bml4UGVybWlzc2lvbnMsIHcpKSA6IChDID0gMjAsIHogfD0gZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHJldHVybiA2MyAmIChlMyB8fCAwKTtcbiAgICAgICAgICB9KGguZG9zUGVybWlzc2lvbnMpKSwgYSA9IGsuZ2V0VVRDSG91cnMoKSwgYSA8PD0gNiwgYSB8PSBrLmdldFVUQ01pbnV0ZXMoKSwgYSA8PD0gNSwgYSB8PSBrLmdldFVUQ1NlY29uZHMoKSAvIDIsIG8gPSBrLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwLCBvIDw8PSA0LCBvIHw9IGsuZ2V0VVRDTW9udGgoKSArIDEsIG8gPDw9IDUsIG8gfD0gay5nZXRVVENEYXRlKCksIF8gJiYgKHYgPSBBKDEsIDEpICsgQShCKGYpLCA0KSArIGMsIGIgKz0gXCJ1cFwiICsgQSh2Lmxlbmd0aCwgMikgKyB2KSwgZyAmJiAoeSA9IEEoMSwgMSkgKyBBKEIocCksIDQpICsgbSwgYiArPSBcInVjXCIgKyBBKHkubGVuZ3RoLCAyKSArIHkpO1xuICAgICAgICAgIHZhciBFID0gXCJcIjtcbiAgICAgICAgICByZXR1cm4gRSArPSBcIlxcblxcMFwiLCBFICs9IEEoUywgMiksIEUgKz0gdS5tYWdpYywgRSArPSBBKGEsIDIpLCBFICs9IEEobywgMiksIEUgKz0gQSh4LmNyYzMyLCA0KSwgRSArPSBBKHguY29tcHJlc3NlZFNpemUsIDQpLCBFICs9IEEoeC51bmNvbXByZXNzZWRTaXplLCA0KSwgRSArPSBBKGYubGVuZ3RoLCAyKSwgRSArPSBBKGIubGVuZ3RoLCAyKSwgeyBmaWxlUmVjb3JkOiBSLkxPQ0FMX0ZJTEVfSEVBREVSICsgRSArIGYgKyBiLCBkaXJSZWNvcmQ6IFIuQ0VOVFJBTF9GSUxFX0hFQURFUiArIEEoQywgMikgKyBFICsgQShwLmxlbmd0aCwgMikgKyBcIlxcMFxcMFxcMFxcMFwiICsgQSh6LCA0KSArIEEobjIsIDQpICsgZiArIGIgKyBwIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIEkgPSBlKFwiLi4vdXRpbHNcIiksIGkgPSBlKFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIiksIE8gPSBlKFwiLi4vdXRmOFwiKSwgQiA9IGUoXCIuLi9jcmMzMlwiKSwgUiA9IGUoXCIuLi9zaWduYXR1cmVcIik7XG4gICAgICAgIGZ1bmN0aW9uIHMoZTIsIHQyLCByMiwgbjIpIHtcbiAgICAgICAgICBpLmNhbGwodGhpcywgXCJaaXBGaWxlV29ya2VyXCIpLCB0aGlzLmJ5dGVzV3JpdHRlbiA9IDAsIHRoaXMuemlwQ29tbWVudCA9IHQyLCB0aGlzLnppcFBsYXRmb3JtID0gcjIsIHRoaXMuZW5jb2RlRmlsZU5hbWUgPSBuMiwgdGhpcy5zdHJlYW1GaWxlcyA9IGUyLCB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZSwgdGhpcy5jb250ZW50QnVmZmVyID0gW10sIHRoaXMuZGlyUmVjb3JkcyA9IFtdLCB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSAwLCB0aGlzLmVudHJpZXNDb3VudCA9IDAsIHRoaXMuY3VycmVudEZpbGUgPSBudWxsLCB0aGlzLl9zb3VyY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgSS5pbmhlcml0cyhzLCBpKSwgcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gZTIubWV0YS5wZXJjZW50IHx8IDAsIHIyID0gdGhpcy5lbnRyaWVzQ291bnQsIG4yID0gdGhpcy5fc291cmNlcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5hY2N1bXVsYXRlID8gdGhpcy5jb250ZW50QnVmZmVyLnB1c2goZTIpIDogKHRoaXMuYnl0ZXNXcml0dGVuICs9IGUyLmRhdGEubGVuZ3RoLCBpLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgeyBkYXRhOiBlMi5kYXRhLCBtZXRhOiB7IGN1cnJlbnRGaWxlOiB0aGlzLmN1cnJlbnRGaWxlLCBwZXJjZW50OiByMiA/ICh0MiArIDEwMCAqIChyMiAtIG4yIC0gMSkpIC8gcjIgOiAxMDAgfSB9KSk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLm9wZW5lZFNvdXJjZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0ID0gdGhpcy5ieXRlc1dyaXR0ZW4sIHRoaXMuY3VycmVudEZpbGUgPSBlMi5maWxlLm5hbWU7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhZTIuZmlsZS5kaXI7XG4gICAgICAgICAgaWYgKHQyKSB7XG4gICAgICAgICAgICB2YXIgcjIgPSBuKGUyLCB0MiwgZmFsc2UsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnB1c2goeyBkYXRhOiByMi5maWxlUmVjb3JkLCBtZXRhOiB7IHBlcmNlbnQ6IDAgfSB9KTtcbiAgICAgICAgICB9IGVsc2UgdGhpcy5hY2N1bXVsYXRlID0gdHJ1ZTtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgdDIgPSB0aGlzLnN0cmVhbUZpbGVzICYmICFlMi5maWxlLmRpciwgcjIgPSBuKGUyLCB0MiwgdHJ1ZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgICBpZiAodGhpcy5kaXJSZWNvcmRzLnB1c2gocjIuZGlyUmVjb3JkKSwgdDIpIHRoaXMucHVzaCh7IGRhdGE6IGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICByZXR1cm4gUi5EQVRBX0RFU0NSSVBUT1IgKyBBKGUzLmNyYzMyLCA0KSArIEEoZTMuY29tcHJlc3NlZFNpemUsIDQpICsgQShlMy51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAgICAgICB9KGUyKSwgbWV0YTogeyBwZXJjZW50OiAxMDAgfSB9KTtcbiAgICAgICAgICBlbHNlIGZvciAodGhpcy5wdXNoKHsgZGF0YTogcjIuZmlsZVJlY29yZCwgbWV0YTogeyBwZXJjZW50OiAwIH0gfSk7IHRoaXMuY29udGVudEJ1ZmZlci5sZW5ndGg7ICkgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBlMiA9IHRoaXMuYnl0ZXNXcml0dGVuLCB0MiA9IDA7IHQyIDwgdGhpcy5kaXJSZWNvcmRzLmxlbmd0aDsgdDIrKykgdGhpcy5wdXNoKHsgZGF0YTogdGhpcy5kaXJSZWNvcmRzW3QyXSwgbWV0YTogeyBwZXJjZW50OiAxMDAgfSB9KTtcbiAgICAgICAgICB2YXIgcjIgPSB0aGlzLmJ5dGVzV3JpdHRlbiAtIGUyLCBuMiA9IGZ1bmN0aW9uKGUzLCB0MywgcjMsIG4zLCBpMikge1xuICAgICAgICAgICAgdmFyIHMyID0gSS50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBpMihuMykpO1xuICAgICAgICAgICAgcmV0dXJuIFIuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EICsgXCJcXDBcXDBcXDBcXDBcIiArIEEoZTMsIDIpICsgQShlMywgMikgKyBBKHQzLCA0KSArIEEocjMsIDQpICsgQShzMi5sZW5ndGgsIDIpICsgczI7XG4gICAgICAgICAgfSh0aGlzLmRpclJlY29yZHMubGVuZ3RoLCByMiwgZTIsIHRoaXMuemlwQ29tbWVudCwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgICAgICAgdGhpcy5wdXNoKHsgZGF0YTogbjIsIG1ldGE6IHsgcGVyY2VudDogMTAwIH0gfSk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnByZXBhcmVOZXh0U291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKSwgdGhpcy5vcGVuZWRTb3VyY2UodGhpcy5wcmV2aW91cy5zdHJlYW1JbmZvKSwgdGhpcy5pc1BhdXNlZCA/IHRoaXMucHJldmlvdXMucGF1c2UoKSA6IHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXMgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXMucHVzaChlMik7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gZTIub24oXCJkYXRhXCIsIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICB0Mi5wcm9jZXNzQ2h1bmsoZTMpO1xuICAgICAgICAgIH0pLCBlMi5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHQyLmNsb3NlZFNvdXJjZSh0Mi5wcmV2aW91cy5zdHJlYW1JbmZvKSwgdDIuX3NvdXJjZXMubGVuZ3RoID8gdDIucHJlcGFyZU5leHRTb3VyY2UoKSA6IHQyLmVuZCgpO1xuICAgICAgICAgIH0pLCBlMi5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICB0Mi5lcnJvcihlMyk7XG4gICAgICAgICAgfSksIHRoaXM7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhIWkucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpICYmICghdGhpcy5wcmV2aW91cyAmJiB0aGlzLl9zb3VyY2VzLmxlbmd0aCA/ICh0aGlzLnByZXBhcmVOZXh0U291cmNlKCksIHRydWUpIDogdGhpcy5wcmV2aW91cyB8fCB0aGlzLl9zb3VyY2VzLmxlbmd0aCB8fCB0aGlzLmdlbmVyYXRlZEVycm9yID8gdm9pZCAwIDogKHRoaXMuZW5kKCksIHRydWUpKTtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiA9IHRoaXMuX3NvdXJjZXM7XG4gICAgICAgICAgaWYgKCFpLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIHIyID0gMDsgcjIgPCB0Mi5sZW5ndGg7IHIyKyspIHRyeSB7XG4gICAgICAgICAgICB0MltyMl0uZXJyb3IoZTIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUzKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaS5wcm90b3R5cGUubG9jay5jYWxsKHRoaXMpO1xuICAgICAgICAgIGZvciAodmFyIGUyID0gdGhpcy5fc291cmNlcywgdDIgPSAwOyB0MiA8IGUyLmxlbmd0aDsgdDIrKykgZTJbdDJdLmxvY2soKTtcbiAgICAgICAgfSwgdC5leHBvcnRzID0gcztcbiAgICAgIH0sIHsgXCIuLi9jcmMzMlwiOiA0LCBcIi4uL3NpZ25hdHVyZVwiOiAyMywgXCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOiAyOCwgXCIuLi91dGY4XCI6IDMxLCBcIi4uL3V0aWxzXCI6IDMyIH1dLCA5OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgdSA9IGUoXCIuLi9jb21wcmVzc2lvbnNcIiksIG4gPSBlKFwiLi9aaXBGaWxlV29ya2VyXCIpO1xuICAgICAgICByLmdlbmVyYXRlV29ya2VyID0gZnVuY3Rpb24oZTIsIGEsIHQyKSB7XG4gICAgICAgICAgdmFyIG8gPSBuZXcgbihhLnN0cmVhbUZpbGVzLCB0MiwgYS5wbGF0Zm9ybSwgYS5lbmNvZGVGaWxlTmFtZSksIGggPSAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlMi5mb3JFYWNoKGZ1bmN0aW9uKGUzLCB0Mykge1xuICAgICAgICAgICAgICBoKys7XG4gICAgICAgICAgICAgIHZhciByMiA9IGZ1bmN0aW9uKGU0LCB0NCkge1xuICAgICAgICAgICAgICAgIHZhciByMyA9IGU0IHx8IHQ0LCBuMyA9IHVbcjNdO1xuICAgICAgICAgICAgICAgIGlmICghbjMpIHRocm93IG5ldyBFcnJvcihyMyArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuMztcbiAgICAgICAgICAgICAgfSh0My5vcHRpb25zLmNvbXByZXNzaW9uLCBhLmNvbXByZXNzaW9uKSwgbjIgPSB0My5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBhLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fSwgaSA9IHQzLmRpciwgcyA9IHQzLmRhdGU7XG4gICAgICAgICAgICAgIHQzLl9jb21wcmVzc1dvcmtlcihyMiwgbjIpLndpdGhTdHJlYW1JbmZvKFwiZmlsZVwiLCB7IG5hbWU6IGUzLCBkaXI6IGksIGRhdGU6IHMsIGNvbW1lbnQ6IHQzLmNvbW1lbnQgfHwgXCJcIiwgdW5peFBlcm1pc3Npb25zOiB0My51bml4UGVybWlzc2lvbnMsIGRvc1Blcm1pc3Npb25zOiB0My5kb3NQZXJtaXNzaW9ucyB9KS5waXBlKG8pO1xuICAgICAgICAgICAgfSksIG8uZW50cmllc0NvdW50ID0gaDtcbiAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgby5lcnJvcihlMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBcIi4uL2NvbXByZXNzaW9uc1wiOiAzLCBcIi4vWmlwRmlsZVdvcmtlclwiOiA4IH1dLCAxMDogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgZnVuY3Rpb24gbigpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbikpIHJldHVybiBuZXcgbigpO1xuICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgICAgICAgIHRoaXMuZmlsZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5jb21tZW50ID0gbnVsbCwgdGhpcy5yb290ID0gXCJcIiwgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUyID0gbmV3IG4oKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQyIGluIHRoaXMpIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdGhpc1t0Ml0gJiYgKGUyW3QyXSA9IHRoaXNbdDJdKTtcbiAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIChuLnByb3RvdHlwZSA9IGUoXCIuL29iamVjdFwiKSkubG9hZEFzeW5jID0gZShcIi4vbG9hZFwiKSwgbi5zdXBwb3J0ID0gZShcIi4vc3VwcG9ydFwiKSwgbi5kZWZhdWx0cyA9IGUoXCIuL2RlZmF1bHRzXCIpLCBuLnZlcnNpb24gPSBcIjMuMTAuMVwiLCBuLmxvYWRBc3luYyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiBuZXcgbigpLmxvYWRBc3luYyhlMiwgdDIpO1xuICAgICAgICB9LCBuLmV4dGVybmFsID0gZShcIi4vZXh0ZXJuYWxcIiksIHQuZXhwb3J0cyA9IG47XG4gICAgICB9LCB7IFwiLi9kZWZhdWx0c1wiOiA1LCBcIi4vZXh0ZXJuYWxcIjogNiwgXCIuL2xvYWRcIjogMTEsIFwiLi9vYmplY3RcIjogMTUsIFwiLi9zdXBwb3J0XCI6IDMwIH1dLCAxMTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIHUgPSBlKFwiLi91dGlsc1wiKSwgaSA9IGUoXCIuL2V4dGVybmFsXCIpLCBuID0gZShcIi4vdXRmOFwiKSwgcyA9IGUoXCIuL3ppcEVudHJpZXNcIiksIGEgPSBlKFwiLi9zdHJlYW0vQ3JjMzJQcm9iZVwiKSwgbCA9IGUoXCIuL25vZGVqc1V0aWxzXCIpO1xuICAgICAgICBmdW5jdGlvbiBmKG4yKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBpLlByb21pc2UoZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgICB2YXIgcjIgPSBuMi5kZWNvbXByZXNzZWQuZ2V0Q29udGVudFdvcmtlcigpLnBpcGUobmV3IGEoKSk7XG4gICAgICAgICAgICByMi5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICAgIHQyKGUzKTtcbiAgICAgICAgICAgIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByMi5zdHJlYW1JbmZvLmNyYzMyICE9PSBuMi5kZWNvbXByZXNzZWQuY3JjMzIgPyB0MihuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogQ1JDMzIgbWlzbWF0Y2hcIikpIDogZTIoKTtcbiAgICAgICAgICAgIH0pLnJlc3VtZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCBvKSB7XG4gICAgICAgICAgdmFyIGggPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBvID0gdS5leHRlbmQobyB8fCB7fSwgeyBiYXNlNjQ6IGZhbHNlLCBjaGVja0NSQzMyOiBmYWxzZSwgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiBmYWxzZSwgY3JlYXRlRm9sZGVyczogZmFsc2UsIGRlY29kZUZpbGVOYW1lOiBuLnV0ZjhkZWNvZGUgfSksIGwuaXNOb2RlICYmIGwuaXNTdHJlYW0oZTIpID8gaS5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKSA6IHUucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGUyLCB0cnVlLCBvLm9wdGltaXplZEJpbmFyeVN0cmluZywgby5iYXNlNjQpLnRoZW4oZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHZhciB0MiA9IG5ldyBzKG8pO1xuICAgICAgICAgICAgcmV0dXJuIHQyLmxvYWQoZTMpLCB0MjtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSBbaS5Qcm9taXNlLnJlc29sdmUoZTMpXSwgcjIgPSBlMy5maWxlcztcbiAgICAgICAgICAgIGlmIChvLmNoZWNrQ1JDMzIpIGZvciAodmFyIG4yID0gMDsgbjIgPCByMi5sZW5ndGg7IG4yKyspIHQyLnB1c2goZihyMltuMl0pKTtcbiAgICAgICAgICAgIHJldHVybiBpLlByb21pc2UuYWxsKHQyKTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0MiA9IGUzLnNoaWZ0KCksIHIyID0gdDIuZmlsZXMsIG4yID0gMDsgbjIgPCByMi5sZW5ndGg7IG4yKyspIHtcbiAgICAgICAgICAgICAgdmFyIGkyID0gcjJbbjJdLCBzMiA9IGkyLmZpbGVOYW1lU3RyLCBhMiA9IHUucmVzb2x2ZShpMi5maWxlTmFtZVN0cik7XG4gICAgICAgICAgICAgIGguZmlsZShhMiwgaTIuZGVjb21wcmVzc2VkLCB7IGJpbmFyeTogdHJ1ZSwgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLCBkYXRlOiBpMi5kYXRlLCBkaXI6IGkyLmRpciwgY29tbWVudDogaTIuZmlsZUNvbW1lbnRTdHIubGVuZ3RoID8gaTIuZmlsZUNvbW1lbnRTdHIgOiBudWxsLCB1bml4UGVybWlzc2lvbnM6IGkyLnVuaXhQZXJtaXNzaW9ucywgZG9zUGVybWlzc2lvbnM6IGkyLmRvc1Blcm1pc3Npb25zLCBjcmVhdGVGb2xkZXJzOiBvLmNyZWF0ZUZvbGRlcnMgfSksIGkyLmRpciB8fCAoaC5maWxlKGEyKS51bnNhZmVPcmlnaW5hbE5hbWUgPSBzMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdDIuemlwQ29tbWVudC5sZW5ndGggJiYgKGguY29tbWVudCA9IHQyLnppcENvbW1lbnQpLCBoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBcIi4vZXh0ZXJuYWxcIjogNiwgXCIuL25vZGVqc1V0aWxzXCI6IDE0LCBcIi4vc3RyZWFtL0NyYzMyUHJvYmVcIjogMjUsIFwiLi91dGY4XCI6IDMxLCBcIi4vdXRpbHNcIjogMzIsIFwiLi96aXBFbnRyaWVzXCI6IDMzIH1dLCAxMjogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBlKFwiLi4vdXRpbHNcIiksIGkgPSBlKFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7XG4gICAgICAgIGZ1bmN0aW9uIHMoZTIsIHQyKSB7XG4gICAgICAgICAgaS5jYWxsKHRoaXMsIFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIiArIGUyKSwgdGhpcy5fdXBzdHJlYW1FbmRlZCA9IGZhbHNlLCB0aGlzLl9iaW5kU3RyZWFtKHQyKTtcbiAgICAgICAgfVxuICAgICAgICBuLmluaGVyaXRzKHMsIGkpLCBzLnByb3RvdHlwZS5fYmluZFN0cmVhbSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcztcbiAgICAgICAgICAodGhpcy5fc3RyZWFtID0gZTIpLnBhdXNlKCksIGUyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgdDIucHVzaCh7IGRhdGE6IGUzLCBtZXRhOiB7IHBlcmNlbnQ6IDAgfSB9KTtcbiAgICAgICAgICB9KS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICB0Mi5pc1BhdXNlZCA/IHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlMyA6IHQyLmVycm9yKGUzKTtcbiAgICAgICAgICB9KS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHQyLmlzUGF1c2VkID8gdDIuX3Vwc3RyZWFtRW5kZWQgPSB0cnVlIDogdDIuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICEhaS5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSAmJiAodGhpcy5fc3RyZWFtLnBhdXNlKCksIHRydWUpO1xuICAgICAgICB9LCBzLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gISFpLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSAmJiAodGhpcy5fdXBzdHJlYW1FbmRlZCA/IHRoaXMuZW5kKCkgOiB0aGlzLl9zdHJlYW0ucmVzdW1lKCksIHRydWUpO1xuICAgICAgICB9LCB0LmV4cG9ydHMgPSBzO1xuICAgICAgfSwgeyBcIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyXCI6IDI4LCBcIi4uL3V0aWxzXCI6IDMyIH1dLCAxMzogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIGkgPSBlKFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlO1xuICAgICAgICBmdW5jdGlvbiBuKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICBpLmNhbGwodGhpcywgdDIpLCB0aGlzLl9oZWxwZXIgPSBlMjtcbiAgICAgICAgICB2YXIgbjIgPSB0aGlzO1xuICAgICAgICAgIGUyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbihlMywgdDMpIHtcbiAgICAgICAgICAgIG4yLnB1c2goZTMpIHx8IG4yLl9oZWxwZXIucGF1c2UoKSwgcjIgJiYgcjIodDMpO1xuICAgICAgICAgIH0pLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIG4yLmVtaXQoXCJlcnJvclwiLCBlMyk7XG4gICAgICAgICAgfSkub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuMi5wdXNoKG51bGwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGUoXCIuLi91dGlsc1wiKS5pbmhlcml0cyhuLCBpKSwgbi5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9oZWxwZXIucmVzdW1lKCk7XG4gICAgICAgIH0sIHQuZXhwb3J0cyA9IG47XG4gICAgICB9LCB7IFwiLi4vdXRpbHNcIjogMzIsIFwicmVhZGFibGUtc3RyZWFtXCI6IDE2IH1dLCAxNDogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdC5leHBvcnRzID0geyBpc05vZGU6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEJ1ZmZlciwgbmV3QnVmZmVyRnJvbTogZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20pIHJldHVybiBCdWZmZXIuZnJvbShlMiwgdDIpO1xuICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBlMikgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJkYXRhXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihlMiwgdDIpO1xuICAgICAgICB9LCBhbGxvY0J1ZmZlcjogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBpZiAoQnVmZmVyLmFsbG9jKSByZXR1cm4gQnVmZmVyLmFsbG9jKGUyKTtcbiAgICAgICAgICB2YXIgdDIgPSBuZXcgQnVmZmVyKGUyKTtcbiAgICAgICAgICByZXR1cm4gdDIuZmlsbCgwKSwgdDI7XG4gICAgICAgIH0sIGlzQnVmZmVyOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZTIpO1xuICAgICAgICB9LCBpc1N0cmVhbTogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gZTIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlMi5vbiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUyLnBhdXNlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZTIucmVzdW1lO1xuICAgICAgICB9IH07XG4gICAgICB9LCB7fV0sIDE1OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICBmdW5jdGlvbiBzKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICB2YXIgbjIsIGkyID0gdS5nZXRUeXBlT2YodDIpLCBzMiA9IHUuZXh0ZW5kKHIyIHx8IHt9LCBmKTtcbiAgICAgICAgICBzMi5kYXRlID0gczIuZGF0ZSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgbnVsbCAhPT0gczIuY29tcHJlc3Npb24gJiYgKHMyLmNvbXByZXNzaW9uID0gczIuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKSksIFwic3RyaW5nXCIgPT0gdHlwZW9mIHMyLnVuaXhQZXJtaXNzaW9ucyAmJiAoczIudW5peFBlcm1pc3Npb25zID0gcGFyc2VJbnQoczIudW5peFBlcm1pc3Npb25zLCA4KSksIHMyLnVuaXhQZXJtaXNzaW9ucyAmJiAxNjM4NCAmIHMyLnVuaXhQZXJtaXNzaW9ucyAmJiAoczIuZGlyID0gdHJ1ZSksIHMyLmRvc1Blcm1pc3Npb25zICYmIDE2ICYgczIuZG9zUGVybWlzc2lvbnMgJiYgKHMyLmRpciA9IHRydWUpLCBzMi5kaXIgJiYgKGUyID0gZyhlMikpLCBzMi5jcmVhdGVGb2xkZXJzICYmIChuMiA9IF8oZTIpKSAmJiBiLmNhbGwodGhpcywgbjIsIHRydWUpO1xuICAgICAgICAgIHZhciBhMiA9IFwic3RyaW5nXCIgPT09IGkyICYmIGZhbHNlID09PSBzMi5iaW5hcnkgJiYgZmFsc2UgPT09IHMyLmJhc2U2NDtcbiAgICAgICAgICByMiAmJiB2b2lkIDAgIT09IHIyLmJpbmFyeSB8fCAoczIuYmluYXJ5ID0gIWEyKSwgKHQyIGluc3RhbmNlb2YgYyAmJiAwID09PSB0Mi51bmNvbXByZXNzZWRTaXplIHx8IHMyLmRpciB8fCAhdDIgfHwgMCA9PT0gdDIubGVuZ3RoKSAmJiAoczIuYmFzZTY0ID0gZmFsc2UsIHMyLmJpbmFyeSA9IHRydWUsIHQyID0gXCJcIiwgczIuY29tcHJlc3Npb24gPSBcIlNUT1JFXCIsIGkyID0gXCJzdHJpbmdcIik7XG4gICAgICAgICAgdmFyIG8yID0gbnVsbDtcbiAgICAgICAgICBvMiA9IHQyIGluc3RhbmNlb2YgYyB8fCB0MiBpbnN0YW5jZW9mIGwgPyB0MiA6IHAuaXNOb2RlICYmIHAuaXNTdHJlYW0odDIpID8gbmV3IG0oZTIsIHQyKSA6IHUucHJlcGFyZUNvbnRlbnQoZTIsIHQyLCBzMi5iaW5hcnksIHMyLm9wdGltaXplZEJpbmFyeVN0cmluZywgczIuYmFzZTY0KTtcbiAgICAgICAgICB2YXIgaDIgPSBuZXcgZChlMiwgbzIsIHMyKTtcbiAgICAgICAgICB0aGlzLmZpbGVzW2UyXSA9IGgyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gZShcIi4vdXRmOFwiKSwgdSA9IGUoXCIuL3V0aWxzXCIpLCBsID0gZShcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIiksIGEgPSBlKFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpLCBmID0gZShcIi4vZGVmYXVsdHNcIiksIGMgPSBlKFwiLi9jb21wcmVzc2VkT2JqZWN0XCIpLCBkID0gZShcIi4vemlwT2JqZWN0XCIpLCBvID0gZShcIi4vZ2VuZXJhdGVcIiksIHAgPSBlKFwiLi9ub2RlanNVdGlsc1wiKSwgbSA9IGUoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIiksIF8gPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIFwiL1wiID09PSBlMi5zbGljZSgtMSkgJiYgKGUyID0gZTIuc3Vic3RyaW5nKDAsIGUyLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICB2YXIgdDIgPSBlMi5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICAgICAgcmV0dXJuIDAgPCB0MiA/IGUyLnN1YnN0cmluZygwLCB0MikgOiBcIlwiO1xuICAgICAgICB9LCBnID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gXCIvXCIgIT09IGUyLnNsaWNlKC0xKSAmJiAoZTIgKz0gXCIvXCIpLCBlMjtcbiAgICAgICAgfSwgYiA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiB0MiA9IHZvaWQgMCAhPT0gdDIgPyB0MiA6IGYuY3JlYXRlRm9sZGVycywgZTIgPSBnKGUyKSwgdGhpcy5maWxlc1tlMl0gfHwgcy5jYWxsKHRoaXMsIGUyLCBudWxsLCB7IGRpcjogdHJ1ZSwgY3JlYXRlRm9sZGVyczogdDIgfSksIHRoaXMuZmlsZXNbZTJdO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBoKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSB7IGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgICAgICB9LCBmb3JFYWNoOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIsIG4yO1xuICAgICAgICAgIGZvciAodDIgaW4gdGhpcy5maWxlcykgbjIgPSB0aGlzLmZpbGVzW3QyXSwgKHIyID0gdDIuc2xpY2UodGhpcy5yb290Lmxlbmd0aCwgdDIubGVuZ3RoKSkgJiYgdDIuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCAmJiBlMihyMiwgbjIpO1xuICAgICAgICB9LCBmaWx0ZXI6IGZ1bmN0aW9uKHIyKSB7XG4gICAgICAgICAgdmFyIG4yID0gW107XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICAgIHIyKGUyLCB0MikgJiYgbjIucHVzaCh0Mik7XG4gICAgICAgICAgfSksIG4yO1xuICAgICAgICB9LCBmaWxlOiBmdW5jdGlvbihlMiwgdDIsIHIyKSB7XG4gICAgICAgICAgaWYgKDEgIT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlMiA9IHRoaXMucm9vdCArIGUyLCBzLmNhbGwodGhpcywgZTIsIHQyLCByMiksIHRoaXM7XG4gICAgICAgICAgaWYgKGgoZTIpKSB7XG4gICAgICAgICAgICB2YXIgbjIgPSBlMjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihlMywgdDMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICF0My5kaXIgJiYgbjIudGVzdChlMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGkyID0gdGhpcy5maWxlc1t0aGlzLnJvb3QgKyBlMl07XG4gICAgICAgICAgcmV0dXJuIGkyICYmICFpMi5kaXIgPyBpMiA6IG51bGw7XG4gICAgICAgIH0sIGZvbGRlcjogZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICBpZiAoIXIyKSByZXR1cm4gdGhpcztcbiAgICAgICAgICBpZiAoaChyMikpIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihlMywgdDMpIHtcbiAgICAgICAgICAgIHJldHVybiB0My5kaXIgJiYgcjIudGVzdChlMyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGUyID0gdGhpcy5yb290ICsgcjIsIHQyID0gYi5jYWxsKHRoaXMsIGUyKSwgbjIgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgcmV0dXJuIG4yLnJvb3QgPSB0Mi5uYW1lLCBuMjtcbiAgICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbihyMikge1xuICAgICAgICAgIHIyID0gdGhpcy5yb290ICsgcjI7XG4gICAgICAgICAgdmFyIGUyID0gdGhpcy5maWxlc1tyMl07XG4gICAgICAgICAgaWYgKGUyIHx8IChcIi9cIiAhPT0gcjIuc2xpY2UoLTEpICYmIChyMiArPSBcIi9cIiksIGUyID0gdGhpcy5maWxlc1tyMl0pLCBlMiAmJiAhZTIuZGlyKSBkZWxldGUgdGhpcy5maWxlc1tyMl07XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciB0MiA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGUzLCB0Mykge1xuICAgICAgICAgICAgcmV0dXJuIHQzLm5hbWUuc2xpY2UoMCwgcjIubGVuZ3RoKSA9PT0gcjI7XG4gICAgICAgICAgfSksIG4yID0gMDsgbjIgPCB0Mi5sZW5ndGg7IG4yKyspIGRlbGV0ZSB0aGlzLmZpbGVzW3QyW24yXS5uYW1lXTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSwgZ2VuZXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgICAgICB9LCBnZW5lcmF0ZUludGVybmFsU3RyZWFtOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIgPSB7fTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChyMiA9IHUuZXh0ZW5kKGUyIHx8IHt9LCB7IHN0cmVhbUZpbGVzOiBmYWxzZSwgY29tcHJlc3Npb246IFwiU1RPUkVcIiwgY29tcHJlc3Npb25PcHRpb25zOiBudWxsLCB0eXBlOiBcIlwiLCBwbGF0Zm9ybTogXCJET1NcIiwgY29tbWVudDogbnVsbCwgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vemlwXCIsIGVuY29kZUZpbGVOYW1lOiBpLnV0ZjhlbmNvZGUgfSkpLnR5cGUgPSByMi50eXBlLnRvTG93ZXJDYXNlKCksIHIyLmNvbXByZXNzaW9uID0gcjIuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKSwgXCJiaW5hcnlzdHJpbmdcIiA9PT0gcjIudHlwZSAmJiAocjIudHlwZSA9IFwic3RyaW5nXCIpLCAhcjIudHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIHUuY2hlY2tTdXBwb3J0KHIyLnR5cGUpLCBcImRhcndpblwiICE9PSByMi5wbGF0Zm9ybSAmJiBcImZyZWVic2RcIiAhPT0gcjIucGxhdGZvcm0gJiYgXCJsaW51eFwiICE9PSByMi5wbGF0Zm9ybSAmJiBcInN1bm9zXCIgIT09IHIyLnBsYXRmb3JtIHx8IChyMi5wbGF0Zm9ybSA9IFwiVU5JWFwiKSwgXCJ3aW4zMlwiID09PSByMi5wbGF0Zm9ybSAmJiAocjIucGxhdGZvcm0gPSBcIkRPU1wiKTtcbiAgICAgICAgICAgIHZhciBuMiA9IHIyLmNvbW1lbnQgfHwgdGhpcy5jb21tZW50IHx8IFwiXCI7XG4gICAgICAgICAgICB0MiA9IG8uZ2VuZXJhdGVXb3JrZXIodGhpcywgcjIsIG4yKTtcbiAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgKHQyID0gbmV3IGwoXCJlcnJvclwiKSkuZXJyb3IoZTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IGEodDIsIHIyLnR5cGUgfHwgXCJzdHJpbmdcIiwgcjIubWltZVR5cGUpO1xuICAgICAgICB9LCBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKGUyKS5hY2N1bXVsYXRlKHQyKTtcbiAgICAgICAgfSwgZ2VuZXJhdGVOb2RlU3RyZWFtOiBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICByZXR1cm4gKGUyID0gZTIgfHwge30pLnR5cGUgfHwgKGUyLnR5cGUgPSBcIm5vZGVidWZmZXJcIiksIHRoaXMuZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbShlMikudG9Ob2RlanNTdHJlYW0odDIpO1xuICAgICAgICB9IH07XG4gICAgICAgIHQuZXhwb3J0cyA9IG47XG4gICAgICB9LCB7IFwiLi9jb21wcmVzc2VkT2JqZWN0XCI6IDIsIFwiLi9kZWZhdWx0c1wiOiA1LCBcIi4vZ2VuZXJhdGVcIjogOSwgXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIjogMTIsIFwiLi9ub2RlanNVdGlsc1wiOiAxNCwgXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCI6IDI4LCBcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiOiAyOSwgXCIuL3V0ZjhcIjogMzEsIFwiLi91dGlsc1wiOiAzMiwgXCIuL3ppcE9iamVjdFwiOiAzNSB9XSwgMTY6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHQuZXhwb3J0cyA9IGUoXCJzdHJlYW1cIik7XG4gICAgICB9LCB7IHN0cmVhbTogdm9pZCAwIH1dLCAxNzogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBlKFwiLi9EYXRhUmVhZGVyXCIpO1xuICAgICAgICBmdW5jdGlvbiBpKGUyKSB7XG4gICAgICAgICAgbi5jYWxsKHRoaXMsIGUyKTtcbiAgICAgICAgICBmb3IgKHZhciB0MiA9IDA7IHQyIDwgdGhpcy5kYXRhLmxlbmd0aDsgdDIrKykgZTJbdDJdID0gMjU1ICYgZTJbdDJdO1xuICAgICAgICB9XG4gICAgICAgIGUoXCIuLi91dGlsc1wiKS5pbmhlcml0cyhpLCBuKSwgaS5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuemVybyArIGUyXTtcbiAgICAgICAgfSwgaS5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGZvciAodmFyIHQyID0gZTIuY2hhckNvZGVBdCgwKSwgcjIgPSBlMi5jaGFyQ29kZUF0KDEpLCBuMiA9IGUyLmNoYXJDb2RlQXQoMiksIGkyID0gZTIuY2hhckNvZGVBdCgzKSwgcyA9IHRoaXMubGVuZ3RoIC0gNDsgMCA8PSBzOyAtLXMpIGlmICh0aGlzLmRhdGFbc10gPT09IHQyICYmIHRoaXMuZGF0YVtzICsgMV0gPT09IHIyICYmIHRoaXMuZGF0YVtzICsgMl0gPT09IG4yICYmIHRoaXMuZGF0YVtzICsgM10gPT09IGkyKSByZXR1cm4gcyAtIHRoaXMuemVybztcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gZTIuY2hhckNvZGVBdCgwKSwgcjIgPSBlMi5jaGFyQ29kZUF0KDEpLCBuMiA9IGUyLmNoYXJDb2RlQXQoMiksIGkyID0gZTIuY2hhckNvZGVBdCgzKSwgcyA9IHRoaXMucmVhZERhdGEoNCk7XG4gICAgICAgICAgcmV0dXJuIHQyID09PSBzWzBdICYmIHIyID09PSBzWzFdICYmIG4yID09PSBzWzJdICYmIGkyID09PSBzWzNdO1xuICAgICAgICB9LCBpLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tPZmZzZXQoZTIpLCAwID09PSBlMikgcmV0dXJuIFtdO1xuICAgICAgICAgIHZhciB0MiA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgZTIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ICs9IGUyLCB0MjtcbiAgICAgICAgfSwgdC5leHBvcnRzID0gaTtcbiAgICAgIH0sIHsgXCIuLi91dGlsc1wiOiAzMiwgXCIuL0RhdGFSZWFkZXJcIjogMTggfV0sIDE4OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgbiA9IGUoXCIuLi91dGlsc1wiKTtcbiAgICAgICAgZnVuY3Rpb24gaShlMikge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IGUyLCB0aGlzLmxlbmd0aCA9IGUyLmxlbmd0aCwgdGhpcy5pbmRleCA9IDAsIHRoaXMuemVybyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaS5wcm90b3R5cGUgPSB7IGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgZTIpO1xuICAgICAgICB9LCBjaGVja0luZGV4OiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IHRoaXMuemVybyArIGUyIHx8IGUyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIiArIHRoaXMubGVuZ3RoICsgXCIsIGFza2VkIGluZGV4ID0gXCIgKyBlMiArIFwiKS4gQ29ycnVwdGVkIHppcCA/XCIpO1xuICAgICAgICB9LCBzZXRJbmRleDogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrSW5kZXgoZTIpLCB0aGlzLmluZGV4ID0gZTI7XG4gICAgICAgIH0sIHNraXA6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgZTIpO1xuICAgICAgICB9LCBieXRlQXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LCByZWFkSW50OiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIgPSAwO1xuICAgICAgICAgIGZvciAodGhpcy5jaGVja09mZnNldChlMiksIHQyID0gdGhpcy5pbmRleCArIGUyIC0gMTsgdDIgPj0gdGhpcy5pbmRleDsgdDItLSkgcjIgPSAocjIgPDwgOCkgKyB0aGlzLmJ5dGVBdCh0Mik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKz0gZTIsIHIyO1xuICAgICAgICB9LCByZWFkU3RyaW5nOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiBuLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHRoaXMucmVhZERhdGEoZTIpKTtcbiAgICAgICAgfSwgcmVhZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LCBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIHJlYWRBbmRDaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIHJlYWREYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIgPSB0aGlzLnJlYWRJbnQoNCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5ODAgKyAoZTIgPj4gMjUgJiAxMjcpLCAoZTIgPj4gMjEgJiAxNSkgLSAxLCBlMiA+PiAxNiAmIDMxLCBlMiA+PiAxMSAmIDMxLCBlMiA+PiA1ICYgNjMsICgzMSAmIGUyKSA8PCAxKSk7XG4gICAgICAgIH0gfSwgdC5leHBvcnRzID0gaTtcbiAgICAgIH0sIHsgXCIuLi91dGlsc1wiOiAzMiB9XSwgMTk6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vVWludDhBcnJheVJlYWRlclwiKTtcbiAgICAgICAgZnVuY3Rpb24gaShlMikge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBlMik7XG4gICAgICAgIH1cbiAgICAgICAgZShcIi4uL3V0aWxzXCIpLmluaGVyaXRzKGksIG4pLCBpLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5jaGVja09mZnNldChlMik7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBlMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggKz0gZTIsIHQyO1xuICAgICAgICB9LCB0LmV4cG9ydHMgPSBpO1xuICAgICAgfSwgeyBcIi4uL3V0aWxzXCI6IDMyLCBcIi4vVWludDhBcnJheVJlYWRlclwiOiAyMSB9XSwgMjA6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vRGF0YVJlYWRlclwiKTtcbiAgICAgICAgZnVuY3Rpb24gaShlMikge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBlMik7XG4gICAgICAgIH1cbiAgICAgICAgZShcIi4uL3V0aWxzXCIpLmluaGVyaXRzKGksIG4pLCBpLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnplcm8gKyBlMik7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKGUyKSAtIHRoaXMuemVybztcbiAgICAgICAgfSwgaS5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gZTIgPT09IHRoaXMucmVhZERhdGEoNCk7XG4gICAgICAgIH0sIGkucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KGUyKTtcbiAgICAgICAgICB2YXIgdDIgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIGUyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCArPSBlMiwgdDI7XG4gICAgICAgIH0sIHQuZXhwb3J0cyA9IGk7XG4gICAgICB9LCB7IFwiLi4vdXRpbHNcIjogMzIsIFwiLi9EYXRhUmVhZGVyXCI6IDE4IH1dLCAyMTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBlKFwiLi9BcnJheVJlYWRlclwiKTtcbiAgICAgICAgZnVuY3Rpb24gaShlMikge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBlMik7XG4gICAgICAgIH1cbiAgICAgICAgZShcIi4uL3V0aWxzXCIpLmluaGVyaXRzKGksIG4pLCBpLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tPZmZzZXQoZTIpLCAwID09PSBlMikgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgIHZhciB0MiA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgZTIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ICs9IGUyLCB0MjtcbiAgICAgICAgfSwgdC5leHBvcnRzID0gaTtcbiAgICAgIH0sIHsgXCIuLi91dGlsc1wiOiAzMiwgXCIuL0FycmF5UmVhZGVyXCI6IDE3IH1dLCAyMjogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBlKFwiLi4vdXRpbHNcIiksIGkgPSBlKFwiLi4vc3VwcG9ydFwiKSwgcyA9IGUoXCIuL0FycmF5UmVhZGVyXCIpLCBhID0gZShcIi4vU3RyaW5nUmVhZGVyXCIpLCBvID0gZShcIi4vTm9kZUJ1ZmZlclJlYWRlclwiKSwgaCA9IGUoXCIuL1VpbnQ4QXJyYXlSZWFkZXJcIik7XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gbi5nZXRUeXBlT2YoZTIpO1xuICAgICAgICAgIHJldHVybiBuLmNoZWNrU3VwcG9ydCh0MiksIFwic3RyaW5nXCIgIT09IHQyIHx8IGkudWludDhhcnJheSA/IFwibm9kZWJ1ZmZlclwiID09PSB0MiA/IG5ldyBvKGUyKSA6IGkudWludDhhcnJheSA/IG5ldyBoKG4udHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGUyKSkgOiBuZXcgcyhuLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZTIpKSA6IG5ldyBhKGUyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHsgXCIuLi9zdXBwb3J0XCI6IDMwLCBcIi4uL3V0aWxzXCI6IDMyLCBcIi4vQXJyYXlSZWFkZXJcIjogMTcsIFwiLi9Ob2RlQnVmZmVyUmVhZGVyXCI6IDE5LCBcIi4vU3RyaW5nUmVhZGVyXCI6IDIwLCBcIi4vVWludDhBcnJheVJlYWRlclwiOiAyMSB9XSwgMjM6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHIuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXHUwMDAzXHUwMDA0XCIsIHIuQ0VOVFJBTF9GSUxFX0hFQURFUiA9IFwiUEtcdTAwMDFcdTAwMDJcIiwgci5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgPSBcIlBLXHUwMDA1XHUwMDA2XCIsIHIuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcdTAwMDZcXHgwN1wiLCByLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcdTAwMDZcdTAwMDZcIiwgci5EQVRBX0RFU0NSSVBUT1IgPSBcIlBLXFx4MDdcXGJcIjtcbiAgICAgIH0sIHt9XSwgMjQ6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gZShcIi4vR2VuZXJpY1dvcmtlclwiKSwgaSA9IGUoXCIuLi91dGlsc1wiKTtcbiAgICAgICAgZnVuY3Rpb24gcyhlMikge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBlMiksIHRoaXMuZGVzdFR5cGUgPSBlMjtcbiAgICAgICAgfVxuICAgICAgICBpLmluaGVyaXRzKHMsIG4pLCBzLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMucHVzaCh7IGRhdGE6IGkudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgZTIuZGF0YSksIG1ldGE6IGUyLm1ldGEgfSk7XG4gICAgICAgIH0sIHQuZXhwb3J0cyA9IHM7XG4gICAgICB9LCB7IFwiLi4vdXRpbHNcIjogMzIsIFwiLi9HZW5lcmljV29ya2VyXCI6IDI4IH1dLCAyNTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSBlKFwiLi9HZW5lcmljV29ya2VyXCIpLCBpID0gZShcIi4uL2NyYzMyXCIpO1xuICAgICAgICBmdW5jdGlvbiBzKCkge1xuICAgICAgICAgIG4uY2FsbCh0aGlzLCBcIkNyYzMyUHJvYmVcIiksIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlKFwiLi4vdXRpbHNcIikuaW5oZXJpdHMocywgbiksIHMucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gaShlMi5kYXRhLCB0aGlzLnN0cmVhbUluZm8uY3JjMzIgfHwgMCksIHRoaXMucHVzaChlMik7XG4gICAgICAgIH0sIHQuZXhwb3J0cyA9IHM7XG4gICAgICB9LCB7IFwiLi4vY3JjMzJcIjogNCwgXCIuLi91dGlsc1wiOiAzMiwgXCIuL0dlbmVyaWNXb3JrZXJcIjogMjggfV0sIDI2OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgbiA9IGUoXCIuLi91dGlsc1wiKSwgaSA9IGUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG4gICAgICAgIGZ1bmN0aW9uIHMoZTIpIHtcbiAgICAgICAgICBpLmNhbGwodGhpcywgXCJEYXRhTGVuZ3RoUHJvYmUgZm9yIFwiICsgZTIpLCB0aGlzLnByb3BOYW1lID0gZTIsIHRoaXMud2l0aFN0cmVhbUluZm8oZTIsIDApO1xuICAgICAgICB9XG4gICAgICAgIG4uaW5oZXJpdHMocywgaSksIHMucHJvdG90eXBlLnByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKGUyKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gfHwgMDtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSA9IHQyICsgZTIuZGF0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsIGUyKTtcbiAgICAgICAgfSwgdC5leHBvcnRzID0gcztcbiAgICAgIH0sIHsgXCIuLi91dGlsc1wiOiAzMiwgXCIuL0dlbmVyaWNXb3JrZXJcIjogMjggfV0sIDI3OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgbiA9IGUoXCIuLi91dGlsc1wiKSwgaSA9IGUoXCIuL0dlbmVyaWNXb3JrZXJcIik7XG4gICAgICAgIGZ1bmN0aW9uIHMoZTIpIHtcbiAgICAgICAgICBpLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgICAgICAgIHZhciB0MiA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5kYXRhSXNSZWFkeSA9IGZhbHNlLCB0aGlzLmluZGV4ID0gMCwgdGhpcy5tYXggPSAwLCB0aGlzLmRhdGEgPSBudWxsLCB0aGlzLnR5cGUgPSBcIlwiLCB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2UsIGUyLnRoZW4oZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHQyLmRhdGFJc1JlYWR5ID0gdHJ1ZSwgdDIuZGF0YSA9IGUzLCB0Mi5tYXggPSBlMyAmJiBlMy5sZW5ndGggfHwgMCwgdDIudHlwZSA9IG4uZ2V0VHlwZU9mKGUzKSwgdDIuaXNQYXVzZWQgfHwgdDIuX3RpY2tBbmRSZXBlYXQoKTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgdDIuZXJyb3IoZTMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG4uaW5oZXJpdHMocywgaSksIHMucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpLnByb3RvdHlwZS5jbGVhblVwLmNhbGwodGhpcyksIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhIWkucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpICYmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5ICYmICh0aGlzLl90aWNrU2NoZWR1bGVkID0gdHJ1ZSwgbi5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcykpLCB0cnVlKTtcbiAgICAgICAgfSwgcy5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2UsIHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkIHx8ICh0aGlzLl90aWNrKCksIHRoaXMuaXNGaW5pc2hlZCB8fCAobi5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyksIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlKSk7XG4gICAgICAgIH0sIHMucHJvdG90eXBlLl90aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNQYXVzZWQgfHwgdGhpcy5pc0ZpbmlzaGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgdmFyIGUyID0gbnVsbCwgdDIgPSBNYXRoLm1pbih0aGlzLm1heCwgdGhpcy5pbmRleCArIDE2Mzg0KTtcbiAgICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgZTIgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIHQyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICBlMiA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCB0Mik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgICBlMiA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCB0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID0gdDIsIHRoaXMucHVzaCh7IGRhdGE6IGUyLCBtZXRhOiB7IHBlcmNlbnQ6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMCB9IH0pO1xuICAgICAgICB9LCB0LmV4cG9ydHMgPSBzO1xuICAgICAgfSwgeyBcIi4uL3V0aWxzXCI6IDMyLCBcIi4vR2VuZXJpY1dvcmtlclwiOiAyOCB9XSwgMjg6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIGZ1bmN0aW9uIG4oZTIpIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBlMiB8fCBcImRlZmF1bHRcIiwgdGhpcy5zdHJlYW1JbmZvID0ge30sIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBudWxsLCB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9LCB0aGlzLmlzUGF1c2VkID0gdHJ1ZSwgdGhpcy5pc0ZpbmlzaGVkID0gZmFsc2UsIHRoaXMuaXNMb2NrZWQgPSBmYWxzZSwgdGhpcy5fbGlzdGVuZXJzID0geyBkYXRhOiBbXSwgZW5kOiBbXSwgZXJyb3I6IFtdIH0sIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG4ucHJvdG90eXBlID0geyBwdXNoOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZTIpO1xuICAgICAgICB9LCBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiKSwgdGhpcy5jbGVhblVwKCksIHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sIGVycm9yOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiAhdGhpcy5pc0ZpbmlzaGVkICYmICh0aGlzLmlzUGF1c2VkID8gdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGUyIDogKHRoaXMuaXNGaW5pc2hlZCA9IHRydWUsIHRoaXMuZW1pdChcImVycm9yXCIsIGUyKSwgdGhpcy5wcmV2aW91cyAmJiB0aGlzLnByZXZpb3VzLmVycm9yKGUyKSwgdGhpcy5jbGVhblVwKCkpLCB0cnVlKTtcbiAgICAgICAgfSwgb246IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZTJdLnB1c2godDIpLCB0aGlzO1xuICAgICAgICB9LCBjbGVhblVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsLCB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfSwgZW1pdDogZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tlMl0pIGZvciAodmFyIHIyID0gMDsgcjIgPCB0aGlzLl9saXN0ZW5lcnNbZTJdLmxlbmd0aDsgcjIrKykgdGhpcy5fbGlzdGVuZXJzW2UyXVtyMl0uY2FsbCh0aGlzLCB0Mik7XG4gICAgICAgIH0sIHBpcGU6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGUyLnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgICAgIH0sIHJlZ2lzdGVyUHJldmlvdXM6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHJlYW0gJ1wiICsgdGhpcyArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO1xuICAgICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IGUyLnN0cmVhbUluZm8sIHRoaXMubWVyZ2VTdHJlYW1JbmZvKCksIHRoaXMucHJldmlvdXMgPSBlMjtcbiAgICAgICAgICB2YXIgdDIgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBlMi5vbihcImRhdGFcIiwgZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHQyLnByb2Nlc3NDaHVuayhlMyk7XG4gICAgICAgICAgfSksIGUyLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdDIuZW5kKCk7XG4gICAgICAgICAgfSksIGUyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHQyLmVycm9yKGUzKTtcbiAgICAgICAgICB9KSwgdGhpcztcbiAgICAgICAgfSwgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiAhdGhpcy5pc0ZpbmlzaGVkICYmICh0aGlzLmlzUGF1c2VkID0gdHJ1ZSwgdGhpcy5wcmV2aW91cyAmJiB0aGlzLnByZXZpb3VzLnBhdXNlKCksIHRydWUpO1xuICAgICAgICB9LCByZXN1bWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YXIgZTIgPSB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVkRXJyb3IgJiYgKHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvciksIGUyID0gdHJ1ZSksIHRoaXMucHJldmlvdXMgJiYgdGhpcy5wcmV2aW91cy5yZXN1bWUoKSwgIWUyO1xuICAgICAgICB9LCBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sIHByb2Nlc3NDaHVuazogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLnB1c2goZTIpO1xuICAgICAgICB9LCB3aXRoU3RyZWFtSW5mbzogZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFTdHJlYW1JbmZvW2UyXSA9IHQyLCB0aGlzLm1lcmdlU3RyZWFtSW5mbygpLCB0aGlzO1xuICAgICAgICB9LCBtZXJnZVN0cmVhbUluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGUyIGluIHRoaXMuZXh0cmFTdHJlYW1JbmZvKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5leHRyYVN0cmVhbUluZm8sIGUyKSAmJiAodGhpcy5zdHJlYW1JbmZvW2UyXSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2UyXSk7XG4gICAgICAgIH0sIGxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZSwgdGhpcy5wcmV2aW91cyAmJiB0aGlzLnByZXZpb3VzLmxvY2soKTtcbiAgICAgICAgfSwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlMiA9IFwiV29ya2VyIFwiICsgdGhpcy5uYW1lO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzID8gdGhpcy5wcmV2aW91cyArIFwiIC0+IFwiICsgZTIgOiBlMjtcbiAgICAgICAgfSB9LCB0LmV4cG9ydHMgPSBuO1xuICAgICAgfSwge31dLCAyOTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIGggPSBlKFwiLi4vdXRpbHNcIiksIGkgPSBlKFwiLi9Db252ZXJ0V29ya2VyXCIpLCBzID0gZShcIi4vR2VuZXJpY1dvcmtlclwiKSwgdSA9IGUoXCIuLi9iYXNlNjRcIiksIG4gPSBlKFwiLi4vc3VwcG9ydFwiKSwgYSA9IGUoXCIuLi9leHRlcm5hbFwiKSwgbyA9IG51bGw7XG4gICAgICAgIGlmIChuLm5vZGVzdHJlYW0pIHRyeSB7XG4gICAgICAgICAgbyA9IGUoXCIuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlclwiKTtcbiAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsKGUyLCBvMikge1xuICAgICAgICAgIHJldHVybiBuZXcgYS5Qcm9taXNlKGZ1bmN0aW9uKHQyLCByMikge1xuICAgICAgICAgICAgdmFyIG4yID0gW10sIGkyID0gZTIuX2ludGVybmFsVHlwZSwgczIgPSBlMi5fb3V0cHV0VHlwZSwgYTIgPSBlMi5fbWltZVR5cGU7XG4gICAgICAgICAgICBlMi5vbihcImRhdGFcIiwgZnVuY3Rpb24oZTMsIHQzKSB7XG4gICAgICAgICAgICAgIG4yLnB1c2goZTMpLCBvMiAmJiBvMih0Myk7XG4gICAgICAgICAgICB9KS5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICAgIG4yID0gW10sIHIyKGUzKTtcbiAgICAgICAgICAgIH0pLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBlMyA9IGZ1bmN0aW9uKGU0LCB0MywgcjMpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZTQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaC5uZXdCbG9iKGgudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLCB0MyksIHIzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1LmVuY29kZSh0Myk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgudHJhbnNmb3JtVG8oZTQsIHQzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KHMyLCBmdW5jdGlvbihlNCwgdDMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByMywgbjMgPSAwLCBpMyA9IG51bGwsIHMzID0gMDtcbiAgICAgICAgICAgICAgICAgIGZvciAocjMgPSAwOyByMyA8IHQzLmxlbmd0aDsgcjMrKykgczMgKz0gdDNbcjNdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZTQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0My5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgdDMpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaTMgPSBuZXcgVWludDhBcnJheShzMyksIHIzID0gMDsgcjMgPCB0My5sZW5ndGg7IHIzKyspIGkzLnNldCh0M1tyM10sIG4zKSwgbjMgKz0gdDNbcjNdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQodDMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICsgZTQgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShpMiwgbjIpLCBhMik7XG4gICAgICAgICAgICAgICAgdDIoZTMpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlNCkge1xuICAgICAgICAgICAgICAgIHIyKGU0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuMiA9IFtdO1xuICAgICAgICAgICAgfSkucmVzdW1lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZihlMiwgdDIsIHIyKSB7XG4gICAgICAgICAgdmFyIG4yID0gdDI7XG4gICAgICAgICAgc3dpdGNoICh0Mikge1xuICAgICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICAgICAgICBuMiA9IFwidWludDhhcnJheVwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgICAgICAgICAgbjIgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxUeXBlID0gbjIsIHRoaXMuX291dHB1dFR5cGUgPSB0MiwgdGhpcy5fbWltZVR5cGUgPSByMiwgaC5jaGVja1N1cHBvcnQobjIpLCB0aGlzLl93b3JrZXIgPSBlMi5waXBlKG5ldyBpKG4yKSksIGUyLmxvY2soKTtcbiAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IHMoXCJlcnJvclwiKSwgdGhpcy5fd29ya2VyLmVycm9yKGUzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZi5wcm90b3R5cGUgPSB7IGFjY3VtdWxhdGU6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGwodGhpcywgZTIpO1xuICAgICAgICB9LCBvbjogZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gXCJkYXRhXCIgPT09IGUyID8gdGhpcy5fd29ya2VyLm9uKGUyLCBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgdDIuY2FsbChyMiwgZTMuZGF0YSwgZTMubWV0YSk7XG4gICAgICAgICAgfSkgOiB0aGlzLl93b3JrZXIub24oZTIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaC5kZWxheSh0MiwgYXJndW1lbnRzLCByMik7XG4gICAgICAgICAgfSksIHRoaXM7XG4gICAgICAgIH0sIHJlc3VtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGguZGVsYXkodGhpcy5fd29ya2VyLnJlc3VtZSwgW10sIHRoaXMuX3dvcmtlciksIHRoaXM7XG4gICAgICAgIH0sIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyLnBhdXNlKCksIHRoaXM7XG4gICAgICAgIH0sIHRvTm9kZWpzU3RyZWFtOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGlmIChoLmNoZWNrU3VwcG9ydChcIm5vZGVzdHJlYW1cIiksIFwibm9kZWJ1ZmZlclwiICE9PSB0aGlzLl9vdXRwdXRUeXBlKSB0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBtZXRob2RcIik7XG4gICAgICAgICAgcmV0dXJuIG5ldyBvKHRoaXMsIHsgb2JqZWN0TW9kZTogXCJub2RlYnVmZmVyXCIgIT09IHRoaXMuX291dHB1dFR5cGUgfSwgZTIpO1xuICAgICAgICB9IH0sIHQuZXhwb3J0cyA9IGY7XG4gICAgICB9LCB7IFwiLi4vYmFzZTY0XCI6IDEsIFwiLi4vZXh0ZXJuYWxcIjogNiwgXCIuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlclwiOiAxMywgXCIuLi9zdXBwb3J0XCI6IDMwLCBcIi4uL3V0aWxzXCI6IDMyLCBcIi4vQ29udmVydFdvcmtlclwiOiAyNCwgXCIuL0dlbmVyaWNXb3JrZXJcIjogMjggfV0sIDMwOiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICBpZiAoci5iYXNlNjQgPSB0cnVlLCByLmFycmF5ID0gdHJ1ZSwgci5zdHJpbmcgPSB0cnVlLCByLmFycmF5YnVmZmVyID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQXJyYXlCdWZmZXIgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgVWludDhBcnJheSwgci5ub2RlYnVmZmVyID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgQnVmZmVyLCByLnVpbnQ4YXJyYXkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBVaW50OEFycmF5LCBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBBcnJheUJ1ZmZlcikgci5ibG9iID0gZmFsc2U7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByLmJsb2IgPSAwID09PSBuZXcgQmxvYihbbl0sIHsgdHlwZTogXCJhcHBsaWNhdGlvbi96aXBcIiB9KS5zaXplO1xuICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgaSA9IG5ldyAoc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyKSgpO1xuICAgICAgICAgICAgICBpLmFwcGVuZChuKSwgci5ibG9iID0gMCA9PT0gaS5nZXRCbG9iKFwiYXBwbGljYXRpb24vemlwXCIpLnNpemU7XG4gICAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgICByLmJsb2IgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByLm5vZGVzdHJlYW0gPSAhIWUoXCJyZWFkYWJsZS1zdHJlYW1cIikuUmVhZGFibGU7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgci5ub2Rlc3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sIHsgXCJyZWFkYWJsZS1zdHJlYW1cIjogMTYgfV0sIDMxOiBbZnVuY3Rpb24oZSwgdCwgcykge1xuICAgICAgICBmb3IgKHZhciBvID0gZShcIi4vdXRpbHNcIiksIGggPSBlKFwiLi9zdXBwb3J0XCIpLCByID0gZShcIi4vbm9kZWpzVXRpbHNcIiksIG4gPSBlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKSwgdSA9IG5ldyBBcnJheSgyNTYpLCBpID0gMDsgaSA8IDI1NjsgaSsrKSB1W2ldID0gMjUyIDw9IGkgPyA2IDogMjQ4IDw9IGkgPyA1IDogMjQwIDw9IGkgPyA0IDogMjI0IDw9IGkgPyAzIDogMTkyIDw9IGkgPyAyIDogMTtcbiAgICAgICAgdVsyNTRdID0gdVsyNTRdID0gMTtcbiAgICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgICBuLmNhbGwodGhpcywgXCJ1dGYtOCBkZWNvZGVcIiksIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgICAgbi5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGgubm9kZWJ1ZmZlciA/IHIubmV3QnVmZmVyRnJvbShlMiwgXCJ1dGYtOFwiKSA6IGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICB2YXIgdDIsIHIyLCBuMiwgaTIsIHMyLCBhMiA9IGUzLmxlbmd0aCwgbzIgPSAwO1xuICAgICAgICAgICAgZm9yIChpMiA9IDA7IGkyIDwgYTI7IGkyKyspIDU1Mjk2ID09ICg2NDUxMiAmIChyMiA9IGUzLmNoYXJDb2RlQXQoaTIpKSkgJiYgaTIgKyAxIDwgYTIgJiYgNTYzMjAgPT0gKDY0NTEyICYgKG4yID0gZTMuY2hhckNvZGVBdChpMiArIDEpKSkgJiYgKHIyID0gNjU1MzYgKyAocjIgLSA1NTI5NiA8PCAxMCkgKyAobjIgLSA1NjMyMCksIGkyKyspLCBvMiArPSByMiA8IDEyOCA/IDEgOiByMiA8IDIwNDggPyAyIDogcjIgPCA2NTUzNiA/IDMgOiA0O1xuICAgICAgICAgICAgZm9yICh0MiA9IGgudWludDhhcnJheSA/IG5ldyBVaW50OEFycmF5KG8yKSA6IG5ldyBBcnJheShvMiksIGkyID0gczIgPSAwOyBzMiA8IG8yOyBpMisrKSA1NTI5NiA9PSAoNjQ1MTIgJiAocjIgPSBlMy5jaGFyQ29kZUF0KGkyKSkpICYmIGkyICsgMSA8IGEyICYmIDU2MzIwID09ICg2NDUxMiAmIChuMiA9IGUzLmNoYXJDb2RlQXQoaTIgKyAxKSkpICYmIChyMiA9IDY1NTM2ICsgKHIyIC0gNTUyOTYgPDwgMTApICsgKG4yIC0gNTYzMjApLCBpMisrKSwgcjIgPCAxMjggPyB0MltzMisrXSA9IHIyIDogKHIyIDwgMjA0OCA/IHQyW3MyKytdID0gMTkyIHwgcjIgPj4+IDYgOiAocjIgPCA2NTUzNiA/IHQyW3MyKytdID0gMjI0IHwgcjIgPj4+IDEyIDogKHQyW3MyKytdID0gMjQwIHwgcjIgPj4+IDE4LCB0MltzMisrXSA9IDEyOCB8IHIyID4+PiAxMiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCByMiA+Pj4gNiAmIDYzKSwgdDJbczIrK10gPSAxMjggfCA2MyAmIHIyKTtcbiAgICAgICAgICAgIHJldHVybiB0MjtcbiAgICAgICAgICB9KGUyKTtcbiAgICAgICAgfSwgcy51dGY4ZGVjb2RlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gaC5ub2RlYnVmZmVyID8gby50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgZTIpLnRvU3RyaW5nKFwidXRmLThcIikgOiBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgdmFyIHQyLCByMiwgbjIsIGkyLCBzMiA9IGUzLmxlbmd0aCwgYTIgPSBuZXcgQXJyYXkoMiAqIHMyKTtcbiAgICAgICAgICAgIGZvciAodDIgPSByMiA9IDA7IHQyIDwgczI7ICkgaWYgKChuMiA9IGUzW3QyKytdKSA8IDEyOCkgYTJbcjIrK10gPSBuMjtcbiAgICAgICAgICAgIGVsc2UgaWYgKDQgPCAoaTIgPSB1W24yXSkpIGEyW3IyKytdID0gNjU1MzMsIHQyICs9IGkyIC0gMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKG4yICY9IDIgPT09IGkyID8gMzEgOiAzID09PSBpMiA/IDE1IDogNzsgMSA8IGkyICYmIHQyIDwgczI7ICkgbjIgPSBuMiA8PCA2IHwgNjMgJiBlM1t0MisrXSwgaTItLTtcbiAgICAgICAgICAgICAgMSA8IGkyID8gYTJbcjIrK10gPSA2NTUzMyA6IG4yIDwgNjU1MzYgPyBhMltyMisrXSA9IG4yIDogKG4yIC09IDY1NTM2LCBhMltyMisrXSA9IDU1Mjk2IHwgbjIgPj4gMTAgJiAxMDIzLCBhMltyMisrXSA9IDU2MzIwIHwgMTAyMyAmIG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhMi5sZW5ndGggIT09IHIyICYmIChhMi5zdWJhcnJheSA/IGEyID0gYTIuc3ViYXJyYXkoMCwgcjIpIDogYTIubGVuZ3RoID0gcjIpLCBvLmFwcGx5RnJvbUNoYXJDb2RlKGEyKTtcbiAgICAgICAgICB9KGUyID0gby50cmFuc2Zvcm1UbyhoLnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIiwgZTIpKTtcbiAgICAgICAgfSwgby5pbmhlcml0cyhhLCBuKSwgYS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgdDIgPSBvLnRyYW5zZm9ybVRvKGgudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBlMi5kYXRhKTtcbiAgICAgICAgICBpZiAodGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGgudWludDhhcnJheSkge1xuICAgICAgICAgICAgICB2YXIgcjIgPSB0MjtcbiAgICAgICAgICAgICAgKHQyID0gbmV3IFVpbnQ4QXJyYXkocjIubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpKS5zZXQodGhpcy5sZWZ0T3ZlciwgMCksIHQyLnNldChyMiwgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHQyID0gdGhpcy5sZWZ0T3Zlci5jb25jYXQodDIpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0T3ZlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuMiA9IGZ1bmN0aW9uKGUzLCB0Mykge1xuICAgICAgICAgICAgdmFyIHIzO1xuICAgICAgICAgICAgZm9yICgodDMgPSB0MyB8fCBlMy5sZW5ndGgpID4gZTMubGVuZ3RoICYmICh0MyA9IGUzLmxlbmd0aCksIHIzID0gdDMgLSAxOyAwIDw9IHIzICYmIDEyOCA9PSAoMTkyICYgZTNbcjNdKTsgKSByMy0tO1xuICAgICAgICAgICAgcmV0dXJuIHIzIDwgMCA/IHQzIDogMCA9PT0gcjMgPyB0MyA6IHIzICsgdVtlM1tyM11dID4gdDMgPyByMyA6IHQzO1xuICAgICAgICAgIH0odDIpLCBpMiA9IHQyO1xuICAgICAgICAgIG4yICE9PSB0Mi5sZW5ndGggJiYgKGgudWludDhhcnJheSA/IChpMiA9IHQyLnN1YmFycmF5KDAsIG4yKSwgdGhpcy5sZWZ0T3ZlciA9IHQyLnN1YmFycmF5KG4yLCB0Mi5sZW5ndGgpKSA6IChpMiA9IHQyLnNsaWNlKDAsIG4yKSwgdGhpcy5sZWZ0T3ZlciA9IHQyLnNsaWNlKG4yLCB0Mi5sZW5ndGgpKSksIHRoaXMucHVzaCh7IGRhdGE6IHMudXRmOGRlY29kZShpMiksIG1ldGE6IGUyLm1ldGEgfSk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5sZWZ0T3ZlciAmJiB0aGlzLmxlZnRPdmVyLmxlbmd0aCAmJiAodGhpcy5wdXNoKHsgZGF0YTogcy51dGY4ZGVjb2RlKHRoaXMubGVmdE92ZXIpLCBtZXRhOiB7fSB9KSwgdGhpcy5sZWZ0T3ZlciA9IG51bGwpO1xuICAgICAgICB9LCBzLlV0ZjhEZWNvZGVXb3JrZXIgPSBhLCBvLmluaGVyaXRzKGwsIG4pLCBsLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMucHVzaCh7IGRhdGE6IHMudXRmOGVuY29kZShlMi5kYXRhKSwgbWV0YTogZTIubWV0YSB9KTtcbiAgICAgICAgfSwgcy5VdGY4RW5jb2RlV29ya2VyID0gbDtcbiAgICAgIH0sIHsgXCIuL25vZGVqc1V0aWxzXCI6IDE0LCBcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIjogMjgsIFwiLi9zdXBwb3J0XCI6IDMwLCBcIi4vdXRpbHNcIjogMzIgfV0sIDMyOiBbZnVuY3Rpb24oZSwgdCwgYSkge1xuICAgICAgICB2YXIgbyA9IGUoXCIuL3N1cHBvcnRcIiksIGggPSBlKFwiLi9iYXNlNjRcIiksIHIgPSBlKFwiLi9ub2RlanNVdGlsc1wiKSwgdSA9IGUoXCIuL2V4dGVybmFsXCIpO1xuICAgICAgICBmdW5jdGlvbiBuKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGwoZTIsIHQyKSB7XG4gICAgICAgICAgZm9yICh2YXIgcjIgPSAwOyByMiA8IGUyLmxlbmd0aDsgKytyMikgdDJbcjJdID0gMjU1ICYgZTIuY2hhckNvZGVBdChyMik7XG4gICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICB9XG4gICAgICAgIGUoXCJzZXRpbW1lZGlhdGVcIiksIGEubmV3QmxvYiA9IGZ1bmN0aW9uKHQyLCByMikge1xuICAgICAgICAgIGEuY2hlY2tTdXBwb3J0KFwiYmxvYlwiKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt0Ml0sIHsgdHlwZTogcjIgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBuMiA9IG5ldyAoc2VsZi5CbG9iQnVpbGRlciB8fCBzZWxmLldlYktpdEJsb2JCdWlsZGVyIHx8IHNlbGYuTW96QmxvYkJ1aWxkZXIgfHwgc2VsZi5NU0Jsb2JCdWlsZGVyKSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbjIuYXBwZW5kKHQyKSwgbjIuZ2V0QmxvYihyMik7XG4gICAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgOiBjYW4ndCBjb25zdHJ1Y3QgdGhlIEJsb2IuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGkgPSB7IHN0cmluZ2lmeUJ5Q2h1bms6IGZ1bmN0aW9uKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICB2YXIgbjIgPSBbXSwgaTIgPSAwLCBzMiA9IGUyLmxlbmd0aDtcbiAgICAgICAgICBpZiAoczIgPD0gcjIpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGUyKTtcbiAgICAgICAgICBmb3IgKDsgaTIgPCBzMjsgKSBcImFycmF5XCIgPT09IHQyIHx8IFwibm9kZWJ1ZmZlclwiID09PSB0MiA/IG4yLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBlMi5zbGljZShpMiwgTWF0aC5taW4oaTIgKyByMiwgczIpKSkpIDogbjIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGUyLnN1YmFycmF5KGkyLCBNYXRoLm1pbihpMiArIHIyLCBzMikpKSksIGkyICs9IHIyO1xuICAgICAgICAgIHJldHVybiBuMi5qb2luKFwiXCIpO1xuICAgICAgICB9LCBzdHJpbmdpZnlCeUNoYXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgZm9yICh2YXIgdDIgPSBcIlwiLCByMiA9IDA7IHIyIDwgZTIubGVuZ3RoOyByMisrKSB0MiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUyW3IyXSk7XG4gICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICB9LCBhcHBseUNhbkJlVXNlZDogeyB1aW50OGFycmF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG8udWludDhhcnJheSAmJiAxID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKS5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKSwgbm9kZWJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBvLm5vZGVidWZmZXIgJiYgMSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCByLmFsbG9jQnVmZmVyKDEpKS5sZW5ndGg7XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKSB9IH07XG4gICAgICAgIGZ1bmN0aW9uIHMoZTIpIHtcbiAgICAgICAgICB2YXIgdDIgPSA2NTUzNiwgcjIgPSBhLmdldFR5cGVPZihlMiksIG4yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoXCJ1aW50OGFycmF5XCIgPT09IHIyID8gbjIgPSBpLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXkgOiBcIm5vZGVidWZmZXJcIiA9PT0gcjIgJiYgKG4yID0gaS5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyKSwgbjIpIGZvciAoOyAxIDwgdDI7ICkgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpLnN0cmluZ2lmeUJ5Q2h1bmsoZTIsIHIyLCB0Mik7XG4gICAgICAgICAgfSBjYXRjaCAoZTMpIHtcbiAgICAgICAgICAgIHQyID0gTWF0aC5mbG9vcih0MiAvIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaS5zdHJpbmdpZnlCeUNoYXIoZTIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGYoZTIsIHQyKSB7XG4gICAgICAgICAgZm9yICh2YXIgcjIgPSAwOyByMiA8IGUyLmxlbmd0aDsgcjIrKykgdDJbcjJdID0gZTJbcjJdO1xuICAgICAgICAgIHJldHVybiB0MjtcbiAgICAgICAgfVxuICAgICAgICBhLmFwcGx5RnJvbUNoYXJDb2RlID0gcztcbiAgICAgICAgdmFyIGMgPSB7fTtcbiAgICAgICAgYy5zdHJpbmcgPSB7IHN0cmluZzogbiwgYXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGwoZTIsIG5ldyBBcnJheShlMi5sZW5ndGgpKTtcbiAgICAgICAgfSwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGMuc3RyaW5nLnVpbnQ4YXJyYXkoZTIpLmJ1ZmZlcjtcbiAgICAgICAgfSwgdWludDhhcnJheTogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gbChlMiwgbmV3IFVpbnQ4QXJyYXkoZTIubGVuZ3RoKSk7XG4gICAgICAgIH0sIG5vZGVidWZmZXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGwoZTIsIHIuYWxsb2NCdWZmZXIoZTIubGVuZ3RoKSk7XG4gICAgICAgIH0gfSwgYy5hcnJheSA9IHsgc3RyaW5nOiBzLCBhcnJheTogbiwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUyKS5idWZmZXI7XG4gICAgICAgIH0sIHVpbnQ4YXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGUyKTtcbiAgICAgICAgfSwgbm9kZWJ1ZmZlcjogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gci5uZXdCdWZmZXJGcm9tKGUyKTtcbiAgICAgICAgfSB9LCBjLmFycmF5YnVmZmVyID0geyBzdHJpbmc6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIHMobmV3IFVpbnQ4QXJyYXkoZTIpKTtcbiAgICAgICAgfSwgYXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGYobmV3IFVpbnQ4QXJyYXkoZTIpLCBuZXcgQXJyYXkoZTIuYnl0ZUxlbmd0aCkpO1xuICAgICAgICB9LCBhcnJheWJ1ZmZlcjogbiwgdWludDhhcnJheTogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZTIpO1xuICAgICAgICB9LCBub2RlYnVmZmVyOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiByLm5ld0J1ZmZlckZyb20obmV3IFVpbnQ4QXJyYXkoZTIpKTtcbiAgICAgICAgfSB9LCBjLnVpbnQ4YXJyYXkgPSB7IHN0cmluZzogcywgYXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGYoZTIsIG5ldyBBcnJheShlMi5sZW5ndGgpKTtcbiAgICAgICAgfSwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGUyLmJ1ZmZlcjtcbiAgICAgICAgfSwgdWludDhhcnJheTogbiwgbm9kZWJ1ZmZlcjogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gci5uZXdCdWZmZXJGcm9tKGUyKTtcbiAgICAgICAgfSB9LCBjLm5vZGVidWZmZXIgPSB7IHN0cmluZzogcywgYXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGYoZTIsIG5ldyBBcnJheShlMi5sZW5ndGgpKTtcbiAgICAgICAgfSwgYXJyYXlidWZmZXI6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGMubm9kZWJ1ZmZlci51aW50OGFycmF5KGUyKS5idWZmZXI7XG4gICAgICAgIH0sIHVpbnQ4YXJyYXk6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIGYoZTIsIG5ldyBVaW50OEFycmF5KGUyLmxlbmd0aCkpO1xuICAgICAgICB9LCBub2RlYnVmZmVyOiBuIH0sIGEudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICBpZiAodDIgPSB0MiB8fCBcIlwiLCAhZTIpIHJldHVybiB0MjtcbiAgICAgICAgICBhLmNoZWNrU3VwcG9ydChlMik7XG4gICAgICAgICAgdmFyIHIyID0gYS5nZXRUeXBlT2YodDIpO1xuICAgICAgICAgIHJldHVybiBjW3IyXVtlMl0odDIpO1xuICAgICAgICB9LCBhLnJlc29sdmUgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGZvciAodmFyIHQyID0gZTIuc3BsaXQoXCIvXCIpLCByMiA9IFtdLCBuMiA9IDA7IG4yIDwgdDIubGVuZ3RoOyBuMisrKSB7XG4gICAgICAgICAgICB2YXIgaTIgPSB0MltuMl07XG4gICAgICAgICAgICBcIi5cIiA9PT0gaTIgfHwgXCJcIiA9PT0gaTIgJiYgMCAhPT0gbjIgJiYgbjIgIT09IHQyLmxlbmd0aCAtIDEgfHwgKFwiLi5cIiA9PT0gaTIgPyByMi5wb3AoKSA6IHIyLnB1c2goaTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHIyLmpvaW4oXCIvXCIpO1xuICAgICAgICB9LCBhLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUyID8gXCJzdHJpbmdcIiA6IFwiW29iamVjdCBBcnJheV1cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUyKSA/IFwiYXJyYXlcIiA6IG8ubm9kZWJ1ZmZlciAmJiByLmlzQnVmZmVyKGUyKSA/IFwibm9kZWJ1ZmZlclwiIDogby51aW50OGFycmF5ICYmIGUyIGluc3RhbmNlb2YgVWludDhBcnJheSA/IFwidWludDhhcnJheVwiIDogby5hcnJheWJ1ZmZlciAmJiBlMiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gXCJhcnJheWJ1ZmZlclwiIDogdm9pZCAwO1xuICAgICAgICB9LCBhLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKCFvW2UyLnRvTG93ZXJDYXNlKCldKSB0aHJvdyBuZXcgRXJyb3IoZTIgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcGxhdGZvcm1cIik7XG4gICAgICAgIH0sIGEuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1LCBhLk1BWF9WQUxVRV8zMkJJVFMgPSAtMSwgYS5wcmV0dHkgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIsIG4yID0gXCJcIjtcbiAgICAgICAgICBmb3IgKHIyID0gMDsgcjIgPCAoZTIgfHwgXCJcIikubGVuZ3RoOyByMisrKSBuMiArPSBcIlxcXFx4XCIgKyAoKHQyID0gZTIuY2hhckNvZGVBdChyMikpIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdDIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgICB9LCBhLmRlbGF5ID0gZnVuY3Rpb24oZTIsIHQyLCByMikge1xuICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUyLmFwcGx5KHIyIHx8IG51bGwsIHQyIHx8IFtdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgYS5pbmhlcml0cyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIGZ1bmN0aW9uIHIyKCkge1xuICAgICAgICAgIH1cbiAgICAgICAgICByMi5wcm90b3R5cGUgPSB0Mi5wcm90b3R5cGUsIGUyLnByb3RvdHlwZSA9IG5ldyByMigpO1xuICAgICAgICB9LCBhLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlMiwgdDIsIHIyID0ge307XG4gICAgICAgICAgZm9yIChlMiA9IDA7IGUyIDwgYXJndW1lbnRzLmxlbmd0aDsgZTIrKykgZm9yICh0MiBpbiBhcmd1bWVudHNbZTJdKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2UyXSwgdDIpICYmIHZvaWQgMCA9PT0gcjJbdDJdICYmIChyMlt0Ml0gPSBhcmd1bWVudHNbZTJdW3QyXSk7XG4gICAgICAgICAgcmV0dXJuIHIyO1xuICAgICAgICB9LCBhLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24ocjIsIGUyLCBuMiwgaTIsIHMyKSB7XG4gICAgICAgICAgcmV0dXJuIHUuUHJvbWlzZS5yZXNvbHZlKGUyKS50aGVuKGZ1bmN0aW9uKG4zKSB7XG4gICAgICAgICAgICByZXR1cm4gby5ibG9iICYmIChuMyBpbnN0YW5jZW9mIEJsb2IgfHwgLTEgIT09IFtcIltvYmplY3QgRmlsZV1cIiwgXCJbb2JqZWN0IEJsb2JdXCJdLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4zKSkpICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEZpbGVSZWFkZXIgPyBuZXcgdS5Qcm9taXNlKGZ1bmN0aW9uKHQyLCByMykge1xuICAgICAgICAgICAgICB2YXIgZTMgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICBlMy5vbmxvYWQgPSBmdW5jdGlvbihlNCkge1xuICAgICAgICAgICAgICAgIHQyKGU0LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICB9LCBlMy5vbmVycm9yID0gZnVuY3Rpb24oZTQpIHtcbiAgICAgICAgICAgICAgICByMyhlNC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICB9LCBlMy5yZWFkQXNBcnJheUJ1ZmZlcihuMyk7XG4gICAgICAgICAgICB9KSA6IG4zO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHZhciB0MiA9IGEuZ2V0VHlwZU9mKGUzKTtcbiAgICAgICAgICAgIHJldHVybiB0MiA/IChcImFycmF5YnVmZmVyXCIgPT09IHQyID8gZTMgPSBhLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBlMykgOiBcInN0cmluZ1wiID09PSB0MiAmJiAoczIgPyBlMyA9IGguZGVjb2RlKGUzKSA6IG4yICYmIHRydWUgIT09IGkyICYmIChlMyA9IGZ1bmN0aW9uKGU0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBsKGU0LCBvLnVpbnQ4YXJyYXkgPyBuZXcgVWludDhBcnJheShlNC5sZW5ndGgpIDogbmV3IEFycmF5KGU0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfShlMykpKSwgZTMpIDogdS5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIHIyICsgXCInLiBJcyBpdCBpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9LCB7IFwiLi9iYXNlNjRcIjogMSwgXCIuL2V4dGVybmFsXCI6IDYsIFwiLi9ub2RlanNVdGlsc1wiOiAxNCwgXCIuL3N1cHBvcnRcIjogMzAsIHNldGltbWVkaWF0ZTogNTQgfV0sIDMzOiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgbiA9IGUoXCIuL3JlYWRlci9yZWFkZXJGb3JcIiksIGkgPSBlKFwiLi91dGlsc1wiKSwgcyA9IGUoXCIuL3NpZ25hdHVyZVwiKSwgYSA9IGUoXCIuL3ppcEVudHJ5XCIpLCBvID0gZShcIi4vc3VwcG9ydFwiKTtcbiAgICAgICAgZnVuY3Rpb24gaChlMikge1xuICAgICAgICAgIHRoaXMuZmlsZXMgPSBbXSwgdGhpcy5sb2FkT3B0aW9ucyA9IGUyO1xuICAgICAgICB9XG4gICAgICAgIGgucHJvdG90eXBlID0geyBjaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBpZiAoIXRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShlMikpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLmluZGV4IC09IDQ7XG4gICAgICAgICAgICB2YXIgdDIgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIChcIiArIGkucHJldHR5KHQyKSArIFwiLCBleHBlY3RlZCBcIiArIGkucHJldHR5KGUyKSArIFwiKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGlzU2lnbmF0dXJlOiBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjIgPSB0aGlzLnJlYWRlci5pbmRleDtcbiAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChlMik7XG4gICAgICAgICAgdmFyIG4yID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KSA9PT0gdDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLnNldEluZGV4KHIyKSwgbjI7XG4gICAgICAgIH0sIHJlYWRCbG9ja0VuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMiksIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoMiksIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCB0aGlzLnppcENvbW1lbnRMZW5ndGggPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgIHZhciBlMiA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCksIHQyID0gby51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIHIyID0gaS50cmFuc2Zvcm1Ubyh0MiwgZTIpO1xuICAgICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUocjIpO1xuICAgICAgICB9LCByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpLCB0aGlzLnJlYWRlci5za2lwKDQpLCB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KSwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpLCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCg4KSwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCksIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCksIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIGUyLCB0MiwgcjIsIG4yID0gdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUgLSA0NDsgMCA8IG4yOyApIGUyID0gdGhpcy5yZWFkZXIucmVhZEludCgyKSwgdDIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpLCByMiA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHQyKSwgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2UyXSA9IHsgaWQ6IGUyLCBsZW5ndGg6IHQyLCB2YWx1ZTogcjIgfTtcbiAgICAgICAgfSwgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KSwgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KSwgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KSwgMSA8IHRoaXMuZGlza3NDb3VudCkgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH0sIHJlYWRMb2NhbEZpbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIsIHQyO1xuICAgICAgICAgIGZvciAoZTIgPSAwOyBlMiA8IHRoaXMuZmlsZXMubGVuZ3RoOyBlMisrKSB0MiA9IHRoaXMuZmlsZXNbZTJdLCB0aGlzLnJlYWRlci5zZXRJbmRleCh0Mi5sb2NhbEhlYWRlck9mZnNldCksIHRoaXMuY2hlY2tTaWduYXR1cmUocy5MT0NBTF9GSUxFX0hFQURFUiksIHQyLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpLCB0Mi5oYW5kbGVVVEY4KCksIHQyLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH0sIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTI7XG4gICAgICAgICAgZm9yICh0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLmNlbnRyYWxEaXJPZmZzZXQpOyB0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUocy5DRU5UUkFMX0ZJTEVfSEVBREVSKTsgKSAoZTIgPSBuZXcgYSh7IHppcDY0OiB0aGlzLnppcDY0IH0sIHRoaXMubG9hZE9wdGlvbnMpKS5yZWFkQ2VudHJhbFBhcnQodGhpcy5yZWFkZXIpLCB0aGlzLmZpbGVzLnB1c2goZTIpO1xuICAgICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCAmJiAwICE9PSB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICYmIDAgPT09IHRoaXMuZmlsZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZzogZXhwZWN0ZWQgXCIgKyB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICsgXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiICsgdGhpcy5maWxlcy5sZW5ndGgpO1xuICAgICAgICB9LCByZWFkRW5kT2ZDZW50cmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgaWYgKGUyIDwgMCkgdGhyb3cgIXRoaXMuaXNTaWduYXR1cmUoMCwgcy5MT0NBTF9GSUxFX0hFQURFUikgPyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IElmIGl0IGlzLCBzZWUgaHR0cHM6Ly9zdHVrLmdpdGh1Yi5pby9qc3ppcC9kb2N1bWVudGF0aW9uL2hvd3RvL3JlYWRfemlwLmh0bWxcIikgOiBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChlMik7XG4gICAgICAgICAgdmFyIHQyID0gZTI7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tTaWduYXR1cmUocy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpLCB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpLCB0aGlzLmRpc2tOdW1iZXIgPT09IGkuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSBpLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IGkuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID09PSBpLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gaS5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gaS5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICBpZiAodGhpcy56aXA2NCA9IHRydWUsIChlMiA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUikpIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkZXIuc2V0SW5kZXgoZTIpLCB0aGlzLmNoZWNrU2lnbmF0dXJlKHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiksIHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCksICF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgcy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpICYmICh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCksIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA8IDApKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIpLCB0aGlzLmNoZWNrU2lnbmF0dXJlKHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKSwgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcjIgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICAgIHRoaXMuemlwNjQgJiYgKHIyICs9IDIwLCByMiArPSAxMiArIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplKTtcbiAgICAgICAgICB2YXIgbjIgPSB0MiAtIHIyO1xuICAgICAgICAgIGlmICgwIDwgbjIpIHRoaXMuaXNTaWduYXR1cmUodDIsIHMuQ0VOVFJBTF9GSUxFX0hFQURFUikgfHwgKHRoaXMucmVhZGVyLnplcm8gPSBuMik7XG4gICAgICAgICAgZWxzZSBpZiAobjIgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBtaXNzaW5nIFwiICsgTWF0aC5hYnMobjIpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9LCBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMucmVhZGVyID0gbihlMik7XG4gICAgICAgIH0sIGxvYWQ6IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5wcmVwYXJlUmVhZGVyKGUyKSwgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCksIHRoaXMucmVhZENlbnRyYWxEaXIoKSwgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgICAgICB9IH0sIHQuZXhwb3J0cyA9IGg7XG4gICAgICB9LCB7IFwiLi9yZWFkZXIvcmVhZGVyRm9yXCI6IDIyLCBcIi4vc2lnbmF0dXJlXCI6IDIzLCBcIi4vc3VwcG9ydFwiOiAzMCwgXCIuL3V0aWxzXCI6IDMyLCBcIi4vemlwRW50cnlcIjogMzQgfV0sIDM0OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB2YXIgbiA9IGUoXCIuL3JlYWRlci9yZWFkZXJGb3JcIiksIHMgPSBlKFwiLi91dGlsc1wiKSwgaSA9IGUoXCIuL2NvbXByZXNzZWRPYmplY3RcIiksIGEgPSBlKFwiLi9jcmMzMlwiKSwgbyA9IGUoXCIuL3V0ZjhcIiksIGggPSBlKFwiLi9jb21wcmVzc2lvbnNcIiksIHUgPSBlKFwiLi9zdXBwb3J0XCIpO1xuICAgICAgICBmdW5jdGlvbiBsKGUyLCB0Mikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGUyLCB0aGlzLmxvYWRPcHRpb25zID0gdDI7XG4gICAgICAgIH1cbiAgICAgICAgbC5wcm90b3R5cGUgPSB7IGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gMSA9PSAoMSAmIHRoaXMuYml0RmxhZyk7XG4gICAgICAgIH0sIHVzZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAyMDQ4ID09ICgyMDQ4ICYgdGhpcy5iaXRGbGFnKTtcbiAgICAgICAgfSwgcmVhZExvY2FsUGFydDogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgdDIsIHIyO1xuICAgICAgICAgIGlmIChlMi5za2lwKDIyKSwgdGhpcy5maWxlTmFtZUxlbmd0aCA9IGUyLnJlYWRJbnQoMiksIHIyID0gZTIucmVhZEludCgyKSwgdGhpcy5maWxlTmFtZSA9IGUyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpLCBlMi5za2lwKHIyKSwgLTEgPT09IHRoaXMuY29tcHJlc3NlZFNpemUgfHwgLTEgPT09IHRoaXMudW5jb21wcmVzc2VkU2l6ZSkgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gKHQyID0gZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHQzIGluIGgpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaCwgdDMpICYmIGhbdDNdLm1hZ2ljID09PSBlMykgcmV0dXJuIGhbdDNdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSh0aGlzLmNvbXByZXNzaW9uTWV0aG9kKSkpIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjb21wcmVzc2lvbiBcIiArIHMucHJldHR5KHRoaXMuY29tcHJlc3Npb25NZXRob2QpICsgXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiICsgcy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBpKHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgdDIsIGUyLnJlYWREYXRhKHRoaXMuY29tcHJlc3NlZFNpemUpKTtcbiAgICAgICAgfSwgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IGUyLnJlYWRJbnQoMiksIGUyLnNraXAoMiksIHRoaXMuYml0RmxhZyA9IGUyLnJlYWRJbnQoMiksIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSBlMi5yZWFkU3RyaW5nKDIpLCB0aGlzLmRhdGUgPSBlMi5yZWFkRGF0ZSgpLCB0aGlzLmNyYzMyID0gZTIucmVhZEludCg0KSwgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGUyLnJlYWRJbnQoNCksIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IGUyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgdmFyIHQyID0gZTIucmVhZEludCgyKTtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUZpZWxkc0xlbmd0aCA9IGUyLnJlYWRJbnQoMiksIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSBlMi5yZWFkSW50KDIpLCB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGUyLnJlYWRJbnQoMiksIHRoaXMuaW50ZXJuYWxGaWxlQXR0cmlidXRlcyA9IGUyLnJlYWRJbnQoMiksIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IGUyLnJlYWRJbnQoNCksIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBlMi5yZWFkSW50KDQpLCB0aGlzLmlzRW5jcnlwdGVkKCkpIHRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgZTIuc2tpcCh0MiksIHRoaXMucmVhZEV4dHJhRmllbGRzKGUyKSwgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChlMiksIHRoaXMuZmlsZUNvbW1lbnQgPSBlMi5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICAgICAgfSwgcHJvY2Vzc0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbCwgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgICAgdmFyIGUyID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG4gICAgICAgICAgdGhpcy5kaXIgPSAhISgxNiAmIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyksIDAgPT0gZTIgJiYgKHRoaXMuZG9zUGVybWlzc2lvbnMgPSA2MyAmIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyksIDMgPT0gZTIgJiYgKHRoaXMudW5peFBlcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID4+IDE2ICYgNjU1MzUpLCB0aGlzLmRpciB8fCBcIi9cIiAhPT0gdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgfHwgKHRoaXMuZGlyID0gdHJ1ZSk7XG4gICAgICAgIH0sIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5leHRyYUZpZWxkc1sxXSkge1xuICAgICAgICAgICAgdmFyIGUyID0gbih0aGlzLmV4dHJhRmllbGRzWzFdLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBlMi5yZWFkSW50KDgpKSwgdGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLmNvbXByZXNzZWRTaXplID0gZTIucmVhZEludCg4KSksIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHMuTUFYX1ZBTFVFXzMyQklUUyAmJiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGUyLnJlYWRJbnQoOCkpLCB0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gcy5NQVhfVkFMVUVfMzJCSVRTICYmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGUyLnJlYWRJbnQoNCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIsIG4yLCBpMiA9IGUyLmluZGV4ICsgdGhpcy5leHRyYUZpZWxkc0xlbmd0aDtcbiAgICAgICAgICBmb3IgKHRoaXMuZXh0cmFGaWVsZHMgfHwgKHRoaXMuZXh0cmFGaWVsZHMgPSB7fSk7IGUyLmluZGV4ICsgNCA8IGkyOyApIHQyID0gZTIucmVhZEludCgyKSwgcjIgPSBlMi5yZWFkSW50KDIpLCBuMiA9IGUyLnJlYWREYXRhKHIyKSwgdGhpcy5leHRyYUZpZWxkc1t0Ml0gPSB7IGlkOiB0MiwgbGVuZ3RoOiByMiwgdmFsdWU6IG4yIH07XG4gICAgICAgICAgZTIuc2V0SW5kZXgoaTIpO1xuICAgICAgICB9LCBoYW5kbGVVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIgPSB1LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgICBpZiAodGhpcy51c2VVVEY4KCkpIHRoaXMuZmlsZU5hbWVTdHIgPSBvLnV0ZjhkZWNvZGUodGhpcy5maWxlTmFtZSksIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSBvLnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSB0MikgdGhpcy5maWxlTmFtZVN0ciA9IHQyO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByMiA9IHMudHJhbnNmb3JtVG8oZTIsIHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShyMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbjIgPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBuMikgdGhpcy5maWxlQ29tbWVudFN0ciA9IG4yO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpMiA9IHMudHJhbnNmb3JtVG8oZTIsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICB0aGlzLmZpbGVDb21tZW50U3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmaW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZTIgPSB0aGlzLmV4dHJhRmllbGRzWzI4Nzg5XTtcbiAgICAgICAgICBpZiAoZTIpIHtcbiAgICAgICAgICAgIHZhciB0MiA9IG4oZTIudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgIT09IHQyLnJlYWRJbnQoMSkgPyBudWxsIDogYSh0aGlzLmZpbGVOYW1lKSAhPT0gdDIucmVhZEludCg0KSA/IG51bGwgOiBvLnV0ZjhkZWNvZGUodDIucmVhZERhdGEoZTIubGVuZ3RoIC0gNSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGUyID0gdGhpcy5leHRyYUZpZWxkc1syNTQ2MV07XG4gICAgICAgICAgaWYgKGUyKSB7XG4gICAgICAgICAgICB2YXIgdDIgPSBuKGUyLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAxICE9PSB0Mi5yZWFkSW50KDEpID8gbnVsbCA6IGEodGhpcy5maWxlQ29tbWVudCkgIT09IHQyLnJlYWRJbnQoNCkgPyBudWxsIDogby51dGY4ZGVjb2RlKHQyLnJlYWREYXRhKGUyLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gfSwgdC5leHBvcnRzID0gbDtcbiAgICAgIH0sIHsgXCIuL2NvbXByZXNzZWRPYmplY3RcIjogMiwgXCIuL2NvbXByZXNzaW9uc1wiOiAzLCBcIi4vY3JjMzJcIjogNCwgXCIuL3JlYWRlci9yZWFkZXJGb3JcIjogMjIsIFwiLi9zdXBwb3J0XCI6IDMwLCBcIi4vdXRmOFwiOiAzMSwgXCIuL3V0aWxzXCI6IDMyIH1dLCAzNTogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgZnVuY3Rpb24gbihlMiwgdDIsIHIyKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gZTIsIHRoaXMuZGlyID0gcjIuZGlyLCB0aGlzLmRhdGUgPSByMi5kYXRlLCB0aGlzLmNvbW1lbnQgPSByMi5jb21tZW50LCB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IHIyLnVuaXhQZXJtaXNzaW9ucywgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IHIyLmRvc1Blcm1pc3Npb25zLCB0aGlzLl9kYXRhID0gdDIsIHRoaXMuX2RhdGFCaW5hcnkgPSByMi5iaW5hcnksIHRoaXMub3B0aW9ucyA9IHsgY29tcHJlc3Npb246IHIyLmNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnM6IHIyLmNvbXByZXNzaW9uT3B0aW9ucyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gZShcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiKSwgaSA9IGUoXCIuL3N0cmVhbS9EYXRhV29ya2VyXCIpLCBhID0gZShcIi4vdXRmOFwiKSwgbyA9IGUoXCIuL2NvbXByZXNzZWRPYmplY3RcIiksIGggPSBlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcbiAgICAgICAgbi5wcm90b3R5cGUgPSB7IGludGVybmFsU3RyZWFtOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiA9IG51bGwsIHIyID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFlMikgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgICAgIHZhciBuMiA9IFwic3RyaW5nXCIgPT09IChyMiA9IGUyLnRvTG93ZXJDYXNlKCkpIHx8IFwidGV4dFwiID09PSByMjtcbiAgICAgICAgICAgIFwiYmluYXJ5c3RyaW5nXCIgIT09IHIyICYmIFwidGV4dFwiICE9PSByMiB8fCAocjIgPSBcInN0cmluZ1wiKSwgdDIgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgICB2YXIgaTIgPSAhdGhpcy5fZGF0YUJpbmFyeTtcbiAgICAgICAgICAgIGkyICYmICFuMiAmJiAodDIgPSB0Mi5waXBlKG5ldyBhLlV0ZjhFbmNvZGVXb3JrZXIoKSkpLCAhaTIgJiYgbjIgJiYgKHQyID0gdDIucGlwZShuZXcgYS5VdGY4RGVjb2RlV29ya2VyKCkpKTtcbiAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgKHQyID0gbmV3IGgoXCJlcnJvclwiKSkuZXJyb3IoZTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IHModDIsIHIyLCBcIlwiKTtcbiAgICAgICAgfSwgYXN5bmM6IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsU3RyZWFtKGUyKS5hY2N1bXVsYXRlKHQyKTtcbiAgICAgICAgfSwgbm9kZVN0cmVhbTogZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0oZTIgfHwgXCJub2RlYnVmZmVyXCIpLnRvTm9kZWpzU3RyZWFtKHQyKTtcbiAgICAgICAgfSwgX2NvbXByZXNzV29ya2VyOiBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIG8gJiYgdGhpcy5fZGF0YS5jb21wcmVzc2lvbi5tYWdpYyA9PT0gZTIubWFnaWMpIHJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTtcbiAgICAgICAgICB2YXIgcjIgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFCaW5hcnkgfHwgKHIyID0gcjIucGlwZShuZXcgYS5VdGY4RW5jb2RlV29ya2VyKCkpKSwgby5jcmVhdGVXb3JrZXJGcm9tKHIyLCBlMiwgdDIpO1xuICAgICAgICB9LCBfZGVjb21wcmVzc1dvcmtlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgaW5zdGFuY2VvZiBvID8gdGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCkgOiB0aGlzLl9kYXRhIGluc3RhbmNlb2YgaCA/IHRoaXMuX2RhdGEgOiBuZXcgaSh0aGlzLl9kYXRhKTtcbiAgICAgICAgfSB9O1xuICAgICAgICBmb3IgKHZhciB1ID0gW1wiYXNUZXh0XCIsIFwiYXNCaW5hcnlcIiwgXCJhc05vZGVCdWZmZXJcIiwgXCJhc1VpbnQ4QXJyYXlcIiwgXCJhc0FycmF5QnVmZmVyXCJdLCBsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIik7XG4gICAgICAgIH0sIGYgPSAwOyBmIDwgdS5sZW5ndGg7IGYrKykgbi5wcm90b3R5cGVbdVtmXV0gPSBsO1xuICAgICAgICB0LmV4cG9ydHMgPSBuO1xuICAgICAgfSwgeyBcIi4vY29tcHJlc3NlZE9iamVjdFwiOiAyLCBcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIjogMjcsIFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOiAyOCwgXCIuL3N0cmVhbS9TdHJlYW1IZWxwZXJcIjogMjksIFwiLi91dGY4XCI6IDMxIH1dLCAzNjogW2Z1bmN0aW9uKGUsIGwsIHQpIHtcbiAgICAgICAgKGZ1bmN0aW9uKHQyKSB7XG4gICAgICAgICAgdmFyIHIsIG4sIGUyID0gdDIuTXV0YXRpb25PYnNlcnZlciB8fCB0Mi5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgICAgICAgIGlmIChlMikge1xuICAgICAgICAgICAgdmFyIGkgPSAwLCBzID0gbmV3IGUyKHUpLCBhID0gdDIuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICBzLm9ic2VydmUoYSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pLCByID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGEuZGF0YSA9IGkgPSArK2kgJSAyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHQyLnNldEltbWVkaWF0ZSB8fCB2b2lkIDAgPT09IHQyLk1lc3NhZ2VDaGFubmVsKSByID0gXCJkb2N1bWVudFwiIGluIHQyICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gdDIuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGUzID0gdDIuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIGUzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB1KCksIGUzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIGUzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZTMpLCBlMyA9IG51bGw7XG4gICAgICAgICAgICB9LCB0Mi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZTMpO1xuICAgICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodSwgMCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IHQyLk1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICBvLnBvcnQxLm9ubWVzc2FnZSA9IHUsIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgby5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoID0gW107XG4gICAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgICAgIHZhciBlMywgdDM7XG4gICAgICAgICAgICBuID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIHIyID0gaC5sZW5ndGg7IHIyOyApIHtcbiAgICAgICAgICAgICAgZm9yICh0MyA9IGgsIGggPSBbXSwgZTMgPSAtMTsgKytlMyA8IHIyOyApIHQzW2UzXSgpO1xuICAgICAgICAgICAgICByMiA9IGgubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsLmV4cG9ydHMgPSBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgMSAhPT0gaC5wdXNoKGUzKSB8fCBuIHx8IHIoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5jYWxsKHRoaXMsIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID8gY29tbW9uanNHbG9iYWwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHt9KTtcbiAgICAgIH0sIHt9XSwgMzc6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBpID0gZShcImltbWVkaWF0ZVwiKTtcbiAgICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCA9IHt9LCBzID0gW1wiUkVKRUNURURcIl0sIGEgPSBbXCJGVUxGSUxMRURcIl0sIG4gPSBbXCJQRU5ESU5HXCJdO1xuICAgICAgICBmdW5jdGlvbiBvKGUyKSB7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZTIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IG4sIHRoaXMucXVldWUgPSBbXSwgdGhpcy5vdXRjb21lID0gdm9pZCAwLCBlMiAhPT0gdSAmJiBkKHRoaXMsIGUyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICB0aGlzLnByb21pc2UgPSBlMiwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0MiAmJiAodGhpcy5vbkZ1bGZpbGxlZCA9IHQyLCB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZCksIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcjIgJiYgKHRoaXMub25SZWplY3RlZCA9IHIyLCB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGYodDIsIHIyLCBuMikge1xuICAgICAgICAgIGkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZTI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlMiA9IHIyKG4yKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsLnJlamVjdCh0MiwgZTMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZTIgPT09IHQyID8gbC5yZWplY3QodDIsIG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKSA6IGwucmVzb2x2ZSh0MiwgZTIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGMoZTIpIHtcbiAgICAgICAgICB2YXIgdDIgPSBlMiAmJiBlMi50aGVuO1xuICAgICAgICAgIGlmIChlMiAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZTIgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlMikgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0MikgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdDIuYXBwbHkoZTIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkKHQyLCBlMikge1xuICAgICAgICAgIHZhciByMiA9IGZhbHNlO1xuICAgICAgICAgIGZ1bmN0aW9uIG4yKGUzKSB7XG4gICAgICAgICAgICByMiB8fCAocjIgPSB0cnVlLCBsLnJlamVjdCh0MiwgZTMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaTIoZTMpIHtcbiAgICAgICAgICAgIHIyIHx8IChyMiA9IHRydWUsIGwucmVzb2x2ZSh0MiwgZTMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHMyID0gcChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGUyKGkyLCBuMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXCJlcnJvclwiID09PSBzMi5zdGF0dXMgJiYgbjIoczIudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHAoZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyID0ge307XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHIyLnZhbHVlID0gZTIodDIpLCByMi5zdGF0dXMgPSBcInN1Y2Nlc3NcIjtcbiAgICAgICAgICB9IGNhdGNoIChlMykge1xuICAgICAgICAgICAgcjIuc3RhdHVzID0gXCJlcnJvclwiLCByMi52YWx1ZSA9IGUzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcjI7XG4gICAgICAgIH1cbiAgICAgICAgKHQuZXhwb3J0cyA9IG8pLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24odDIpIHtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0MikgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgdmFyIHIyID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjIucmVzb2x2ZSh0MigpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlMikge1xuICAgICAgICAgICAgcmV0dXJuIHIyLnJlc29sdmUodDIoKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgby5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgZTIpO1xuICAgICAgICB9LCBvLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZTIgJiYgdGhpcy5zdGF0ZSA9PT0gYSB8fCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQyICYmIHRoaXMuc3RhdGUgPT09IHMpIHJldHVybiB0aGlzO1xuICAgICAgICAgIHZhciByMiA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHUpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgIT09IG4gPyBmKHIyLCB0aGlzLnN0YXRlID09PSBhID8gZTIgOiB0MiwgdGhpcy5vdXRjb21lKSA6IHRoaXMucXVldWUucHVzaChuZXcgaChyMiwgZTIsIHQyKSk7XG4gICAgICAgICAgcmV0dXJuIHIyO1xuICAgICAgICB9LCBoLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBsLnJlc29sdmUodGhpcy5wcm9taXNlLCBlMik7XG4gICAgICAgIH0sIGgucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgZih0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIGUyKTtcbiAgICAgICAgfSwgaC5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBsLnJlamVjdCh0aGlzLnByb21pc2UsIGUyKTtcbiAgICAgICAgfSwgaC5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGYodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIGUyKTtcbiAgICAgICAgfSwgbC5yZXNvbHZlID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyID0gcChjLCB0Mik7XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiA9PT0gcjIuc3RhdHVzKSByZXR1cm4gbC5yZWplY3QoZTIsIHIyLnZhbHVlKTtcbiAgICAgICAgICB2YXIgbjIgPSByMi52YWx1ZTtcbiAgICAgICAgICBpZiAobjIpIGQoZTIsIG4yKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGUyLnN0YXRlID0gYSwgZTIub3V0Y29tZSA9IHQyO1xuICAgICAgICAgICAgZm9yICh2YXIgaTIgPSAtMSwgczIgPSBlMi5xdWV1ZS5sZW5ndGg7ICsraTIgPCBzMjsgKSBlMi5xdWV1ZVtpMl0uY2FsbEZ1bGZpbGxlZCh0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgfSwgbC5yZWplY3QgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICBlMi5zdGF0ZSA9IHMsIGUyLm91dGNvbWUgPSB0MjtcbiAgICAgICAgICBmb3IgKHZhciByMiA9IC0xLCBuMiA9IGUyLnF1ZXVlLmxlbmd0aDsgKytyMiA8IG4yOyApIGUyLnF1ZXVlW3IyXS5jYWxsUmVqZWN0ZWQodDIpO1xuICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgfSwgby5yZXNvbHZlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBpZiAoZTIgaW5zdGFuY2VvZiB0aGlzKSByZXR1cm4gZTI7XG4gICAgICAgICAgcmV0dXJuIGwucmVzb2x2ZShuZXcgdGhpcyh1KSwgZTIpO1xuICAgICAgICB9LCBvLnJlamVjdCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gbmV3IHRoaXModSk7XG4gICAgICAgICAgcmV0dXJuIGwucmVqZWN0KHQyLCBlMik7XG4gICAgICAgIH0sIG8uYWxsID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgcjIgPSB0aGlzO1xuICAgICAgICAgIGlmIChcIltvYmplY3QgQXJyYXldXCIgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlMikpIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKFwibXVzdCBiZSBhbiBhcnJheVwiKSk7XG4gICAgICAgICAgdmFyIG4yID0gZTIubGVuZ3RoLCBpMiA9IGZhbHNlO1xuICAgICAgICAgIGlmICghbjIpIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICAgICAgICAgIHZhciBzMiA9IG5ldyBBcnJheShuMiksIGEyID0gMCwgdDIgPSAtMSwgbzIgPSBuZXcgdGhpcyh1KTtcbiAgICAgICAgICBmb3IgKDsgKyt0MiA8IG4yOyApIGgyKGUyW3QyXSwgdDIpO1xuICAgICAgICAgIHJldHVybiBvMjtcbiAgICAgICAgICBmdW5jdGlvbiBoMihlMywgdDMpIHtcbiAgICAgICAgICAgIHIyLnJlc29sdmUoZTMpLnRoZW4oZnVuY3Rpb24oZTQpIHtcbiAgICAgICAgICAgICAgczJbdDNdID0gZTQsICsrYTIgIT09IG4yIHx8IGkyIHx8IChpMiA9IHRydWUsIGwucmVzb2x2ZShvMiwgczIpKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGU0KSB7XG4gICAgICAgICAgICAgIGkyIHx8IChpMiA9IHRydWUsIGwucmVqZWN0KG8yLCBlNCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvLnJhY2UgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiA9IHRoaXM7XG4gICAgICAgICAgaWYgKFwiW29iamVjdCBBcnJheV1cIiAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUyKSkgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJtdXN0IGJlIGFuIGFycmF5XCIpKTtcbiAgICAgICAgICB2YXIgcjIgPSBlMi5sZW5ndGgsIG4yID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFyMikgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gICAgICAgICAgdmFyIGkyID0gLTEsIHMyID0gbmV3IHRoaXModSk7XG4gICAgICAgICAgZm9yICg7ICsraTIgPCByMjsgKSBhMiA9IGUyW2kyXSwgdDIucmVzb2x2ZShhMikudGhlbihmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgbjIgfHwgKG4yID0gdHJ1ZSwgbC5yZXNvbHZlKHMyLCBlMykpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGUzKSB7XG4gICAgICAgICAgICBuMiB8fCAobjIgPSB0cnVlLCBsLnJlamVjdChzMiwgZTMpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYTI7XG4gICAgICAgICAgcmV0dXJuIHMyO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBpbW1lZGlhdGU6IDM2IH1dLCAzODogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIG4gPSB7fTtcbiAgICAgICAgKDAsIGUoXCIuL2xpYi91dGlscy9jb21tb25cIikuYXNzaWduKShuLCBlKFwiLi9saWIvZGVmbGF0ZVwiKSwgZShcIi4vbGliL2luZmxhdGVcIiksIGUoXCIuL2xpYi96bGliL2NvbnN0YW50c1wiKSksIHQuZXhwb3J0cyA9IG47XG4gICAgICB9LCB7IFwiLi9saWIvZGVmbGF0ZVwiOiAzOSwgXCIuL2xpYi9pbmZsYXRlXCI6IDQwLCBcIi4vbGliL3V0aWxzL2NvbW1vblwiOiA0MSwgXCIuL2xpYi96bGliL2NvbnN0YW50c1wiOiA0NCB9XSwgMzk6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBhID0gZShcIi4vemxpYi9kZWZsYXRlXCIpLCBvID0gZShcIi4vdXRpbHMvY29tbW9uXCIpLCBoID0gZShcIi4vdXRpbHMvc3RyaW5nc1wiKSwgaSA9IGUoXCIuL3psaWIvbWVzc2FnZXNcIiksIHMgPSBlKFwiLi96bGliL3pzdHJlYW1cIiksIHUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBsID0gMCwgZiA9IC0xLCBjID0gMCwgZCA9IDg7XG4gICAgICAgIGZ1bmN0aW9uIHAoZTIpIHtcbiAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcCkpIHJldHVybiBuZXcgcChlMik7XG4gICAgICAgICAgdGhpcy5vcHRpb25zID0gby5hc3NpZ24oeyBsZXZlbDogZiwgbWV0aG9kOiBkLCBjaHVua1NpemU6IDE2Mzg0LCB3aW5kb3dCaXRzOiAxNSwgbWVtTGV2ZWw6IDgsIHN0cmF0ZWd5OiBjLCB0bzogXCJcIiB9LCBlMiB8fCB7fSk7XG4gICAgICAgICAgdmFyIHQyID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgIHQyLnJhdyAmJiAwIDwgdDIud2luZG93Qml0cyA/IHQyLndpbmRvd0JpdHMgPSAtdDIud2luZG93Qml0cyA6IHQyLmd6aXAgJiYgMCA8IHQyLndpbmRvd0JpdHMgJiYgdDIud2luZG93Qml0cyA8IDE2ICYmICh0Mi53aW5kb3dCaXRzICs9IDE2KSwgdGhpcy5lcnIgPSAwLCB0aGlzLm1zZyA9IFwiXCIsIHRoaXMuZW5kZWQgPSBmYWxzZSwgdGhpcy5jaHVua3MgPSBbXSwgdGhpcy5zdHJtID0gbmV3IHMoKSwgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICAgICAgdmFyIHIyID0gYS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCB0Mi5sZXZlbCwgdDIubWV0aG9kLCB0Mi53aW5kb3dCaXRzLCB0Mi5tZW1MZXZlbCwgdDIuc3RyYXRlZ3kpO1xuICAgICAgICAgIGlmIChyMiAhPT0gbCkgdGhyb3cgbmV3IEVycm9yKGlbcjJdKTtcbiAgICAgICAgICBpZiAodDIuaGVhZGVyICYmIGEuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIHQyLmhlYWRlciksIHQyLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgICAgIHZhciBuMjtcbiAgICAgICAgICAgIGlmIChuMiA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQyLmRpY3Rpb25hcnkgPyBoLnN0cmluZzJidWYodDIuZGljdGlvbmFyeSkgOiBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIgPT09IHUuY2FsbCh0Mi5kaWN0aW9uYXJ5KSA/IG5ldyBVaW50OEFycmF5KHQyLmRpY3Rpb25hcnkpIDogdDIuZGljdGlvbmFyeSwgKHIyID0gYS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG4yKSkgIT09IGwpIHRocm93IG5ldyBFcnJvcihpW3IyXSk7XG4gICAgICAgICAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG4oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyID0gbmV3IHAodDIpO1xuICAgICAgICAgIGlmIChyMi5wdXNoKGUyLCB0cnVlKSwgcjIuZXJyKSB0aHJvdyByMi5tc2cgfHwgaVtyMi5lcnJdO1xuICAgICAgICAgIHJldHVybiByMi5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHZhciByMiwgbjIsIGkyID0gdGhpcy5zdHJtLCBzMiA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBuMiA9IHQyID09PSB+fnQyID8gdDIgOiB0cnVlID09PSB0MiA/IDQgOiAwLCBcInN0cmluZ1wiID09IHR5cGVvZiBlMiA/IGkyLmlucHV0ID0gaC5zdHJpbmcyYnVmKGUyKSA6IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiA9PT0gdS5jYWxsKGUyKSA/IGkyLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZTIpIDogaTIuaW5wdXQgPSBlMiwgaTIubmV4dF9pbiA9IDAsIGkyLmF2YWlsX2luID0gaTIuaW5wdXQubGVuZ3RoO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgwID09PSBpMi5hdmFpbF9vdXQgJiYgKGkyLm91dHB1dCA9IG5ldyBvLkJ1ZjgoczIpLCBpMi5uZXh0X291dCA9IDAsIGkyLmF2YWlsX291dCA9IHMyKSwgMSAhPT0gKHIyID0gYS5kZWZsYXRlKGkyLCBuMikpICYmIHIyICE9PSBsKSByZXR1cm4gdGhpcy5vbkVuZChyMiksICEodGhpcy5lbmRlZCA9IHRydWUpO1xuICAgICAgICAgICAgMCAhPT0gaTIuYXZhaWxfb3V0ICYmICgwICE9PSBpMi5hdmFpbF9pbiB8fCA0ICE9PSBuMiAmJiAyICE9PSBuMikgfHwgKFwic3RyaW5nXCIgPT09IHRoaXMub3B0aW9ucy50byA/IHRoaXMub25EYXRhKGguYnVmMmJpbnN0cmluZyhvLnNocmlua0J1ZihpMi5vdXRwdXQsIGkyLm5leHRfb3V0KSkpIDogdGhpcy5vbkRhdGEoby5zaHJpbmtCdWYoaTIub3V0cHV0LCBpMi5uZXh0X291dCkpKTtcbiAgICAgICAgICB9IHdoaWxlICgoMCA8IGkyLmF2YWlsX2luIHx8IDAgPT09IGkyLmF2YWlsX291dCkgJiYgMSAhPT0gcjIpO1xuICAgICAgICAgIHJldHVybiA0ID09PSBuMiA/IChyMiA9IGEuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pLCB0aGlzLm9uRW5kKHIyKSwgdGhpcy5lbmRlZCA9IHRydWUsIHIyID09PSBsKSA6IDIgIT09IG4yIHx8ICh0aGlzLm9uRW5kKGwpLCAhKGkyLmF2YWlsX291dCA9IDApKTtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGUyKTtcbiAgICAgICAgfSwgcC5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGUyID09PSBsICYmIChcInN0cmluZ1wiID09PSB0aGlzLm9wdGlvbnMudG8gPyB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oXCJcIikgOiB0aGlzLnJlc3VsdCA9IG8uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLCB0aGlzLmNodW5rcyA9IFtdLCB0aGlzLmVyciA9IGUyLCB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG4gICAgICAgIH0sIHIuRGVmbGF0ZSA9IHAsIHIuZGVmbGF0ZSA9IG4sIHIuZGVmbGF0ZVJhdyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiAodDIgPSB0MiB8fCB7fSkucmF3ID0gdHJ1ZSwgbihlMiwgdDIpO1xuICAgICAgICB9LCByLmd6aXAgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICByZXR1cm4gKHQyID0gdDIgfHwge30pLmd6aXAgPSB0cnVlLCBuKGUyLCB0Mik7XG4gICAgICAgIH07XG4gICAgICB9LCB7IFwiLi91dGlscy9jb21tb25cIjogNDEsIFwiLi91dGlscy9zdHJpbmdzXCI6IDQyLCBcIi4vemxpYi9kZWZsYXRlXCI6IDQ2LCBcIi4vemxpYi9tZXNzYWdlc1wiOiA1MSwgXCIuL3psaWIvenN0cmVhbVwiOiA1MyB9XSwgNDA6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBjID0gZShcIi4vemxpYi9pbmZsYXRlXCIpLCBkID0gZShcIi4vdXRpbHMvY29tbW9uXCIpLCBwID0gZShcIi4vdXRpbHMvc3RyaW5nc1wiKSwgbSA9IGUoXCIuL3psaWIvY29uc3RhbnRzXCIpLCBuID0gZShcIi4vemxpYi9tZXNzYWdlc1wiKSwgaSA9IGUoXCIuL3psaWIvenN0cmVhbVwiKSwgcyA9IGUoXCIuL3psaWIvZ3poZWFkZXJcIiksIF8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgICAgICBmdW5jdGlvbiBhKGUyKSB7XG4gICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGEpKSByZXR1cm4gbmV3IGEoZTIpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGQuYXNzaWduKHsgY2h1bmtTaXplOiAxNjM4NCwgd2luZG93Qml0czogMCwgdG86IFwiXCIgfSwgZTIgfHwge30pO1xuICAgICAgICAgIHZhciB0MiA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICB0Mi5yYXcgJiYgMCA8PSB0Mi53aW5kb3dCaXRzICYmIHQyLndpbmRvd0JpdHMgPCAxNiAmJiAodDIud2luZG93Qml0cyA9IC10Mi53aW5kb3dCaXRzLCAwID09PSB0Mi53aW5kb3dCaXRzICYmICh0Mi53aW5kb3dCaXRzID0gLTE1KSksICEoMCA8PSB0Mi53aW5kb3dCaXRzICYmIHQyLndpbmRvd0JpdHMgPCAxNikgfHwgZTIgJiYgZTIud2luZG93Qml0cyB8fCAodDIud2luZG93Qml0cyArPSAzMiksIDE1IDwgdDIud2luZG93Qml0cyAmJiB0Mi53aW5kb3dCaXRzIDwgNDggJiYgMCA9PSAoMTUgJiB0Mi53aW5kb3dCaXRzKSAmJiAodDIud2luZG93Qml0cyB8PSAxNSksIHRoaXMuZXJyID0gMCwgdGhpcy5tc2cgPSBcIlwiLCB0aGlzLmVuZGVkID0gZmFsc2UsIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuc3RybSA9IG5ldyBpKCksIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgICAgIHZhciByMiA9IGMuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSwgdDIud2luZG93Qml0cyk7XG4gICAgICAgICAgaWYgKHIyICE9PSBtLlpfT0spIHRocm93IG5ldyBFcnJvcihuW3IyXSk7XG4gICAgICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgcygpLCBjLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbyhlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjIgPSBuZXcgYSh0Mik7XG4gICAgICAgICAgaWYgKHIyLnB1c2goZTIsIHRydWUpLCByMi5lcnIpIHRocm93IHIyLm1zZyB8fCBuW3IyLmVycl07XG4gICAgICAgICAgcmV0dXJuIHIyLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGggPSB0aGlzLnN0cm0sIHUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplLCBsID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnksIGYgPSBmYWxzZTtcbiAgICAgICAgICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIG4yID0gdDIgPT09IH5+dDIgPyB0MiA6IHRydWUgPT09IHQyID8gbS5aX0ZJTklTSCA6IG0uWl9OT19GTFVTSCwgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZTIgPyBoLmlucHV0ID0gcC5iaW5zdHJpbmcyYnVmKGUyKSA6IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIiA9PT0gXy5jYWxsKGUyKSA/IGguaW5wdXQgPSBuZXcgVWludDhBcnJheShlMikgOiBoLmlucHV0ID0gZTIsIGgubmV4dF9pbiA9IDAsIGguYXZhaWxfaW4gPSBoLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoMCA9PT0gaC5hdmFpbF9vdXQgJiYgKGgub3V0cHV0ID0gbmV3IGQuQnVmOCh1KSwgaC5uZXh0X291dCA9IDAsIGguYXZhaWxfb3V0ID0gdSksIChyMiA9IGMuaW5mbGF0ZShoLCBtLlpfTk9fRkxVU0gpKSA9PT0gbS5aX05FRURfRElDVCAmJiBsICYmIChvMiA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGwgPyBwLnN0cmluZzJidWYobCkgOiBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIgPT09IF8uY2FsbChsKSA/IG5ldyBVaW50OEFycmF5KGwpIDogbCwgcjIgPSBjLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgbzIpKSwgcjIgPT09IG0uWl9CVUZfRVJST1IgJiYgdHJ1ZSA9PT0gZiAmJiAocjIgPSBtLlpfT0ssIGYgPSBmYWxzZSksIHIyICE9PSBtLlpfU1RSRUFNX0VORCAmJiByMiAhPT0gbS5aX09LKSByZXR1cm4gdGhpcy5vbkVuZChyMiksICEodGhpcy5lbmRlZCA9IHRydWUpO1xuICAgICAgICAgICAgaC5uZXh0X291dCAmJiAoMCAhPT0gaC5hdmFpbF9vdXQgJiYgcjIgIT09IG0uWl9TVFJFQU1fRU5EICYmICgwICE9PSBoLmF2YWlsX2luIHx8IG4yICE9PSBtLlpfRklOSVNIICYmIG4yICE9PSBtLlpfU1lOQ19GTFVTSCkgfHwgKFwic3RyaW5nXCIgPT09IHRoaXMub3B0aW9ucy50byA/IChpMiA9IHAudXRmOGJvcmRlcihoLm91dHB1dCwgaC5uZXh0X291dCksIHMyID0gaC5uZXh0X291dCAtIGkyLCBhMiA9IHAuYnVmMnN0cmluZyhoLm91dHB1dCwgaTIpLCBoLm5leHRfb3V0ID0gczIsIGguYXZhaWxfb3V0ID0gdSAtIHMyLCBzMiAmJiBkLmFycmF5U2V0KGgub3V0cHV0LCBoLm91dHB1dCwgaTIsIHMyLCAwKSwgdGhpcy5vbkRhdGEoYTIpKSA6IHRoaXMub25EYXRhKGQuc2hyaW5rQnVmKGgub3V0cHV0LCBoLm5leHRfb3V0KSkpKSwgMCA9PT0gaC5hdmFpbF9pbiAmJiAwID09PSBoLmF2YWlsX291dCAmJiAoZiA9IHRydWUpO1xuICAgICAgICAgIH0gd2hpbGUgKCgwIDwgaC5hdmFpbF9pbiB8fCAwID09PSBoLmF2YWlsX291dCkgJiYgcjIgIT09IG0uWl9TVFJFQU1fRU5EKTtcbiAgICAgICAgICByZXR1cm4gcjIgPT09IG0uWl9TVFJFQU1fRU5EICYmIChuMiA9IG0uWl9GSU5JU0gpLCBuMiA9PT0gbS5aX0ZJTklTSCA/IChyMiA9IGMuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pLCB0aGlzLm9uRW5kKHIyKSwgdGhpcy5lbmRlZCA9IHRydWUsIHIyID09PSBtLlpfT0spIDogbjIgIT09IG0uWl9TWU5DX0ZMVVNIIHx8ICh0aGlzLm9uRW5kKG0uWl9PSyksICEoaC5hdmFpbF9vdXQgPSAwKSk7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgdGhpcy5jaHVua3MucHVzaChlMik7XG4gICAgICAgIH0sIGEucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBlMiA9PT0gbS5aX09LICYmIChcInN0cmluZ1wiID09PSB0aGlzLm9wdGlvbnMudG8gPyB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oXCJcIikgOiB0aGlzLnJlc3VsdCA9IGQuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLCB0aGlzLmNodW5rcyA9IFtdLCB0aGlzLmVyciA9IGUyLCB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG4gICAgICAgIH0sIHIuSW5mbGF0ZSA9IGEsIHIuaW5mbGF0ZSA9IG8sIHIuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiAodDIgPSB0MiB8fCB7fSkucmF3ID0gdHJ1ZSwgbyhlMiwgdDIpO1xuICAgICAgICB9LCByLnVuZ3ppcCA9IG87XG4gICAgICB9LCB7IFwiLi91dGlscy9jb21tb25cIjogNDEsIFwiLi91dGlscy9zdHJpbmdzXCI6IDQyLCBcIi4vemxpYi9jb25zdGFudHNcIjogNDQsIFwiLi96bGliL2d6aGVhZGVyXCI6IDQ3LCBcIi4vemxpYi9pbmZsYXRlXCI6IDQ5LCBcIi4vemxpYi9tZXNzYWdlc1wiOiA1MSwgXCIuL3psaWIvenN0cmVhbVwiOiA1MyB9XSwgNDE6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBuID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgVWludDhBcnJheSAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBVaW50MTZBcnJheSAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBJbnQzMkFycmF5O1xuICAgICAgICByLmFzc2lnbiA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgZm9yICh2YXIgdDIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyB0Mi5sZW5ndGg7ICkge1xuICAgICAgICAgICAgdmFyIHIyID0gdDIuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyMikge1xuICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgcjIpIHRocm93IG5ldyBUeXBlRXJyb3IocjIgKyBcIm11c3QgYmUgbm9uLW9iamVjdFwiKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbjIgaW4gcjIpIHIyLmhhc093blByb3BlcnR5KG4yKSAmJiAoZTJbbjJdID0gcjJbbjJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICB9LCByLnNocmlua0J1ZiA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiBlMi5sZW5ndGggPT09IHQyID8gZTIgOiBlMi5zdWJhcnJheSA/IGUyLnN1YmFycmF5KDAsIHQyKSA6IChlMi5sZW5ndGggPSB0MiwgZTIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaSA9IHsgYXJyYXlTZXQ6IGZ1bmN0aW9uKGUyLCB0MiwgcjIsIG4yLCBpMikge1xuICAgICAgICAgIGlmICh0Mi5zdWJhcnJheSAmJiBlMi5zdWJhcnJheSkgZTIuc2V0KHQyLnN1YmFycmF5KHIyLCByMiArIG4yKSwgaTIpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgczIgPSAwOyBzMiA8IG4yOyBzMisrKSBlMltpMiArIHMyXSA9IHQyW3IyICsgczJdO1xuICAgICAgICB9LCBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHZhciB0MiwgcjIsIG4yLCBpMiwgczIsIGE7XG4gICAgICAgICAgZm9yICh0MiA9IG4yID0gMCwgcjIgPSBlMi5sZW5ndGg7IHQyIDwgcjI7IHQyKyspIG4yICs9IGUyW3QyXS5sZW5ndGg7XG4gICAgICAgICAgZm9yIChhID0gbmV3IFVpbnQ4QXJyYXkobjIpLCB0MiA9IGkyID0gMCwgcjIgPSBlMi5sZW5ndGg7IHQyIDwgcjI7IHQyKyspIHMyID0gZTJbdDJdLCBhLnNldChzMiwgaTIpLCBpMiArPSBzMi5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH0gfSwgcyA9IHsgYXJyYXlTZXQ6IGZ1bmN0aW9uKGUyLCB0MiwgcjIsIG4yLCBpMikge1xuICAgICAgICAgIGZvciAodmFyIHMyID0gMDsgczIgPCBuMjsgczIrKykgZTJbaTIgKyBzMl0gPSB0MltyMiArIHMyXTtcbiAgICAgICAgfSwgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBlMik7XG4gICAgICAgIH0gfTtcbiAgICAgICAgci5zZXRUeXBlZCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgZTIgPyAoci5CdWY4ID0gVWludDhBcnJheSwgci5CdWYxNiA9IFVpbnQxNkFycmF5LCByLkJ1ZjMyID0gSW50MzJBcnJheSwgci5hc3NpZ24ociwgaSkpIDogKHIuQnVmOCA9IEFycmF5LCByLkJ1ZjE2ID0gQXJyYXksIHIuQnVmMzIgPSBBcnJheSwgci5hc3NpZ24ociwgcykpO1xuICAgICAgICB9LCByLnNldFR5cGVkKG4pO1xuICAgICAgfSwge31dLCA0MjogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIGggPSBlKFwiLi9jb21tb25cIiksIGkgPSB0cnVlLCBzID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIFswXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgaSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHUgPSBuZXcgaC5CdWY4KDI1NiksIG4gPSAwOyBuIDwgMjU2OyBuKyspIHVbbl0gPSAyNTIgPD0gbiA/IDYgOiAyNDggPD0gbiA/IDUgOiAyNDAgPD0gbiA/IDQgOiAyMjQgPD0gbiA/IDMgOiAxOTIgPD0gbiA/IDIgOiAxO1xuICAgICAgICBmdW5jdGlvbiBsKGUyLCB0Mikge1xuICAgICAgICAgIGlmICh0MiA8IDY1NTM3ICYmIChlMi5zdWJhcnJheSAmJiBzIHx8ICFlMi5zdWJhcnJheSAmJiBpKSkgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaC5zaHJpbmtCdWYoZTIsIHQyKSk7XG4gICAgICAgICAgZm9yICh2YXIgcjIgPSBcIlwiLCBuMiA9IDA7IG4yIDwgdDI7IG4yKyspIHIyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZTJbbjJdKTtcbiAgICAgICAgICByZXR1cm4gcjI7XG4gICAgICAgIH1cbiAgICAgICAgdVsyNTRdID0gdVsyNTRdID0gMSwgci5zdHJpbmcyYnVmID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgdDIsIHIyLCBuMiwgaTIsIHMyLCBhID0gZTIubGVuZ3RoLCBvID0gMDtcbiAgICAgICAgICBmb3IgKGkyID0gMDsgaTIgPCBhOyBpMisrKSA1NTI5NiA9PSAoNjQ1MTIgJiAocjIgPSBlMi5jaGFyQ29kZUF0KGkyKSkpICYmIGkyICsgMSA8IGEgJiYgNTYzMjAgPT0gKDY0NTEyICYgKG4yID0gZTIuY2hhckNvZGVBdChpMiArIDEpKSkgJiYgKHIyID0gNjU1MzYgKyAocjIgLSA1NTI5NiA8PCAxMCkgKyAobjIgLSA1NjMyMCksIGkyKyspLCBvICs9IHIyIDwgMTI4ID8gMSA6IHIyIDwgMjA0OCA/IDIgOiByMiA8IDY1NTM2ID8gMyA6IDQ7XG4gICAgICAgICAgZm9yICh0MiA9IG5ldyBoLkJ1ZjgobyksIGkyID0gczIgPSAwOyBzMiA8IG87IGkyKyspIDU1Mjk2ID09ICg2NDUxMiAmIChyMiA9IGUyLmNoYXJDb2RlQXQoaTIpKSkgJiYgaTIgKyAxIDwgYSAmJiA1NjMyMCA9PSAoNjQ1MTIgJiAobjIgPSBlMi5jaGFyQ29kZUF0KGkyICsgMSkpKSAmJiAocjIgPSA2NTUzNiArIChyMiAtIDU1Mjk2IDw8IDEwKSArIChuMiAtIDU2MzIwKSwgaTIrKyksIHIyIDwgMTI4ID8gdDJbczIrK10gPSByMiA6IChyMiA8IDIwNDggPyB0MltzMisrXSA9IDE5MiB8IHIyID4+PiA2IDogKHIyIDwgNjU1MzYgPyB0MltzMisrXSA9IDIyNCB8IHIyID4+PiAxMiA6ICh0MltzMisrXSA9IDI0MCB8IHIyID4+PiAxOCwgdDJbczIrK10gPSAxMjggfCByMiA+Pj4gMTIgJiA2MyksIHQyW3MyKytdID0gMTI4IHwgcjIgPj4+IDYgJiA2MyksIHQyW3MyKytdID0gMTI4IHwgNjMgJiByMik7XG4gICAgICAgICAgcmV0dXJuIHQyO1xuICAgICAgICB9LCByLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIHJldHVybiBsKGUyLCBlMi5sZW5ndGgpO1xuICAgICAgICB9LCByLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGZvciAodmFyIHQyID0gbmV3IGguQnVmOChlMi5sZW5ndGgpLCByMiA9IDAsIG4yID0gdDIubGVuZ3RoOyByMiA8IG4yOyByMisrKSB0MltyMl0gPSBlMi5jaGFyQ29kZUF0KHIyKTtcbiAgICAgICAgICByZXR1cm4gdDI7XG4gICAgICAgIH0sIHIuYnVmMnN0cmluZyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHZhciByMiwgbjIsIGkyLCBzMiwgYSA9IHQyIHx8IGUyLmxlbmd0aCwgbyA9IG5ldyBBcnJheSgyICogYSk7XG4gICAgICAgICAgZm9yIChyMiA9IG4yID0gMDsgcjIgPCBhOyApIGlmICgoaTIgPSBlMltyMisrXSkgPCAxMjgpIG9bbjIrK10gPSBpMjtcbiAgICAgICAgICBlbHNlIGlmICg0IDwgKHMyID0gdVtpMl0pKSBvW24yKytdID0gNjU1MzMsIHIyICs9IHMyIC0gMTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaTIgJj0gMiA9PT0gczIgPyAzMSA6IDMgPT09IHMyID8gMTUgOiA3OyAxIDwgczIgJiYgcjIgPCBhOyApIGkyID0gaTIgPDwgNiB8IDYzICYgZTJbcjIrK10sIHMyLS07XG4gICAgICAgICAgICAxIDwgczIgPyBvW24yKytdID0gNjU1MzMgOiBpMiA8IDY1NTM2ID8gb1tuMisrXSA9IGkyIDogKGkyIC09IDY1NTM2LCBvW24yKytdID0gNTUyOTYgfCBpMiA+PiAxMCAmIDEwMjMsIG9bbjIrK10gPSA1NjMyMCB8IDEwMjMgJiBpMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsKG8sIG4yKTtcbiAgICAgICAgfSwgci51dGY4Ym9yZGVyID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyO1xuICAgICAgICAgIGZvciAoKHQyID0gdDIgfHwgZTIubGVuZ3RoKSA+IGUyLmxlbmd0aCAmJiAodDIgPSBlMi5sZW5ndGgpLCByMiA9IHQyIC0gMTsgMCA8PSByMiAmJiAxMjggPT0gKDE5MiAmIGUyW3IyXSk7ICkgcjItLTtcbiAgICAgICAgICByZXR1cm4gcjIgPCAwID8gdDIgOiAwID09PSByMiA/IHQyIDogcjIgKyB1W2UyW3IyXV0gPiB0MiA/IHIyIDogdDI7XG4gICAgICAgIH07XG4gICAgICB9LCB7IFwiLi9jb21tb25cIjogNDEgfV0sIDQzOiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbihlMiwgdDIsIHIyLCBuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDY1NTM1ICYgZTIgfCAwLCBzID0gZTIgPj4+IDE2ICYgNjU1MzUgfCAwLCBhID0gMDsgMCAhPT0gcjI7ICkge1xuICAgICAgICAgICAgZm9yIChyMiAtPSBhID0gMmUzIDwgcjIgPyAyZTMgOiByMjsgcyA9IHMgKyAoaSA9IGkgKyB0MltuKytdIHwgMCkgfCAwLCAtLWE7ICkgO1xuICAgICAgICAgICAgaSAlPSA2NTUyMSwgcyAlPSA2NTUyMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGkgfCBzIDw8IDE2IHwgMDtcbiAgICAgICAgfTtcbiAgICAgIH0sIHt9XSwgNDQ6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHQuZXhwb3J0cyA9IHsgWl9OT19GTFVTSDogMCwgWl9QQVJUSUFMX0ZMVVNIOiAxLCBaX1NZTkNfRkxVU0g6IDIsIFpfRlVMTF9GTFVTSDogMywgWl9GSU5JU0g6IDQsIFpfQkxPQ0s6IDUsIFpfVFJFRVM6IDYsIFpfT0s6IDAsIFpfU1RSRUFNX0VORDogMSwgWl9ORUVEX0RJQ1Q6IDIsIFpfRVJSTk86IC0xLCBaX1NUUkVBTV9FUlJPUjogLTIsIFpfREFUQV9FUlJPUjogLTMsIFpfQlVGX0VSUk9SOiAtNSwgWl9OT19DT01QUkVTU0lPTjogMCwgWl9CRVNUX1NQRUVEOiAxLCBaX0JFU1RfQ09NUFJFU1NJT046IDksIFpfREVGQVVMVF9DT01QUkVTU0lPTjogLTEsIFpfRklMVEVSRUQ6IDEsIFpfSFVGRk1BTl9PTkxZOiAyLCBaX1JMRTogMywgWl9GSVhFRDogNCwgWl9ERUZBVUxUX1NUUkFURUdZOiAwLCBaX0JJTkFSWTogMCwgWl9URVhUOiAxLCBaX1VOS05PV046IDIsIFpfREVGTEFURUQ6IDggfTtcbiAgICAgIH0sIHt9XSwgNDU6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgZTIsIHQyID0gW10sIHIyID0gMDsgcjIgPCAyNTY7IHIyKyspIHtcbiAgICAgICAgICAgIGUyID0gcjI7XG4gICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IDg7IG4rKykgZTIgPSAxICYgZTIgPyAzOTg4MjkyMzg0IF4gZTIgPj4+IDEgOiBlMiA+Pj4gMTtcbiAgICAgICAgICAgIHQyW3IyXSA9IGUyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdDI7XG4gICAgICAgIH0oKTtcbiAgICAgICAgdC5leHBvcnRzID0gZnVuY3Rpb24oZTIsIHQyLCByMiwgbikge1xuICAgICAgICAgIHZhciBpID0gbywgcyA9IG4gKyByMjtcbiAgICAgICAgICBlMiBePSAtMTtcbiAgICAgICAgICBmb3IgKHZhciBhID0gbjsgYSA8IHM7IGErKykgZTIgPSBlMiA+Pj4gOCBeIGlbMjU1ICYgKGUyIF4gdDJbYV0pXTtcbiAgICAgICAgICByZXR1cm4gLTEgXiBlMjtcbiAgICAgICAgfTtcbiAgICAgIH0sIHt9XSwgNDY6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBoLCBjID0gZShcIi4uL3V0aWxzL2NvbW1vblwiKSwgdSA9IGUoXCIuL3RyZWVzXCIpLCBkID0gZShcIi4vYWRsZXIzMlwiKSwgcCA9IGUoXCIuL2NyYzMyXCIpLCBuID0gZShcIi4vbWVzc2FnZXNcIiksIGwgPSAwLCBmID0gNCwgbSA9IDAsIF8gPSAtMiwgZyA9IC0xLCBiID0gNCwgaSA9IDIsIHYgPSA4LCB5ID0gOSwgcyA9IDI4NiwgYSA9IDMwLCBvID0gMTksIHcgPSAyICogcyArIDEsIGsgPSAxNSwgeCA9IDMsIFMgPSAyNTgsIHogPSBTICsgeCArIDEsIEMgPSA0MiwgRSA9IDExMywgQSA9IDEsIEkgPSAyLCBPID0gMywgQiA9IDQ7XG4gICAgICAgIGZ1bmN0aW9uIFIoZTIsIHQyKSB7XG4gICAgICAgICAgcmV0dXJuIGUyLm1zZyA9IG5bdDJdLCB0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBUKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIChlMiA8PCAxKSAtICg0IDwgZTIgPyA5IDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gRChlMikge1xuICAgICAgICAgIGZvciAodmFyIHQyID0gZTIubGVuZ3RoOyAwIDw9IC0tdDI7ICkgZTJbdDJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBGKGUyKSB7XG4gICAgICAgICAgdmFyIHQyID0gZTIuc3RhdGUsIHIyID0gdDIucGVuZGluZztcbiAgICAgICAgICByMiA+IGUyLmF2YWlsX291dCAmJiAocjIgPSBlMi5hdmFpbF9vdXQpLCAwICE9PSByMiAmJiAoYy5hcnJheVNldChlMi5vdXRwdXQsIHQyLnBlbmRpbmdfYnVmLCB0Mi5wZW5kaW5nX291dCwgcjIsIGUyLm5leHRfb3V0KSwgZTIubmV4dF9vdXQgKz0gcjIsIHQyLnBlbmRpbmdfb3V0ICs9IHIyLCBlMi50b3RhbF9vdXQgKz0gcjIsIGUyLmF2YWlsX291dCAtPSByMiwgdDIucGVuZGluZyAtPSByMiwgMCA9PT0gdDIucGVuZGluZyAmJiAodDIucGVuZGluZ19vdXQgPSAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTihlMiwgdDIpIHtcbiAgICAgICAgICB1Ll90cl9mbHVzaF9ibG9jayhlMiwgMCA8PSBlMi5ibG9ja19zdGFydCA/IGUyLmJsb2NrX3N0YXJ0IDogLTEsIGUyLnN0cnN0YXJ0IC0gZTIuYmxvY2tfc3RhcnQsIHQyKSwgZTIuYmxvY2tfc3RhcnQgPSBlMi5zdHJzdGFydCwgRihlMi5zdHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBVKGUyLCB0Mikge1xuICAgICAgICAgIGUyLnBlbmRpbmdfYnVmW2UyLnBlbmRpbmcrK10gPSB0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBQKGUyLCB0Mikge1xuICAgICAgICAgIGUyLnBlbmRpbmdfYnVmW2UyLnBlbmRpbmcrK10gPSB0MiA+Pj4gOCAmIDI1NSwgZTIucGVuZGluZ19idWZbZTIucGVuZGluZysrXSA9IDI1NSAmIHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEwoZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMiwgaTIgPSBlMi5tYXhfY2hhaW5fbGVuZ3RoLCBzMiA9IGUyLnN0cnN0YXJ0LCBhMiA9IGUyLnByZXZfbGVuZ3RoLCBvMiA9IGUyLm5pY2VfbWF0Y2gsIGgyID0gZTIuc3Ryc3RhcnQgPiBlMi53X3NpemUgLSB6ID8gZTIuc3Ryc3RhcnQgLSAoZTIud19zaXplIC0geikgOiAwLCB1MiA9IGUyLndpbmRvdywgbDIgPSBlMi53X21hc2ssIGYyID0gZTIucHJldiwgYzIgPSBlMi5zdHJzdGFydCArIFMsIGQyID0gdTJbczIgKyBhMiAtIDFdLCBwMiA9IHUyW3MyICsgYTJdO1xuICAgICAgICAgIGUyLnByZXZfbGVuZ3RoID49IGUyLmdvb2RfbWF0Y2ggJiYgKGkyID4+PSAyKSwgbzIgPiBlMi5sb29rYWhlYWQgJiYgKG8yID0gZTIubG9va2FoZWFkKTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodTJbKHIyID0gdDIpICsgYTJdID09PSBwMiAmJiB1MltyMiArIGEyIC0gMV0gPT09IGQyICYmIHUyW3IyXSA9PT0gdTJbczJdICYmIHUyWysrcjJdID09PSB1MltzMiArIDFdKSB7XG4gICAgICAgICAgICAgIHMyICs9IDIsIHIyKys7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodTJbKytzMl0gPT09IHUyWysrcjJdICYmIHUyWysrczJdID09PSB1MlsrK3IyXSAmJiB1MlsrK3MyXSA9PT0gdTJbKytyMl0gJiYgdTJbKytzMl0gPT09IHUyWysrcjJdICYmIHUyWysrczJdID09PSB1MlsrK3IyXSAmJiB1MlsrK3MyXSA9PT0gdTJbKytyMl0gJiYgdTJbKytzMl0gPT09IHUyWysrcjJdICYmIHUyWysrczJdID09PSB1MlsrK3IyXSAmJiBzMiA8IGMyKTtcbiAgICAgICAgICAgICAgaWYgKG4yID0gUyAtIChjMiAtIHMyKSwgczIgPSBjMiAtIFMsIGEyIDwgbjIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZTIubWF0Y2hfc3RhcnQgPSB0MiwgbzIgPD0gKGEyID0gbjIpKSBicmVhaztcbiAgICAgICAgICAgICAgICBkMiA9IHUyW3MyICsgYTIgLSAxXSwgcDIgPSB1MltzMiArIGEyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKCh0MiA9IGYyW3QyICYgbDJdKSA+IGgyICYmIDAgIT0gLS1pMik7XG4gICAgICAgICAgcmV0dXJuIGEyIDw9IGUyLmxvb2thaGVhZCA/IGEyIDogZTIubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGooZTIpIHtcbiAgICAgICAgICB2YXIgdDIsIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGgyLCB1MiwgbDIsIGYyID0gZTIud19zaXplO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChpMiA9IGUyLndpbmRvd19zaXplIC0gZTIubG9va2FoZWFkIC0gZTIuc3Ryc3RhcnQsIGUyLnN0cnN0YXJ0ID49IGYyICsgKGYyIC0geikpIHtcbiAgICAgICAgICAgICAgZm9yIChjLmFycmF5U2V0KGUyLndpbmRvdywgZTIud2luZG93LCBmMiwgZjIsIDApLCBlMi5tYXRjaF9zdGFydCAtPSBmMiwgZTIuc3Ryc3RhcnQgLT0gZjIsIGUyLmJsb2NrX3N0YXJ0IC09IGYyLCB0MiA9IHIyID0gZTIuaGFzaF9zaXplOyBuMiA9IGUyLmhlYWRbLS10Ml0sIGUyLmhlYWRbdDJdID0gZjIgPD0gbjIgPyBuMiAtIGYyIDogMCwgLS1yMjsgKSA7XG4gICAgICAgICAgICAgIGZvciAodDIgPSByMiA9IGYyOyBuMiA9IGUyLnByZXZbLS10Ml0sIGUyLnByZXZbdDJdID0gZjIgPD0gbjIgPyBuMiAtIGYyIDogMCwgLS1yMjsgKSA7XG4gICAgICAgICAgICAgIGkyICs9IGYyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPT09IGUyLnN0cm0uYXZhaWxfaW4pIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGEyID0gZTIuc3RybSwgbzIgPSBlMi53aW5kb3csIGgyID0gZTIuc3Ryc3RhcnQgKyBlMi5sb29rYWhlYWQsIHUyID0gaTIsIGwyID0gdm9pZCAwLCBsMiA9IGEyLmF2YWlsX2luLCB1MiA8IGwyICYmIChsMiA9IHUyKSwgcjIgPSAwID09PSBsMiA/IDAgOiAoYTIuYXZhaWxfaW4gLT0gbDIsIGMuYXJyYXlTZXQobzIsIGEyLmlucHV0LCBhMi5uZXh0X2luLCBsMiwgaDIpLCAxID09PSBhMi5zdGF0ZS53cmFwID8gYTIuYWRsZXIgPSBkKGEyLmFkbGVyLCBvMiwgbDIsIGgyKSA6IDIgPT09IGEyLnN0YXRlLndyYXAgJiYgKGEyLmFkbGVyID0gcChhMi5hZGxlciwgbzIsIGwyLCBoMikpLCBhMi5uZXh0X2luICs9IGwyLCBhMi50b3RhbF9pbiArPSBsMiwgbDIpLCBlMi5sb29rYWhlYWQgKz0gcjIsIGUyLmxvb2thaGVhZCArIGUyLmluc2VydCA+PSB4KSBmb3IgKHMyID0gZTIuc3Ryc3RhcnQgLSBlMi5pbnNlcnQsIGUyLmluc19oID0gZTIud2luZG93W3MyXSwgZTIuaW5zX2ggPSAoZTIuaW5zX2ggPDwgZTIuaGFzaF9zaGlmdCBeIGUyLndpbmRvd1tzMiArIDFdKSAmIGUyLmhhc2hfbWFzazsgZTIuaW5zZXJ0ICYmIChlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W3MyICsgeCAtIDFdKSAmIGUyLmhhc2hfbWFzaywgZTIucHJldltzMiAmIGUyLndfbWFza10gPSBlMi5oZWFkW2UyLmluc19oXSwgZTIuaGVhZFtlMi5pbnNfaF0gPSBzMiwgczIrKywgZTIuaW5zZXJ0LS0sICEoZTIubG9va2FoZWFkICsgZTIuaW5zZXJ0IDwgeCkpOyApIDtcbiAgICAgICAgICB9IHdoaWxlIChlMi5sb29rYWhlYWQgPCB6ICYmIDAgIT09IGUyLnN0cm0uYXZhaWxfaW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFooZTIsIHQyKSB7XG4gICAgICAgICAgZm9yICh2YXIgcjIsIG4yOyA7ICkge1xuICAgICAgICAgICAgaWYgKGUyLmxvb2thaGVhZCA8IHopIHtcbiAgICAgICAgICAgICAgaWYgKGooZTIpLCBlMi5sb29rYWhlYWQgPCB6ICYmIHQyID09PSBsKSByZXR1cm4gQTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGUyLmxvb2thaGVhZCkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjIgPSAwLCBlMi5sb29rYWhlYWQgPj0geCAmJiAoZTIuaW5zX2ggPSAoZTIuaW5zX2ggPDwgZTIuaGFzaF9zaGlmdCBeIGUyLndpbmRvd1tlMi5zdHJzdGFydCArIHggLSAxXSkgJiBlMi5oYXNoX21hc2ssIHIyID0gZTIucHJldltlMi5zdHJzdGFydCAmIGUyLndfbWFza10gPSBlMi5oZWFkW2UyLmluc19oXSwgZTIuaGVhZFtlMi5pbnNfaF0gPSBlMi5zdHJzdGFydCksIDAgIT09IHIyICYmIGUyLnN0cnN0YXJ0IC0gcjIgPD0gZTIud19zaXplIC0geiAmJiAoZTIubWF0Y2hfbGVuZ3RoID0gTChlMiwgcjIpKSwgZTIubWF0Y2hfbGVuZ3RoID49IHgpIGlmIChuMiA9IHUuX3RyX3RhbGx5KGUyLCBlMi5zdHJzdGFydCAtIGUyLm1hdGNoX3N0YXJ0LCBlMi5tYXRjaF9sZW5ndGggLSB4KSwgZTIubG9va2FoZWFkIC09IGUyLm1hdGNoX2xlbmd0aCwgZTIubWF0Y2hfbGVuZ3RoIDw9IGUyLm1heF9sYXp5X21hdGNoICYmIGUyLmxvb2thaGVhZCA+PSB4KSB7XG4gICAgICAgICAgICAgIGZvciAoZTIubWF0Y2hfbGVuZ3RoLS07IGUyLnN0cnN0YXJ0KyssIGUyLmluc19oID0gKGUyLmluc19oIDw8IGUyLmhhc2hfc2hpZnQgXiBlMi53aW5kb3dbZTIuc3Ryc3RhcnQgKyB4IC0gMV0pICYgZTIuaGFzaF9tYXNrLCByMiA9IGUyLnByZXZbZTIuc3Ryc3RhcnQgJiBlMi53X21hc2tdID0gZTIuaGVhZFtlMi5pbnNfaF0sIGUyLmhlYWRbZTIuaW5zX2hdID0gZTIuc3Ryc3RhcnQsIDAgIT0gLS1lMi5tYXRjaF9sZW5ndGg7ICkgO1xuICAgICAgICAgICAgICBlMi5zdHJzdGFydCsrO1xuICAgICAgICAgICAgfSBlbHNlIGUyLnN0cnN0YXJ0ICs9IGUyLm1hdGNoX2xlbmd0aCwgZTIubWF0Y2hfbGVuZ3RoID0gMCwgZTIuaW5zX2ggPSBlMi53aW5kb3dbZTIuc3Ryc3RhcnRdLCBlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W2UyLnN0cnN0YXJ0ICsgMV0pICYgZTIuaGFzaF9tYXNrO1xuICAgICAgICAgICAgZWxzZSBuMiA9IHUuX3RyX3RhbGx5KGUyLCAwLCBlMi53aW5kb3dbZTIuc3Ryc3RhcnRdKSwgZTIubG9va2FoZWFkLS0sIGUyLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgICBpZiAobjIgJiYgKE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUyLmluc2VydCA9IGUyLnN0cnN0YXJ0IDwgeCAtIDEgPyBlMi5zdHJzdGFydCA6IHggLSAxLCB0MiA9PT0gZiA/IChOKGUyLCB0cnVlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQgPyBPIDogQikgOiBlMi5sYXN0X2xpdCAmJiAoTihlMiwgZmFsc2UpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCkgPyBBIDogSTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBXKGUyLCB0Mikge1xuICAgICAgICAgIGZvciAodmFyIHIyLCBuMiwgaTI7IDsgKSB7XG4gICAgICAgICAgICBpZiAoZTIubG9va2FoZWFkIDwgeikge1xuICAgICAgICAgICAgICBpZiAoaihlMiksIGUyLmxvb2thaGVhZCA8IHogJiYgdDIgPT09IGwpIHJldHVybiBBO1xuICAgICAgICAgICAgICBpZiAoMCA9PT0gZTIubG9va2FoZWFkKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMiA9IDAsIGUyLmxvb2thaGVhZCA+PSB4ICYmIChlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W2UyLnN0cnN0YXJ0ICsgeCAtIDFdKSAmIGUyLmhhc2hfbWFzaywgcjIgPSBlMi5wcmV2W2UyLnN0cnN0YXJ0ICYgZTIud19tYXNrXSA9IGUyLmhlYWRbZTIuaW5zX2hdLCBlMi5oZWFkW2UyLmluc19oXSA9IGUyLnN0cnN0YXJ0KSwgZTIucHJldl9sZW5ndGggPSBlMi5tYXRjaF9sZW5ndGgsIGUyLnByZXZfbWF0Y2ggPSBlMi5tYXRjaF9zdGFydCwgZTIubWF0Y2hfbGVuZ3RoID0geCAtIDEsIDAgIT09IHIyICYmIGUyLnByZXZfbGVuZ3RoIDwgZTIubWF4X2xhenlfbWF0Y2ggJiYgZTIuc3Ryc3RhcnQgLSByMiA8PSBlMi53X3NpemUgLSB6ICYmIChlMi5tYXRjaF9sZW5ndGggPSBMKGUyLCByMiksIGUyLm1hdGNoX2xlbmd0aCA8PSA1ICYmICgxID09PSBlMi5zdHJhdGVneSB8fCBlMi5tYXRjaF9sZW5ndGggPT09IHggJiYgNDA5NiA8IGUyLnN0cnN0YXJ0IC0gZTIubWF0Y2hfc3RhcnQpICYmIChlMi5tYXRjaF9sZW5ndGggPSB4IC0gMSkpLCBlMi5wcmV2X2xlbmd0aCA+PSB4ICYmIGUyLm1hdGNoX2xlbmd0aCA8PSBlMi5wcmV2X2xlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGkyID0gZTIuc3Ryc3RhcnQgKyBlMi5sb29rYWhlYWQgLSB4LCBuMiA9IHUuX3RyX3RhbGx5KGUyLCBlMi5zdHJzdGFydCAtIDEgLSBlMi5wcmV2X21hdGNoLCBlMi5wcmV2X2xlbmd0aCAtIHgpLCBlMi5sb29rYWhlYWQgLT0gZTIucHJldl9sZW5ndGggLSAxLCBlMi5wcmV2X2xlbmd0aCAtPSAyOyArK2UyLnN0cnN0YXJ0IDw9IGkyICYmIChlMi5pbnNfaCA9IChlMi5pbnNfaCA8PCBlMi5oYXNoX3NoaWZ0IF4gZTIud2luZG93W2UyLnN0cnN0YXJ0ICsgeCAtIDFdKSAmIGUyLmhhc2hfbWFzaywgcjIgPSBlMi5wcmV2W2UyLnN0cnN0YXJ0ICYgZTIud19tYXNrXSA9IGUyLmhlYWRbZTIuaW5zX2hdLCBlMi5oZWFkW2UyLmluc19oXSA9IGUyLnN0cnN0YXJ0KSwgMCAhPSAtLWUyLnByZXZfbGVuZ3RoOyApIDtcbiAgICAgICAgICAgICAgaWYgKGUyLm1hdGNoX2F2YWlsYWJsZSA9IDAsIGUyLm1hdGNoX2xlbmd0aCA9IHggLSAxLCBlMi5zdHJzdGFydCsrLCBuMiAmJiAoTihlMiwgZmFsc2UpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCkpIHJldHVybiBBO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlMi5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgaWYgKChuMiA9IHUuX3RyX3RhbGx5KGUyLCAwLCBlMi53aW5kb3dbZTIuc3Ryc3RhcnQgLSAxXSkpICYmIE4oZTIsIGZhbHNlKSwgZTIuc3Ryc3RhcnQrKywgZTIubG9va2FoZWFkLS0sIDAgPT09IGUyLnN0cm0uYXZhaWxfb3V0KSByZXR1cm4gQTtcbiAgICAgICAgICAgIH0gZWxzZSBlMi5tYXRjaF9hdmFpbGFibGUgPSAxLCBlMi5zdHJzdGFydCsrLCBlMi5sb29rYWhlYWQtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUyLm1hdGNoX2F2YWlsYWJsZSAmJiAobjIgPSB1Ll90cl90YWxseShlMiwgMCwgZTIud2luZG93W2UyLnN0cnN0YXJ0IC0gMV0pLCBlMi5tYXRjaF9hdmFpbGFibGUgPSAwKSwgZTIuaW5zZXJ0ID0gZTIuc3Ryc3RhcnQgPCB4IC0gMSA/IGUyLnN0cnN0YXJ0IDogeCAtIDEsIHQyID09PSBmID8gKE4oZTIsIHRydWUpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCA/IE8gOiBCKSA6IGUyLmxhc3RfbGl0ICYmIChOKGUyLCBmYWxzZSksIDAgPT09IGUyLnN0cm0uYXZhaWxfb3V0KSA/IEEgOiBJO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE0oZTIsIHQyLCByMiwgbjIsIGkyKSB7XG4gICAgICAgICAgdGhpcy5nb29kX2xlbmd0aCA9IGUyLCB0aGlzLm1heF9sYXp5ID0gdDIsIHRoaXMubmljZV9sZW5ndGggPSByMiwgdGhpcy5tYXhfY2hhaW4gPSBuMiwgdGhpcy5mdW5jID0gaTI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gSCgpIHtcbiAgICAgICAgICB0aGlzLnN0cm0gPSBudWxsLCB0aGlzLnN0YXR1cyA9IDAsIHRoaXMucGVuZGluZ19idWYgPSBudWxsLCB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwLCB0aGlzLnBlbmRpbmdfb3V0ID0gMCwgdGhpcy5wZW5kaW5nID0gMCwgdGhpcy53cmFwID0gMCwgdGhpcy5nemhlYWQgPSBudWxsLCB0aGlzLmd6aW5kZXggPSAwLCB0aGlzLm1ldGhvZCA9IHYsIHRoaXMubGFzdF9mbHVzaCA9IC0xLCB0aGlzLndfc2l6ZSA9IDAsIHRoaXMud19iaXRzID0gMCwgdGhpcy53X21hc2sgPSAwLCB0aGlzLndpbmRvdyA9IG51bGwsIHRoaXMud2luZG93X3NpemUgPSAwLCB0aGlzLnByZXYgPSBudWxsLCB0aGlzLmhlYWQgPSBudWxsLCB0aGlzLmluc19oID0gMCwgdGhpcy5oYXNoX3NpemUgPSAwLCB0aGlzLmhhc2hfYml0cyA9IDAsIHRoaXMuaGFzaF9tYXNrID0gMCwgdGhpcy5oYXNoX3NoaWZ0ID0gMCwgdGhpcy5ibG9ja19zdGFydCA9IDAsIHRoaXMubWF0Y2hfbGVuZ3RoID0gMCwgdGhpcy5wcmV2X21hdGNoID0gMCwgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwLCB0aGlzLnN0cnN0YXJ0ID0gMCwgdGhpcy5tYXRjaF9zdGFydCA9IDAsIHRoaXMubG9va2FoZWFkID0gMCwgdGhpcy5wcmV2X2xlbmd0aCA9IDAsIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDAsIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwLCB0aGlzLmxldmVsID0gMCwgdGhpcy5zdHJhdGVneSA9IDAsIHRoaXMuZ29vZF9tYXRjaCA9IDAsIHRoaXMubmljZV9tYXRjaCA9IDAsIHRoaXMuZHluX2x0cmVlID0gbmV3IGMuQnVmMTYoMiAqIHcpLCB0aGlzLmR5bl9kdHJlZSA9IG5ldyBjLkJ1ZjE2KDIgKiAoMiAqIGEgKyAxKSksIHRoaXMuYmxfdHJlZSA9IG5ldyBjLkJ1ZjE2KDIgKiAoMiAqIG8gKyAxKSksIEQodGhpcy5keW5fbHRyZWUpLCBEKHRoaXMuZHluX2R0cmVlKSwgRCh0aGlzLmJsX3RyZWUpLCB0aGlzLmxfZGVzYyA9IG51bGwsIHRoaXMuZF9kZXNjID0gbnVsbCwgdGhpcy5ibF9kZXNjID0gbnVsbCwgdGhpcy5ibF9jb3VudCA9IG5ldyBjLkJ1ZjE2KGsgKyAxKSwgdGhpcy5oZWFwID0gbmV3IGMuQnVmMTYoMiAqIHMgKyAxKSwgRCh0aGlzLmhlYXApLCB0aGlzLmhlYXBfbGVuID0gMCwgdGhpcy5oZWFwX21heCA9IDAsIHRoaXMuZGVwdGggPSBuZXcgYy5CdWYxNigyICogcyArIDEpLCBEKHRoaXMuZGVwdGgpLCB0aGlzLmxfYnVmID0gMCwgdGhpcy5saXRfYnVmc2l6ZSA9IDAsIHRoaXMubGFzdF9saXQgPSAwLCB0aGlzLmRfYnVmID0gMCwgdGhpcy5vcHRfbGVuID0gMCwgdGhpcy5zdGF0aWNfbGVuID0gMCwgdGhpcy5tYXRjaGVzID0gMCwgdGhpcy5pbnNlcnQgPSAwLCB0aGlzLmJpX2J1ZiA9IDAsIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEcoZTIpIHtcbiAgICAgICAgICB2YXIgdDI7XG4gICAgICAgICAgcmV0dXJuIGUyICYmIGUyLnN0YXRlID8gKGUyLnRvdGFsX2luID0gZTIudG90YWxfb3V0ID0gMCwgZTIuZGF0YV90eXBlID0gaSwgKHQyID0gZTIuc3RhdGUpLnBlbmRpbmcgPSAwLCB0Mi5wZW5kaW5nX291dCA9IDAsIHQyLndyYXAgPCAwICYmICh0Mi53cmFwID0gLXQyLndyYXApLCB0Mi5zdGF0dXMgPSB0Mi53cmFwID8gQyA6IEUsIGUyLmFkbGVyID0gMiA9PT0gdDIud3JhcCA/IDAgOiAxLCB0Mi5sYXN0X2ZsdXNoID0gbCwgdS5fdHJfaW5pdCh0MiksIG0pIDogUihlMiwgXyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gSyhlMikge1xuICAgICAgICAgIHZhciB0MiA9IEcoZTIpO1xuICAgICAgICAgIHJldHVybiB0MiA9PT0gbSAmJiBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgZTMud2luZG93X3NpemUgPSAyICogZTMud19zaXplLCBEKGUzLmhlYWQpLCBlMy5tYXhfbGF6eV9tYXRjaCA9IGhbZTMubGV2ZWxdLm1heF9sYXp5LCBlMy5nb29kX21hdGNoID0gaFtlMy5sZXZlbF0uZ29vZF9sZW5ndGgsIGUzLm5pY2VfbWF0Y2ggPSBoW2UzLmxldmVsXS5uaWNlX2xlbmd0aCwgZTMubWF4X2NoYWluX2xlbmd0aCA9IGhbZTMubGV2ZWxdLm1heF9jaGFpbiwgZTMuc3Ryc3RhcnQgPSAwLCBlMy5ibG9ja19zdGFydCA9IDAsIGUzLmxvb2thaGVhZCA9IDAsIGUzLmluc2VydCA9IDAsIGUzLm1hdGNoX2xlbmd0aCA9IGUzLnByZXZfbGVuZ3RoID0geCAtIDEsIGUzLm1hdGNoX2F2YWlsYWJsZSA9IDAsIGUzLmluc19oID0gMDtcbiAgICAgICAgICB9KGUyLnN0YXRlKSwgdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gWShlMiwgdDIsIHIyLCBuMiwgaTIsIHMyKSB7XG4gICAgICAgICAgaWYgKCFlMikgcmV0dXJuIF87XG4gICAgICAgICAgdmFyIGEyID0gMTtcbiAgICAgICAgICBpZiAodDIgPT09IGcgJiYgKHQyID0gNiksIG4yIDwgMCA/IChhMiA9IDAsIG4yID0gLW4yKSA6IDE1IDwgbjIgJiYgKGEyID0gMiwgbjIgLT0gMTYpLCBpMiA8IDEgfHwgeSA8IGkyIHx8IHIyICE9PSB2IHx8IG4yIDwgOCB8fCAxNSA8IG4yIHx8IHQyIDwgMCB8fCA5IDwgdDIgfHwgczIgPCAwIHx8IGIgPCBzMikgcmV0dXJuIFIoZTIsIF8pO1xuICAgICAgICAgIDggPT09IG4yICYmIChuMiA9IDkpO1xuICAgICAgICAgIHZhciBvMiA9IG5ldyBIKCk7XG4gICAgICAgICAgcmV0dXJuIChlMi5zdGF0ZSA9IG8yKS5zdHJtID0gZTIsIG8yLndyYXAgPSBhMiwgbzIuZ3poZWFkID0gbnVsbCwgbzIud19iaXRzID0gbjIsIG8yLndfc2l6ZSA9IDEgPDwgbzIud19iaXRzLCBvMi53X21hc2sgPSBvMi53X3NpemUgLSAxLCBvMi5oYXNoX2JpdHMgPSBpMiArIDcsIG8yLmhhc2hfc2l6ZSA9IDEgPDwgbzIuaGFzaF9iaXRzLCBvMi5oYXNoX21hc2sgPSBvMi5oYXNoX3NpemUgLSAxLCBvMi5oYXNoX3NoaWZ0ID0gfn4oKG8yLmhhc2hfYml0cyArIHggLSAxKSAvIHgpLCBvMi53aW5kb3cgPSBuZXcgYy5CdWY4KDIgKiBvMi53X3NpemUpLCBvMi5oZWFkID0gbmV3IGMuQnVmMTYobzIuaGFzaF9zaXplKSwgbzIucHJldiA9IG5ldyBjLkJ1ZjE2KG8yLndfc2l6ZSksIG8yLmxpdF9idWZzaXplID0gMSA8PCBpMiArIDYsIG8yLnBlbmRpbmdfYnVmX3NpemUgPSA0ICogbzIubGl0X2J1ZnNpemUsIG8yLnBlbmRpbmdfYnVmID0gbmV3IGMuQnVmOChvMi5wZW5kaW5nX2J1Zl9zaXplKSwgbzIuZF9idWYgPSAxICogbzIubGl0X2J1ZnNpemUsIG8yLmxfYnVmID0gMyAqIG8yLmxpdF9idWZzaXplLCBvMi5sZXZlbCA9IHQyLCBvMi5zdHJhdGVneSA9IHMyLCBvMi5tZXRob2QgPSByMiwgSyhlMik7XG4gICAgICAgIH1cbiAgICAgICAgaCA9IFtuZXcgTSgwLCAwLCAwLCAwLCBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjIgPSA2NTUzNTtcbiAgICAgICAgICBmb3IgKHIyID4gZTIucGVuZGluZ19idWZfc2l6ZSAtIDUgJiYgKHIyID0gZTIucGVuZGluZ19idWZfc2l6ZSAtIDUpOyA7ICkge1xuICAgICAgICAgICAgaWYgKGUyLmxvb2thaGVhZCA8PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChqKGUyKSwgMCA9PT0gZTIubG9va2FoZWFkICYmIHQyID09PSBsKSByZXR1cm4gQTtcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGUyLmxvb2thaGVhZCkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlMi5zdHJzdGFydCArPSBlMi5sb29rYWhlYWQsIGUyLmxvb2thaGVhZCA9IDA7XG4gICAgICAgICAgICB2YXIgbjIgPSBlMi5ibG9ja19zdGFydCArIHIyO1xuICAgICAgICAgICAgaWYgKCgwID09PSBlMi5zdHJzdGFydCB8fCBlMi5zdHJzdGFydCA+PSBuMikgJiYgKGUyLmxvb2thaGVhZCA9IGUyLnN0cnN0YXJ0IC0gbjIsIGUyLnN0cnN0YXJ0ID0gbjIsIE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpKSByZXR1cm4gQTtcbiAgICAgICAgICAgIGlmIChlMi5zdHJzdGFydCAtIGUyLmJsb2NrX3N0YXJ0ID49IGUyLndfc2l6ZSAtIHogJiYgKE4oZTIsIGZhbHNlKSwgMCA9PT0gZTIuc3RybS5hdmFpbF9vdXQpKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUyLmluc2VydCA9IDAsIHQyID09PSBmID8gKE4oZTIsIHRydWUpLCAwID09PSBlMi5zdHJtLmF2YWlsX291dCA/IE8gOiBCKSA6IChlMi5zdHJzdGFydCA+IGUyLmJsb2NrX3N0YXJ0ICYmIChOKGUyLCBmYWxzZSksIGUyLnN0cm0uYXZhaWxfb3V0KSwgQSk7XG4gICAgICAgIH0pLCBuZXcgTSg0LCA0LCA4LCA0LCBaKSwgbmV3IE0oNCwgNSwgMTYsIDgsIFopLCBuZXcgTSg0LCA2LCAzMiwgMzIsIFopLCBuZXcgTSg0LCA0LCAxNiwgMTYsIFcpLCBuZXcgTSg4LCAxNiwgMzIsIDMyLCBXKSwgbmV3IE0oOCwgMTYsIDEyOCwgMTI4LCBXKSwgbmV3IE0oOCwgMzIsIDEyOCwgMjU2LCBXKSwgbmV3IE0oMzIsIDEyOCwgMjU4LCAxMDI0LCBXKSwgbmV3IE0oMzIsIDI1OCwgMjU4LCA0MDk2LCBXKV0sIHIuZGVmbGF0ZUluaXQgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICByZXR1cm4gWShlMiwgdDIsIHYsIDE1LCA4LCAwKTtcbiAgICAgICAgfSwgci5kZWZsYXRlSW5pdDIgPSBZLCByLmRlZmxhdGVSZXNldCA9IEssIHIuZGVmbGF0ZVJlc2V0S2VlcCA9IEcsIHIuZGVmbGF0ZVNldEhlYWRlciA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/IDIgIT09IGUyLnN0YXRlLndyYXAgPyBfIDogKGUyLnN0YXRlLmd6aGVhZCA9IHQyLCBtKSA6IF87XG4gICAgICAgIH0sIHIuZGVmbGF0ZSA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHZhciByMiwgbjIsIGkyLCBzMjtcbiAgICAgICAgICBpZiAoIWUyIHx8ICFlMi5zdGF0ZSB8fCA1IDwgdDIgfHwgdDIgPCAwKSByZXR1cm4gZTIgPyBSKGUyLCBfKSA6IF87XG4gICAgICAgICAgaWYgKG4yID0gZTIuc3RhdGUsICFlMi5vdXRwdXQgfHwgIWUyLmlucHV0ICYmIDAgIT09IGUyLmF2YWlsX2luIHx8IDY2NiA9PT0gbjIuc3RhdHVzICYmIHQyICE9PSBmKSByZXR1cm4gUihlMiwgMCA9PT0gZTIuYXZhaWxfb3V0ID8gLTUgOiBfKTtcbiAgICAgICAgICBpZiAobjIuc3RybSA9IGUyLCByMiA9IG4yLmxhc3RfZmx1c2gsIG4yLmxhc3RfZmx1c2ggPSB0MiwgbjIuc3RhdHVzID09PSBDKSBpZiAoMiA9PT0gbjIud3JhcCkgZTIuYWRsZXIgPSAwLCBVKG4yLCAzMSksIFUobjIsIDEzOSksIFUobjIsIDgpLCBuMi5nemhlYWQgPyAoVShuMiwgKG4yLmd6aGVhZC50ZXh0ID8gMSA6IDApICsgKG4yLmd6aGVhZC5oY3JjID8gMiA6IDApICsgKG4yLmd6aGVhZC5leHRyYSA/IDQgOiAwKSArIChuMi5nemhlYWQubmFtZSA/IDggOiAwKSArIChuMi5nemhlYWQuY29tbWVudCA/IDE2IDogMCkpLCBVKG4yLCAyNTUgJiBuMi5nemhlYWQudGltZSksIFUobjIsIG4yLmd6aGVhZC50aW1lID4+IDggJiAyNTUpLCBVKG4yLCBuMi5nemhlYWQudGltZSA+PiAxNiAmIDI1NSksIFUobjIsIG4yLmd6aGVhZC50aW1lID4+IDI0ICYgMjU1KSwgVShuMiwgOSA9PT0gbjIubGV2ZWwgPyAyIDogMiA8PSBuMi5zdHJhdGVneSB8fCBuMi5sZXZlbCA8IDIgPyA0IDogMCksIFUobjIsIDI1NSAmIG4yLmd6aGVhZC5vcyksIG4yLmd6aGVhZC5leHRyYSAmJiBuMi5nemhlYWQuZXh0cmEubGVuZ3RoICYmIChVKG4yLCAyNTUgJiBuMi5nemhlYWQuZXh0cmEubGVuZ3RoKSwgVShuMiwgbjIuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4ICYgMjU1KSksIG4yLmd6aGVhZC5oY3JjICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nLCAwKSksIG4yLmd6aW5kZXggPSAwLCBuMi5zdGF0dXMgPSA2OSkgOiAoVShuMiwgMCksIFUobjIsIDApLCBVKG4yLCAwKSwgVShuMiwgMCksIFUobjIsIDApLCBVKG4yLCA5ID09PSBuMi5sZXZlbCA/IDIgOiAyIDw9IG4yLnN0cmF0ZWd5IHx8IG4yLmxldmVsIDwgMiA/IDQgOiAwKSwgVShuMiwgMyksIG4yLnN0YXR1cyA9IEUpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGEyID0gdiArIChuMi53X2JpdHMgLSA4IDw8IDQpIDw8IDg7XG4gICAgICAgICAgICBhMiB8PSAoMiA8PSBuMi5zdHJhdGVneSB8fCBuMi5sZXZlbCA8IDIgPyAwIDogbjIubGV2ZWwgPCA2ID8gMSA6IDYgPT09IG4yLmxldmVsID8gMiA6IDMpIDw8IDYsIDAgIT09IG4yLnN0cnN0YXJ0ICYmIChhMiB8PSAzMiksIGEyICs9IDMxIC0gYTIgJSAzMSwgbjIuc3RhdHVzID0gRSwgUChuMiwgYTIpLCAwICE9PSBuMi5zdHJzdGFydCAmJiAoUChuMiwgZTIuYWRsZXIgPj4+IDE2KSwgUChuMiwgNjU1MzUgJiBlMi5hZGxlcikpLCBlMi5hZGxlciA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICg2OSA9PT0gbjIuc3RhdHVzKSBpZiAobjIuZ3poZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKGkyID0gbjIucGVuZGluZzsgbjIuZ3ppbmRleCA8ICg2NTUzNSAmIG4yLmd6aGVhZC5leHRyYS5sZW5ndGgpICYmIChuMi5wZW5kaW5nICE9PSBuMi5wZW5kaW5nX2J1Zl9zaXplIHx8IChuMi5nemhlYWQuaGNyYyAmJiBuMi5wZW5kaW5nID4gaTIgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcgLSBpMiwgaTIpKSwgRihlMiksIGkyID0gbjIucGVuZGluZywgbjIucGVuZGluZyAhPT0gbjIucGVuZGluZ19idWZfc2l6ZSkpOyApIFUobjIsIDI1NSAmIG4yLmd6aGVhZC5leHRyYVtuMi5nemluZGV4XSksIG4yLmd6aW5kZXgrKztcbiAgICAgICAgICAgIG4yLmd6aGVhZC5oY3JjICYmIG4yLnBlbmRpbmcgPiBpMiAmJiAoZTIuYWRsZXIgPSBwKGUyLmFkbGVyLCBuMi5wZW5kaW5nX2J1ZiwgbjIucGVuZGluZyAtIGkyLCBpMikpLCBuMi5nemluZGV4ID09PSBuMi5nemhlYWQuZXh0cmEubGVuZ3RoICYmIChuMi5nemluZGV4ID0gMCwgbjIuc3RhdHVzID0gNzMpO1xuICAgICAgICAgIH0gZWxzZSBuMi5zdGF0dXMgPSA3MztcbiAgICAgICAgICBpZiAoNzMgPT09IG4yLnN0YXR1cykgaWYgKG4yLmd6aGVhZC5uYW1lKSB7XG4gICAgICAgICAgICBpMiA9IG4yLnBlbmRpbmc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChuMi5wZW5kaW5nID09PSBuMi5wZW5kaW5nX2J1Zl9zaXplICYmIChuMi5nemhlYWQuaGNyYyAmJiBuMi5wZW5kaW5nID4gaTIgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcgLSBpMiwgaTIpKSwgRihlMiksIGkyID0gbjIucGVuZGluZywgbjIucGVuZGluZyA9PT0gbjIucGVuZGluZ19idWZfc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBzMiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgczIgPSBuMi5nemluZGV4IDwgbjIuZ3poZWFkLm5hbWUubGVuZ3RoID8gMjU1ICYgbjIuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChuMi5nemluZGV4KyspIDogMCwgVShuMiwgczIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoMCAhPT0gczIpO1xuICAgICAgICAgICAgbjIuZ3poZWFkLmhjcmMgJiYgbjIucGVuZGluZyA+IGkyICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nIC0gaTIsIGkyKSksIDAgPT09IHMyICYmIChuMi5nemluZGV4ID0gMCwgbjIuc3RhdHVzID0gOTEpO1xuICAgICAgICAgIH0gZWxzZSBuMi5zdGF0dXMgPSA5MTtcbiAgICAgICAgICBpZiAoOTEgPT09IG4yLnN0YXR1cykgaWYgKG4yLmd6aGVhZC5jb21tZW50KSB7XG4gICAgICAgICAgICBpMiA9IG4yLnBlbmRpbmc7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmIChuMi5wZW5kaW5nID09PSBuMi5wZW5kaW5nX2J1Zl9zaXplICYmIChuMi5nemhlYWQuaGNyYyAmJiBuMi5wZW5kaW5nID4gaTIgJiYgKGUyLmFkbGVyID0gcChlMi5hZGxlciwgbjIucGVuZGluZ19idWYsIG4yLnBlbmRpbmcgLSBpMiwgaTIpKSwgRihlMiksIGkyID0gbjIucGVuZGluZywgbjIucGVuZGluZyA9PT0gbjIucGVuZGluZ19idWZfc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBzMiA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgczIgPSBuMi5nemluZGV4IDwgbjIuZ3poZWFkLmNvbW1lbnQubGVuZ3RoID8gMjU1ICYgbjIuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChuMi5nemluZGV4KyspIDogMCwgVShuMiwgczIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoMCAhPT0gczIpO1xuICAgICAgICAgICAgbjIuZ3poZWFkLmhjcmMgJiYgbjIucGVuZGluZyA+IGkyICYmIChlMi5hZGxlciA9IHAoZTIuYWRsZXIsIG4yLnBlbmRpbmdfYnVmLCBuMi5wZW5kaW5nIC0gaTIsIGkyKSksIDAgPT09IHMyICYmIChuMi5zdGF0dXMgPSAxMDMpO1xuICAgICAgICAgIH0gZWxzZSBuMi5zdGF0dXMgPSAxMDM7XG4gICAgICAgICAgaWYgKDEwMyA9PT0gbjIuc3RhdHVzICYmIChuMi5nemhlYWQuaGNyYyA/IChuMi5wZW5kaW5nICsgMiA+IG4yLnBlbmRpbmdfYnVmX3NpemUgJiYgRihlMiksIG4yLnBlbmRpbmcgKyAyIDw9IG4yLnBlbmRpbmdfYnVmX3NpemUgJiYgKFUobjIsIDI1NSAmIGUyLmFkbGVyKSwgVShuMiwgZTIuYWRsZXIgPj4gOCAmIDI1NSksIGUyLmFkbGVyID0gMCwgbjIuc3RhdHVzID0gRSkpIDogbjIuc3RhdHVzID0gRSksIDAgIT09IG4yLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChGKGUyKSwgMCA9PT0gZTIuYXZhaWxfb3V0KSByZXR1cm4gbjIubGFzdF9mbHVzaCA9IC0xLCBtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoMCA9PT0gZTIuYXZhaWxfaW4gJiYgVCh0MikgPD0gVChyMikgJiYgdDIgIT09IGYpIHJldHVybiBSKGUyLCAtNSk7XG4gICAgICAgICAgaWYgKDY2NiA9PT0gbjIuc3RhdHVzICYmIDAgIT09IGUyLmF2YWlsX2luKSByZXR1cm4gUihlMiwgLTUpO1xuICAgICAgICAgIGlmICgwICE9PSBlMi5hdmFpbF9pbiB8fCAwICE9PSBuMi5sb29rYWhlYWQgfHwgdDIgIT09IGwgJiYgNjY2ICE9PSBuMi5zdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBvMiA9IDIgPT09IG4yLnN0cmF0ZWd5ID8gZnVuY3Rpb24oZTMsIHQzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHIzOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBlMy5sb29rYWhlYWQgJiYgKGooZTMpLCAwID09PSBlMy5sb29rYWhlYWQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodDMgPT09IGwpIHJldHVybiBBO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlMy5tYXRjaF9sZW5ndGggPSAwLCByMyA9IHUuX3RyX3RhbGx5KGUzLCAwLCBlMy53aW5kb3dbZTMuc3Ryc3RhcnRdKSwgZTMubG9va2FoZWFkLS0sIGUzLnN0cnN0YXJ0KyssIHIzICYmIChOKGUzLCBmYWxzZSksIDAgPT09IGUzLnN0cm0uYXZhaWxfb3V0KSkgcmV0dXJuIEE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGUzLmluc2VydCA9IDAsIHQzID09PSBmID8gKE4oZTMsIHRydWUpLCAwID09PSBlMy5zdHJtLmF2YWlsX291dCA/IE8gOiBCKSA6IGUzLmxhc3RfbGl0ICYmIChOKGUzLCBmYWxzZSksIDAgPT09IGUzLnN0cm0uYXZhaWxfb3V0KSA/IEEgOiBJO1xuICAgICAgICAgICAgfShuMiwgdDIpIDogMyA9PT0gbjIuc3RyYXRlZ3kgPyBmdW5jdGlvbihlMywgdDMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgcjMsIG4zLCBpMywgczMsIGEzID0gZTMud2luZG93OyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChlMy5sb29rYWhlYWQgPD0gUykge1xuICAgICAgICAgICAgICAgICAgaWYgKGooZTMpLCBlMy5sb29rYWhlYWQgPD0gUyAmJiB0MyA9PT0gbCkgcmV0dXJuIEE7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZTMubG9va2FoZWFkKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUzLm1hdGNoX2xlbmd0aCA9IDAsIGUzLmxvb2thaGVhZCA+PSB4ICYmIDAgPCBlMy5zdHJzdGFydCAmJiAobjMgPSBhM1tpMyA9IGUzLnN0cnN0YXJ0IC0gMV0pID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgbjMgPT09IGEzWysraTNdKSB7XG4gICAgICAgICAgICAgICAgICBzMyA9IGUzLnN0cnN0YXJ0ICsgUztcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgbjMgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgbjMgPT09IGEzWysraTNdICYmIG4zID09PSBhM1srK2kzXSAmJiBuMyA9PT0gYTNbKytpM10gJiYgaTMgPCBzMyk7XG4gICAgICAgICAgICAgICAgICBlMy5tYXRjaF9sZW5ndGggPSBTIC0gKHMzIC0gaTMpLCBlMy5tYXRjaF9sZW5ndGggPiBlMy5sb29rYWhlYWQgJiYgKGUzLm1hdGNoX2xlbmd0aCA9IGUzLmxvb2thaGVhZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlMy5tYXRjaF9sZW5ndGggPj0geCA/IChyMyA9IHUuX3RyX3RhbGx5KGUzLCAxLCBlMy5tYXRjaF9sZW5ndGggLSB4KSwgZTMubG9va2FoZWFkIC09IGUzLm1hdGNoX2xlbmd0aCwgZTMuc3Ryc3RhcnQgKz0gZTMubWF0Y2hfbGVuZ3RoLCBlMy5tYXRjaF9sZW5ndGggPSAwKSA6IChyMyA9IHUuX3RyX3RhbGx5KGUzLCAwLCBlMy53aW5kb3dbZTMuc3Ryc3RhcnRdKSwgZTMubG9va2FoZWFkLS0sIGUzLnN0cnN0YXJ0KyspLCByMyAmJiAoTihlMywgZmFsc2UpLCAwID09PSBlMy5zdHJtLmF2YWlsX291dCkpIHJldHVybiBBO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBlMy5pbnNlcnQgPSAwLCB0MyA9PT0gZiA/IChOKGUzLCB0cnVlKSwgMCA9PT0gZTMuc3RybS5hdmFpbF9vdXQgPyBPIDogQikgOiBlMy5sYXN0X2xpdCAmJiAoTihlMywgZmFsc2UpLCAwID09PSBlMy5zdHJtLmF2YWlsX291dCkgPyBBIDogSTtcbiAgICAgICAgICAgIH0objIsIHQyKSA6IGhbbjIubGV2ZWxdLmZ1bmMobjIsIHQyKTtcbiAgICAgICAgICAgIGlmIChvMiAhPT0gTyAmJiBvMiAhPT0gQiB8fCAobjIuc3RhdHVzID0gNjY2KSwgbzIgPT09IEEgfHwgbzIgPT09IE8pIHJldHVybiAwID09PSBlMi5hdmFpbF9vdXQgJiYgKG4yLmxhc3RfZmx1c2ggPSAtMSksIG07XG4gICAgICAgICAgICBpZiAobzIgPT09IEkgJiYgKDEgPT09IHQyID8gdS5fdHJfYWxpZ24objIpIDogNSAhPT0gdDIgJiYgKHUuX3RyX3N0b3JlZF9ibG9jayhuMiwgMCwgMCwgZmFsc2UpLCAzID09PSB0MiAmJiAoRChuMi5oZWFkKSwgMCA9PT0gbjIubG9va2FoZWFkICYmIChuMi5zdHJzdGFydCA9IDAsIG4yLmJsb2NrX3N0YXJ0ID0gMCwgbjIuaW5zZXJ0ID0gMCkpKSwgRihlMiksIDAgPT09IGUyLmF2YWlsX291dCkpIHJldHVybiBuMi5sYXN0X2ZsdXNoID0gLTEsIG07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0MiAhPT0gZiA/IG0gOiBuMi53cmFwIDw9IDAgPyAxIDogKDIgPT09IG4yLndyYXAgPyAoVShuMiwgMjU1ICYgZTIuYWRsZXIpLCBVKG4yLCBlMi5hZGxlciA+PiA4ICYgMjU1KSwgVShuMiwgZTIuYWRsZXIgPj4gMTYgJiAyNTUpLCBVKG4yLCBlMi5hZGxlciA+PiAyNCAmIDI1NSksIFUobjIsIDI1NSAmIGUyLnRvdGFsX2luKSwgVShuMiwgZTIudG90YWxfaW4gPj4gOCAmIDI1NSksIFUobjIsIGUyLnRvdGFsX2luID4+IDE2ICYgMjU1KSwgVShuMiwgZTIudG90YWxfaW4gPj4gMjQgJiAyNTUpKSA6IChQKG4yLCBlMi5hZGxlciA+Pj4gMTYpLCBQKG4yLCA2NTUzNSAmIGUyLmFkbGVyKSksIEYoZTIpLCAwIDwgbjIud3JhcCAmJiAobjIud3JhcCA9IC1uMi53cmFwKSwgMCAhPT0gbjIucGVuZGluZyA/IG0gOiAxKTtcbiAgICAgICAgfSwgci5kZWZsYXRlRW5kID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICB2YXIgdDI7XG4gICAgICAgICAgcmV0dXJuIGUyICYmIGUyLnN0YXRlID8gKHQyID0gZTIuc3RhdGUuc3RhdHVzKSAhPT0gQyAmJiA2OSAhPT0gdDIgJiYgNzMgIT09IHQyICYmIDkxICE9PSB0MiAmJiAxMDMgIT09IHQyICYmIHQyICE9PSBFICYmIDY2NiAhPT0gdDIgPyBSKGUyLCBfKSA6IChlMi5zdGF0ZSA9IG51bGwsIHQyID09PSBFID8gUihlMiwgLTMpIDogbSkgOiBfO1xuICAgICAgICB9LCByLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMiwgaTIsIHMyLCBhMiwgbzIsIGgyLCB1MiwgbDIgPSB0Mi5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFlMiB8fCAhZTIuc3RhdGUpIHJldHVybiBfO1xuICAgICAgICAgIGlmICgyID09PSAoczIgPSAocjIgPSBlMi5zdGF0ZSkud3JhcCkgfHwgMSA9PT0gczIgJiYgcjIuc3RhdHVzICE9PSBDIHx8IHIyLmxvb2thaGVhZCkgcmV0dXJuIF87XG4gICAgICAgICAgZm9yICgxID09PSBzMiAmJiAoZTIuYWRsZXIgPSBkKGUyLmFkbGVyLCB0MiwgbDIsIDApKSwgcjIud3JhcCA9IDAsIGwyID49IHIyLndfc2l6ZSAmJiAoMCA9PT0gczIgJiYgKEQocjIuaGVhZCksIHIyLnN0cnN0YXJ0ID0gMCwgcjIuYmxvY2tfc3RhcnQgPSAwLCByMi5pbnNlcnQgPSAwKSwgdTIgPSBuZXcgYy5CdWY4KHIyLndfc2l6ZSksIGMuYXJyYXlTZXQodTIsIHQyLCBsMiAtIHIyLndfc2l6ZSwgcjIud19zaXplLCAwKSwgdDIgPSB1MiwgbDIgPSByMi53X3NpemUpLCBhMiA9IGUyLmF2YWlsX2luLCBvMiA9IGUyLm5leHRfaW4sIGgyID0gZTIuaW5wdXQsIGUyLmF2YWlsX2luID0gbDIsIGUyLm5leHRfaW4gPSAwLCBlMi5pbnB1dCA9IHQyLCBqKHIyKTsgcjIubG9va2FoZWFkID49IHg7ICkge1xuICAgICAgICAgICAgZm9yIChuMiA9IHIyLnN0cnN0YXJ0LCBpMiA9IHIyLmxvb2thaGVhZCAtICh4IC0gMSk7IHIyLmluc19oID0gKHIyLmluc19oIDw8IHIyLmhhc2hfc2hpZnQgXiByMi53aW5kb3dbbjIgKyB4IC0gMV0pICYgcjIuaGFzaF9tYXNrLCByMi5wcmV2W24yICYgcjIud19tYXNrXSA9IHIyLmhlYWRbcjIuaW5zX2hdLCByMi5oZWFkW3IyLmluc19oXSA9IG4yLCBuMisrLCAtLWkyOyApIDtcbiAgICAgICAgICAgIHIyLnN0cnN0YXJ0ID0gbjIsIHIyLmxvb2thaGVhZCA9IHggLSAxLCBqKHIyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHIyLnN0cnN0YXJ0ICs9IHIyLmxvb2thaGVhZCwgcjIuYmxvY2tfc3RhcnQgPSByMi5zdHJzdGFydCwgcjIuaW5zZXJ0ID0gcjIubG9va2FoZWFkLCByMi5sb29rYWhlYWQgPSAwLCByMi5tYXRjaF9sZW5ndGggPSByMi5wcmV2X2xlbmd0aCA9IHggLSAxLCByMi5tYXRjaF9hdmFpbGFibGUgPSAwLCBlMi5uZXh0X2luID0gbzIsIGUyLmlucHV0ID0gaDIsIGUyLmF2YWlsX2luID0gYTIsIHIyLndyYXAgPSBzMiwgbTtcbiAgICAgICAgfSwgci5kZWZsYXRlSW5mbyA9IFwicGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KVwiO1xuICAgICAgfSwgeyBcIi4uL3V0aWxzL2NvbW1vblwiOiA0MSwgXCIuL2FkbGVyMzJcIjogNDMsIFwiLi9jcmMzMlwiOiA0NSwgXCIuL21lc3NhZ2VzXCI6IDUxLCBcIi4vdHJlZXNcIjogNTIgfV0sIDQ3OiBbZnVuY3Rpb24oZSwgdCwgcikge1xuICAgICAgICB0LmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnRleHQgPSAwLCB0aGlzLnRpbWUgPSAwLCB0aGlzLnhmbGFncyA9IDAsIHRoaXMub3MgPSAwLCB0aGlzLmV4dHJhID0gbnVsbCwgdGhpcy5leHRyYV9sZW4gPSAwLCB0aGlzLm5hbWUgPSBcIlwiLCB0aGlzLmNvbW1lbnQgPSBcIlwiLCB0aGlzLmhjcmMgPSAwLCB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0sIHt9XSwgNDg6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCB0Mikge1xuICAgICAgICAgIHZhciByMiwgbiwgaSwgcywgYSwgbywgaCwgdSwgbCwgZiwgYywgZCwgcCwgbSwgXywgZywgYiwgdiwgeSwgdywgaywgeCwgUywgeiwgQztcbiAgICAgICAgICByMiA9IGUyLnN0YXRlLCBuID0gZTIubmV4dF9pbiwgeiA9IGUyLmlucHV0LCBpID0gbiArIChlMi5hdmFpbF9pbiAtIDUpLCBzID0gZTIubmV4dF9vdXQsIEMgPSBlMi5vdXRwdXQsIGEgPSBzIC0gKHQyIC0gZTIuYXZhaWxfb3V0KSwgbyA9IHMgKyAoZTIuYXZhaWxfb3V0IC0gMjU3KSwgaCA9IHIyLmRtYXgsIHUgPSByMi53c2l6ZSwgbCA9IHIyLndoYXZlLCBmID0gcjIud25leHQsIGMgPSByMi53aW5kb3csIGQgPSByMi5ob2xkLCBwID0gcjIuYml0cywgbSA9IHIyLmxlbmNvZGUsIF8gPSByMi5kaXN0Y29kZSwgZyA9ICgxIDw8IHIyLmxlbmJpdHMpIC0gMSwgYiA9ICgxIDw8IHIyLmRpc3RiaXRzKSAtIDE7XG4gICAgICAgICAgZTogZG8ge1xuICAgICAgICAgICAgcCA8IDE1ICYmIChkICs9IHpbbisrXSA8PCBwLCBwICs9IDgsIGQgKz0geltuKytdIDw8IHAsIHAgKz0gOCksIHYgPSBtW2QgJiBnXTtcbiAgICAgICAgICAgIHQ6IGZvciAoOyA7ICkge1xuICAgICAgICAgICAgICBpZiAoZCA+Pj49IHkgPSB2ID4+PiAyNCwgcCAtPSB5LCAwID09PSAoeSA9IHYgPj4+IDE2ICYgMjU1KSkgQ1tzKytdID0gNjU1MzUgJiB2O1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgxNiAmIHkpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PSAoNjQgJiB5KSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gbVsoNjU1MzUgJiB2KSArIChkICYgKDEgPDwgeSkgLSAxKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoMzIgJiB5KSB7XG4gICAgICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcgPSA2NTUzNSAmIHYsICh5ICY9IDE1KSAmJiAocCA8IHkgJiYgKGQgKz0geltuKytdIDw8IHAsIHAgKz0gOCksIHcgKz0gZCAmICgxIDw8IHkpIC0gMSwgZCA+Pj49IHksIHAgLT0geSksIHAgPCAxNSAmJiAoZCArPSB6W24rK10gPDwgcCwgcCArPSA4LCBkICs9IHpbbisrXSA8PCBwLCBwICs9IDgpLCB2ID0gX1tkICYgYl07XG4gICAgICAgICAgICAgICAgcjogZm9yICg7IDsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZCA+Pj49IHkgPSB2ID4+PiAyNCwgcCAtPSB5LCAhKDE2ICYgKHkgPSB2ID4+PiAxNiAmIDI1NSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09ICg2NCAmIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdiA9IF9bKDY1NTM1ICYgdikgKyAoZCAmICgxIDw8IHkpIC0gMSldO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGsgPSA2NTUzNSAmIHYsIHAgPCAoeSAmPSAxNSkgJiYgKGQgKz0geltuKytdIDw8IHAsIChwICs9IDgpIDwgeSAmJiAoZCArPSB6W24rK10gPDwgcCwgcCArPSA4KSksIGggPCAoayArPSBkICYgKDEgPDwgeSkgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrXCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkID4+Pj0geSwgcCAtPSB5LCAoeSA9IHMgLSBhKSA8IGspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPCAoeSA9IGsgLSB5KSAmJiByMi5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoUyA9IGMsICh4ID0gMCkgPT09IGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoeCArPSB1IC0geSwgeSA8IHcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodyAtPSB5OyBDW3MrK10gPSBjW3grK10sIC0teTsgKSA7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcyAtIGssIFMgPSBDO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmIDwgeSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICs9IHUgKyBmIC0geSwgKHkgLT0gZikgPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHcgLT0geTsgQ1tzKytdID0gY1t4KytdLCAtLXk7ICkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPSAwLCBmIDwgdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHcgLT0geSA9IGY7IENbcysrXSA9IGNbeCsrXSwgLS15OyApIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHMgLSBrLCBTID0gQztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCArPSBmIC0geSwgeSA8IHcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHcgLT0geTsgQ1tzKytdID0gY1t4KytdLCAtLXk7ICkgO1xuICAgICAgICAgICAgICAgICAgICAgIHggPSBzIC0gaywgUyA9IEM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IDIgPCB3OyApIENbcysrXSA9IFNbeCsrXSwgQ1tzKytdID0gU1t4KytdLCBDW3MrK10gPSBTW3grK10sIHcgLT0gMztcbiAgICAgICAgICAgICAgICAgICAgdyAmJiAoQ1tzKytdID0gU1t4KytdLCAxIDwgdyAmJiAoQ1tzKytdID0gU1t4KytdKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHggPSBzIC0gazsgQ1tzKytdID0gQ1t4KytdLCBDW3MrK10gPSBDW3grK10sIENbcysrXSA9IENbeCsrXSwgMiA8ICh3IC09IDMpOyApIDtcbiAgICAgICAgICAgICAgICAgICAgdyAmJiAoQ1tzKytdID0gQ1t4KytdLCAxIDwgdyAmJiAoQ1tzKytdID0gQ1t4KytdKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobiA8IGkgJiYgcyA8IG8pO1xuICAgICAgICAgIG4gLT0gdyA9IHAgPj4gMywgZCAmPSAoMSA8PCAocCAtPSB3IDw8IDMpKSAtIDEsIGUyLm5leHRfaW4gPSBuLCBlMi5uZXh0X291dCA9IHMsIGUyLmF2YWlsX2luID0gbiA8IGkgPyBpIC0gbiArIDUgOiA1IC0gKG4gLSBpKSwgZTIuYXZhaWxfb3V0ID0gcyA8IG8gPyBvIC0gcyArIDI1NyA6IDI1NyAtIChzIC0gbyksIHIyLmhvbGQgPSBkLCByMi5iaXRzID0gcDtcbiAgICAgICAgfTtcbiAgICAgIH0sIHt9XSwgNDk6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHZhciBJID0gZShcIi4uL3V0aWxzL2NvbW1vblwiKSwgTyA9IGUoXCIuL2FkbGVyMzJcIiksIEIgPSBlKFwiLi9jcmMzMlwiKSwgUiA9IGUoXCIuL2luZmZhc3RcIiksIFQgPSBlKFwiLi9pbmZ0cmVlc1wiKSwgRCA9IDEsIEYgPSAyLCBOID0gMCwgVSA9IC0yLCBQID0gMSwgbiA9IDg1MiwgaSA9IDU5MjtcbiAgICAgICAgZnVuY3Rpb24gTChlMikge1xuICAgICAgICAgIHJldHVybiAoZTIgPj4+IDI0ICYgMjU1KSArIChlMiA+Pj4gOCAmIDY1MjgwKSArICgoNjUyODAgJiBlMikgPDwgOCkgKyAoKDI1NSAmIGUyKSA8PCAyNCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcygpIHtcbiAgICAgICAgICB0aGlzLm1vZGUgPSAwLCB0aGlzLmxhc3QgPSBmYWxzZSwgdGhpcy53cmFwID0gMCwgdGhpcy5oYXZlZGljdCA9IGZhbHNlLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5kbWF4ID0gMCwgdGhpcy5jaGVjayA9IDAsIHRoaXMudG90YWwgPSAwLCB0aGlzLmhlYWQgPSBudWxsLCB0aGlzLndiaXRzID0gMCwgdGhpcy53c2l6ZSA9IDAsIHRoaXMud2hhdmUgPSAwLCB0aGlzLnduZXh0ID0gMCwgdGhpcy53aW5kb3cgPSBudWxsLCB0aGlzLmhvbGQgPSAwLCB0aGlzLmJpdHMgPSAwLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMub2Zmc2V0ID0gMCwgdGhpcy5leHRyYSA9IDAsIHRoaXMubGVuY29kZSA9IG51bGwsIHRoaXMuZGlzdGNvZGUgPSBudWxsLCB0aGlzLmxlbmJpdHMgPSAwLCB0aGlzLmRpc3RiaXRzID0gMCwgdGhpcy5uY29kZSA9IDAsIHRoaXMubmxlbiA9IDAsIHRoaXMubmRpc3QgPSAwLCB0aGlzLmhhdmUgPSAwLCB0aGlzLm5leHQgPSBudWxsLCB0aGlzLmxlbnMgPSBuZXcgSS5CdWYxNigzMjApLCB0aGlzLndvcmsgPSBuZXcgSS5CdWYxNigyODgpLCB0aGlzLmxlbmR5biA9IG51bGwsIHRoaXMuZGlzdGR5biA9IG51bGwsIHRoaXMuc2FuZSA9IDAsIHRoaXMuYmFjayA9IDAsIHRoaXMud2FzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhKGUyKSB7XG4gICAgICAgICAgdmFyIHQyO1xuICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/ICh0MiA9IGUyLnN0YXRlLCBlMi50b3RhbF9pbiA9IGUyLnRvdGFsX291dCA9IHQyLnRvdGFsID0gMCwgZTIubXNnID0gXCJcIiwgdDIud3JhcCAmJiAoZTIuYWRsZXIgPSAxICYgdDIud3JhcCksIHQyLm1vZGUgPSBQLCB0Mi5sYXN0ID0gMCwgdDIuaGF2ZWRpY3QgPSAwLCB0Mi5kbWF4ID0gMzI3NjgsIHQyLmhlYWQgPSBudWxsLCB0Mi5ob2xkID0gMCwgdDIuYml0cyA9IDAsIHQyLmxlbmNvZGUgPSB0Mi5sZW5keW4gPSBuZXcgSS5CdWYzMihuKSwgdDIuZGlzdGNvZGUgPSB0Mi5kaXN0ZHluID0gbmV3IEkuQnVmMzIoaSksIHQyLnNhbmUgPSAxLCB0Mi5iYWNrID0gLTEsIE4pIDogVTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvKGUyKSB7XG4gICAgICAgICAgdmFyIHQyO1xuICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/ICgodDIgPSBlMi5zdGF0ZSkud3NpemUgPSAwLCB0Mi53aGF2ZSA9IDAsIHQyLnduZXh0ID0gMCwgYShlMikpIDogVTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoKGUyLCB0Mikge1xuICAgICAgICAgIHZhciByMiwgbjI7XG4gICAgICAgICAgcmV0dXJuIGUyICYmIGUyLnN0YXRlID8gKG4yID0gZTIuc3RhdGUsIHQyIDwgMCA/IChyMiA9IDAsIHQyID0gLXQyKSA6IChyMiA9IDEgKyAodDIgPj4gNCksIHQyIDwgNDggJiYgKHQyICY9IDE1KSksIHQyICYmICh0MiA8IDggfHwgMTUgPCB0MikgPyBVIDogKG51bGwgIT09IG4yLndpbmRvdyAmJiBuMi53Yml0cyAhPT0gdDIgJiYgKG4yLndpbmRvdyA9IG51bGwpLCBuMi53cmFwID0gcjIsIG4yLndiaXRzID0gdDIsIG8oZTIpKSkgOiBVO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHUoZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMjtcbiAgICAgICAgICByZXR1cm4gZTIgPyAobjIgPSBuZXcgcygpLCAoZTIuc3RhdGUgPSBuMikud2luZG93ID0gbnVsbCwgKHIyID0gaChlMiwgdDIpKSAhPT0gTiAmJiAoZTIuc3RhdGUgPSBudWxsKSwgcjIpIDogVTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbCwgZiwgYyA9IHRydWU7XG4gICAgICAgIGZ1bmN0aW9uIGooZTIpIHtcbiAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgdmFyIHQyO1xuICAgICAgICAgICAgZm9yIChsID0gbmV3IEkuQnVmMzIoNTEyKSwgZiA9IG5ldyBJLkJ1ZjMyKDMyKSwgdDIgPSAwOyB0MiA8IDE0NDsgKSBlMi5sZW5zW3QyKytdID0gODtcbiAgICAgICAgICAgIGZvciAoOyB0MiA8IDI1NjsgKSBlMi5sZW5zW3QyKytdID0gOTtcbiAgICAgICAgICAgIGZvciAoOyB0MiA8IDI4MDsgKSBlMi5sZW5zW3QyKytdID0gNztcbiAgICAgICAgICAgIGZvciAoOyB0MiA8IDI4ODsgKSBlMi5sZW5zW3QyKytdID0gODtcbiAgICAgICAgICAgIGZvciAoVChELCBlMi5sZW5zLCAwLCAyODgsIGwsIDAsIGUyLndvcmssIHsgYml0czogOSB9KSwgdDIgPSAwOyB0MiA8IDMyOyApIGUyLmxlbnNbdDIrK10gPSA1O1xuICAgICAgICAgICAgVChGLCBlMi5sZW5zLCAwLCAzMiwgZiwgMCwgZTIud29yaywgeyBiaXRzOiA1IH0pLCBjID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUyLmxlbmNvZGUgPSBsLCBlMi5sZW5iaXRzID0gOSwgZTIuZGlzdGNvZGUgPSBmLCBlMi5kaXN0Yml0cyA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gWihlMiwgdDIsIHIyLCBuMikge1xuICAgICAgICAgIHZhciBpMiwgczIgPSBlMi5zdGF0ZTtcbiAgICAgICAgICByZXR1cm4gbnVsbCA9PT0gczIud2luZG93ICYmIChzMi53c2l6ZSA9IDEgPDwgczIud2JpdHMsIHMyLnduZXh0ID0gMCwgczIud2hhdmUgPSAwLCBzMi53aW5kb3cgPSBuZXcgSS5CdWY4KHMyLndzaXplKSksIG4yID49IHMyLndzaXplID8gKEkuYXJyYXlTZXQoczIud2luZG93LCB0MiwgcjIgLSBzMi53c2l6ZSwgczIud3NpemUsIDApLCBzMi53bmV4dCA9IDAsIHMyLndoYXZlID0gczIud3NpemUpIDogKG4yIDwgKGkyID0gczIud3NpemUgLSBzMi53bmV4dCkgJiYgKGkyID0gbjIpLCBJLmFycmF5U2V0KHMyLndpbmRvdywgdDIsIHIyIC0gbjIsIGkyLCBzMi53bmV4dCksIChuMiAtPSBpMikgPyAoSS5hcnJheVNldChzMi53aW5kb3csIHQyLCByMiAtIG4yLCBuMiwgMCksIHMyLnduZXh0ID0gbjIsIHMyLndoYXZlID0gczIud3NpemUpIDogKHMyLnduZXh0ICs9IGkyLCBzMi53bmV4dCA9PT0gczIud3NpemUgJiYgKHMyLnduZXh0ID0gMCksIHMyLndoYXZlIDwgczIud3NpemUgJiYgKHMyLndoYXZlICs9IGkyKSkpLCAwO1xuICAgICAgICB9XG4gICAgICAgIHIuaW5mbGF0ZVJlc2V0ID0gbywgci5pbmZsYXRlUmVzZXQyID0gaCwgci5pbmZsYXRlUmVzZXRLZWVwID0gYSwgci5pbmZsYXRlSW5pdCA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgcmV0dXJuIHUoZTIsIDE1KTtcbiAgICAgICAgfSwgci5pbmZsYXRlSW5pdDIgPSB1LCByLmluZmxhdGUgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjIsIG4yLCBpMiwgczIsIGEyLCBvMiwgaDIsIHUyLCBsMiwgZjIsIGMyLCBkLCBwLCBtLCBfLCBnLCBiLCB2LCB5LCB3LCBrLCB4LCBTLCB6LCBDID0gMCwgRSA9IG5ldyBJLkJ1ZjgoNCksIEEgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07XG4gICAgICAgICAgaWYgKCFlMiB8fCAhZTIuc3RhdGUgfHwgIWUyLm91dHB1dCB8fCAhZTIuaW5wdXQgJiYgMCAhPT0gZTIuYXZhaWxfaW4pIHJldHVybiBVO1xuICAgICAgICAgIDEyID09PSAocjIgPSBlMi5zdGF0ZSkubW9kZSAmJiAocjIubW9kZSA9IDEzKSwgYTIgPSBlMi5uZXh0X291dCwgaTIgPSBlMi5vdXRwdXQsIGgyID0gZTIuYXZhaWxfb3V0LCBzMiA9IGUyLm5leHRfaW4sIG4yID0gZTIuaW5wdXQsIG8yID0gZTIuYXZhaWxfaW4sIHUyID0gcjIuaG9sZCwgbDIgPSByMi5iaXRzLCBmMiA9IG8yLCBjMiA9IGgyLCB4ID0gTjtcbiAgICAgICAgICBlOiBmb3IgKDsgOyApIHN3aXRjaCAocjIubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBQOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gcjIud3JhcCkge1xuICAgICAgICAgICAgICAgIHIyLm1vZGUgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAxNjsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgyICYgcjIud3JhcCAmJiAzNTYxNSA9PT0gdTIpIHtcbiAgICAgICAgICAgICAgICBFW3IyLmNoZWNrID0gMF0gPSAyNTUgJiB1MiwgRVsxXSA9IHUyID4+PiA4ICYgMjU1LCByMi5jaGVjayA9IEIocjIuY2hlY2ssIEUsIDIsIDApLCBsMiA9IHUyID0gMCwgcjIubW9kZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIyLmZsYWdzID0gMCwgcjIuaGVhZCAmJiAocjIuaGVhZC5kb25lID0gZmFsc2UpLCAhKDEgJiByMi53cmFwKSB8fCAoKCgyNTUgJiB1MikgPDwgOCkgKyAodTIgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImluY29ycmVjdCBoZWFkZXIgY2hlY2tcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICg4ICE9ICgxNSAmIHUyKSkge1xuICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsMiAtPSA0LCBrID0gOCArICgxNSAmICh1MiA+Pj49IDQpKSwgMCA9PT0gcjIud2JpdHMpIHIyLndiaXRzID0gaztcbiAgICAgICAgICAgICAgZWxzZSBpZiAoayA+IHIyLndiaXRzKSB7XG4gICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIHdpbmRvdyBzaXplXCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5kbWF4ID0gMSA8PCBrLCBlMi5hZGxlciA9IHIyLmNoZWNrID0gMSwgcjIubW9kZSA9IDUxMiAmIHUyID8gMTAgOiAxMiwgbDIgPSB1MiA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAxNjsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyMi5mbGFncyA9IHUyLCA4ICE9ICgyNTUgJiByMi5mbGFncykpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcInVua25vd24gY29tcHJlc3Npb24gbWV0aG9kXCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoNTczNDQgJiByMi5mbGFncykge1xuICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwidW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0XCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5oZWFkICYmIChyMi5oZWFkLnRleHQgPSB1MiA+PiA4ICYgMSksIDUxMiAmIHIyLmZsYWdzICYmIChFWzBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCAyLCAwKSksIGwyID0gdTIgPSAwLCByMi5tb2RlID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMzI7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5oZWFkICYmIChyMi5oZWFkLnRpbWUgPSB1MiksIDUxMiAmIHIyLmZsYWdzICYmIChFWzBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgRVsyXSA9IHUyID4+PiAxNiAmIDI1NSwgRVszXSA9IHUyID4+PiAyNCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCA0LCAwKSksIGwyID0gdTIgPSAwLCByMi5tb2RlID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMTY7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5oZWFkICYmIChyMi5oZWFkLnhmbGFncyA9IDI1NSAmIHUyLCByMi5oZWFkLm9zID0gdTIgPj4gOCksIDUxMiAmIHIyLmZsYWdzICYmIChFWzBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCAyLCAwKSksIGwyID0gdTIgPSAwLCByMi5tb2RlID0gNTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgaWYgKDEwMjQgJiByMi5mbGFncykge1xuICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDE2OyApIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByMi5sZW5ndGggPSB1MiwgcjIuaGVhZCAmJiAocjIuaGVhZC5leHRyYV9sZW4gPSB1MiksIDUxMiAmIHIyLmZsYWdzICYmIChFWzBdID0gMjU1ICYgdTIsIEVbMV0gPSB1MiA+Pj4gOCAmIDI1NSwgcjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBFLCAyLCAwKSksIGwyID0gdTIgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2UgcjIuaGVhZCAmJiAocjIuaGVhZC5leHRyYSA9IG51bGwpO1xuICAgICAgICAgICAgICByMi5tb2RlID0gNjtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaWYgKDEwMjQgJiByMi5mbGFncyAmJiAobzIgPCAoZCA9IHIyLmxlbmd0aCkgJiYgKGQgPSBvMiksIGQgJiYgKHIyLmhlYWQgJiYgKGsgPSByMi5oZWFkLmV4dHJhX2xlbiAtIHIyLmxlbmd0aCwgcjIuaGVhZC5leHRyYSB8fCAocjIuaGVhZC5leHRyYSA9IG5ldyBBcnJheShyMi5oZWFkLmV4dHJhX2xlbikpLCBJLmFycmF5U2V0KHIyLmhlYWQuZXh0cmEsIG4yLCBzMiwgZCwgaykpLCA1MTIgJiByMi5mbGFncyAmJiAocjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBuMiwgZCwgczIpKSwgbzIgLT0gZCwgczIgKz0gZCwgcjIubGVuZ3RoIC09IGQpLCByMi5sZW5ndGgpKSBicmVhayBlO1xuICAgICAgICAgICAgICByMi5sZW5ndGggPSAwLCByMi5tb2RlID0gNztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgaWYgKDIwNDggJiByMi5mbGFncykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBrID0gbjJbczIgKyBkKytdLCByMi5oZWFkICYmIGsgJiYgcjIubGVuZ3RoIDwgNjU1MzYgJiYgKHIyLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGspKSwgayAmJiBkIDwgbzI7ICkgO1xuICAgICAgICAgICAgICAgIGlmICg1MTIgJiByMi5mbGFncyAmJiAocjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBuMiwgZCwgczIpKSwgbzIgLT0gZCwgczIgKz0gZCwgaykgYnJlYWsgZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHIyLmhlYWQgJiYgKHIyLmhlYWQubmFtZSA9IG51bGwpO1xuICAgICAgICAgICAgICByMi5sZW5ndGggPSAwLCByMi5tb2RlID0gODtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgaWYgKDQwOTYgJiByMi5mbGFncykge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBrID0gbjJbczIgKyBkKytdLCByMi5oZWFkICYmIGsgJiYgcjIubGVuZ3RoIDwgNjU1MzYgJiYgKHIyLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGspKSwgayAmJiBkIDwgbzI7ICkgO1xuICAgICAgICAgICAgICAgIGlmICg1MTIgJiByMi5mbGFncyAmJiAocjIuY2hlY2sgPSBCKHIyLmNoZWNrLCBuMiwgZCwgczIpKSwgbzIgLT0gZCwgczIgKz0gZCwgaykgYnJlYWsgZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHIyLmhlYWQgJiYgKHIyLmhlYWQuY29tbWVudCA9IG51bGwpO1xuICAgICAgICAgICAgICByMi5tb2RlID0gOTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgaWYgKDUxMiAmIHIyLmZsYWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMTY7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1MiAhPT0gKDY1NTM1ICYgcjIuY2hlY2spKSB7XG4gICAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImhlYWRlciBjcmMgbWlzbWF0Y2hcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGwyID0gdTIgPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIyLmhlYWQgJiYgKHIyLmhlYWQuaGNyYyA9IHIyLmZsYWdzID4+IDkgJiAxLCByMi5oZWFkLmRvbmUgPSB0cnVlKSwgZTIuYWRsZXIgPSByMi5jaGVjayA9IDAsIHIyLm1vZGUgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAzMjsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGUyLmFkbGVyID0gcjIuY2hlY2sgPSBMKHUyKSwgbDIgPSB1MiA9IDAsIHIyLm1vZGUgPSAxMTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGlmICgwID09PSByMi5oYXZlZGljdCkgcmV0dXJuIGUyLm5leHRfb3V0ID0gYTIsIGUyLmF2YWlsX291dCA9IGgyLCBlMi5uZXh0X2luID0gczIsIGUyLmF2YWlsX2luID0gbzIsIHIyLmhvbGQgPSB1MiwgcjIuYml0cyA9IGwyLCAyO1xuICAgICAgICAgICAgICBlMi5hZGxlciA9IHIyLmNoZWNrID0gMSwgcjIubW9kZSA9IDEyO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgaWYgKDUgPT09IHQyIHx8IDYgPT09IHQyKSBicmVhayBlO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgaWYgKHIyLmxhc3QpIHtcbiAgICAgICAgICAgICAgICB1MiA+Pj49IDcgJiBsMiwgbDIgLT0gNyAmIGwyLCByMi5tb2RlID0gMjc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMzsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN3aXRjaCAocjIubGFzdCA9IDEgJiB1MiwgbDIgLT0gMSwgMyAmICh1MiA+Pj49IDEpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgcjIubW9kZSA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgaWYgKGoocjIpLCByMi5tb2RlID0gMjAsIDYgIT09IHQyKSBicmVhaztcbiAgICAgICAgICAgICAgICAgIHUyID4+Pj0gMiwgbDIgLT0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgcjIubW9kZSA9IDE3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGJsb2NrIHR5cGVcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHUyID4+Pj0gMiwgbDIgLT0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBmb3IgKHUyID4+Pj0gNyAmIGwyLCBsMiAtPSA3ICYgbDI7IGwyIDwgMzI7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKDY1NTM1ICYgdTIpICE9ICh1MiA+Pj4gMTYgXiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyMi5sZW5ndGggPSA2NTUzNSAmIHUyLCBsMiA9IHUyID0gMCwgcjIubW9kZSA9IDE1LCA2ID09PSB0MikgYnJlYWsgZTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHIyLm1vZGUgPSAxNjtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIGlmIChkID0gcjIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8yIDwgZCAmJiAoZCA9IG8yKSwgaDIgPCBkICYmIChkID0gaDIpLCAwID09PSBkKSBicmVhayBlO1xuICAgICAgICAgICAgICAgIEkuYXJyYXlTZXQoaTIsIG4yLCBzMiwgZCwgYTIpLCBvMiAtPSBkLCBzMiArPSBkLCBoMiAtPSBkLCBhMiArPSBkLCByMi5sZW5ndGggLT0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5tb2RlID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgZm9yICg7IGwyIDwgMTQ7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocjIubmxlbiA9IDI1NyArICgzMSAmIHUyKSwgdTIgPj4+PSA1LCBsMiAtPSA1LCByMi5uZGlzdCA9IDEgKyAoMzEgJiB1MiksIHUyID4+Pj0gNSwgbDIgLT0gNSwgcjIubmNvZGUgPSA0ICsgKDE1ICYgdTIpLCB1MiA+Pj49IDQsIGwyIC09IDQsIDI4NiA8IHIyLm5sZW4gfHwgMzAgPCByMi5uZGlzdCkge1xuICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwidG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHNcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIyLmhhdmUgPSAwLCByMi5tb2RlID0gMTg7XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBmb3IgKDsgcjIuaGF2ZSA8IHIyLm5jb2RlOyApIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAzOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByMi5sZW5zW0FbcjIuaGF2ZSsrXV0gPSA3ICYgdTIsIHUyID4+Pj0gMywgbDIgLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKDsgcjIuaGF2ZSA8IDE5OyApIHIyLmxlbnNbQVtyMi5oYXZlKytdXSA9IDA7XG4gICAgICAgICAgICAgIGlmIChyMi5sZW5jb2RlID0gcjIubGVuZHluLCByMi5sZW5iaXRzID0gNywgUyA9IHsgYml0czogcjIubGVuYml0cyB9LCB4ID0gVCgwLCByMi5sZW5zLCAwLCAxOSwgcjIubGVuY29kZSwgMCwgcjIud29yaywgUyksIHIyLmxlbmJpdHMgPSBTLmJpdHMsIHgpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgY29kZSBsZW5ndGhzIHNldFwiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcjIuaGF2ZSA9IDAsIHIyLm1vZGUgPSAxOTtcbiAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgIGZvciAoOyByMi5oYXZlIDwgcjIubmxlbiArIHIyLm5kaXN0OyApIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgZyA9IChDID0gcjIubGVuY29kZVt1MiAmICgxIDw8IHIyLmxlbmJpdHMpIC0gMV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISgoXyA9IEMgPj4+IDI0KSA8PSBsMik7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiIDwgMTYpIHUyID4+Pj0gXywgbDIgLT0gXywgcjIubGVuc1tyMi5oYXZlKytdID0gYjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICgxNiA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHogPSBfICsgMjsgbDIgPCB6OyApIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHUyID4+Pj0gXywgbDIgLT0gXywgMCA9PT0gcjIuaGF2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgayA9IHIyLmxlbnNbcjIuaGF2ZSAtIDFdLCBkID0gMyArICgzICYgdTIpLCB1MiA+Pj49IDIsIGwyIC09IDI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDE3ID09PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoeiA9IF8gKyAzOyBsMiA8IHo7ICkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsMiAtPSBfLCBrID0gMCwgZCA9IDMgKyAoNyAmICh1MiA+Pj49IF8pKSwgdTIgPj4+PSAzLCBsMiAtPSAzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh6ID0gXyArIDc7IGwyIDwgejsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGwyIC09IF8sIGsgPSAwLCBkID0gMTEgKyAoMTI3ICYgKHUyID4+Pj0gXykpLCB1MiA+Pj49IDcsIGwyIC09IDc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocjIuaGF2ZSArIGQgPiByMi5ubGVuICsgcjIubmRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0XCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgZC0tOyApIHIyLmxlbnNbcjIuaGF2ZSsrXSA9IGs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICgzMCA9PT0gcjIubW9kZSkgYnJlYWs7XG4gICAgICAgICAgICAgIGlmICgwID09PSByMi5sZW5zWzI1Nl0pIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9ja1wiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIyLmxlbmJpdHMgPSA5LCBTID0geyBiaXRzOiByMi5sZW5iaXRzIH0sIHggPSBUKEQsIHIyLmxlbnMsIDAsIHIyLm5sZW4sIHIyLmxlbmNvZGUsIDAsIHIyLndvcmssIFMpLCByMi5sZW5iaXRzID0gUy5iaXRzLCB4KSB7XG4gICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXRcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyMi5kaXN0Yml0cyA9IDYsIHIyLmRpc3Rjb2RlID0gcjIuZGlzdGR5biwgUyA9IHsgYml0czogcjIuZGlzdGJpdHMgfSwgeCA9IFQoRiwgcjIubGVucywgcjIubmxlbiwgcjIubmRpc3QsIHIyLmRpc3Rjb2RlLCAwLCByMi53b3JrLCBTKSwgcjIuZGlzdGJpdHMgPSBTLmJpdHMsIHgpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgZGlzdGFuY2VzIHNldFwiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHIyLm1vZGUgPSAyMCwgNiA9PT0gdDIpIGJyZWFrIGU7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICByMi5tb2RlID0gMjE7XG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBpZiAoNiA8PSBvMiAmJiAyNTggPD0gaDIpIHtcbiAgICAgICAgICAgICAgICBlMi5uZXh0X291dCA9IGEyLCBlMi5hdmFpbF9vdXQgPSBoMiwgZTIubmV4dF9pbiA9IHMyLCBlMi5hdmFpbF9pbiA9IG8yLCByMi5ob2xkID0gdTIsIHIyLmJpdHMgPSBsMiwgUihlMiwgYzIpLCBhMiA9IGUyLm5leHRfb3V0LCBpMiA9IGUyLm91dHB1dCwgaDIgPSBlMi5hdmFpbF9vdXQsIHMyID0gZTIubmV4dF9pbiwgbjIgPSBlMi5pbnB1dCwgbzIgPSBlMi5hdmFpbF9pbiwgdTIgPSByMi5ob2xkLCBsMiA9IHIyLmJpdHMsIDEyID09PSByMi5tb2RlICYmIChyMi5iYWNrID0gLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAocjIuYmFjayA9IDA7IGcgPSAoQyA9IHIyLmxlbmNvZGVbdTIgJiAoMSA8PCByMi5sZW5iaXRzKSAtIDFdKSA+Pj4gMTYgJiAyNTUsIGIgPSA2NTUzNSAmIEMsICEoKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGcgJiYgMCA9PSAoMjQwICYgZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHYgPSBfLCB5ID0gZywgdyA9IGI7IGcgPSAoQyA9IHIyLmxlbmNvZGVbdyArICgodTIgJiAoMSA8PCB2ICsgeSkgLSAxKSA+PiB2KV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISh2ICsgKF8gPSBDID4+PiAyNCkgPD0gbDIpOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIG8yLS0sIHUyICs9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1MiA+Pj49IHYsIGwyIC09IHYsIHIyLmJhY2sgKz0gdjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodTIgPj4+PSBfLCBsMiAtPSBfLCByMi5iYWNrICs9IF8sIHIyLmxlbmd0aCA9IGIsIDAgPT09IGcpIHtcbiAgICAgICAgICAgICAgICByMi5tb2RlID0gMjY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKDMyICYgZykge1xuICAgICAgICAgICAgICAgIHIyLmJhY2sgPSAtMSwgcjIubW9kZSA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICg2NCAmIGcpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcjIuZXh0cmEgPSAxNSAmIGcsIHIyLm1vZGUgPSAyMjtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIGlmIChyMi5leHRyYSkge1xuICAgICAgICAgICAgICAgIGZvciAoeiA9IHIyLmV4dHJhOyBsMiA8IHo7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIyLmxlbmd0aCArPSB1MiAmICgxIDw8IHIyLmV4dHJhKSAtIDEsIHUyID4+Pj0gcjIuZXh0cmEsIGwyIC09IHIyLmV4dHJhLCByMi5iYWNrICs9IHIyLmV4dHJhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHIyLndhcyA9IHIyLmxlbmd0aCwgcjIubW9kZSA9IDIzO1xuICAgICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgICAgZm9yICg7IGcgPSAoQyA9IHIyLmRpc3Rjb2RlW3UyICYgKDEgPDwgcjIuZGlzdGJpdHMpIC0gMV0pID4+PiAxNiAmIDI1NSwgYiA9IDY1NTM1ICYgQywgISgoXyA9IEMgPj4+IDI0KSA8PSBsMik7ICkge1xuICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoMCA9PSAoMjQwICYgZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHYgPSBfLCB5ID0gZywgdyA9IGI7IGcgPSAoQyA9IHIyLmRpc3Rjb2RlW3cgKyAoKHUyICYgKDEgPDwgdiArIHkpIC0gMSkgPj4gdildKSA+Pj4gMTYgJiAyNTUsIGIgPSA2NTUzNSAmIEMsICEodiArIChfID0gQyA+Pj4gMjQpIDw9IGwyKTsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdTIgPj4+PSB2LCBsMiAtPSB2LCByMi5iYWNrICs9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHUyID4+Pj0gXywgbDIgLT0gXywgcjIuYmFjayArPSBfLCA2NCAmIGcpIHtcbiAgICAgICAgICAgICAgICBlMi5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcjIub2Zmc2V0ID0gYiwgcjIuZXh0cmEgPSAxNSAmIGcsIHIyLm1vZGUgPSAyNDtcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIGlmIChyMi5leHRyYSkge1xuICAgICAgICAgICAgICAgIGZvciAoeiA9IHIyLmV4dHJhOyBsMiA8IHo7ICkge1xuICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IG8yKSBicmVhayBlO1xuICAgICAgICAgICAgICAgICAgbzItLSwgdTIgKz0gbjJbczIrK10gPDwgbDIsIGwyICs9IDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHIyLm9mZnNldCArPSB1MiAmICgxIDw8IHIyLmV4dHJhKSAtIDEsIHUyID4+Pj0gcjIuZXh0cmEsIGwyIC09IHIyLmV4dHJhLCByMi5iYWNrICs9IHIyLmV4dHJhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyMi5vZmZzZXQgPiByMi5kbWF4KSB7XG4gICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcjIubW9kZSA9IDI1O1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGgyKSBicmVhayBlO1xuICAgICAgICAgICAgICBpZiAoZCA9IGMyIC0gaDIsIHIyLm9mZnNldCA+IGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGQgPSByMi5vZmZzZXQgLSBkKSA+IHIyLndoYXZlICYmIHIyLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIGUyLm1zZyA9IFwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIiwgcjIubW9kZSA9IDMwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBkID4gcjIud25leHQgPyAoZCAtPSByMi53bmV4dCwgcjIud3NpemUgLSBkKSA6IHIyLnduZXh0IC0gZCwgZCA+IHIyLmxlbmd0aCAmJiAoZCA9IHIyLmxlbmd0aCksIG0gPSByMi53aW5kb3c7XG4gICAgICAgICAgICAgIH0gZWxzZSBtID0gaTIsIHAgPSBhMiAtIHIyLm9mZnNldCwgZCA9IHIyLmxlbmd0aDtcbiAgICAgICAgICAgICAgZm9yIChoMiA8IGQgJiYgKGQgPSBoMiksIGgyIC09IGQsIHIyLmxlbmd0aCAtPSBkOyBpMlthMisrXSA9IG1bcCsrXSwgLS1kOyApIDtcbiAgICAgICAgICAgICAgMCA9PT0gcjIubGVuZ3RoICYmIChyMi5tb2RlID0gMjEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgIGlmICgwID09PSBoMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgaTJbYTIrK10gPSByMi5sZW5ndGgsIGgyLS0sIHIyLm1vZGUgPSAyMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBpZiAocjIud3JhcCkge1xuICAgICAgICAgICAgICAgIGZvciAoOyBsMiA8IDMyOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmICgwID09PSBvMikgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIG8yLS0sIHUyIHw9IG4yW3MyKytdIDw8IGwyLCBsMiArPSA4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYzIgLT0gaDIsIGUyLnRvdGFsX291dCArPSBjMiwgcjIudG90YWwgKz0gYzIsIGMyICYmIChlMi5hZGxlciA9IHIyLmNoZWNrID0gcjIuZmxhZ3MgPyBCKHIyLmNoZWNrLCBpMiwgYzIsIGEyIC0gYzIpIDogTyhyMi5jaGVjaywgaTIsIGMyLCBhMiAtIGMyKSksIGMyID0gaDIsIChyMi5mbGFncyA/IHUyIDogTCh1MikpICE9PSByMi5jaGVjaykge1xuICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbmNvcnJlY3QgZGF0YSBjaGVja1wiLCByMi5tb2RlID0gMzA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbDIgPSB1MiA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcjIubW9kZSA9IDI4O1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgaWYgKHIyLndyYXAgJiYgcjIuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbDIgPCAzMjsgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gbzIpIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgICBvMi0tLCB1MiArPSBuMltzMisrXSA8PCBsMiwgbDIgKz0gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHUyICE9PSAoNDI5NDk2NzI5NSAmIHIyLnRvdGFsKSkge1xuICAgICAgICAgICAgICAgICAgZTIubXNnID0gXCJpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrXCIsIHIyLm1vZGUgPSAzMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsMiA9IHUyID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByMi5tb2RlID0gMjk7XG4gICAgICAgICAgICBjYXNlIDI5OlxuICAgICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgIHggPSAtMztcbiAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIHJldHVybiAtNDtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGUyLm5leHRfb3V0ID0gYTIsIGUyLmF2YWlsX291dCA9IGgyLCBlMi5uZXh0X2luID0gczIsIGUyLmF2YWlsX2luID0gbzIsIHIyLmhvbGQgPSB1MiwgcjIuYml0cyA9IGwyLCAocjIud3NpemUgfHwgYzIgIT09IGUyLmF2YWlsX291dCAmJiByMi5tb2RlIDwgMzAgJiYgKHIyLm1vZGUgPCAyNyB8fCA0ICE9PSB0MikpICYmIFooZTIsIGUyLm91dHB1dCwgZTIubmV4dF9vdXQsIGMyIC0gZTIuYXZhaWxfb3V0KSA/IChyMi5tb2RlID0gMzEsIC00KSA6IChmMiAtPSBlMi5hdmFpbF9pbiwgYzIgLT0gZTIuYXZhaWxfb3V0LCBlMi50b3RhbF9pbiArPSBmMiwgZTIudG90YWxfb3V0ICs9IGMyLCByMi50b3RhbCArPSBjMiwgcjIud3JhcCAmJiBjMiAmJiAoZTIuYWRsZXIgPSByMi5jaGVjayA9IHIyLmZsYWdzID8gQihyMi5jaGVjaywgaTIsIGMyLCBlMi5uZXh0X291dCAtIGMyKSA6IE8ocjIuY2hlY2ssIGkyLCBjMiwgZTIubmV4dF9vdXQgLSBjMikpLCBlMi5kYXRhX3R5cGUgPSByMi5iaXRzICsgKHIyLmxhc3QgPyA2NCA6IDApICsgKDEyID09PSByMi5tb2RlID8gMTI4IDogMCkgKyAoMjAgPT09IHIyLm1vZGUgfHwgMTUgPT09IHIyLm1vZGUgPyAyNTYgOiAwKSwgKDAgPT0gZjIgJiYgMCA9PT0gYzIgfHwgNCA9PT0gdDIpICYmIHggPT09IE4gJiYgKHggPSAtNSksIHgpO1xuICAgICAgICB9LCByLmluZmxhdGVFbmQgPSBmdW5jdGlvbihlMikge1xuICAgICAgICAgIGlmICghZTIgfHwgIWUyLnN0YXRlKSByZXR1cm4gVTtcbiAgICAgICAgICB2YXIgdDIgPSBlMi5zdGF0ZTtcbiAgICAgICAgICByZXR1cm4gdDIud2luZG93ICYmICh0Mi53aW5kb3cgPSBudWxsKSwgZTIuc3RhdGUgPSBudWxsLCBOO1xuICAgICAgICB9LCByLmluZmxhdGVHZXRIZWFkZXIgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjI7XG4gICAgICAgICAgcmV0dXJuIGUyICYmIGUyLnN0YXRlID8gMCA9PSAoMiAmIChyMiA9IGUyLnN0YXRlKS53cmFwKSA/IFUgOiAoKHIyLmhlYWQgPSB0MikuZG9uZSA9IGZhbHNlLCBOKSA6IFU7XG4gICAgICAgIH0sIHIuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBmdW5jdGlvbihlMiwgdDIpIHtcbiAgICAgICAgICB2YXIgcjIsIG4yID0gdDIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBlMiAmJiBlMi5zdGF0ZSA/IDAgIT09IChyMiA9IGUyLnN0YXRlKS53cmFwICYmIDExICE9PSByMi5tb2RlID8gVSA6IDExID09PSByMi5tb2RlICYmIE8oMSwgdDIsIG4yLCAwKSAhPT0gcjIuY2hlY2sgPyAtMyA6IFooZTIsIHQyLCBuMiwgbjIpID8gKHIyLm1vZGUgPSAzMSwgLTQpIDogKHIyLmhhdmVkaWN0ID0gMSwgTikgOiBVO1xuICAgICAgICB9LCByLmluZmxhdGVJbmZvID0gXCJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpXCI7XG4gICAgICB9LCB7IFwiLi4vdXRpbHMvY29tbW9uXCI6IDQxLCBcIi4vYWRsZXIzMlwiOiA0MywgXCIuL2NyYzMyXCI6IDQ1LCBcIi4vaW5mZmFzdFwiOiA0OCwgXCIuL2luZnRyZWVzXCI6IDUwIH1dLCA1MDogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIEQgPSBlKFwiLi4vdXRpbHMvY29tbW9uXCIpLCBGID0gWzMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXSwgTiA9IFsxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OF0sIFUgPSBbMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLCAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBdLCBQID0gWzE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLCAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNywgMjgsIDI4LCAyOSwgMjksIDY0LCA2NF07XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIsIG4sIGksIHMsIGEsIG8pIHtcbiAgICAgICAgICB2YXIgaCwgdSwgbCwgZiwgYywgZCwgcCwgbSwgXywgZyA9IG8uYml0cywgYiA9IDAsIHYgPSAwLCB5ID0gMCwgdyA9IDAsIGsgPSAwLCB4ID0gMCwgUyA9IDAsIHogPSAwLCBDID0gMCwgRSA9IDAsIEEgPSBudWxsLCBJID0gMCwgTyA9IG5ldyBELkJ1ZjE2KDE2KSwgQiA9IG5ldyBELkJ1ZjE2KDE2KSwgUiA9IG51bGwsIFQgPSAwO1xuICAgICAgICAgIGZvciAoYiA9IDA7IGIgPD0gMTU7IGIrKykgT1tiXSA9IDA7XG4gICAgICAgICAgZm9yICh2ID0gMDsgdiA8IG47IHYrKykgT1t0MltyMiArIHZdXSsrO1xuICAgICAgICAgIGZvciAoayA9IGcsIHcgPSAxNTsgMSA8PSB3ICYmIDAgPT09IE9bd107IHctLSkgO1xuICAgICAgICAgIGlmICh3IDwgayAmJiAoayA9IHcpLCAwID09PSB3KSByZXR1cm4gaVtzKytdID0gMjA5NzE1MjAsIGlbcysrXSA9IDIwOTcxNTIwLCBvLmJpdHMgPSAxLCAwO1xuICAgICAgICAgIGZvciAoeSA9IDE7IHkgPCB3ICYmIDAgPT09IE9beV07IHkrKykgO1xuICAgICAgICAgIGZvciAoayA8IHkgJiYgKGsgPSB5KSwgYiA9IHogPSAxOyBiIDw9IDE1OyBiKyspIGlmICh6IDw8PSAxLCAoeiAtPSBPW2JdKSA8IDApIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoMCA8IHogJiYgKDAgPT09IGUyIHx8IDEgIT09IHcpKSByZXR1cm4gLTE7XG4gICAgICAgICAgZm9yIChCWzFdID0gMCwgYiA9IDE7IGIgPCAxNTsgYisrKSBCW2IgKyAxXSA9IEJbYl0gKyBPW2JdO1xuICAgICAgICAgIGZvciAodiA9IDA7IHYgPCBuOyB2KyspIDAgIT09IHQyW3IyICsgdl0gJiYgKGFbQlt0MltyMiArIHZdXSsrXSA9IHYpO1xuICAgICAgICAgIGlmIChkID0gMCA9PT0gZTIgPyAoQSA9IFIgPSBhLCAxOSkgOiAxID09PSBlMiA/IChBID0gRiwgSSAtPSAyNTcsIFIgPSBOLCBUIC09IDI1NywgMjU2KSA6IChBID0gVSwgUiA9IFAsIC0xKSwgYiA9IHksIGMgPSBzLCBTID0gdiA9IEUgPSAwLCBsID0gLTEsIGYgPSAoQyA9IDEgPDwgKHggPSBrKSkgLSAxLCAxID09PSBlMiAmJiA4NTIgPCBDIHx8IDIgPT09IGUyICYmIDU5MiA8IEMpIHJldHVybiAxO1xuICAgICAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICAgICAgZm9yIChwID0gYiAtIFMsIF8gPSBhW3ZdIDwgZCA/IChtID0gMCwgYVt2XSkgOiBhW3ZdID4gZCA/IChtID0gUltUICsgYVt2XV0sIEFbSSArIGFbdl1dKSA6IChtID0gOTYsIDApLCBoID0gMSA8PCBiIC0gUywgeSA9IHUgPSAxIDw8IHg7IGlbYyArIChFID4+IFMpICsgKHUgLT0gaCldID0gcCA8PCAyNCB8IG0gPDwgMTYgfCBfIHwgMCwgMCAhPT0gdTsgKSA7XG4gICAgICAgICAgICBmb3IgKGggPSAxIDw8IGIgLSAxOyBFICYgaDsgKSBoID4+PSAxO1xuICAgICAgICAgICAgaWYgKDAgIT09IGggPyAoRSAmPSBoIC0gMSwgRSArPSBoKSA6IEUgPSAwLCB2KyssIDAgPT0gLS1PW2JdKSB7XG4gICAgICAgICAgICAgIGlmIChiID09PSB3KSBicmVhaztcbiAgICAgICAgICAgICAgYiA9IHQyW3IyICsgYVt2XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA8IGIgJiYgKEUgJiBmKSAhPT0gbCkge1xuICAgICAgICAgICAgICBmb3IgKDAgPT09IFMgJiYgKFMgPSBrKSwgYyArPSB5LCB6ID0gMSA8PCAoeCA9IGIgLSBTKTsgeCArIFMgPCB3ICYmICEoKHogLT0gT1t4ICsgU10pIDw9IDApOyApIHgrKywgeiA8PD0gMTtcbiAgICAgICAgICAgICAgaWYgKEMgKz0gMSA8PCB4LCAxID09PSBlMiAmJiA4NTIgPCBDIHx8IDIgPT09IGUyICYmIDU5MiA8IEMpIHJldHVybiAxO1xuICAgICAgICAgICAgICBpW2wgPSBFICYgZl0gPSBrIDw8IDI0IHwgeCA8PCAxNiB8IGMgLSBzIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDAgIT09IEUgJiYgKGlbYyArIEVdID0gYiAtIFMgPDwgMjQgfCA2NCA8PCAxNiB8IDApLCBvLmJpdHMgPSBrLCAwO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBcIi4uL3V0aWxzL2NvbW1vblwiOiA0MSB9XSwgNTE6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHQuZXhwb3J0cyA9IHsgMjogXCJuZWVkIGRpY3Rpb25hcnlcIiwgMTogXCJzdHJlYW0gZW5kXCIsIDA6IFwiXCIsIFwiLTFcIjogXCJmaWxlIGVycm9yXCIsIFwiLTJcIjogXCJzdHJlYW0gZXJyb3JcIiwgXCItM1wiOiBcImRhdGEgZXJyb3JcIiwgXCItNFwiOiBcImluc3VmZmljaWVudCBtZW1vcnlcIiwgXCItNVwiOiBcImJ1ZmZlciBlcnJvclwiLCBcIi02XCI6IFwiaW5jb21wYXRpYmxlIHZlcnNpb25cIiB9O1xuICAgICAgfSwge31dLCA1MjogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgdmFyIGkgPSBlKFwiLi4vdXRpbHMvY29tbW9uXCIpLCBvID0gMCwgaCA9IDE7XG4gICAgICAgIGZ1bmN0aW9uIG4oZTIpIHtcbiAgICAgICAgICBmb3IgKHZhciB0MiA9IGUyLmxlbmd0aDsgMCA8PSAtLXQyOyApIGUyW3QyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSAwLCBhID0gMjksIHUgPSAyNTYsIGwgPSB1ICsgMSArIGEsIGYgPSAzMCwgYyA9IDE5LCBfID0gMiAqIGwgKyAxLCBnID0gMTUsIGQgPSAxNiwgcCA9IDcsIG0gPSAyNTYsIGIgPSAxNiwgdiA9IDE3LCB5ID0gMTgsIHcgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgMywgMywgMywgMywgNCwgNCwgNCwgNCwgNSwgNSwgNSwgNSwgMF0sIGsgPSBbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzXSwgeCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAyLCAzLCA3XSwgUyA9IFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XSwgeiA9IG5ldyBBcnJheSgyICogKGwgKyAyKSk7XG4gICAgICAgIG4oeik7XG4gICAgICAgIHZhciBDID0gbmV3IEFycmF5KDIgKiBmKTtcbiAgICAgICAgbihDKTtcbiAgICAgICAgdmFyIEUgPSBuZXcgQXJyYXkoNTEyKTtcbiAgICAgICAgbihFKTtcbiAgICAgICAgdmFyIEEgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgICAgbihBKTtcbiAgICAgICAgdmFyIEkgPSBuZXcgQXJyYXkoYSk7XG4gICAgICAgIG4oSSk7XG4gICAgICAgIHZhciBPLCBCLCBSLCBUID0gbmV3IEFycmF5KGYpO1xuICAgICAgICBmdW5jdGlvbiBEKGUyLCB0MiwgcjIsIG4yLCBpMikge1xuICAgICAgICAgIHRoaXMuc3RhdGljX3RyZWUgPSBlMiwgdGhpcy5leHRyYV9iaXRzID0gdDIsIHRoaXMuZXh0cmFfYmFzZSA9IHIyLCB0aGlzLmVsZW1zID0gbjIsIHRoaXMubWF4X2xlbmd0aCA9IGkyLCB0aGlzLmhhc19zdHJlZSA9IGUyICYmIGUyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBGKGUyLCB0Mikge1xuICAgICAgICAgIHRoaXMuZHluX3RyZWUgPSBlMiwgdGhpcy5tYXhfY29kZSA9IDAsIHRoaXMuc3RhdF9kZXNjID0gdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTihlMikge1xuICAgICAgICAgIHJldHVybiBlMiA8IDI1NiA/IEVbZTJdIDogRVsyNTYgKyAoZTIgPj4+IDcpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBVKGUyLCB0Mikge1xuICAgICAgICAgIGUyLnBlbmRpbmdfYnVmW2UyLnBlbmRpbmcrK10gPSAyNTUgJiB0MiwgZTIucGVuZGluZ19idWZbZTIucGVuZGluZysrXSA9IHQyID4+PiA4ICYgMjU1O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFAoZTIsIHQyLCByMikge1xuICAgICAgICAgIGUyLmJpX3ZhbGlkID4gZCAtIHIyID8gKGUyLmJpX2J1ZiB8PSB0MiA8PCBlMi5iaV92YWxpZCAmIDY1NTM1LCBVKGUyLCBlMi5iaV9idWYpLCBlMi5iaV9idWYgPSB0MiA+PiBkIC0gZTIuYmlfdmFsaWQsIGUyLmJpX3ZhbGlkICs9IHIyIC0gZCkgOiAoZTIuYmlfYnVmIHw9IHQyIDw8IGUyLmJpX3ZhbGlkICYgNjU1MzUsIGUyLmJpX3ZhbGlkICs9IHIyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBMKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICBQKGUyLCByMlsyICogdDJdLCByMlsyICogdDIgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaihlMiwgdDIpIHtcbiAgICAgICAgICBmb3IgKHZhciByMiA9IDA7IHIyIHw9IDEgJiBlMiwgZTIgPj4+PSAxLCByMiA8PD0gMSwgMCA8IC0tdDI7ICkgO1xuICAgICAgICAgIHJldHVybiByMiA+Pj4gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBaKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICB2YXIgbjIsIGkyLCBzMiA9IG5ldyBBcnJheShnICsgMSksIGEyID0gMDtcbiAgICAgICAgICBmb3IgKG4yID0gMTsgbjIgPD0gZzsgbjIrKykgczJbbjJdID0gYTIgPSBhMiArIHIyW24yIC0gMV0gPDwgMTtcbiAgICAgICAgICBmb3IgKGkyID0gMDsgaTIgPD0gdDI7IGkyKyspIHtcbiAgICAgICAgICAgIHZhciBvMiA9IGUyWzIgKiBpMiArIDFdO1xuICAgICAgICAgICAgMCAhPT0gbzIgJiYgKGUyWzIgKiBpMl0gPSBqKHMyW28yXSsrLCBvMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBXKGUyKSB7XG4gICAgICAgICAgdmFyIHQyO1xuICAgICAgICAgIGZvciAodDIgPSAwOyB0MiA8IGw7IHQyKyspIGUyLmR5bl9sdHJlZVsyICogdDJdID0gMDtcbiAgICAgICAgICBmb3IgKHQyID0gMDsgdDIgPCBmOyB0MisrKSBlMi5keW5fZHRyZWVbMiAqIHQyXSA9IDA7XG4gICAgICAgICAgZm9yICh0MiA9IDA7IHQyIDwgYzsgdDIrKykgZTIuYmxfdHJlZVsyICogdDJdID0gMDtcbiAgICAgICAgICBlMi5keW5fbHRyZWVbMiAqIG1dID0gMSwgZTIub3B0X2xlbiA9IGUyLnN0YXRpY19sZW4gPSAwLCBlMi5sYXN0X2xpdCA9IGUyLm1hdGNoZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIE0oZTIpIHtcbiAgICAgICAgICA4IDwgZTIuYmlfdmFsaWQgPyBVKGUyLCBlMi5iaV9idWYpIDogMCA8IGUyLmJpX3ZhbGlkICYmIChlMi5wZW5kaW5nX2J1ZltlMi5wZW5kaW5nKytdID0gZTIuYmlfYnVmKSwgZTIuYmlfYnVmID0gMCwgZTIuYmlfdmFsaWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIEgoZTIsIHQyLCByMiwgbjIpIHtcbiAgICAgICAgICB2YXIgaTIgPSAyICogdDIsIHMyID0gMiAqIHIyO1xuICAgICAgICAgIHJldHVybiBlMltpMl0gPCBlMltzMl0gfHwgZTJbaTJdID09PSBlMltzMl0gJiYgbjJbdDJdIDw9IG4yW3IyXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBHKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICBmb3IgKHZhciBuMiA9IGUyLmhlYXBbcjJdLCBpMiA9IHIyIDw8IDE7IGkyIDw9IGUyLmhlYXBfbGVuICYmIChpMiA8IGUyLmhlYXBfbGVuICYmIEgodDIsIGUyLmhlYXBbaTIgKyAxXSwgZTIuaGVhcFtpMl0sIGUyLmRlcHRoKSAmJiBpMisrLCAhSCh0MiwgbjIsIGUyLmhlYXBbaTJdLCBlMi5kZXB0aCkpOyApIGUyLmhlYXBbcjJdID0gZTIuaGVhcFtpMl0sIHIyID0gaTIsIGkyIDw8PSAxO1xuICAgICAgICAgIGUyLmhlYXBbcjJdID0gbjI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gSyhlMiwgdDIsIHIyKSB7XG4gICAgICAgICAgdmFyIG4yLCBpMiwgczIsIGEyLCBvMiA9IDA7XG4gICAgICAgICAgaWYgKDAgIT09IGUyLmxhc3RfbGl0KSBmb3IgKDsgbjIgPSBlMi5wZW5kaW5nX2J1ZltlMi5kX2J1ZiArIDIgKiBvMl0gPDwgOCB8IGUyLnBlbmRpbmdfYnVmW2UyLmRfYnVmICsgMiAqIG8yICsgMV0sIGkyID0gZTIucGVuZGluZ19idWZbZTIubF9idWYgKyBvMl0sIG8yKyssIDAgPT09IG4yID8gTChlMiwgaTIsIHQyKSA6IChMKGUyLCAoczIgPSBBW2kyXSkgKyB1ICsgMSwgdDIpLCAwICE9PSAoYTIgPSB3W3MyXSkgJiYgUChlMiwgaTIgLT0gSVtzMl0sIGEyKSwgTChlMiwgczIgPSBOKC0tbjIpLCByMiksIDAgIT09IChhMiA9IGtbczJdKSAmJiBQKGUyLCBuMiAtPSBUW3MyXSwgYTIpKSwgbzIgPCBlMi5sYXN0X2xpdDsgKSA7XG4gICAgICAgICAgTChlMiwgbSwgdDIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFkoZTIsIHQyKSB7XG4gICAgICAgICAgdmFyIHIyLCBuMiwgaTIsIHMyID0gdDIuZHluX3RyZWUsIGEyID0gdDIuc3RhdF9kZXNjLnN0YXRpY190cmVlLCBvMiA9IHQyLnN0YXRfZGVzYy5oYXNfc3RyZWUsIGgyID0gdDIuc3RhdF9kZXNjLmVsZW1zLCB1MiA9IC0xO1xuICAgICAgICAgIGZvciAoZTIuaGVhcF9sZW4gPSAwLCBlMi5oZWFwX21heCA9IF8sIHIyID0gMDsgcjIgPCBoMjsgcjIrKykgMCAhPT0gczJbMiAqIHIyXSA/IChlMi5oZWFwWysrZTIuaGVhcF9sZW5dID0gdTIgPSByMiwgZTIuZGVwdGhbcjJdID0gMCkgOiBzMlsyICogcjIgKyAxXSA9IDA7XG4gICAgICAgICAgZm9yICg7IGUyLmhlYXBfbGVuIDwgMjsgKSBzMlsyICogKGkyID0gZTIuaGVhcFsrK2UyLmhlYXBfbGVuXSA9IHUyIDwgMiA/ICsrdTIgOiAwKV0gPSAxLCBlMi5kZXB0aFtpMl0gPSAwLCBlMi5vcHRfbGVuLS0sIG8yICYmIChlMi5zdGF0aWNfbGVuIC09IGEyWzIgKiBpMiArIDFdKTtcbiAgICAgICAgICBmb3IgKHQyLm1heF9jb2RlID0gdTIsIHIyID0gZTIuaGVhcF9sZW4gPj4gMTsgMSA8PSByMjsgcjItLSkgRyhlMiwgczIsIHIyKTtcbiAgICAgICAgICBmb3IgKGkyID0gaDI7IHIyID0gZTIuaGVhcFsxXSwgZTIuaGVhcFsxXSA9IGUyLmhlYXBbZTIuaGVhcF9sZW4tLV0sIEcoZTIsIHMyLCAxKSwgbjIgPSBlMi5oZWFwWzFdLCBlMi5oZWFwWy0tZTIuaGVhcF9tYXhdID0gcjIsIGUyLmhlYXBbLS1lMi5oZWFwX21heF0gPSBuMiwgczJbMiAqIGkyXSA9IHMyWzIgKiByMl0gKyBzMlsyICogbjJdLCBlMi5kZXB0aFtpMl0gPSAoZTIuZGVwdGhbcjJdID49IGUyLmRlcHRoW24yXSA/IGUyLmRlcHRoW3IyXSA6IGUyLmRlcHRoW24yXSkgKyAxLCBzMlsyICogcjIgKyAxXSA9IHMyWzIgKiBuMiArIDFdID0gaTIsIGUyLmhlYXBbMV0gPSBpMisrLCBHKGUyLCBzMiwgMSksIDIgPD0gZTIuaGVhcF9sZW47ICkgO1xuICAgICAgICAgIGUyLmhlYXBbLS1lMi5oZWFwX21heF0gPSBlMi5oZWFwWzFdLCBmdW5jdGlvbihlMywgdDMpIHtcbiAgICAgICAgICAgIHZhciByMywgbjMsIGkzLCBzMywgYTMsIG8zLCBoMyA9IHQzLmR5bl90cmVlLCB1MyA9IHQzLm1heF9jb2RlLCBsMiA9IHQzLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSwgZjIgPSB0My5zdGF0X2Rlc2MuaGFzX3N0cmVlLCBjMiA9IHQzLnN0YXRfZGVzYy5leHRyYV9iaXRzLCBkMiA9IHQzLnN0YXRfZGVzYy5leHRyYV9iYXNlLCBwMiA9IHQzLnN0YXRfZGVzYy5tYXhfbGVuZ3RoLCBtMiA9IDA7XG4gICAgICAgICAgICBmb3IgKHMzID0gMDsgczMgPD0gZzsgczMrKykgZTMuYmxfY291bnRbczNdID0gMDtcbiAgICAgICAgICAgIGZvciAoaDNbMiAqIGUzLmhlYXBbZTMuaGVhcF9tYXhdICsgMV0gPSAwLCByMyA9IGUzLmhlYXBfbWF4ICsgMTsgcjMgPCBfOyByMysrKSBwMiA8IChzMyA9IGgzWzIgKiBoM1syICogKG4zID0gZTMuaGVhcFtyM10pICsgMV0gKyAxXSArIDEpICYmIChzMyA9IHAyLCBtMisrKSwgaDNbMiAqIG4zICsgMV0gPSBzMywgdTMgPCBuMyB8fCAoZTMuYmxfY291bnRbczNdKyssIGEzID0gMCwgZDIgPD0gbjMgJiYgKGEzID0gYzJbbjMgLSBkMl0pLCBvMyA9IGgzWzIgKiBuM10sIGUzLm9wdF9sZW4gKz0gbzMgKiAoczMgKyBhMyksIGYyICYmIChlMy5zdGF0aWNfbGVuICs9IG8zICogKGwyWzIgKiBuMyArIDFdICsgYTMpKSk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gbTIpIHtcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGZvciAoczMgPSBwMiAtIDE7IDAgPT09IGUzLmJsX2NvdW50W3MzXTsgKSBzMy0tO1xuICAgICAgICAgICAgICAgIGUzLmJsX2NvdW50W3MzXS0tLCBlMy5ibF9jb3VudFtzMyArIDFdICs9IDIsIGUzLmJsX2NvdW50W3AyXS0tLCBtMiAtPSAyO1xuICAgICAgICAgICAgICB9IHdoaWxlICgwIDwgbTIpO1xuICAgICAgICAgICAgICBmb3IgKHMzID0gcDI7IDAgIT09IHMzOyBzMy0tKSBmb3IgKG4zID0gZTMuYmxfY291bnRbczNdOyAwICE9PSBuMzsgKSB1MyA8IChpMyA9IGUzLmhlYXBbLS1yM10pIHx8IChoM1syICogaTMgKyAxXSAhPT0gczMgJiYgKGUzLm9wdF9sZW4gKz0gKHMzIC0gaDNbMiAqIGkzICsgMV0pICogaDNbMiAqIGkzXSwgaDNbMiAqIGkzICsgMV0gPSBzMyksIG4zLS0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0oZTIsIHQyKSwgWihzMiwgdTIsIGUyLmJsX2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBYKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICB2YXIgbjIsIGkyLCBzMiA9IC0xLCBhMiA9IHQyWzFdLCBvMiA9IDAsIGgyID0gNywgdTIgPSA0O1xuICAgICAgICAgIGZvciAoMCA9PT0gYTIgJiYgKGgyID0gMTM4LCB1MiA9IDMpLCB0MlsyICogKHIyICsgMSkgKyAxXSA9IDY1NTM1LCBuMiA9IDA7IG4yIDw9IHIyOyBuMisrKSBpMiA9IGEyLCBhMiA9IHQyWzIgKiAobjIgKyAxKSArIDFdLCArK28yIDwgaDIgJiYgaTIgPT09IGEyIHx8IChvMiA8IHUyID8gZTIuYmxfdHJlZVsyICogaTJdICs9IG8yIDogMCAhPT0gaTIgPyAoaTIgIT09IHMyICYmIGUyLmJsX3RyZWVbMiAqIGkyXSsrLCBlMi5ibF90cmVlWzIgKiBiXSsrKSA6IG8yIDw9IDEwID8gZTIuYmxfdHJlZVsyICogdl0rKyA6IGUyLmJsX3RyZWVbMiAqIHldKyssIHMyID0gaTIsIHUyID0gKG8yID0gMCkgPT09IGEyID8gKGgyID0gMTM4LCAzKSA6IGkyID09PSBhMiA/IChoMiA9IDYsIDMpIDogKGgyID0gNywgNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFYoZTIsIHQyLCByMikge1xuICAgICAgICAgIHZhciBuMiwgaTIsIHMyID0gLTEsIGEyID0gdDJbMV0sIG8yID0gMCwgaDIgPSA3LCB1MiA9IDQ7XG4gICAgICAgICAgZm9yICgwID09PSBhMiAmJiAoaDIgPSAxMzgsIHUyID0gMyksIG4yID0gMDsgbjIgPD0gcjI7IG4yKyspIGlmIChpMiA9IGEyLCBhMiA9IHQyWzIgKiAobjIgKyAxKSArIDFdLCAhKCsrbzIgPCBoMiAmJiBpMiA9PT0gYTIpKSB7XG4gICAgICAgICAgICBpZiAobzIgPCB1MikgZm9yICg7IEwoZTIsIGkyLCBlMi5ibF90cmVlKSwgMCAhPSAtLW8yOyApIDtcbiAgICAgICAgICAgIGVsc2UgMCAhPT0gaTIgPyAoaTIgIT09IHMyICYmIChMKGUyLCBpMiwgZTIuYmxfdHJlZSksIG8yLS0pLCBMKGUyLCBiLCBlMi5ibF90cmVlKSwgUChlMiwgbzIgLSAzLCAyKSkgOiBvMiA8PSAxMCA/IChMKGUyLCB2LCBlMi5ibF90cmVlKSwgUChlMiwgbzIgLSAzLCAzKSkgOiAoTChlMiwgeSwgZTIuYmxfdHJlZSksIFAoZTIsIG8yIC0gMTEsIDcpKTtcbiAgICAgICAgICAgIHMyID0gaTIsIHUyID0gKG8yID0gMCkgPT09IGEyID8gKGgyID0gMTM4LCAzKSA6IGkyID09PSBhMiA/IChoMiA9IDYsIDMpIDogKGgyID0gNywgNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4oVCk7XG4gICAgICAgIHZhciBxID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIEooZTIsIHQyLCByMiwgbjIpIHtcbiAgICAgICAgICBQKGUyLCAocyA8PCAxKSArIChuMiA/IDEgOiAwKSwgMyksIGZ1bmN0aW9uKGUzLCB0MywgcjMsIG4zKSB7XG4gICAgICAgICAgICBNKGUzKSwgVShlMywgcjMpLCBVKGUzLCB+cjMpLCBpLmFycmF5U2V0KGUzLnBlbmRpbmdfYnVmLCBlMy53aW5kb3csIHQzLCByMywgZTMucGVuZGluZyksIGUzLnBlbmRpbmcgKz0gcjM7XG4gICAgICAgICAgfShlMiwgdDIsIHIyKTtcbiAgICAgICAgfVxuICAgICAgICByLl90cl9pbml0ID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBxIHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlMywgdDIsIHIyLCBuMiwgaTIsIHMyID0gbmV3IEFycmF5KGcgKyAxKTtcbiAgICAgICAgICAgIGZvciAobjIgPSByMiA9IDA7IG4yIDwgYSAtIDE7IG4yKyspIGZvciAoSVtuMl0gPSByMiwgZTMgPSAwOyBlMyA8IDEgPDwgd1tuMl07IGUzKyspIEFbcjIrK10gPSBuMjtcbiAgICAgICAgICAgIGZvciAoQVtyMiAtIDFdID0gbjIsIG4yID0gaTIgPSAwOyBuMiA8IDE2OyBuMisrKSBmb3IgKFRbbjJdID0gaTIsIGUzID0gMDsgZTMgPCAxIDw8IGtbbjJdOyBlMysrKSBFW2kyKytdID0gbjI7XG4gICAgICAgICAgICBmb3IgKGkyID4+PSA3OyBuMiA8IGY7IG4yKyspIGZvciAoVFtuMl0gPSBpMiA8PCA3LCBlMyA9IDA7IGUzIDwgMSA8PCBrW24yXSAtIDc7IGUzKyspIEVbMjU2ICsgaTIrK10gPSBuMjtcbiAgICAgICAgICAgIGZvciAodDIgPSAwOyB0MiA8PSBnOyB0MisrKSBzMlt0Ml0gPSAwO1xuICAgICAgICAgICAgZm9yIChlMyA9IDA7IGUzIDw9IDE0MzsgKSB6WzIgKiBlMyArIDFdID0gOCwgZTMrKywgczJbOF0rKztcbiAgICAgICAgICAgIGZvciAoOyBlMyA8PSAyNTU7ICkgelsyICogZTMgKyAxXSA9IDksIGUzKyssIHMyWzldKys7XG4gICAgICAgICAgICBmb3IgKDsgZTMgPD0gMjc5OyApIHpbMiAqIGUzICsgMV0gPSA3LCBlMysrLCBzMls3XSsrO1xuICAgICAgICAgICAgZm9yICg7IGUzIDw9IDI4NzsgKSB6WzIgKiBlMyArIDFdID0gOCwgZTMrKywgczJbOF0rKztcbiAgICAgICAgICAgIGZvciAoWih6LCBsICsgMSwgczIpLCBlMyA9IDA7IGUzIDwgZjsgZTMrKykgQ1syICogZTMgKyAxXSA9IDUsIENbMiAqIGUzXSA9IGooZTMsIDUpO1xuICAgICAgICAgICAgTyA9IG5ldyBEKHosIHcsIHUgKyAxLCBsLCBnKSwgQiA9IG5ldyBEKEMsIGssIDAsIGYsIGcpLCBSID0gbmV3IEQobmV3IEFycmF5KDApLCB4LCAwLCBjLCBwKTtcbiAgICAgICAgICB9KCksIHEgPSB0cnVlKSwgZTIubF9kZXNjID0gbmV3IEYoZTIuZHluX2x0cmVlLCBPKSwgZTIuZF9kZXNjID0gbmV3IEYoZTIuZHluX2R0cmVlLCBCKSwgZTIuYmxfZGVzYyA9IG5ldyBGKGUyLmJsX3RyZWUsIFIpLCBlMi5iaV9idWYgPSAwLCBlMi5iaV92YWxpZCA9IDAsIFcoZTIpO1xuICAgICAgICB9LCByLl90cl9zdG9yZWRfYmxvY2sgPSBKLCByLl90cl9mbHVzaF9ibG9jayA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIsIG4yKSB7XG4gICAgICAgICAgdmFyIGkyLCBzMiwgYTIgPSAwO1xuICAgICAgICAgIDAgPCBlMi5sZXZlbCA/ICgyID09PSBlMi5zdHJtLmRhdGFfdHlwZSAmJiAoZTIuc3RybS5kYXRhX3R5cGUgPSBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgdmFyIHQzLCByMyA9IDQwOTM2MjQ0NDc7XG4gICAgICAgICAgICBmb3IgKHQzID0gMDsgdDMgPD0gMzE7IHQzKyssIHIzID4+Pj0gMSkgaWYgKDEgJiByMyAmJiAwICE9PSBlMy5keW5fbHRyZWVbMiAqIHQzXSkgcmV0dXJuIG87XG4gICAgICAgICAgICBpZiAoMCAhPT0gZTMuZHluX2x0cmVlWzE4XSB8fCAwICE9PSBlMy5keW5fbHRyZWVbMjBdIHx8IDAgIT09IGUzLmR5bl9sdHJlZVsyNl0pIHJldHVybiBoO1xuICAgICAgICAgICAgZm9yICh0MyA9IDMyOyB0MyA8IHU7IHQzKyspIGlmICgwICE9PSBlMy5keW5fbHRyZWVbMiAqIHQzXSkgcmV0dXJuIGg7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICB9KGUyKSksIFkoZTIsIGUyLmxfZGVzYyksIFkoZTIsIGUyLmRfZGVzYyksIGEyID0gZnVuY3Rpb24oZTMpIHtcbiAgICAgICAgICAgIHZhciB0MztcbiAgICAgICAgICAgIGZvciAoWChlMywgZTMuZHluX2x0cmVlLCBlMy5sX2Rlc2MubWF4X2NvZGUpLCBYKGUzLCBlMy5keW5fZHRyZWUsIGUzLmRfZGVzYy5tYXhfY29kZSksIFkoZTMsIGUzLmJsX2Rlc2MpLCB0MyA9IGMgLSAxOyAzIDw9IHQzICYmIDAgPT09IGUzLmJsX3RyZWVbMiAqIFNbdDNdICsgMV07IHQzLS0pIDtcbiAgICAgICAgICAgIHJldHVybiBlMy5vcHRfbGVuICs9IDMgKiAodDMgKyAxKSArIDUgKyA1ICsgNCwgdDM7XG4gICAgICAgICAgfShlMiksIGkyID0gZTIub3B0X2xlbiArIDMgKyA3ID4+PiAzLCAoczIgPSBlMi5zdGF0aWNfbGVuICsgMyArIDcgPj4+IDMpIDw9IGkyICYmIChpMiA9IHMyKSkgOiBpMiA9IHMyID0gcjIgKyA1LCByMiArIDQgPD0gaTIgJiYgLTEgIT09IHQyID8gSihlMiwgdDIsIHIyLCBuMikgOiA0ID09PSBlMi5zdHJhdGVneSB8fCBzMiA9PT0gaTIgPyAoUChlMiwgMiArIChuMiA/IDEgOiAwKSwgMyksIEsoZTIsIHosIEMpKSA6IChQKGUyLCA0ICsgKG4yID8gMSA6IDApLCAzKSwgZnVuY3Rpb24oZTMsIHQzLCByMywgbjMpIHtcbiAgICAgICAgICAgIHZhciBpMztcbiAgICAgICAgICAgIGZvciAoUChlMywgdDMgLSAyNTcsIDUpLCBQKGUzLCByMyAtIDEsIDUpLCBQKGUzLCBuMyAtIDQsIDQpLCBpMyA9IDA7IGkzIDwgbjM7IGkzKyspIFAoZTMsIGUzLmJsX3RyZWVbMiAqIFNbaTNdICsgMV0sIDMpO1xuICAgICAgICAgICAgVihlMywgZTMuZHluX2x0cmVlLCB0MyAtIDEpLCBWKGUzLCBlMy5keW5fZHRyZWUsIHIzIC0gMSk7XG4gICAgICAgICAgfShlMiwgZTIubF9kZXNjLm1heF9jb2RlICsgMSwgZTIuZF9kZXNjLm1heF9jb2RlICsgMSwgYTIgKyAxKSwgSyhlMiwgZTIuZHluX2x0cmVlLCBlMi5keW5fZHRyZWUpKSwgVyhlMiksIG4yICYmIE0oZTIpO1xuICAgICAgICB9LCByLl90cl90YWxseSA9IGZ1bmN0aW9uKGUyLCB0MiwgcjIpIHtcbiAgICAgICAgICByZXR1cm4gZTIucGVuZGluZ19idWZbZTIuZF9idWYgKyAyICogZTIubGFzdF9saXRdID0gdDIgPj4+IDggJiAyNTUsIGUyLnBlbmRpbmdfYnVmW2UyLmRfYnVmICsgMiAqIGUyLmxhc3RfbGl0ICsgMV0gPSAyNTUgJiB0MiwgZTIucGVuZGluZ19idWZbZTIubF9idWYgKyBlMi5sYXN0X2xpdF0gPSAyNTUgJiByMiwgZTIubGFzdF9saXQrKywgMCA9PT0gdDIgPyBlMi5keW5fbHRyZWVbMiAqIHIyXSsrIDogKGUyLm1hdGNoZXMrKywgdDItLSwgZTIuZHluX2x0cmVlWzIgKiAoQVtyMl0gKyB1ICsgMSldKyssIGUyLmR5bl9kdHJlZVsyICogTih0MildKyspLCBlMi5sYXN0X2xpdCA9PT0gZTIubGl0X2J1ZnNpemUgLSAxO1xuICAgICAgICB9LCByLl90cl9hbGlnbiA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgUChlMiwgMiwgMyksIEwoZTIsIG0sIHopLCBmdW5jdGlvbihlMykge1xuICAgICAgICAgICAgMTYgPT09IGUzLmJpX3ZhbGlkID8gKFUoZTMsIGUzLmJpX2J1ZiksIGUzLmJpX2J1ZiA9IDAsIGUzLmJpX3ZhbGlkID0gMCkgOiA4IDw9IGUzLmJpX3ZhbGlkICYmIChlMy5wZW5kaW5nX2J1ZltlMy5wZW5kaW5nKytdID0gMjU1ICYgZTMuYmlfYnVmLCBlMy5iaV9idWYgPj49IDgsIGUzLmJpX3ZhbGlkIC09IDgpO1xuICAgICAgICAgIH0oZTIpO1xuICAgICAgICB9O1xuICAgICAgfSwgeyBcIi4uL3V0aWxzL2NvbW1vblwiOiA0MSB9XSwgNTM6IFtmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgICAgIHQuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5wdXQgPSBudWxsLCB0aGlzLm5leHRfaW4gPSAwLCB0aGlzLmF2YWlsX2luID0gMCwgdGhpcy50b3RhbF9pbiA9IDAsIHRoaXMub3V0cHV0ID0gbnVsbCwgdGhpcy5uZXh0X291dCA9IDAsIHRoaXMuYXZhaWxfb3V0ID0gMCwgdGhpcy50b3RhbF9vdXQgPSAwLCB0aGlzLm1zZyA9IFwiXCIsIHRoaXMuc3RhdGUgPSBudWxsLCB0aGlzLmRhdGFfdHlwZSA9IDIsIHRoaXMuYWRsZXIgPSAwO1xuICAgICAgICB9O1xuICAgICAgfSwge31dLCA1NDogW2Z1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICAgICAgKGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgIWZ1bmN0aW9uKHIyLCBuKSB7XG4gICAgICAgICAgICBpZiAoIXIyLnNldEltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICB2YXIgaSwgcywgdDIsIGEsIG8gPSAxLCBoID0ge30sIHUgPSBmYWxzZSwgbCA9IHIyLmRvY3VtZW50LCBlMyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocjIpO1xuICAgICAgICAgICAgICBlMyA9IGUzICYmIGUzLnNldFRpbWVvdXQgPyBlMyA6IHIyLCBpID0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwocjIucHJvY2VzcykgPyBmdW5jdGlvbihlNCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGMoZTQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIyLnBvc3RNZXNzYWdlICYmICFyMi5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZTQgPSB0cnVlLCB0MyA9IHIyLm9ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByMi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZTQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH0sIHIyLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKSwgcjIub25tZXNzYWdlID0gdDMsIGU0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSgpID8gKGEgPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIiwgcjIuYWRkRXZlbnRMaXN0ZW5lciA/IHIyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGQsIGZhbHNlKSA6IHIyLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIGQpLCBmdW5jdGlvbihlNCkge1xuICAgICAgICAgICAgICAgIHIyLnBvc3RNZXNzYWdlKGEgKyBlNCwgXCIqXCIpO1xuICAgICAgICAgICAgICB9KSA6IHIyLk1lc3NhZ2VDaGFubmVsID8gKCh0MiA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpKS5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlNCkge1xuICAgICAgICAgICAgICAgIGMoZTQuZGF0YSk7XG4gICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGU0KSB7XG4gICAgICAgICAgICAgICAgdDIucG9ydDIucG9zdE1lc3NhZ2UoZTQpO1xuICAgICAgICAgICAgICB9KSA6IGwgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBsLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikgPyAocyA9IGwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbihlNCkge1xuICAgICAgICAgICAgICAgIHZhciB0MyA9IGwuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgICAgICB0My5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGMoZTQpLCB0My5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBzLnJlbW92ZUNoaWxkKHQzKSwgdDMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sIHMuYXBwZW5kQ2hpbGQodDMpO1xuICAgICAgICAgICAgICB9KSA6IGZ1bmN0aW9uKGU0KSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjLCAwLCBlNCk7XG4gICAgICAgICAgICAgIH0sIGUzLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGU0KSB7XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlNCAmJiAoZTQgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGU0KSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdDMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCByMyA9IDA7IHIzIDwgdDMubGVuZ3RoOyByMysrKSB0M1tyM10gPSBhcmd1bWVudHNbcjMgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSB7IGNhbGxiYWNrOiBlNCwgYXJnczogdDMgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaFtvXSA9IG4yLCBpKG8pLCBvKys7XG4gICAgICAgICAgICAgIH0sIGUzLmNsZWFySW1tZWRpYXRlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGYoZTQpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGhbZTRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYyhlNCkge1xuICAgICAgICAgICAgICBpZiAodSkgc2V0VGltZW91dChjLCAwLCBlNCk7XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0MyA9IGhbZTRdO1xuICAgICAgICAgICAgICAgIGlmICh0Mykge1xuICAgICAgICAgICAgICAgICAgdSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdDQgPSBlNS5jYWxsYmFjaywgcjMgPSBlNS5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocjMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHQ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICB0NChyM1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICB0NChyM1swXSwgcjNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdDQocjNbMF0sIHIzWzFdLCByM1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdDQuYXBwbHkobiwgcjMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSh0Myk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBmKGU0KSwgdSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZChlNCkge1xuICAgICAgICAgICAgICBlNC5zb3VyY2UgPT09IHIyICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGU0LmRhdGEgJiYgMCA9PT0gZTQuZGF0YS5pbmRleE9mKGEpICYmIGMoK2U0LmRhdGEuc2xpY2UoYS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHNlbGYgPyB2b2lkIDAgPT09IGUyID8gdGhpcyA6IGUyIDogc2VsZik7XG4gICAgICAgIH0pLmNhbGwodGhpcywgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPyBjb21tb25qc0dsb2JhbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDoge30pO1xuICAgICAgfSwge31dIH0sIHt9LCBbMTBdKSgxMCk7XG4gICAgfSk7XG4gIH0pKGpzemlwX21pbik7XG4gIHJldHVybiBqc3ppcF9taW4uZXhwb3J0cztcbn1cbnZhciBqc3ppcF9taW5FeHBvcnRzID0gcmVxdWlyZUpzemlwX21pbigpO1xuY29uc3QgSlNaaXAgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMShqc3ppcF9taW5FeHBvcnRzKTtcbnZhciB4bWwkMSA9IHsgZXhwb3J0czoge30gfTtcbnZhciBlc2NhcGVGb3JYTUxfMTtcbnZhciBoYXNSZXF1aXJlZEVzY2FwZUZvclhNTDtcbmZ1bmN0aW9uIHJlcXVpcmVFc2NhcGVGb3JYTUwoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEVzY2FwZUZvclhNTCkgcmV0dXJuIGVzY2FwZUZvclhNTF8xO1xuICBoYXNSZXF1aXJlZEVzY2FwZUZvclhNTCA9IDE7XG4gIHZhciBYTUxfQ0hBUkFDVEVSX01BUCA9IHtcbiAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgXCInXCI6IFwiJmFwb3M7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIlxuICB9O1xuICBmdW5jdGlvbiBlc2NhcGVGb3JYTUwoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZSA/IHN0cmluZy5yZXBsYWNlKC8oWyZcIjw+J10pL2csIGZ1bmN0aW9uKHN0ciwgaXRlbSkge1xuICAgICAgcmV0dXJuIFhNTF9DSEFSQUNURVJfTUFQW2l0ZW1dO1xuICAgIH0pIDogc3RyaW5nO1xuICB9XG4gIGVzY2FwZUZvclhNTF8xID0gZXNjYXBlRm9yWE1MO1xuICByZXR1cm4gZXNjYXBlRm9yWE1MXzE7XG59XG52YXIgaGFzUmVxdWlyZWRYbWw7XG5mdW5jdGlvbiByZXF1aXJlWG1sKCkge1xuICBpZiAoaGFzUmVxdWlyZWRYbWwpIHJldHVybiB4bWwkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZFhtbCA9IDE7XG4gIHZhciBlc2NhcGVGb3JYTUwgPSByZXF1aXJlRXNjYXBlRm9yWE1MKCk7XG4gIHZhciBTdHJlYW0gPSByZXF1aXJlU3RyZWFtQnJvd3NlcmlmeSgpLlN0cmVhbTtcbiAgdmFyIERFRkFVTFRfSU5ERU5UID0gXCIgICAgXCI7XG4gIGZ1bmN0aW9uIHhtbDIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGluZGVudDogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbSA9IG9wdGlvbnMuc3RyZWFtID8gbmV3IFN0cmVhbSgpIDogbnVsbCwgb3V0cHV0ID0gXCJcIiwgaW50ZXJydXB0ZWQgPSBmYWxzZSwgaW5kZW50ID0gIW9wdGlvbnMuaW5kZW50ID8gXCJcIiA6IG9wdGlvbnMuaW5kZW50ID09PSB0cnVlID8gREVGQVVMVF9JTkRFTlQgOiBvcHRpb25zLmluZGVudCwgaW5zdGFudCA9IHRydWU7XG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYykge1xuICAgICAgaWYgKCFpbnN0YW50KSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MkMS5uZXh0VGljayhmdW5jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZW5kKGludGVycnVwdCwgb3V0KSB7XG4gICAgICBpZiAob3V0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgb3V0cHV0ICs9IG91dDtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnJ1cHQgJiYgIWludGVycnVwdGVkKSB7XG4gICAgICAgIHN0cmVhbSA9IHN0cmVhbSB8fCBuZXcgU3RyZWFtKCk7XG4gICAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcnJ1cHQgJiYgaW50ZXJydXB0ZWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBvdXRwdXQ7XG4gICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dCA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZSwgbGFzdCkge1xuICAgICAgZm9ybWF0KGFwcGVuZCwgcmVzb2x2ZSh2YWx1ZSwgaW5kZW50LCBpbmRlbnQgPyAxIDogMCksIGxhc3QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHZhciBkYXRhID0gb3V0cHV0O1xuICAgICAgICBkZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdChcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoXCJlbmRcIik7XG4gICAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoXCJjbG9zZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFhtbERlY2xhcmF0aW9uKGRlY2xhcmF0aW9uKSB7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBkZWNsYXJhdGlvbi5lbmNvZGluZyB8fCBcIlVURi04XCIsIGF0dHIgPSB7IHZlcnNpb246IFwiMS4wXCIsIGVuY29kaW5nIH07XG4gICAgICBpZiAoZGVjbGFyYXRpb24uc3RhbmRhbG9uZSkge1xuICAgICAgICBhdHRyLnN0YW5kYWxvbmUgPSBkZWNsYXJhdGlvbi5zdGFuZGFsb25lO1xuICAgICAgfVxuICAgICAgYWRkKHsgXCI/eG1sXCI6IHsgX2F0dHI6IGF0dHIgfSB9KTtcbiAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKFwiLz5cIiwgXCI/PlwiKTtcbiAgICB9XG4gICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICBpbnN0YW50ID0gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuZGVjbGFyYXRpb24pIHtcbiAgICAgIGFkZFhtbERlY2xhcmF0aW9uKG9wdGlvbnMuZGVjbGFyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZm9yRWFjaCkge1xuICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgaSkge1xuICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgaWYgKGkgKyAxID09PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgbGFzdCA9IGVuZDtcbiAgICAgICAgYWRkKHZhbHVlLCBsYXN0KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGQoaW5wdXQsIGVuZCk7XG4gICAgfVxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIGZ1bmN0aW9uIGVsZW1lbnQoKSB7XG4gICAgdmFyIGlucHV0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgc2VsZjIgPSB7XG4gICAgICBfZWxlbTogcmVzb2x2ZShpbnB1dClcbiAgICB9O1xuICAgIHNlbGYyLnB1c2ggPSBmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgIGlmICghdGhpcy5hcHBlbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFzc2lnbmVkIHRvIGEgcGFyZW50IVwiKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBpbmRlbnQgPSB0aGlzLl9lbGVtLmluZGVudDtcbiAgICAgIGZvcm1hdChcbiAgICAgICAgdGhpcy5hcHBlbmQsXG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgaW5wdXQyLFxuICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICB0aGlzLl9lbGVtLmljb3VudCArIChpbmRlbnQgPyAxIDogMClcbiAgICAgICAgKSxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhhdC5hcHBlbmQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgICBzZWxmMi5jbG9zZSA9IGZ1bmN0aW9uKGlucHV0Mikge1xuICAgICAgaWYgKGlucHV0MiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMucHVzaChpbnB1dDIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5kKSB7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjI7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlX2luZGVudChjaGFyYWN0ZXIsIGNvdW50KSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShjb3VudCB8fCAwKS5qb2luKGNoYXJhY3RlciB8fCBcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlKGRhdGEsIGluZGVudCwgaW5kZW50X2NvdW50KSB7XG4gICAgaW5kZW50X2NvdW50ID0gaW5kZW50X2NvdW50IHx8IDA7XG4gICAgdmFyIGluZGVudF9zcGFjZXMgPSBjcmVhdGVfaW5kZW50KGluZGVudCwgaW5kZW50X2NvdW50KTtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgdmFsdWVzID0gZGF0YTtcbiAgICB2YXIgaW50ZXJydXB0ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgbmFtZSA9IGtleXNbMF07XG4gICAgICB2YWx1ZXMgPSBkYXRhW25hbWVdO1xuICAgICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMuX2VsZW0pIHtcbiAgICAgICAgdmFsdWVzLl9lbGVtLm5hbWUgPSBuYW1lO1xuICAgICAgICB2YWx1ZXMuX2VsZW0uaWNvdW50ID0gaW5kZW50X2NvdW50O1xuICAgICAgICB2YWx1ZXMuX2VsZW0uaW5kZW50ID0gaW5kZW50O1xuICAgICAgICB2YWx1ZXMuX2VsZW0uaW5kZW50cyA9IGluZGVudF9zcGFjZXM7XG4gICAgICAgIHZhbHVlcy5fZWxlbS5pbnRlcnJ1cHQgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuX2VsZW07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhdHRyaWJ1dGVzID0gW10sIGNvbnRlbnQgPSBbXTtcbiAgICB2YXIgaXNTdHJpbmdDb250ZW50O1xuICAgIGZ1bmN0aW9uIGdldF9hdHRyaWJ1dGVzKG9iaikge1xuICAgICAgdmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgIGtleXMyLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUoa2V5LCBvYmpba2V5XSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlcykge1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICBpZiAodmFsdWVzID09PSBudWxsKSBicmVhaztcbiAgICAgICAgaWYgKHZhbHVlcy5fYXR0cikge1xuICAgICAgICAgIGdldF9hdHRyaWJ1dGVzKHZhbHVlcy5fYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5fY2RhdGEpIHtcbiAgICAgICAgICBjb250ZW50LnB1c2goXG4gICAgICAgICAgICAoXCI8IVtDREFUQVtcIiArIHZhbHVlcy5fY2RhdGEpLnJlcGxhY2UoL1xcXVxcXT4vZywgXCJdXV1dPjwhW0NEQVRBWz5cIikgKyBcIl1dPlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmZvckVhY2gpIHtcbiAgICAgICAgICBpc1N0cmluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb250ZW50LnB1c2goXCJcIik7XG4gICAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICB2YXIgX25hbWUgPSBPYmplY3Qua2V5cyh2YWx1ZSlbMF07XG4gICAgICAgICAgICAgIGlmIChfbmFtZSA9PSBcIl9hdHRyXCIpIHtcbiAgICAgICAgICAgICAgICBnZXRfYXR0cmlidXRlcyh2YWx1ZS5fYXR0cik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGluZGVudCxcbiAgICAgICAgICAgICAgICAgIGluZGVudF9jb3VudCArIDFcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgaXNTdHJpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29udGVudC5wdXNoKGVzY2FwZUZvclhNTCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaXNTdHJpbmdDb250ZW50KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGVudC5wdXNoKGVzY2FwZUZvclhNTCh2YWx1ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBpbnRlcnJ1cHQsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgY29udGVudCxcbiAgICAgIGljb3VudDogaW5kZW50X2NvdW50LFxuICAgICAgaW5kZW50czogaW5kZW50X3NwYWNlcyxcbiAgICAgIGluZGVudFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZm9ybWF0KGFwcGVuZCwgZWxlbSwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbGVtICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBhcHBlbmQoZmFsc2UsIGVsZW0pO1xuICAgIH1cbiAgICB2YXIgbGVuID0gZWxlbS5pbnRlcnJ1cHQgPyAxIDogZWxlbS5jb250ZW50Lmxlbmd0aDtcbiAgICBmdW5jdGlvbiBwcm9jZWVkKCkge1xuICAgICAgd2hpbGUgKGVsZW0uY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZWxlbS5jb250ZW50LnNoaWZ0KCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgaWYgKGludGVycnVwdCh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgZm9ybWF0KGFwcGVuZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgYXBwZW5kKGZhbHNlLCAobGVuID4gMSA/IGVsZW0uaW5kZW50cyA6IFwiXCIpICsgKGVsZW0ubmFtZSA/IFwiPC9cIiArIGVsZW0ubmFtZSArIFwiPlwiIDogXCJcIikgKyAoZWxlbS5pbmRlbnQgJiYgIWVuZCA/IFwiXFxuXCIgOiBcIlwiKSk7XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnJ1cHQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5pbnRlcnJ1cHQpIHtcbiAgICAgICAgdmFsdWUuaW50ZXJydXB0LmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgdmFsdWUuaW50ZXJydXB0LmVuZCA9IHByb2NlZWQ7XG4gICAgICAgIHZhbHVlLmludGVycnVwdCA9IGZhbHNlO1xuICAgICAgICBhcHBlbmQodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhcHBlbmQoZmFsc2UsIGVsZW0uaW5kZW50cyArIChlbGVtLm5hbWUgPyBcIjxcIiArIGVsZW0ubmFtZSA6IFwiXCIpICsgKGVsZW0uYXR0cmlidXRlcy5sZW5ndGggPyBcIiBcIiArIGVsZW0uYXR0cmlidXRlcy5qb2luKFwiIFwiKSA6IFwiXCIpICsgKGxlbiA/IGVsZW0ubmFtZSA/IFwiPlwiIDogXCJcIiA6IGVsZW0ubmFtZSA/IFwiLz5cIiA6IFwiXCIpICsgKGVsZW0uaW5kZW50ICYmIGxlbiA+IDEgPyBcIlxcblwiIDogXCJcIikpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gYXBwZW5kKGZhbHNlLCBlbGVtLmluZGVudCA/IFwiXFxuXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnJ1cHQoZWxlbSkpIHtcbiAgICAgIHByb2NlZWQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5ICsgJz1cIicgKyBlc2NhcGVGb3JYTUwodmFsdWUpICsgJ1wiJztcbiAgfVxuICB4bWwkMS5leHBvcnRzID0geG1sMjtcbiAgeG1sJDEuZXhwb3J0cy5lbGVtZW50ID0geG1sJDEuZXhwb3J0cy5FbGVtZW50ID0gZWxlbWVudDtcbiAgcmV0dXJuIHhtbCQxLmV4cG9ydHM7XG59XG52YXIgeG1sRXhwb3J0cyA9IHJlcXVpcmVYbWwoKTtcbmNvbnN0IHhtbCA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyQxKHhtbEV4cG9ydHMpO1xuY29uc3Qgb2JmdXNjYXRlZFN0YXJ0T2Zmc2V0ID0gMDtcbmNvbnN0IG9iZnVzY2F0ZWRFbmRPZmZzZXQgPSAzMjtcbmNvbnN0IGd1aWRTaXplID0gMzI7XG5jb25zdCBvYmZ1c2NhdGUgPSAoYnVmLCBmb250S2V5KSA9PiB7XG4gIGNvbnN0IGd1aWQgPSBmb250S2V5LnJlcGxhY2UoLy0vZywgXCJcIik7XG4gIGlmIChndWlkLmxlbmd0aCAhPT0gZ3VpZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiBDYW5ub3QgZXh0cmFjdCBHVUlEIGZyb20gZm9udCBmaWxlbmFtZTogJHtmb250S2V5fWApO1xuICB9XG4gIGNvbnN0IGhleFN0cmluZ3MgPSBndWlkLnJlcGxhY2UoLyguLikvZywgXCIkMSBcIikudHJpbSgpLnNwbGl0KFwiIFwiKTtcbiAgY29uc3QgaGV4TnVtYmVycyA9IGhleFN0cmluZ3MubWFwKChoZXhTdHJpbmcpID0+IHBhcnNlSW50KGhleFN0cmluZywgMTYpKTtcbiAgaGV4TnVtYmVycy5yZXZlcnNlKCk7XG4gIGNvbnN0IGJ5dGVzVG9PYmZ1c2NhdGUgPSBidWYuc2xpY2Uob2JmdXNjYXRlZFN0YXJ0T2Zmc2V0LCBvYmZ1c2NhdGVkRW5kT2Zmc2V0KTtcbiAgY29uc3Qgb2JmdXNjYXRlZEJ5dGVzID0gYnl0ZXNUb09iZnVzY2F0ZS5tYXAoKGJ5dGUsIGkpID0+IGJ5dGUgXiBoZXhOdW1iZXJzW2kgJSBoZXhOdW1iZXJzLmxlbmd0aF0pO1xuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShvYmZ1c2NhdGVkU3RhcnRPZmZzZXQgKyBvYmZ1c2NhdGVkQnl0ZXMubGVuZ3RoICsgTWF0aC5tYXgoMCwgYnVmLmxlbmd0aCAtIG9iZnVzY2F0ZWRFbmRPZmZzZXQpKTtcbiAgb3V0LnNldChidWYuc2xpY2UoMCwgb2JmdXNjYXRlZFN0YXJ0T2Zmc2V0KSk7XG4gIG91dC5zZXQob2JmdXNjYXRlZEJ5dGVzLCBvYmZ1c2NhdGVkU3RhcnRPZmZzZXQpO1xuICBvdXQuc2V0KGJ1Zi5zbGljZShvYmZ1c2NhdGVkRW5kT2Zmc2V0KSwgb2JmdXNjYXRlZFN0YXJ0T2Zmc2V0ICsgb2JmdXNjYXRlZEJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiBvdXQ7XG59O1xuY2xhc3MgRm9ybWF0dGVyIHtcbiAgZm9ybWF0KGlucHV0LCBjb250ZXh0ID0geyBzdGFjazogW10gfSkge1xuICAgIGNvbnN0IG91dHB1dCA9IGlucHV0LnByZXBGb3JYbWwoY29udGV4dCk7XG4gICAgaWYgKG91dHB1dCkge1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJYTUxDb21wb25lbnQgZGlkIG5vdCBmb3JtYXQgY29ycmVjdGx5XCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgSW1hZ2VSZXBsYWNlciB7XG4gIHJlcGxhY2UoeG1sRGF0YSwgbWVkaWFEYXRhLCBvZmZzZXQpIHtcbiAgICBsZXQgY3VycmVudFhtbERhdGEgPSB4bWxEYXRhO1xuICAgIG1lZGlhRGF0YS5mb3JFYWNoKChpbWFnZSwgaSkgPT4ge1xuICAgICAgY3VycmVudFhtbERhdGEgPSBjdXJyZW50WG1sRGF0YS5yZXBsYWNlKG5ldyBSZWdFeHAoYHske2ltYWdlLmZpbGVOYW1lfX1gLCBcImdcIiksIChvZmZzZXQgKyBpKS50b1N0cmluZygpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3VycmVudFhtbERhdGE7XG4gIH1cbiAgZ2V0TWVkaWFEYXRhKHhtbERhdGEsIG1lZGlhKSB7XG4gICAgcmV0dXJuIG1lZGlhLkFycmF5LmZpbHRlcigoaW1hZ2UpID0+IHhtbERhdGEuc2VhcmNoKGB7JHtpbWFnZS5maWxlTmFtZX19YCkgPiAwKTtcbiAgfVxufVxuY2xhc3MgTnVtYmVyaW5nUmVwbGFjZXIge1xuICByZXBsYWNlKHhtbERhdGEsIGNvbmNyZXRlTnVtYmVyaW5ncykge1xuICAgIGxldCBjdXJyZW50WG1sRGF0YSA9IHhtbERhdGE7XG4gICAgZm9yIChjb25zdCBjb25jcmV0ZU51bWJlcmluZyBvZiBjb25jcmV0ZU51bWJlcmluZ3MpIHtcbiAgICAgIGN1cnJlbnRYbWxEYXRhID0gY3VycmVudFhtbERhdGEucmVwbGFjZShcbiAgICAgICAgbmV3IFJlZ0V4cChgeyR7Y29uY3JldGVOdW1iZXJpbmcucmVmZXJlbmNlfS0ke2NvbmNyZXRlTnVtYmVyaW5nLmluc3RhbmNlfX1gLCBcImdcIiksXG4gICAgICAgIGNvbmNyZXRlTnVtYmVyaW5nLm51bUlkLnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50WG1sRGF0YTtcbiAgfVxufVxuY2xhc3MgQ29tcGlsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZm9ybWF0dGVyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbWFnZVJlcGxhY2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJudW1iZXJpbmdSZXBsYWNlclwiKTtcbiAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICB0aGlzLmltYWdlUmVwbGFjZXIgPSBuZXcgSW1hZ2VSZXBsYWNlcigpO1xuICAgIHRoaXMubnVtYmVyaW5nUmVwbGFjZXIgPSBuZXcgTnVtYmVyaW5nUmVwbGFjZXIoKTtcbiAgfVxuICBjb21waWxlKGZpbGUsIHByZXR0aWZ5WG1sLCBvdmVycmlkZXMgPSBbXSkge1xuICAgIGNvbnN0IHppcCA9IG5ldyBKU1ppcCgpO1xuICAgIGNvbnN0IHhtbGlmaWVkRmlsZU1hcHBpbmcgPSB0aGlzLnhtbGlmeUZpbGUoZmlsZSwgcHJldHRpZnlYbWwpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoeG1saWZpZWRGaWxlTWFwcGluZykpO1xuICAgIGZvciAoY29uc3QgWywgb2JqXSBvZiBtYXApIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJGaWxlIG9mIG9iaikge1xuICAgICAgICAgIHppcC5maWxlKHN1YkZpbGUucGF0aCwgc3ViRmlsZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgemlwLmZpbGUob2JqLnBhdGgsIG9iai5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzdWJGaWxlIG9mIG92ZXJyaWRlcykge1xuICAgICAgemlwLmZpbGUoc3ViRmlsZS5wYXRoLCBzdWJGaWxlLmRhdGEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgZmlsZS5NZWRpYS5BcnJheSkge1xuICAgICAgaWYgKGRhdGEudHlwZSAhPT0gXCJzdmdcIikge1xuICAgICAgICB6aXAuZmlsZShgd29yZC9tZWRpYS8ke2RhdGEuZmlsZU5hbWV9YCwgZGF0YS5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHppcC5maWxlKGB3b3JkL21lZGlhLyR7ZGF0YS5maWxlTmFtZX1gLCBkYXRhLmRhdGEpO1xuICAgICAgICB6aXAuZmlsZShgd29yZC9tZWRpYS8ke2RhdGEuZmFsbGJhY2suZmlsZU5hbWV9YCwgZGF0YS5mYWxsYmFjay5kYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB7IGRhdGE6IGJ1ZmZlcjIsIG5hbWUsIGZvbnRLZXkgfSBvZiBmaWxlLkZvbnRUYWJsZS5mb250T3B0aW9uc1dpdGhLZXkpIHtcbiAgICAgIGNvbnN0IFtuYW1lV2l0aG91dEV4dGVuc2lvbl0gPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgIHppcC5maWxlKGB3b3JkL2ZvbnRzLyR7bmFtZVdpdGhvdXRFeHRlbnNpb259Lm9kdHRmYCwgb2JmdXNjYXRlKGJ1ZmZlcjIsIGZvbnRLZXkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHppcDtcbiAgfVxuICB4bWxpZnlGaWxlKGZpbGUsIHByZXR0aWZ5KSB7XG4gICAgY29uc3QgZG9jdW1lbnRSZWxhdGlvbnNoaXBDb3VudCA9IGZpbGUuRG9jdW1lbnQuUmVsYXRpb25zaGlwcy5SZWxhdGlvbnNoaXBDb3VudCArIDE7XG4gICAgY29uc3QgZG9jdW1lbnRYbWxEYXRhID0geG1sKFxuICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuRG9jdW1lbnQuVmlldywge1xuICAgICAgICB2aWV3V3JhcHBlcjogZmlsZS5Eb2N1bWVudCxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgc3RhY2s6IFtdXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICBzdGFuZGFsb25lOiBcInllc1wiLFxuICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgY29tbWVudFJlbGF0aW9uc2hpcENvdW50ID0gZmlsZS5Db21tZW50cy5SZWxhdGlvbnNoaXBzLlJlbGF0aW9uc2hpcENvdW50ICsgMTtcbiAgICBjb25zdCBjb21tZW50WG1sRGF0YSA9IHhtbChcbiAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChmaWxlLkNvbW1lbnRzLCB7XG4gICAgICAgIHZpZXdXcmFwcGVyOiB7XG4gICAgICAgICAgVmlldzogZmlsZS5Db21tZW50cyxcbiAgICAgICAgICBSZWxhdGlvbnNoaXBzOiBmaWxlLkNvbW1lbnRzLlJlbGF0aW9uc2hpcHNcbiAgICAgICAgfSxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgc3RhY2s6IFtdXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICBzdGFuZGFsb25lOiBcInllc1wiLFxuICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZG9jdW1lbnRNZWRpYURhdGFzID0gdGhpcy5pbWFnZVJlcGxhY2VyLmdldE1lZGlhRGF0YShkb2N1bWVudFhtbERhdGEsIGZpbGUuTWVkaWEpO1xuICAgIGNvbnN0IGNvbW1lbnRNZWRpYURhdGFzID0gdGhpcy5pbWFnZVJlcGxhY2VyLmdldE1lZGlhRGF0YShjb21tZW50WG1sRGF0YSwgZmlsZS5NZWRpYSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHtcbiAgICAgICAgICBkb2N1bWVudE1lZGlhRGF0YXMuZm9yRWFjaCgobWVkaWFEYXRhLCBpKSA9PiB7XG4gICAgICAgICAgICBmaWxlLkRvY3VtZW50LlJlbGF0aW9uc2hpcHMuY3JlYXRlUmVsYXRpb25zaGlwKFxuICAgICAgICAgICAgICBkb2N1bWVudFJlbGF0aW9uc2hpcENvdW50ICsgaSxcbiAgICAgICAgICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlXCIsXG4gICAgICAgICAgICAgIGBtZWRpYS8ke21lZGlhRGF0YS5maWxlTmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZpbGUuRG9jdW1lbnQuUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAgICAgICBmaWxlLkRvY3VtZW50LlJlbGF0aW9uc2hpcHMuUmVsYXRpb25zaGlwQ291bnQgKyAxLFxuICAgICAgICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ZvbnRUYWJsZVwiLFxuICAgICAgICAgICAgXCJmb250VGFibGUueG1sXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiB4bWwoXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5Eb2N1bWVudC5SZWxhdGlvbnNoaXBzLCB7XG4gICAgICAgICAgICAgIHZpZXdXcmFwcGVyOiBmaWxlLkRvY3VtZW50LFxuICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbmRlbnQ6IHByZXR0aWZ5LFxuICAgICAgICAgICAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0pKCksXG4gICAgICAgIHBhdGg6IFwid29yZC9fcmVscy9kb2N1bWVudC54bWwucmVsc1wiXG4gICAgICB9LFxuICAgICAgRG9jdW1lbnQ6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCB4bWxEYXRhID0gdGhpcy5pbWFnZVJlcGxhY2VyLnJlcGxhY2UoZG9jdW1lbnRYbWxEYXRhLCBkb2N1bWVudE1lZGlhRGF0YXMsIGRvY3VtZW50UmVsYXRpb25zaGlwQ291bnQpO1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5lZFhtbERhdGEgPSB0aGlzLm51bWJlcmluZ1JlcGxhY2VyLnJlcGxhY2UoeG1sRGF0YSwgZmlsZS5OdW1iZXJpbmcuQ29uY3JldGVOdW1iZXJpbmcpO1xuICAgICAgICAgIHJldHVybiByZWZlcmVuZWRYbWxEYXRhO1xuICAgICAgICB9KSgpLFxuICAgICAgICBwYXRoOiBcIndvcmQvZG9jdW1lbnQueG1sXCJcbiAgICAgIH0sXG4gICAgICBTdHlsZXM6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCB4bWxTdHlsZXMgPSB4bWwoXG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5TdHlsZXMsIHtcbiAgICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgc3RhbmRhbG9uZTogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJVVEYtOFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZWRYbWxTdHlsZXMgPSB0aGlzLm51bWJlcmluZ1JlcGxhY2VyLnJlcGxhY2UoeG1sU3R5bGVzLCBmaWxlLk51bWJlcmluZy5Db25jcmV0ZU51bWJlcmluZyk7XG4gICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZWRYbWxTdHlsZXM7XG4gICAgICAgIH0pKCksXG4gICAgICAgIHBhdGg6IFwid29yZC9zdHlsZXMueG1sXCJcbiAgICAgIH0sXG4gICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgIGRhdGE6IHhtbChcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5Db3JlUHJvcGVydGllcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIHN0YW5kYWxvbmU6IFwieWVzXCIsXG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHBhdGg6IFwiZG9jUHJvcHMvY29yZS54bWxcIlxuICAgICAgfSxcbiAgICAgIE51bWJlcmluZzoge1xuICAgICAgICBkYXRhOiB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuTnVtYmVyaW5nLCB7XG4gICAgICAgICAgICB2aWV3V3JhcHBlcjogZmlsZS5Eb2N1bWVudCxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQ6IHByZXR0aWZ5LFxuICAgICAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZTogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcGF0aDogXCJ3b3JkL251bWJlcmluZy54bWxcIlxuICAgICAgfSxcbiAgICAgIEZpbGVSZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgIGRhdGE6IHhtbChcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5GaWxlUmVsYXRpb25zaGlwcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHBhdGg6IFwiX3JlbHMvLnJlbHNcIlxuICAgICAgfSxcbiAgICAgIEhlYWRlclJlbGF0aW9uc2hpcHM6IGZpbGUuSGVhZGVycy5tYXAoKGhlYWRlcldyYXBwZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHhtbERhdGEgPSB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGhlYWRlcldyYXBwZXIuVmlldywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGhlYWRlcldyYXBwZXIsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1lZGlhRGF0YXMgPSB0aGlzLmltYWdlUmVwbGFjZXIuZ2V0TWVkaWFEYXRhKHhtbERhdGEsIGZpbGUuTWVkaWEpO1xuICAgICAgICBtZWRpYURhdGFzLmZvckVhY2goKG1lZGlhRGF0YSwgaSkgPT4ge1xuICAgICAgICAgIGhlYWRlcldyYXBwZXIuUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlXCIsXG4gICAgICAgICAgICBgbWVkaWEvJHttZWRpYURhdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHhtbChcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChoZWFkZXJXcmFwcGVyLlJlbGF0aW9uc2hpcHMsIHtcbiAgICAgICAgICAgICAgdmlld1dyYXBwZXI6IGhlYWRlcldyYXBwZXIsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBwYXRoOiBgd29yZC9fcmVscy9oZWFkZXIke2luZGV4ICsgMX0ueG1sLnJlbHNgXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIEZvb3RlclJlbGF0aW9uc2hpcHM6IGZpbGUuRm9vdGVycy5tYXAoKGZvb3RlcldyYXBwZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHhtbERhdGEgPSB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZvb3RlcldyYXBwZXIuVmlldywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZvb3RlcldyYXBwZXIsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1lZGlhRGF0YXMgPSB0aGlzLmltYWdlUmVwbGFjZXIuZ2V0TWVkaWFEYXRhKHhtbERhdGEsIGZpbGUuTWVkaWEpO1xuICAgICAgICBtZWRpYURhdGFzLmZvckVhY2goKG1lZGlhRGF0YSwgaSkgPT4ge1xuICAgICAgICAgIGZvb3RlcldyYXBwZXIuUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlXCIsXG4gICAgICAgICAgICBgbWVkaWEvJHttZWRpYURhdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHhtbChcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChmb290ZXJXcmFwcGVyLlJlbGF0aW9uc2hpcHMsIHtcbiAgICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZvb3RlcldyYXBwZXIsXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBwYXRoOiBgd29yZC9fcmVscy9mb290ZXIke2luZGV4ICsgMX0ueG1sLnJlbHNgXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIEhlYWRlcnM6IGZpbGUuSGVhZGVycy5tYXAoKGhlYWRlcldyYXBwZXIsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHRlbXBYbWxEYXRhID0geG1sKFxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChoZWFkZXJXcmFwcGVyLlZpZXcsIHtcbiAgICAgICAgICAgIHZpZXdXcmFwcGVyOiBoZWFkZXJXcmFwcGVyLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICBlbmNvZGluZzogXCJVVEYtOFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBtZWRpYURhdGFzID0gdGhpcy5pbWFnZVJlcGxhY2VyLmdldE1lZGlhRGF0YSh0ZW1wWG1sRGF0YSwgZmlsZS5NZWRpYSk7XG4gICAgICAgIGNvbnN0IHhtbERhdGEgPSB0aGlzLmltYWdlUmVwbGFjZXIucmVwbGFjZSh0ZW1wWG1sRGF0YSwgbWVkaWFEYXRhcywgMCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5lZFhtbERhdGEgPSB0aGlzLm51bWJlcmluZ1JlcGxhY2VyLnJlcGxhY2UoeG1sRGF0YSwgZmlsZS5OdW1iZXJpbmcuQ29uY3JldGVOdW1iZXJpbmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHJlZmVyZW5lZFhtbERhdGEsXG4gICAgICAgICAgcGF0aDogYHdvcmQvaGVhZGVyJHtpbmRleCArIDF9LnhtbGBcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgRm9vdGVyczogZmlsZS5Gb290ZXJzLm1hcCgoZm9vdGVyV3JhcHBlciwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdGVtcFhtbERhdGEgPSB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZvb3RlcldyYXBwZXIuVmlldywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZvb3RlcldyYXBwZXIsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1lZGlhRGF0YXMgPSB0aGlzLmltYWdlUmVwbGFjZXIuZ2V0TWVkaWFEYXRhKHRlbXBYbWxEYXRhLCBmaWxlLk1lZGlhKTtcbiAgICAgICAgY29uc3QgeG1sRGF0YSA9IHRoaXMuaW1hZ2VSZXBsYWNlci5yZXBsYWNlKHRlbXBYbWxEYXRhLCBtZWRpYURhdGFzLCAwKTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmVkWG1sRGF0YSA9IHRoaXMubnVtYmVyaW5nUmVwbGFjZXIucmVwbGFjZSh4bWxEYXRhLCBmaWxlLk51bWJlcmluZy5Db25jcmV0ZU51bWJlcmluZyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogcmVmZXJlbmVkWG1sRGF0YSxcbiAgICAgICAgICBwYXRoOiBgd29yZC9mb290ZXIke2luZGV4ICsgMX0ueG1sYFxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBDb250ZW50VHlwZXM6IHtcbiAgICAgICAgZGF0YTogeG1sKFxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChmaWxlLkNvbnRlbnRUeXBlcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHBhdGg6IFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiXG4gICAgICB9LFxuICAgICAgQ3VzdG9tUHJvcGVydGllczoge1xuICAgICAgICBkYXRhOiB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuQ3VzdG9tUHJvcGVydGllcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIHN0YW5kYWxvbmU6IFwieWVzXCIsXG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHBhdGg6IFwiZG9jUHJvcHMvY3VzdG9tLnhtbFwiXG4gICAgICB9LFxuICAgICAgQXBwUHJvcGVydGllczoge1xuICAgICAgICBkYXRhOiB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuQXBwUHJvcGVydGllcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIHN0YW5kYWxvbmU6IFwieWVzXCIsXG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHBhdGg6IFwiZG9jUHJvcHMvYXBwLnhtbFwiXG4gICAgICB9LFxuICAgICAgRm9vdE5vdGVzOiB7XG4gICAgICAgIGRhdGE6IHhtbChcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5Gb290Tm90ZXMuVmlldywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRm9vdE5vdGVzLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgICAgICAgICBlbmNvZGluZzogXCJVVEYtOFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwYXRoOiBcIndvcmQvZm9vdG5vdGVzLnhtbFwiXG4gICAgICB9LFxuICAgICAgRm9vdE5vdGVzUmVsYXRpb25zaGlwczoge1xuICAgICAgICBkYXRhOiB4bWwoXG4gICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuRm9vdE5vdGVzLlJlbGF0aW9uc2hpcHMsIHtcbiAgICAgICAgICAgIHZpZXdXcmFwcGVyOiBmaWxlLkZvb3ROb3RlcyxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQ6IHByZXR0aWZ5LFxuICAgICAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcGF0aDogXCJ3b3JkL19yZWxzL2Zvb3Rub3Rlcy54bWwucmVsc1wiXG4gICAgICB9LFxuICAgICAgU2V0dGluZ3M6IHtcbiAgICAgICAgZGF0YTogeG1sKFxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChmaWxlLlNldHRpbmdzLCB7XG4gICAgICAgICAgICB2aWV3V3JhcHBlcjogZmlsZS5Eb2N1bWVudCxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQ6IHByZXR0aWZ5LFxuICAgICAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZTogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcGF0aDogXCJ3b3JkL3NldHRpbmdzLnhtbFwiXG4gICAgICB9LFxuICAgICAgQ29tbWVudHM6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCB4bWxEYXRhID0gdGhpcy5pbWFnZVJlcGxhY2VyLnJlcGxhY2UoY29tbWVudFhtbERhdGEsIGNvbW1lbnRNZWRpYURhdGFzLCBjb21tZW50UmVsYXRpb25zaGlwQ291bnQpO1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5lZFhtbERhdGEgPSB0aGlzLm51bWJlcmluZ1JlcGxhY2VyLnJlcGxhY2UoeG1sRGF0YSwgZmlsZS5OdW1iZXJpbmcuQ29uY3JldGVOdW1iZXJpbmcpO1xuICAgICAgICAgIHJldHVybiByZWZlcmVuZWRYbWxEYXRhO1xuICAgICAgICB9KSgpLFxuICAgICAgICBwYXRoOiBcIndvcmQvY29tbWVudHMueG1sXCJcbiAgICAgIH0sXG4gICAgICBDb21tZW50c1JlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHtcbiAgICAgICAgICBjb21tZW50TWVkaWFEYXRhcy5mb3JFYWNoKChtZWRpYURhdGEsIGkpID0+IHtcbiAgICAgICAgICAgIGZpbGUuQ29tbWVudHMuUmVsYXRpb25zaGlwcy5jcmVhdGVSZWxhdGlvbnNoaXAoXG4gICAgICAgICAgICAgIGNvbW1lbnRSZWxhdGlvbnNoaXBDb3VudCArIGksXG4gICAgICAgICAgICAgIFwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9pbWFnZVwiLFxuICAgICAgICAgICAgICBgbWVkaWEvJHttZWRpYURhdGEuZmlsZU5hbWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4geG1sKFxuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KGZpbGUuQ29tbWVudHMuUmVsYXRpb25zaGlwcywge1xuICAgICAgICAgICAgICB2aWV3V3JhcHBlcjoge1xuICAgICAgICAgICAgICAgIFZpZXc6IGZpbGUuQ29tbWVudHMsXG4gICAgICAgICAgICAgICAgUmVsYXRpb25zaGlwczogZmlsZS5Db21tZW50cy5SZWxhdGlvbnNoaXBzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluZGVudDogcHJldHRpZnksXG4gICAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfSkoKSxcbiAgICAgICAgcGF0aDogXCJ3b3JkL19yZWxzL2NvbW1lbnRzLnhtbC5yZWxzXCJcbiAgICAgIH0sXG4gICAgICBGb250VGFibGU6IHtcbiAgICAgICAgZGF0YTogeG1sKFxuICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLmZvcm1hdChmaWxlLkZvbnRUYWJsZS5WaWV3LCB7XG4gICAgICAgICAgICB2aWV3V3JhcHBlcjogZmlsZS5Eb2N1bWVudCxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpbmRlbnQ6IHByZXR0aWZ5LFxuICAgICAgICAgICAgZGVjbGFyYXRpb246IHtcbiAgICAgICAgICAgICAgc3RhbmRhbG9uZTogXCJ5ZXNcIixcbiAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwiVVRGLThcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcGF0aDogXCJ3b3JkL2ZvbnRUYWJsZS54bWxcIlxuICAgICAgfSxcbiAgICAgIEZvbnRUYWJsZVJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgZGF0YTogKCgpID0+IHhtbChcbiAgICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXQoZmlsZS5Gb250VGFibGUuUmVsYXRpb25zaGlwcywge1xuICAgICAgICAgICAgdmlld1dyYXBwZXI6IGZpbGUuRG9jdW1lbnQsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc3RhY2s6IFtdXG4gICAgICAgICAgfSksXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5kZW50OiBwcmV0dGlmeSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICAgICAgICAgIGVuY29kaW5nOiBcIlVURi04XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICkpKCksXG4gICAgICAgIHBhdGg6IFwid29yZC9fcmVscy9mb250VGFibGUueG1sLnJlbHNcIlxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IFByZXR0aWZ5VHlwZSA9IHtcbiAgTk9ORTogXCJcIixcbiAgV0lUSF8yX0JMQU5LUzogXCIgIFwiLFxuICBXSVRIXzRfQkxBTktTOiBcIiAgICBcIixcbiAgV0lUSF9UQUI6IFwiXHRcIlxufTtcbmNvbnN0IGNvbnZlcnRQcmV0dGlmeVR5cGUgPSAocHJldHRpZnkpID0+IHByZXR0aWZ5ID09PSB0cnVlID8gUHJldHRpZnlUeXBlLldJVEhfMl9CTEFOS1MgOiBwcmV0dGlmeSA9PT0gZmFsc2UgPyB2b2lkIDAgOiBwcmV0dGlmeTtcbmNvbnN0IF9QYWNrZXIgPSBjbGFzcyBfUGFja2VyIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXdhaXRcbiAgc3RhdGljIHBhY2soXzAsIF8xMiwgXzIpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoZmlsZSwgdHlwZTIsIHByZXR0aWZ5LCBvdmVycmlkZXMgPSBbXSkge1xuICAgICAgY29uc3QgemlwID0gdGhpcy5jb21waWxlci5jb21waWxlKGZpbGUsIGNvbnZlcnRQcmV0dGlmeVR5cGUocHJldHRpZnkpLCBvdmVycmlkZXMpO1xuICAgICAgcmV0dXJuIHppcC5nZW5lcmF0ZUFzeW5jKHtcbiAgICAgICAgdHlwZTogdHlwZTIsXG4gICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50XCIsXG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHRvU3RyaW5nKGZpbGUsIHByZXR0aWZ5LCBvdmVycmlkZXMgPSBbXSkge1xuICAgIHJldHVybiBfUGFja2VyLnBhY2soZmlsZSwgXCJzdHJpbmdcIiwgcHJldHRpZnksIG92ZXJyaWRlcyk7XG4gIH1cbiAgc3RhdGljIHRvQnVmZmVyKGZpbGUsIHByZXR0aWZ5LCBvdmVycmlkZXMgPSBbXSkge1xuICAgIHJldHVybiBfUGFja2VyLnBhY2soZmlsZSwgXCJub2RlYnVmZmVyXCIsIHByZXR0aWZ5LCBvdmVycmlkZXMpO1xuICB9XG4gIHN0YXRpYyB0b0Jhc2U2NFN0cmluZyhmaWxlLCBwcmV0dGlmeSwgb3ZlcnJpZGVzID0gW10pIHtcbiAgICByZXR1cm4gX1BhY2tlci5wYWNrKGZpbGUsIFwiYmFzZTY0XCIsIHByZXR0aWZ5LCBvdmVycmlkZXMpO1xuICB9XG4gIHN0YXRpYyB0b0Jsb2IoZmlsZSwgcHJldHRpZnksIG92ZXJyaWRlcyA9IFtdKSB7XG4gICAgcmV0dXJuIF9QYWNrZXIucGFjayhmaWxlLCBcImJsb2JcIiwgcHJldHRpZnksIG92ZXJyaWRlcyk7XG4gIH1cbiAgc3RhdGljIHRvQXJyYXlCdWZmZXIoZmlsZSwgcHJldHRpZnksIG92ZXJyaWRlcyA9IFtdKSB7XG4gICAgcmV0dXJuIF9QYWNrZXIucGFjayhmaWxlLCBcImFycmF5YnVmZmVyXCIsIHByZXR0aWZ5LCBvdmVycmlkZXMpO1xuICB9XG4gIHN0YXRpYyB0b1N0cmVhbShmaWxlLCBwcmV0dGlmeSwgb3ZlcnJpZGVzID0gW10pIHtcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgc3RyZWFtQnJvd3NlcmlmeUV4cG9ydHMuU3RyZWFtKCk7XG4gICAgY29uc3QgemlwID0gdGhpcy5jb21waWxlci5jb21waWxlKGZpbGUsIGNvbnZlcnRQcmV0dGlmeVR5cGUocHJldHRpZnkpLCBvdmVycmlkZXMpO1xuICAgIHppcC5nZW5lcmF0ZUFzeW5jKHtcbiAgICAgIHR5cGU6IFwibm9kZWJ1ZmZlclwiLFxuICAgICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnRcIixcbiAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIlxuICAgIH0pLnRoZW4oKHopID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KFwiZGF0YVwiLCB6KTtcbiAgICAgIHN0cmVhbS5lbWl0KFwiZW5kXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cbn07XG5fX3B1YmxpY0ZpZWxkKF9QYWNrZXIsIFwiY29tcGlsZXJcIiwgbmV3IENvbXBpbGVyKCkpO1xubGV0IFBhY2tlciA9IF9QYWNrZXI7XG5jb25zdCBmb3JtYXR0ZXIkMSA9IG5ldyBGb3JtYXR0ZXIoKTtcbmNvbnN0IHRvSnNvbiA9ICh4bWxEYXRhKSA9PiB7XG4gIGNvbnN0IHhtbE9iaiA9IGxpYkV4cG9ydHMueG1sMmpzKHhtbERhdGEsIHsgY29tcGFjdDogZmFsc2UsIGNhcHR1cmVTcGFjZXNCZXR3ZWVuRWxlbWVudHM6IHRydWUgfSk7XG4gIHJldHVybiB4bWxPYmo7XG59O1xuY29uc3QgY3JlYXRlVGV4dEVsZW1lbnRDb250ZW50cyA9ICh0ZXh0KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgdGV4dEpzb24gPSB0b0pzb24oeG1sKGZvcm1hdHRlciQxLmZvcm1hdChuZXcgVGV4dCh7IHRleHQgfSkpKSk7XG4gIHJldHVybiAoX2EgPSB0ZXh0SnNvbi5lbGVtZW50c1swXS5lbGVtZW50cykgIT0gbnVsbCA/IF9hIDogW107XG59O1xuY29uc3QgcGF0Y2hTcGFjZUF0dHJpYnV0ZSA9IChlbGVtZW50KSA9PiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBlbGVtZW50KSwge1xuICBhdHRyaWJ1dGVzOiB7XG4gICAgXCJ4bWw6c3BhY2VcIjogXCJwcmVzZXJ2ZVwiXG4gIH1cbn0pO1xuY29uc3QgZ2V0Rmlyc3RMZXZlbEVsZW1lbnRzID0gKHJlbGF0aW9uc2hpcHMsIGlkKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIHJldHVybiAoX2IgPSAoX2EgPSByZWxhdGlvbnNoaXBzLmVsZW1lbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlsdGVyKChlKSA9PiBlLm5hbWUgPT09IGlkKVswXS5lbGVtZW50cykgIT0gbnVsbCA/IF9iIDogW107XG59O1xuY29uc3QgYXBwZW5kQ29udGVudFR5cGUgPSAoZWxlbWVudCwgY29udGVudFR5cGUsIGV4dGVuc2lvbikgPT4ge1xuICBjb25zdCByZWxhdGlvbnNoaXBFbGVtZW50cyA9IGdldEZpcnN0TGV2ZWxFbGVtZW50cyhlbGVtZW50LCBcIlR5cGVzXCIpO1xuICBjb25zdCBleGlzdCA9IHJlbGF0aW9uc2hpcEVsZW1lbnRzLnNvbWUoXG4gICAgKGVsKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIGVsLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGVsLm5hbWUgPT09IFwiRGVmYXVsdFwiICYmICgoX2EgPSBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuYXR0cmlidXRlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLkNvbnRlbnRUeXBlKSA9PT0gY29udGVudFR5cGUgJiYgKChfYiA9IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5hdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2IuRXh0ZW5zaW9uKSA9PT0gZXh0ZW5zaW9uO1xuICAgIH1cbiAgKTtcbiAgaWYgKGV4aXN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbGF0aW9uc2hpcEVsZW1lbnRzLnB1c2goe1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIENvbnRlbnRUeXBlOiBjb250ZW50VHlwZSxcbiAgICAgIEV4dGVuc2lvbjogZXh0ZW5zaW9uXG4gICAgfSxcbiAgICBuYW1lOiBcIkRlZmF1bHRcIixcbiAgICB0eXBlOiBcImVsZW1lbnRcIlxuICB9KTtcbn07XG5jb25zdCBnZXRJZEZyb21SZWxhdGlvbnNoaXBJZCA9IChyZWxhdGlvbnNoaXBJZCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBwYXJzZUludChyZWxhdGlvbnNoaXBJZC5zdWJzdHJpbmcoMyksIDEwKTtcbiAgcmV0dXJuIGlzTmFOKG91dHB1dCkgPyAwIDogb3V0cHV0O1xufTtcbmNvbnN0IGdldE5leHRSZWxhdGlvbnNoaXBJbmRleCA9IChyZWxhdGlvbnNoaXBzKSA9PiB7XG4gIGNvbnN0IHJlbGF0aW9uc2hpcEVsZW1lbnRzID0gZ2V0Rmlyc3RMZXZlbEVsZW1lbnRzKHJlbGF0aW9uc2hpcHMsIFwiUmVsYXRpb25zaGlwc1wiKTtcbiAgcmV0dXJuIHJlbGF0aW9uc2hpcEVsZW1lbnRzLm1hcCgoZSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiBnZXRJZEZyb21SZWxhdGlvbnNoaXBJZCgoX2MgPSAoX2IgPSAoX2EgPSBlLmF0dHJpYnV0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5JZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfYyA6IFwiXCIpO1xuICB9KS5yZWR1Y2UoKGFjYywgY3VycikgPT4gTWF0aC5tYXgoYWNjLCBjdXJyKSwgMCkgKyAxO1xufTtcbmNvbnN0IGFwcGVuZFJlbGF0aW9uc2hpcCA9IChyZWxhdGlvbnNoaXBzLCBpZCwgdHlwZTIsIHRhcmdldCwgdGFyZ2V0TW9kZSkgPT4ge1xuICBjb25zdCByZWxhdGlvbnNoaXBFbGVtZW50cyA9IGdldEZpcnN0TGV2ZWxFbGVtZW50cyhyZWxhdGlvbnNoaXBzLCBcIlJlbGF0aW9uc2hpcHNcIik7XG4gIHJlbGF0aW9uc2hpcEVsZW1lbnRzLnB1c2goe1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIElkOiBgcklkJHtpZH1gLFxuICAgICAgVHlwZTogdHlwZTIsXG4gICAgICBUYXJnZXQ6IHRhcmdldCxcbiAgICAgIFRhcmdldE1vZGU6IHRhcmdldE1vZGVcbiAgICB9LFxuICAgIG5hbWU6IFwiUmVsYXRpb25zaGlwXCIsXG4gICAgdHlwZTogXCJlbGVtZW50XCJcbiAgfSk7XG4gIHJldHVybiByZWxhdGlvbnNoaXBFbGVtZW50cztcbn07XG5jb25zdCBmaW5kUnVuRWxlbWVudEluZGV4V2l0aFRva2VuID0gKHBhcmFncmFwaEVsZW1lbnQsIHRva2VuKSA9PiB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAoKF9hID0gcGFyYWdyYXBoRWxlbWVudC5lbGVtZW50cykgIT0gbnVsbCA/IF9hIDogW10pLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHBhcmFncmFwaEVsZW1lbnQuZWxlbWVudHNbaV07XG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgZWxlbWVudC5uYW1lID09PSBcInc6clwiKSB7XG4gICAgICBjb25zdCB0ZXh0RWxlbWVudCA9ICgoX2IgPSBlbGVtZW50LmVsZW1lbnRzKSAhPSBudWxsID8gX2IgOiBbXSkuZmlsdGVyKChlKSA9PiBlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGUubmFtZSA9PT0gXCJ3OnRcIik7XG4gICAgICBmb3IgKGNvbnN0IHRleHQgb2YgdGV4dEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCEoKF9jID0gdGV4dC5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2QgPSB0ZXh0LmVsZW1lbnRzWzBdLnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5pbmNsdWRlcyh0b2tlbikpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbiBub3QgZm91bmRcIik7XG59O1xuY29uc3Qgc3BsaXRSdW5FbGVtZW50ID0gKHJ1bkVsZW1lbnQsIHRva2VuKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGxldCBzcGxpdEluZGV4ID0gMDtcbiAgY29uc3Qgc3BsaXRFbGVtZW50cyA9IChfYiA9IChfYSA9IHJ1bkVsZW1lbnQuZWxlbWVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5tYXAoKGUsIGkpID0+IHtcbiAgICB2YXIgX2EyLCBfYjIsIF9jO1xuICAgIGlmIChlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGUubmFtZSA9PT0gXCJ3OnRcIikge1xuICAgICAgY29uc3QgdGV4dCA9IChfYyA9IChfYjIgPSAoX2EyID0gZS5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi50ZXh0KSAhPSBudWxsID8gX2MgOiBcIlwiO1xuICAgICAgY29uc3Qgc3BsaXRUZXh0ID0gdGV4dC5zcGxpdCh0b2tlbik7XG4gICAgICBjb25zdCBuZXdFbGVtZW50cyA9IHNwbGl0VGV4dC5tYXAoKHQpID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGUpLCBwYXRjaFNwYWNlQXR0cmlidXRlKGUpKSwge1xuICAgICAgICBlbGVtZW50czogY3JlYXRlVGV4dEVsZW1lbnRDb250ZW50cyh0KVxuICAgICAgfSkpO1xuICAgICAgc3BsaXRJbmRleCA9IGk7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgfSkuZmxhdCgpKSAhPSBudWxsID8gX2IgOiBbXTtcbiAgY29uc3QgbGVmdFJ1bkVsZW1lbnQgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJ1bkVsZW1lbnQpKSksIHtcbiAgICBlbGVtZW50czogc3BsaXRFbGVtZW50cy5zbGljZSgwLCBzcGxpdEluZGV4ICsgMSlcbiAgfSk7XG4gIGNvbnN0IHJpZ2h0UnVuRWxlbWVudCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocnVuRWxlbWVudCkpKSwge1xuICAgIGVsZW1lbnRzOiBzcGxpdEVsZW1lbnRzLnNsaWNlKHNwbGl0SW5kZXggKyAxKVxuICB9KTtcbiAgcmV0dXJuIHsgbGVmdDogbGVmdFJ1bkVsZW1lbnQsIHJpZ2h0OiByaWdodFJ1bkVsZW1lbnQgfTtcbn07XG5jb25zdCBSZXBsYWNlTW9kZSA9IHtcbiAgU1RBUlQ6IDAsXG4gIE1JRERMRTogMSxcbiAgRU5EOiAyXG59O1xuY29uc3QgcmVwbGFjZVRva2VuSW5QYXJhZ3JhcGhFbGVtZW50ID0gKHtcbiAgcGFyYWdyYXBoRWxlbWVudCxcbiAgcmVuZGVyZWRQYXJhZ3JhcGgsXG4gIG9yaWdpbmFsVGV4dCxcbiAgcmVwbGFjZW1lbnRUZXh0XG59KSA9PiB7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSByZW5kZXJlZFBhcmFncmFwaC50ZXh0LmluZGV4T2Yob3JpZ2luYWxUZXh0KTtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgb3JpZ2luYWxUZXh0Lmxlbmd0aCAtIDE7XG4gIGxldCByZXBsYWNlTW9kZSA9IFJlcGxhY2VNb2RlLlNUQVJUO1xuICBmb3IgKGNvbnN0IHJ1biBvZiByZW5kZXJlZFBhcmFncmFwaC5ydW5zKSB7XG4gICAgZm9yIChjb25zdCB7IHRleHQsIGluZGV4LCBzdGFydCwgZW5kIH0gb2YgcnVuLnBhcnRzKSB7XG4gICAgICBzd2l0Y2ggKHJlcGxhY2VNb2RlKSB7XG4gICAgICAgIGNhc2UgUmVwbGFjZU1vZGUuU1RBUlQ6XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFN0YXJ0SW5kZXggPSBzdGFydEluZGV4IC0gc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRFbmRJbmRleCA9IE1hdGgubWluKGVuZEluZGV4LCBlbmQpIC0gc3RhcnQ7XG4gICAgICAgICAgICBjb25zdCBwYXJ0VG9SZXBsYWNlID0gcnVuLnRleHQuc3Vic3RyaW5nKG9mZnNldFN0YXJ0SW5kZXgsIG9mZnNldEVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAocGFydFRvUmVwbGFjZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHRleHQucmVwbGFjZShwYXJ0VG9SZXBsYWNlLCByZXBsYWNlbWVudFRleHQpO1xuICAgICAgICAgICAgcGF0Y2hUZXh0RWxlbWVudChwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzW3J1bi5pbmRleF0uZWxlbWVudHNbaW5kZXhdLCBmaXJzdFBhcnQpO1xuICAgICAgICAgICAgcmVwbGFjZU1vZGUgPSBSZXBsYWNlTW9kZS5NSURETEU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVwbGFjZU1vZGUuTUlERExFOlxuICAgICAgICAgIGlmIChlbmRJbmRleCA8PSBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gdGV4dC5zdWJzdHJpbmcoZW5kSW5kZXggLSBzdGFydCArIDEpO1xuICAgICAgICAgICAgcGF0Y2hUZXh0RWxlbWVudChwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzW3J1bi5pbmRleF0uZWxlbWVudHNbaW5kZXhdLCBsYXN0UGFydCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudCA9IHBhcmFncmFwaEVsZW1lbnQuZWxlbWVudHNbcnVuLmluZGV4XS5lbGVtZW50c1tpbmRleF07XG4gICAgICAgICAgICBwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzW3J1bi5pbmRleF0uZWxlbWVudHNbaW5kZXhdID0gcGF0Y2hTcGFjZUF0dHJpYnV0ZShjdXJyZW50RWxlbWVudCk7XG4gICAgICAgICAgICByZXBsYWNlTW9kZSA9IFJlcGxhY2VNb2RlLkVORDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hUZXh0RWxlbWVudChwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzW3J1bi5pbmRleF0uZWxlbWVudHNbaW5kZXhdLCBcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhZ3JhcGhFbGVtZW50O1xufTtcbmNvbnN0IHBhdGNoVGV4dEVsZW1lbnQgPSAoZWxlbWVudCwgdGV4dCkgPT4ge1xuICBlbGVtZW50LmVsZW1lbnRzID0gY3JlYXRlVGV4dEVsZW1lbnRDb250ZW50cyh0ZXh0KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuY29uc3QgcmVuZGVyUGFyYWdyYXBoTm9kZSA9IChub2RlKSA9PiB7XG4gIGlmIChub2RlLmVsZW1lbnQubmFtZSAhPT0gXCJ3OnBcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBub2RlIHR5cGU6ICR7bm9kZS5lbGVtZW50Lm5hbWV9YCk7XG4gIH1cbiAgaWYgKCFub2RlLmVsZW1lbnQuZWxlbWVudHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dDogXCJcIixcbiAgICAgIHJ1bnM6IFtdLFxuICAgICAgaW5kZXg6IC0xLFxuICAgICAgcGF0aFRvUGFyYWdyYXBoOiBbXVxuICAgIH07XG4gIH1cbiAgbGV0IGN1cnJlbnRSdW5TdHJpbmdMZW5ndGggPSAwO1xuICBjb25zdCBydW5zID0gbm9kZS5lbGVtZW50LmVsZW1lbnRzLm1hcCgoZWxlbWVudCwgaSkgPT4gKHsgZWxlbWVudCwgaSB9KSkuZmlsdGVyKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC5uYW1lID09PSBcInc6clwiKS5tYXAoKHsgZWxlbWVudCwgaSB9KSA9PiB7XG4gICAgY29uc3QgcmVuZGVyZWRSdW5Ob2RlID0gcmVuZGVyUnVuTm9kZShlbGVtZW50LCBpLCBjdXJyZW50UnVuU3RyaW5nTGVuZ3RoKTtcbiAgICBjdXJyZW50UnVuU3RyaW5nTGVuZ3RoICs9IHJlbmRlcmVkUnVuTm9kZS50ZXh0Lmxlbmd0aDtcbiAgICByZXR1cm4gcmVuZGVyZWRSdW5Ob2RlO1xuICB9KS5maWx0ZXIoKGUpID0+ICEhZSk7XG4gIGNvbnN0IHRleHQgPSBydW5zLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLnRleHQsIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHRleHQsXG4gICAgcnVucyxcbiAgICBpbmRleDogbm9kZS5pbmRleCxcbiAgICBwYXRoVG9QYXJhZ3JhcGg6IGJ1aWxkTm9kZVBhdGgobm9kZSlcbiAgfTtcbn07XG5jb25zdCByZW5kZXJSdW5Ob2RlID0gKG5vZGUsIGluZGV4LCBjdXJyZW50UnVuU3RyaW5nSW5kZXgpID0+IHtcbiAgaWYgKCFub2RlLmVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBwYXJ0czogW10sXG4gICAgICBpbmRleDogLTEsXG4gICAgICBzdGFydDogY3VycmVudFJ1blN0cmluZ0luZGV4LFxuICAgICAgZW5kOiBjdXJyZW50UnVuU3RyaW5nSW5kZXhcbiAgICB9O1xuICB9XG4gIGxldCBjdXJyZW50VGV4dFN0cmluZ0luZGV4ID0gY3VycmVudFJ1blN0cmluZ0luZGV4O1xuICBjb25zdCBwYXJ0cyA9IG5vZGUuZWxlbWVudHMubWFwKFxuICAgIChlbGVtZW50LCBpKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIGVsZW1lbnQubmFtZSA9PT0gXCJ3OnRcIiAmJiBlbGVtZW50LmVsZW1lbnRzICYmIGVsZW1lbnQuZWxlbWVudHMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgdGV4dDogKF9iID0gKF9hID0gZWxlbWVudC5lbGVtZW50c1swXS50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9iIDogXCJcIixcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHN0YXJ0OiBjdXJyZW50VGV4dFN0cmluZ0luZGV4LFxuICAgICAgICBlbmQ6ICgoKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMiwgX2IyO1xuICAgICAgICAgIGN1cnJlbnRUZXh0U3RyaW5nSW5kZXggKz0gKChfYjIgPSAoX2EyID0gZWxlbWVudC5lbGVtZW50c1swXS50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfYjIgOiBcIlwiKS5sZW5ndGggLSAxO1xuICAgICAgICAgIHJldHVybiBjdXJyZW50VGV4dFN0cmluZ0luZGV4O1xuICAgICAgICB9KSgpXG4gICAgICB9IDogdm9pZCAwO1xuICAgIH1cbiAgKS5maWx0ZXIoKGUpID0+ICEhZSkubWFwKChlKSA9PiBlKTtcbiAgY29uc3QgdGV4dCA9IHBhcnRzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLnRleHQsIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHRleHQsXG4gICAgcGFydHMsXG4gICAgaW5kZXgsXG4gICAgc3RhcnQ6IGN1cnJlbnRSdW5TdHJpbmdJbmRleCxcbiAgICBlbmQ6IGN1cnJlbnRUZXh0U3RyaW5nSW5kZXhcbiAgfTtcbn07XG5jb25zdCBidWlsZE5vZGVQYXRoID0gKG5vZGUpID0+IG5vZGUucGFyZW50ID8gWy4uLmJ1aWxkTm9kZVBhdGgobm9kZS5wYXJlbnQpLCBub2RlLmluZGV4XSA6IFtub2RlLmluZGV4XTtcbmNvbnN0IGVsZW1lbnRzVG9XcmFwcGVyID0gKHdyYXBwZXIpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYSA9IHdyYXBwZXIuZWxlbWVudC5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgoZSwgaSkgPT4gKHtcbiAgICBlbGVtZW50OiBlLFxuICAgIGluZGV4OiBpLFxuICAgIHBhcmVudDogd3JhcHBlclxuICB9KSkpICE9IG51bGwgPyBfYiA6IFtdO1xufTtcbmNvbnN0IHRyYXZlcnNlID0gKG5vZGUpID0+IHtcbiAgbGV0IHJlbmRlcmVkUGFyYWdyYXBocyA9IFtdO1xuICBjb25zdCBxdWV1ZTIgPSBbXG4gICAgLi4uZWxlbWVudHNUb1dyYXBwZXIoe1xuICAgICAgZWxlbWVudDogbm9kZSxcbiAgICAgIGluZGV4OiAwLFxuICAgICAgcGFyZW50OiB2b2lkIDBcbiAgICB9KVxuICBdO1xuICBsZXQgY3VycmVudE5vZGU7XG4gIHdoaWxlIChxdWV1ZTIubGVuZ3RoID4gMCkge1xuICAgIGN1cnJlbnROb2RlID0gcXVldWUyLnNoaWZ0KCk7XG4gICAgaWYgKGN1cnJlbnROb2RlLmVsZW1lbnQubmFtZSA9PT0gXCJ3OnBcIikge1xuICAgICAgcmVuZGVyZWRQYXJhZ3JhcGhzID0gWy4uLnJlbmRlcmVkUGFyYWdyYXBocywgcmVuZGVyUGFyYWdyYXBoTm9kZShjdXJyZW50Tm9kZSldO1xuICAgIH1cbiAgICBxdWV1ZTIucHVzaCguLi5lbGVtZW50c1RvV3JhcHBlcihjdXJyZW50Tm9kZSkpO1xuICB9XG4gIHJldHVybiByZW5kZXJlZFBhcmFncmFwaHM7XG59O1xuY29uc3QgZmluZExvY2F0aW9uT2ZUZXh0ID0gKG5vZGUsIHRleHQpID0+IHRyYXZlcnNlKG5vZGUpLmZpbHRlcigocCkgPT4gcC50ZXh0LmluY2x1ZGVzKHRleHQpKTtcbmNvbnN0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbmNvbnN0IFNQTElUX1RPS0VOID0gXCLJtVwiO1xuY29uc3QgcmVwbGFjZXIgPSAoe1xuICBqc29uLFxuICBwYXRjaCxcbiAgcGF0Y2hUZXh0LFxuICBjb250ZXh0LFxuICBrZWVwT3JpZ2luYWxTdHlsZXMgPSB0cnVlXG59KSA9PiB7XG4gIGNvbnN0IHJlbmRlcmVkUGFyYWdyYXBocyA9IGZpbmRMb2NhdGlvbk9mVGV4dChqc29uLCBwYXRjaFRleHQpO1xuICBpZiAocmVuZGVyZWRQYXJhZ3JhcGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IGVsZW1lbnQ6IGpzb24sIGRpZEZpbmRPY2N1cnJlbmNlOiBmYWxzZSB9O1xuICB9XG4gIGZvciAoY29uc3QgcmVuZGVyZWRQYXJhZ3JhcGggb2YgcmVuZGVyZWRQYXJhZ3JhcGhzKSB7XG4gICAgY29uc3QgdGV4dEpzb24gPSBwYXRjaC5jaGlsZHJlbi5tYXAoKGMpID0+IHRvSnNvbih4bWwoZm9ybWF0dGVyLmZvcm1hdChjLCBjb250ZXh0KSkpKS5tYXAoKGMpID0+IGMuZWxlbWVudHNbMF0pO1xuICAgIHN3aXRjaCAocGF0Y2gudHlwZSkge1xuICAgICAgY2FzZSBQYXRjaFR5cGUuRE9DVU1FTlQ6IHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGdvVG9QYXJlbnRFbGVtZW50RnJvbVBhdGgoanNvbiwgcmVuZGVyZWRQYXJhZ3JhcGgucGF0aFRvUGFyYWdyYXBoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudEluZGV4ID0gZ2V0TGFzdEVsZW1lbnRJbmRleEZyb21QYXRoKHJlbmRlcmVkUGFyYWdyYXBoLnBhdGhUb1BhcmFncmFwaCk7XG4gICAgICAgIHBhcmVudEVsZW1lbnQuZWxlbWVudHMuc3BsaWNlKGVsZW1lbnRJbmRleCwgMSwgLi4udGV4dEpzb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgUGF0Y2hUeXBlLlBBUkFHUkFQSDpcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoRWxlbWVudCA9IGdvVG9FbGVtZW50RnJvbVBhdGgoanNvbiwgcmVuZGVyZWRQYXJhZ3JhcGgucGF0aFRvUGFyYWdyYXBoKTtcbiAgICAgICAgcmVwbGFjZVRva2VuSW5QYXJhZ3JhcGhFbGVtZW50KHtcbiAgICAgICAgICBwYXJhZ3JhcGhFbGVtZW50LFxuICAgICAgICAgIHJlbmRlcmVkUGFyYWdyYXBoLFxuICAgICAgICAgIG9yaWdpbmFsVGV4dDogcGF0Y2hUZXh0LFxuICAgICAgICAgIHJlcGxhY2VtZW50VGV4dDogU1BMSVRfVE9LRU5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZmluZFJ1bkVsZW1lbnRJbmRleFdpdGhUb2tlbihwYXJhZ3JhcGhFbGVtZW50LCBTUExJVF9UT0tFTik7XG4gICAgICAgIGNvbnN0IHJ1bkVsZW1lbnRUb0JlUmVwbGFjZWQgPSBwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gc3BsaXRSdW5FbGVtZW50KHJ1bkVsZW1lbnRUb0JlUmVwbGFjZWQsIFNQTElUX1RPS0VOKTtcbiAgICAgICAgbGV0IG5ld1J1bkVsZW1lbnRzID0gdGV4dEpzb247XG4gICAgICAgIGxldCBwYXRjaGVkUmlnaHRFbGVtZW50ID0gcmlnaHQ7XG4gICAgICAgIGlmIChrZWVwT3JpZ2luYWxTdHlsZXMpIHtcbiAgICAgICAgICBjb25zdCBydW5FbGVtZW50Tm9uVGV4dHVhbEVsZW1lbnRzID0gcnVuRWxlbWVudFRvQmVSZXBsYWNlZC5lbGVtZW50cy5maWx0ZXIoXG4gICAgICAgICAgICAoZSkgPT4gZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBlLm5hbWUgPT09IFwidzpyUHJcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3UnVuRWxlbWVudHMgPSB0ZXh0SnNvbi5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBlKSwge1xuICAgICAgICAgICAgICBlbGVtZW50czogWy4uLnJ1bkVsZW1lbnROb25UZXh0dWFsRWxlbWVudHMsIC4uLihfYSA9IGUuZWxlbWVudHMpICE9IG51bGwgPyBfYSA6IFtdXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF0Y2hlZFJpZ2h0RWxlbWVudCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJpZ2h0KSwge1xuICAgICAgICAgICAgZWxlbWVudHM6IFsuLi5ydW5FbGVtZW50Tm9uVGV4dHVhbEVsZW1lbnRzLCAuLi5yaWdodC5lbGVtZW50c11cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhZ3JhcGhFbGVtZW50LmVsZW1lbnRzLnNwbGljZShpbmRleCwgMSwgbGVmdCwgLi4ubmV3UnVuRWxlbWVudHMsIHBhdGNoZWRSaWdodEVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZWxlbWVudDoganNvbiwgZGlkRmluZE9jY3VycmVuY2U6IHRydWUgfTtcbn07XG5jb25zdCBnb1RvRWxlbWVudEZyb21QYXRoID0gKGpzb24sIHBhdGgpID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBqc29uO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhbaV07XG4gICAgY29uc3QgbmV4dEVsZW1lbnRzID0gZWxlbWVudC5lbGVtZW50cztcbiAgICBlbGVtZW50ID0gbmV4dEVsZW1lbnRzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn07XG5jb25zdCBnb1RvUGFyZW50RWxlbWVudEZyb21QYXRoID0gKGpzb24sIHBhdGgpID0+IGdvVG9FbGVtZW50RnJvbVBhdGgoanNvbiwgcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpKTtcbmNvbnN0IGdldExhc3RFbGVtZW50SW5kZXhGcm9tUGF0aCA9IChwYXRoKSA9PiBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5jb25zdCBQYXRjaFR5cGUgPSB7XG4gIERPQ1VNRU5UOiBcImZpbGVcIixcbiAgUEFSQUdSQVBIOiBcInBhcmFncmFwaFwiXG59O1xuY29uc3QgaW1hZ2VSZXBsYWNlciA9IG5ldyBJbWFnZVJlcGxhY2VyKCk7XG5jb25zdCBVVEYxNkxFID0gbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU0XSk7XG5jb25zdCBVVEYxNkJFID0gbmV3IFVpbnQ4QXJyYXkoWzI1NCwgMjU1XSk7XG5jb25zdCBjb21wYXJlQnl0ZUFycmF5cyA9IChhLCBiKSA9PiB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgcGF0Y2hEb2N1bWVudCA9IChfMCkgPT4gX19hc3luYyh2b2lkIDAsIFtfMF0sIGZ1bmN0aW9uKiAoe1xuICBvdXRwdXRUeXBlLFxuICBkYXRhLFxuICBwYXRjaGVzLFxuICBrZWVwT3JpZ2luYWxTdHlsZXMsXG4gIHBsYWNlaG9sZGVyRGVsaW1pdGVycyA9IHsgc3RhcnQ6IFwie3tcIiwgZW5kOiBcIn19XCIgfSxcbiAgLyoqXG4gICAqIFNlYXJjaCBmb3Igb2NjdXJyZW5jZXMgb3ZlciBwYXRjaGVkIGRvY3VtZW50XG4gICAqL1xuICByZWN1cnNpdmUgPSB0cnVlXG59KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCB6aXBDb250ZW50ID0gZGF0YSBpbnN0YW5jZW9mIEpTWmlwID8gZGF0YSA6IHlpZWxkIEpTWmlwLmxvYWRBc3luYyhkYXRhKTtcbiAgY29uc3QgY29udGV4dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBmaWxlID0ge1xuICAgIE1lZGlhOiBuZXcgTWVkaWEoKVxuICB9O1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBpbWFnZVJlbGF0aW9uc2hpcEFkZGl0aW9ucyA9IFtdO1xuICBjb25zdCBoeXBlcmxpbmtSZWxhdGlvbnNoaXBBZGRpdGlvbnMgPSBbXTtcbiAgbGV0IGhhc01lZGlhID0gZmFsc2U7XG4gIGNvbnN0IGJpbmFyeUNvbnRlbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh6aXBDb250ZW50LmZpbGVzKSkge1xuICAgIGNvbnN0IGJpbmFyeVZhbHVlID0geWllbGQgdmFsdWUuYXN5bmMoXCJ1aW50OGFycmF5XCIpO1xuICAgIGNvbnN0IHN0YXJ0Qnl0ZXMgPSBiaW5hcnlWYWx1ZS5zbGljZSgwLCAyKTtcbiAgICBpZiAoY29tcGFyZUJ5dGVBcnJheXMoc3RhcnRCeXRlcywgVVRGMTZMRSkgfHwgY29tcGFyZUJ5dGVBcnJheXMoc3RhcnRCeXRlcywgVVRGMTZCRSkpIHtcbiAgICAgIGJpbmFyeUNvbnRlbnRNYXAuc2V0KGtleSwgYmluYXJ5VmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgha2V5LmVuZHNXaXRoKFwiLnhtbFwiKSAmJiAha2V5LmVuZHNXaXRoKFwiLnJlbHNcIikpIHtcbiAgICAgIGJpbmFyeUNvbnRlbnRNYXAuc2V0KGtleSwgYmluYXJ5VmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSB0b0pzb24oeWllbGQgdmFsdWUuYXN5bmMoXCJ0ZXh0XCIpKTtcbiAgICBpZiAoa2V5ID09PSBcIndvcmQvZG9jdW1lbnQueG1sXCIpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50MiA9IChfYSA9IGpzb24uZWxlbWVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKChpKSA9PiBpLm5hbWUgPT09IFwidzpkb2N1bWVudFwiKTtcbiAgICAgIGlmIChkb2N1bWVudDIgJiYgZG9jdW1lbnQyLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBucyBvZiBbXCJtY1wiLCBcIndwXCIsIFwiclwiLCBcIncxNVwiLCBcIm1cIl0pIHtcbiAgICAgICAgICBkb2N1bWVudDIuYXR0cmlidXRlc1tgeG1sbnM6JHtuc31gXSA9IERvY3VtZW50QXR0cmlidXRlTmFtZXNwYWNlc1tuc107XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQyLmF0dHJpYnV0ZXNbXCJtYzpJZ25vcmFibGVcIl0gPSBgJHtkb2N1bWVudDIuYXR0cmlidXRlc1tcIm1jOklnbm9yYWJsZVwiXSB8fCBcIlwifSB3MTVgLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKFwid29yZC9cIikgJiYgIWtleS5lbmRzV2l0aChcIi54bWwucmVsc1wiKSkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgdmlld1dyYXBwZXI6IHtcbiAgICAgICAgICBSZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICBjcmVhdGVSZWxhdGlvbnNoaXA6IChsaW5rSWQsIF8sIHRhcmdldCwgX18pID0+IHtcbiAgICAgICAgICAgICAgaHlwZXJsaW5rUmVsYXRpb25zaGlwQWRkaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBoeXBlcmxpbms6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBsaW5rSWQsXG4gICAgICAgICAgICAgICAgICBsaW5rOiB0YXJnZXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhY2s6IFtdXG4gICAgICB9O1xuICAgICAgY29udGV4dHMuc2V0KGtleSwgY29udGV4dCk7XG4gICAgICBpZiAoIShwbGFjZWhvbGRlckRlbGltaXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYWNlaG9sZGVyRGVsaW1pdGVycy5zdGFydC50cmltKCkpIHx8ICEocGxhY2Vob2xkZXJEZWxpbWl0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBwbGFjZWhvbGRlckRlbGltaXRlcnMuZW5kLnRyaW0oKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBzdGFydCBhbmQgZW5kIGRlbGltaXRlcnMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHBsYWNlaG9sZGVyRGVsaW1pdGVycztcbiAgICAgIGZvciAoY29uc3QgW3BhdGNoS2V5LCBwYXRjaFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXRjaGVzKSkge1xuICAgICAgICBjb25zdCBwYXRjaFRleHQgPSBgJHtzdGFydH0ke3BhdGNoS2V5fSR7ZW5kfWA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkaWRGaW5kT2NjdXJyZW5jZSB9ID0gcmVwbGFjZXIoe1xuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHBhdGNoOiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwYXRjaFZhbHVlKSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogcGF0Y2hWYWx1ZS5jaGlsZHJlbi5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEV4dGVybmFsSHlwZXJsaW5rKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjb25jcmV0ZUh5cGVybGluayA9IG5ldyBDb25jcmV0ZUh5cGVybGluayhlbGVtZW50Lm9wdGlvbnMuY2hpbGRyZW4sIHVuaXF1ZUlkKCkpO1xuICAgICAgICAgICAgICAgICAgaHlwZXJsaW5rUmVsYXRpb25zaGlwQWRkaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGh5cGVybGluazoge1xuICAgICAgICAgICAgICAgICAgICAgIGlkOiBjb25jcmV0ZUh5cGVybGluay5saW5rSWQsXG4gICAgICAgICAgICAgICAgICAgICAgbGluazogZWxlbWVudC5vcHRpb25zLmxpbmtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVIeXBlcmxpbms7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGF0Y2hUZXh0LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGtlZXBPcmlnaW5hbFN0eWxlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFkaWRGaW5kT2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtZWRpYURhdGFzID0gaW1hZ2VSZXBsYWNlci5nZXRNZWRpYURhdGEoSlNPTi5zdHJpbmdpZnkoanNvbiksIGNvbnRleHQuZmlsZS5NZWRpYSk7XG4gICAgICBpZiAobWVkaWFEYXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhc01lZGlhID0gdHJ1ZTtcbiAgICAgICAgaW1hZ2VSZWxhdGlvbnNoaXBBZGRpdGlvbnMucHVzaCh7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1lZGlhRGF0YXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcC5zZXQoa2V5LCBqc29uKTtcbiAgfVxuICBmb3IgKGNvbnN0IHsga2V5LCBtZWRpYURhdGFzIH0gb2YgaW1hZ2VSZWxhdGlvbnNoaXBBZGRpdGlvbnMpIHtcbiAgICBjb25zdCByZWxhdGlvbnNoaXBLZXkgPSBgd29yZC9fcmVscy8ke2tleS5zcGxpdChcIi9cIikucG9wKCl9LnJlbHNgO1xuICAgIGNvbnN0IHJlbGF0aW9uc2hpcHNKc29uID0gKF9iID0gbWFwLmdldChyZWxhdGlvbnNoaXBLZXkpKSAhPSBudWxsID8gX2IgOiBjcmVhdGVSZWxhdGlvbnNoaXBGaWxlKCk7XG4gICAgbWFwLnNldChyZWxhdGlvbnNoaXBLZXksIHJlbGF0aW9uc2hpcHNKc29uKTtcbiAgICBjb25zdCBpbmRleCA9IGdldE5leHRSZWxhdGlvbnNoaXBJbmRleChyZWxhdGlvbnNoaXBzSnNvbik7XG4gICAgY29uc3QgbmV3SnNvbiA9IGltYWdlUmVwbGFjZXIucmVwbGFjZShKU09OLnN0cmluZ2lmeShtYXAuZ2V0KGtleSkpLCBtZWRpYURhdGFzLCBpbmRleCk7XG4gICAgbWFwLnNldChrZXksIEpTT04ucGFyc2UobmV3SnNvbikpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVkaWFEYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyBmaWxlTmFtZSB9ID0gbWVkaWFEYXRhc1tpXTtcbiAgICAgIGFwcGVuZFJlbGF0aW9uc2hpcChcbiAgICAgICAgcmVsYXRpb25zaGlwc0pzb24sXG4gICAgICAgIGluZGV4ICsgaSxcbiAgICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2ltYWdlXCIsXG4gICAgICAgIGBtZWRpYS8ke2ZpbGVOYW1lfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgeyBrZXksIGh5cGVybGluayB9IG9mIGh5cGVybGlua1JlbGF0aW9uc2hpcEFkZGl0aW9ucykge1xuICAgIGNvbnN0IHJlbGF0aW9uc2hpcEtleSA9IGB3b3JkL19yZWxzLyR7a2V5LnNwbGl0KFwiL1wiKS5wb3AoKX0ucmVsc2A7XG4gICAgY29uc3QgcmVsYXRpb25zaGlwc0pzb24gPSAoX2MgPSBtYXAuZ2V0KHJlbGF0aW9uc2hpcEtleSkpICE9IG51bGwgPyBfYyA6IGNyZWF0ZVJlbGF0aW9uc2hpcEZpbGUoKTtcbiAgICBtYXAuc2V0KHJlbGF0aW9uc2hpcEtleSwgcmVsYXRpb25zaGlwc0pzb24pO1xuICAgIGFwcGVuZFJlbGF0aW9uc2hpcChcbiAgICAgIHJlbGF0aW9uc2hpcHNKc29uLFxuICAgICAgaHlwZXJsaW5rLmlkLFxuICAgICAgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL2h5cGVybGlua1wiLFxuICAgICAgaHlwZXJsaW5rLmxpbmssXG4gICAgICBUYXJnZXRNb2RlVHlwZS5FWFRFUk5BTFxuICAgICk7XG4gIH1cbiAgaWYgKGhhc01lZGlhKSB7XG4gICAgY29uc3QgY29udGVudFR5cGVzSnNvbiA9IG1hcC5nZXQoXCJbQ29udGVudF9UeXBlc10ueG1sXCIpO1xuICAgIGlmICghY29udGVudFR5cGVzSnNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY29udGVudCB0eXBlcyBmaWxlXCIpO1xuICAgIH1cbiAgICBhcHBlbmRDb250ZW50VHlwZShjb250ZW50VHlwZXNKc29uLCBcImltYWdlL3BuZ1wiLCBcInBuZ1wiKTtcbiAgICBhcHBlbmRDb250ZW50VHlwZShjb250ZW50VHlwZXNKc29uLCBcImltYWdlL2pwZWdcIiwgXCJqcGVnXCIpO1xuICAgIGFwcGVuZENvbnRlbnRUeXBlKGNvbnRlbnRUeXBlc0pzb24sIFwiaW1hZ2UvanBlZ1wiLCBcImpwZ1wiKTtcbiAgICBhcHBlbmRDb250ZW50VHlwZShjb250ZW50VHlwZXNKc29uLCBcImltYWdlL2JtcFwiLCBcImJtcFwiKTtcbiAgICBhcHBlbmRDb250ZW50VHlwZShjb250ZW50VHlwZXNKc29uLCBcImltYWdlL2dpZlwiLCBcImdpZlwiKTtcbiAgICBhcHBlbmRDb250ZW50VHlwZShjb250ZW50VHlwZXNKc29uLCBcImltYWdlL3N2Zyt4bWxcIiwgXCJzdmdcIik7XG4gIH1cbiAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHRvWG1sKHZhbHVlKTtcbiAgICB6aXAuZmlsZShrZXksIG91dHB1dCk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYmluYXJ5Q29udGVudE1hcCkge1xuICAgIHppcC5maWxlKGtleSwgdmFsdWUpO1xuICB9XG4gIGZvciAoY29uc3QgeyBkYXRhOiBzdHJlYW0sIGZpbGVOYW1lIH0gb2YgZmlsZS5NZWRpYS5BcnJheSkge1xuICAgIHppcC5maWxlKGB3b3JkL21lZGlhLyR7ZmlsZU5hbWV9YCwgc3RyZWFtKTtcbiAgfVxuICByZXR1cm4gemlwLmdlbmVyYXRlQXN5bmMoe1xuICAgIHR5cGU6IG91dHB1dFR5cGUsXG4gICAgbWltZVR5cGU6IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnRcIixcbiAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCJcbiAgfSk7XG59KTtcbmNvbnN0IHRvWG1sID0gKGpzb25PYmopID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gbGliRXhwb3J0cy5qczJ4bWwoanNvbk9iaiwge1xuICAgIGF0dHJpYnV0ZVZhbHVlRm46IChzdHIpID0+IFN0cmluZyhzdHIpLnJlcGxhY2UoLyYoPyFhbXA7fGx0O3xndDt8cXVvdDt8YXBvczspL2csIFwiJmFtcDtcIikucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikucmVwbGFjZSgvXCIvZywgXCImcXVvdDtcIikucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKVxuICAgIC8vIGNzcGVsbDp3b3JkcyBhcG9zXG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufTtcbmNvbnN0IGNyZWF0ZVJlbGF0aW9uc2hpcEZpbGUgPSAoKSA9PiAoe1xuICBkZWNsYXJhdGlvbjoge1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHZlcnNpb246IFwiMS4wXCIsXG4gICAgICBlbmNvZGluZzogXCJVVEYtOFwiLFxuICAgICAgc3RhbmRhbG9uZTogXCJ5ZXNcIlxuICAgIH1cbiAgfSxcbiAgZWxlbWVudHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIG5hbWU6IFwiUmVsYXRpb25zaGlwc1wiLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICB4bWxuczogXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHNcIlxuICAgICAgfSxcbiAgICAgIGVsZW1lbnRzOiBbXVxuICAgIH1cbiAgXVxufSk7XG5jb25zdCBwYXRjaERldGVjdG9yID0gKF8wKSA9PiBfX2FzeW5jKHZvaWQgMCwgW18wXSwgZnVuY3Rpb24qICh7IGRhdGEgfSkge1xuICBjb25zdCB6aXBDb250ZW50ID0gZGF0YSBpbnN0YW5jZW9mIEpTWmlwID8gZGF0YSA6IHlpZWxkIEpTWmlwLmxvYWRBc3luYyhkYXRhKTtcbiAgY29uc3QgcGF0Y2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHppcENvbnRlbnQuZmlsZXMpKSB7XG4gICAgaWYgKCFrZXkuZW5kc1dpdGgoXCIueG1sXCIpICYmICFrZXkuZW5kc1dpdGgoXCIucmVsc1wiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIndvcmQvXCIpICYmICFrZXkuZW5kc1dpdGgoXCIueG1sLnJlbHNcIikpIHtcbiAgICAgIGNvbnN0IGpzb24gPSB0b0pzb24oeWllbGQgdmFsdWUuYXN5bmMoXCJ0ZXh0XCIpKTtcbiAgICAgIHRyYXZlcnNlKGpzb24pLmZvckVhY2goKHApID0+IGZpbmRQYXRjaEtleXMocC50ZXh0KS5mb3JFYWNoKChwYXRjaCkgPT4gcGF0Y2hlcy5hZGQocGF0Y2gpKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHBhdGNoZXMpO1xufSk7XG5jb25zdCBmaW5kUGF0Y2hLZXlzID0gKHRleHQpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIig/PD1cXFxce1xcXFx7KS4rPyg/PVxcXFx9XFxcXH0pXCIsIFwiZ3NcIik7XG4gIHJldHVybiAoX2EgPSB0ZXh0Lm1hdGNoKHBhdHRlcm4pKSAhPSBudWxsID8gX2EgOiBbXTtcbn07XG5leHBvcnQge1xuICBBYnN0cmFjdE51bWJlcmluZyxcbiAgQWxpZ25tZW50LFxuICBBbGlnbm1lbnRBdHRyaWJ1dGVzLFxuICBBbGlnbm1lbnRUeXBlLFxuICBBbm5vdGF0aW9uUmVmZXJlbmNlLFxuICBBdHRyaWJ1dGVzLFxuICBCYXNlRW1waGFzaXNNYXJrLFxuICBCYXNlWG1sQ29tcG9uZW50LFxuICBCb2R5LFxuICBCb29rbWFyayxcbiAgQm9va21hcmtFbmQsXG4gIEJvb2ttYXJrU3RhcnQsXG4gIEJvcmRlcixcbiAgQm9yZGVyRWxlbWVudCxcbiAgQm9yZGVyU3R5bGUsXG4gIEJ1aWxkZXJFbGVtZW50LFxuICBDYXJyaWFnZVJldHVybixcbiAgQ2hhcmFjdGVyU2V0LFxuICBDaGVja0JveCxcbiAgQ2hlY2tCb3hTeW1ib2xFbGVtZW50LFxuICBDaGVja0JveFV0aWwsXG4gIENvbHVtbixcbiAgQ29sdW1uQnJlYWssXG4gIENvbHVtbnMsXG4gIENvbW1lbnQsXG4gIENvbW1lbnRSYW5nZUVuZCxcbiAgQ29tbWVudFJhbmdlU3RhcnQsXG4gIENvbW1lbnRSZWZlcmVuY2UsXG4gIENvbW1lbnRzLFxuICBDb25jcmV0ZUh5cGVybGluayxcbiAgQ29uY3JldGVOdW1iZXJpbmcsXG4gIENvbnRpbnVhdGlvblNlcGFyYXRvcixcbiAgRGF5TG9uZyxcbiAgRGF5U2hvcnQsXG4gIERlbGV0ZWRUZXh0UnVuLFxuICBGaWxlIGFzIERvY3VtZW50LFxuICBEb2N1bWVudEF0dHJpYnV0ZU5hbWVzcGFjZXMsXG4gIERvY3VtZW50QXR0cmlidXRlcyxcbiAgRG9jdW1lbnRCYWNrZ3JvdW5kLFxuICBEb2N1bWVudEJhY2tncm91bmRBdHRyaWJ1dGVzLFxuICBEb2N1bWVudERlZmF1bHRzLFxuICBEb2N1bWVudEdyaWRUeXBlLFxuICBEb3RFbXBoYXNpc01hcmssXG4gIERyYXdpbmcsXG4gIERyb3BDYXBUeXBlLFxuICBFTVBUWV9PQkpFQ1QsXG4gIEVtcGhhc2lzTWFyayxcbiAgRW1waGFzaXNNYXJrVHlwZSxcbiAgRW1wdHlFbGVtZW50LFxuICBFbmRub3RlUmVmZXJlbmNlLFxuICBFeHRlcm5hbEh5cGVybGluayxcbiAgRmlsZSxcbiAgRmlsZUNoaWxkLFxuICBGb290Tm90ZVJlZmVyZW5jZVJ1bkF0dHJpYnV0ZXMsXG4gIEZvb3ROb3RlcyxcbiAgRm9vdGVyMiBhcyBGb290ZXIsXG4gIEZvb3RlcldyYXBwZXIsXG4gIEZvb3Rub3RlUmVmZXJlbmNlLFxuICBGb290bm90ZVJlZmVyZW5jZUVsZW1lbnQsXG4gIEZvb3Rub3RlUmVmZXJlbmNlUnVuLFxuICBGcmFtZUFuY2hvclR5cGUsXG4gIEZyYW1lV3JhcCxcbiAgR3JpZFNwYW4sXG4gIEhlYWRlcjIgYXMgSGVhZGVyLFxuICBIZWFkZXJGb290ZXJSZWZlcmVuY2UsXG4gIEhlYWRlckZvb3RlclJlZmVyZW5jZVR5cGUsXG4gIEhlYWRlckZvb3RlclR5cGUsXG4gIEhlYWRlcldyYXBwZXIsXG4gIEhlYWRpbmdMZXZlbCxcbiAgSGVpZ2h0UnVsZSxcbiAgSGlnaGxpZ2h0Q29sb3IsXG4gIEhvcml6b250YWxQb3NpdGlvbkFsaWduLFxuICBIb3Jpem9udGFsUG9zaXRpb25SZWxhdGl2ZUZyb20sXG4gIEhwc01lYXN1cmVFbGVtZW50LFxuICBIeXBlcmxpbmtUeXBlLFxuICBJZ25vcmVJZkVtcHR5WG1sQ29tcG9uZW50LFxuICBJbWFnZVJ1bixcbiAgSW1wb3J0ZWRSb290RWxlbWVudEF0dHJpYnV0ZXMsXG4gIEltcG9ydGVkWG1sQ29tcG9uZW50LFxuICBJbmRlbnQsXG4gIEluaXRpYWxpemFibGVYbWxDb21wb25lbnQsXG4gIEluc2VydGVkVGV4dFJ1bixcbiAgSW50ZXJuYWxIeXBlcmxpbmssXG4gIExhc3RSZW5kZXJlZFBhZ2VCcmVhayxcbiAgTGVhZGVyVHlwZSxcbiAgTGV2ZWwsXG4gIExldmVsQmFzZSxcbiAgTGV2ZWxGb3JPdmVycmlkZSxcbiAgTGV2ZWxGb3JtYXQsXG4gIExldmVsT3ZlcnJpZGUsXG4gIExldmVsU3VmZml4LFxuICBMaW5lTnVtYmVyUmVzdGFydEZvcm1hdCxcbiAgTGluZVJ1bGVUeXBlLFxuICBNYXRoJDEgYXMgTWF0aCxcbiAgTWF0aEFuZ2xlZEJyYWNrZXRzLFxuICBNYXRoQ3VybHlCcmFja2V0cyxcbiAgTWF0aERlZ3JlZSxcbiAgTWF0aERlbm9taW5hdG9yLFxuICBNYXRoRnJhY3Rpb24sXG4gIE1hdGhGdW5jdGlvbixcbiAgTWF0aEZ1bmN0aW9uTmFtZSxcbiAgTWF0aEZ1bmN0aW9uUHJvcGVydGllcyxcbiAgTWF0aEludGVncmFsLFxuICBNYXRoTGltaXQsXG4gIE1hdGhMaW1pdExvd2VyLFxuICBNYXRoTGltaXRVcHBlcixcbiAgTWF0aE51bWVyYXRvcixcbiAgTWF0aFByZVN1YlN1cGVyU2NyaXB0LFxuICBNYXRoUmFkaWNhbCxcbiAgTWF0aFJhZGljYWxQcm9wZXJ0aWVzLFxuICBNYXRoUm91bmRCcmFja2V0cyxcbiAgTWF0aFJ1bixcbiAgTWF0aFNxdWFyZUJyYWNrZXRzLFxuICBNYXRoU3ViU2NyaXB0LFxuICBNYXRoU3ViU3VwZXJTY3JpcHQsXG4gIE1hdGhTdW0sXG4gIE1hdGhTdXBlclNjcmlwdCxcbiAgTWVkaWEsXG4gIE1vbnRoTG9uZyxcbiAgTW9udGhTaG9ydCxcbiAgTmV4dEF0dHJpYnV0ZUNvbXBvbmVudCxcbiAgTm9CcmVha0h5cGhlbixcbiAgTnVtYmVyRm9ybWF0JDEgYXMgTnVtYmVyRm9ybWF0LFxuICBOdW1iZXJQcm9wZXJ0aWVzLFxuICBOdW1iZXJWYWx1ZUVsZW1lbnQsXG4gIE51bWJlcmluZyxcbiAgT25PZmZFbGVtZW50LFxuICBPdXRsaW5lTGV2ZWwsXG4gIE92ZXJsYXBUeXBlLFxuICBQYWNrZXIsXG4gIFBhZ2VCb3JkZXJEaXNwbGF5LFxuICBQYWdlQm9yZGVyT2Zmc2V0RnJvbSxcbiAgUGFnZUJvcmRlclpPcmRlcixcbiAgUGFnZUJvcmRlcnMsXG4gIFBhZ2VCcmVhayxcbiAgUGFnZUJyZWFrQmVmb3JlLFxuICBQYWdlTWFyZ2luLFxuICBQYWdlTnVtYmVyLFxuICBQYWdlTnVtYmVyRWxlbWVudCxcbiAgUGFnZU51bWJlclNlcGFyYXRvcixcbiAgUGFnZU51bWJlclR5cGUsXG4gIFBhZ2VOdW1iZXJUeXBlQXR0cmlidXRlcyxcbiAgUGFnZU9yaWVudGF0aW9uLFxuICBQYWdlUmVmZXJlbmNlLFxuICBQYWdlVGV4dERpcmVjdGlvbixcbiAgUGFnZVRleHREaXJlY3Rpb25UeXBlLFxuICBQYXJhZ3JhcGgsXG4gIFBhcmFncmFwaFByb3BlcnRpZXMsXG4gIFBhcmFncmFwaFByb3BlcnRpZXNEZWZhdWx0cyxcbiAgUGF0Y2hUeXBlLFxuICBQb3NpdGlvbmFsVGFiLFxuICBQb3NpdGlvbmFsVGFiQWxpZ25tZW50LFxuICBQb3NpdGlvbmFsVGFiTGVhZGVyLFxuICBQb3NpdGlvbmFsVGFiUmVsYXRpdmVUbyxcbiAgUHJldHRpZnlUeXBlLFxuICBSZWxhdGl2ZUhvcml6b250YWxQb3NpdGlvbixcbiAgUmVsYXRpdmVWZXJ0aWNhbFBvc2l0aW9uLFxuICBSdW4sXG4gIFJ1bkZvbnRzLFxuICBSdW5Qcm9wZXJ0aWVzLFxuICBSdW5Qcm9wZXJ0aWVzQ2hhbmdlLFxuICBSdW5Qcm9wZXJ0aWVzRGVmYXVsdHMsXG4gIFNlY3Rpb25Qcm9wZXJ0aWVzLFxuICBTZWN0aW9uVHlwZSxcbiAgU2VjdGlvblR5cGVBdHRyaWJ1dGVzLFxuICBTZXBhcmF0b3IsXG4gIFNlcXVlbnRpYWxJZGVudGlmaWVyLFxuICBTaGFkaW5nLFxuICBTaGFkaW5nVHlwZSxcbiAgU2ltcGxlRmllbGQsXG4gIFNpbXBsZU1haWxNZXJnZUZpZWxkLFxuICBTb2Z0SHlwaGVuLFxuICBTcGFjZVR5cGUsXG4gIFNwYWNpbmcsXG4gIFN0cmluZ0NvbnRhaW5lcixcbiAgU3RyaW5nRW51bVZhbHVlRWxlbWVudCxcbiAgU3RyaW5nVmFsdWVFbGVtZW50LFxuICBTdHlsZSQxIGFzIFN0eWxlLFxuICBTdHlsZUZvckNoYXJhY3RlcixcbiAgU3R5bGVGb3JQYXJhZ3JhcGgsXG4gIFN0eWxlTGV2ZWwsXG4gIFN0eWxlcyxcbiAgU3ltYm9sUnVuLFxuICBURGlyZWN0aW9uLFxuICBUYWIsXG4gIFRhYkF0dHJpYnV0ZXMsXG4gIFRhYlN0b3AsXG4gIFRhYlN0b3BJdGVtLFxuICBUYWJTdG9wUG9zaXRpb24sXG4gIFRhYlN0b3BUeXBlLFxuICBUYWJsZSxcbiAgVGFibGVBbmNob3JUeXBlLFxuICBUYWJsZUJvcmRlcnMsXG4gIFRhYmxlQ2VsbCxcbiAgVGFibGVDZWxsQm9yZGVycyxcbiAgVGFibGVGbG9hdFByb3BlcnRpZXMsXG4gIFRhYmxlTGF5b3V0LFxuICBUYWJsZUxheW91dFR5cGUsXG4gIFRhYmxlT2ZDb250ZW50cyxcbiAgVGFibGVQcm9wZXJ0aWVzLFxuICBUYWJsZVJvdyxcbiAgVGFibGVSb3dIZWlnaHQsXG4gIFRhYmxlUm93SGVpZ2h0QXR0cmlidXRlcyxcbiAgVGFibGVSb3dQcm9wZXJ0aWVzLFxuICBUYWJsZVdpZHRoRWxlbWVudCxcbiAgVGV4dERpcmVjdGlvbixcbiAgVGV4dEVmZmVjdCxcbiAgVGV4dFJ1bixcbiAgVGV4dFdyYXBwaW5nU2lkZSxcbiAgVGV4dFdyYXBwaW5nVHlwZSxcbiAgVGV4dGJveCxcbiAgVGhlbWF0aWNCcmVhayxcbiAgVHlwZSxcbiAgVW5kZXJsaW5lLFxuICBVbmRlcmxpbmVUeXBlLFxuICBWZXJ0aWNhbEFsaWduMiBhcyBWZXJ0aWNhbEFsaWduLFxuICBWZXJ0aWNhbEFsaWduQXR0cmlidXRlcyxcbiAgVmVydGljYWxBbGlnbkVsZW1lbnQsXG4gIFZlcnRpY2FsQWxpZ25TZWN0aW9uLFxuICBWZXJ0aWNhbEFsaWduVGFibGUsXG4gIFZlcnRpY2FsTWVyZ2UsXG4gIFZlcnRpY2FsTWVyZ2VUeXBlLFxuICBWZXJ0aWNhbFBvc2l0aW9uQWxpZ24sXG4gIFZlcnRpY2FsUG9zaXRpb25SZWxhdGl2ZUZyb20sXG4gIFdPUktBUk9VTkQyLFxuICBXT1JLQVJPVU5EMyxcbiAgV09SS0FST1VORDQsXG4gIFdpZHRoVHlwZSxcbiAgV3JhcE5vbmUsXG4gIFdyYXBTcXVhcmUsXG4gIFdyYXBUaWdodCxcbiAgV3JhcFRvcEFuZEJvdHRvbSxcbiAgWG1sQXR0cmlidXRlQ29tcG9uZW50LFxuICBYbWxDb21wb25lbnQsXG4gIFllYXJMb25nLFxuICBZZWFyU2hvcnQsXG4gIGFic3RyYWN0TnVtVW5pcXVlTnVtZXJpY0lkR2VuLFxuICBib29rbWFya1VuaXF1ZU51bWVyaWNJZEdlbixcbiAgY29uY3JldGVOdW1VbmlxdWVOdW1lcmljSWRHZW4sXG4gIGNvbnZlcnRJbmNoZXNUb1R3aXAsXG4gIGNvbnZlcnRNaWxsaW1ldGVyc1RvVHdpcCxcbiAgY29udmVydFRvWG1sQ29tcG9uZW50LFxuICBjcmVhdGVEb2N1bWVudEdyaWQsXG4gIGNyZWF0ZUZyYW1lUHJvcGVydGllcyxcbiAgY3JlYXRlSG9yaXpvbnRhbFBvc2l0aW9uLFxuICBjcmVhdGVMaW5lTnVtYmVyVHlwZSxcbiAgY3JlYXRlTWF0aEFjY2VudENoYXJhY3RlcixcbiAgY3JlYXRlTWF0aEJhc2UsXG4gIGNyZWF0ZU1hdGhMaW1pdExvY2F0aW9uLFxuICBjcmVhdGVNYXRoTkFyeVByb3BlcnRpZXMsXG4gIGNyZWF0ZU1hdGhQcmVTdWJTdXBlclNjcmlwdFByb3BlcnRpZXMsXG4gIGNyZWF0ZU1hdGhTdWJTY3JpcHRFbGVtZW50LFxuICBjcmVhdGVNYXRoU3ViU2NyaXB0UHJvcGVydGllcyxcbiAgY3JlYXRlTWF0aFN1YlN1cGVyU2NyaXB0UHJvcGVydGllcyxcbiAgY3JlYXRlTWF0aFN1cGVyU2NyaXB0RWxlbWVudCxcbiAgY3JlYXRlTWF0aFN1cGVyU2NyaXB0UHJvcGVydGllcyxcbiAgY3JlYXRlUGFnZVNpemUsXG4gIGNyZWF0ZVNpbXBsZVBvcyxcbiAgY3JlYXRlU3RyaW5nRWxlbWVudCxcbiAgY3JlYXRlVmVydGljYWxQb3NpdGlvbixcbiAgZGF0ZVRpbWVWYWx1ZSxcbiAgZGVjaW1hbE51bWJlcixcbiAgZG9jUHJvcGVydGllc1VuaXF1ZU51bWVyaWNJZEdlbixcbiAgZWlnaHRoUG9pbnRNZWFzdXJlVmFsdWUsXG4gIGhhc2hlZElkLFxuICBoZXhDb2xvclZhbHVlLFxuICBocHNNZWFzdXJlVmFsdWUsXG4gIGxvbmdIZXhOdW1iZXIsXG4gIG1lYXN1cmVtZW50T3JQZXJjZW50VmFsdWUsXG4gIHBhdGNoRGV0ZWN0b3IsXG4gIHBhdGNoRG9jdW1lbnQsXG4gIHBlcmNlbnRhZ2VWYWx1ZSxcbiAgcG9pbnRNZWFzdXJlVmFsdWUsXG4gIHBvc2l0aXZlVW5pdmVyc2FsTWVhc3VyZVZhbHVlLFxuICBzZWN0aW9uTWFyZ2luRGVmYXVsdHMsXG4gIHNlY3Rpb25QYWdlU2l6ZURlZmF1bHRzLFxuICBzaG9ydEhleE51bWJlcixcbiAgc2lnbmVkSHBzTWVhc3VyZVZhbHVlLFxuICBzaWduZWRUd2lwc01lYXN1cmVWYWx1ZSxcbiAgdHdpcHNNZWFzdXJlVmFsdWUsXG4gIHVDaGFySGV4TnVtYmVyLFxuICB1bmlxdWVJZCxcbiAgdW5pcXVlTnVtZXJpY0lkQ3JlYXRvcixcbiAgdW5pcXVlVXVpZCxcbiAgdW5pdmVyc2FsTWVhc3VyZVZhbHVlLFxuICB1bnNpZ25lZERlY2ltYWxOdW1iZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/docx/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/decode.js":
/*!*************************************************!*\
  !*** ./node_modules/entities/lib/esm/decode.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinTrieFlags: function() { return /* binding */ BinTrieFlags; },\n/* harmony export */   DecodingMode: function() { return /* binding */ DecodingMode; },\n/* harmony export */   EntityDecoder: function() { return /* binding */ EntityDecoder; },\n/* harmony export */   decodeCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   decodeHTML: function() { return /* binding */ decodeHTML; },\n/* harmony export */   decodeHTMLAttribute: function() { return /* binding */ decodeHTMLAttribute; },\n/* harmony export */   decodeHTMLStrict: function() { return /* binding */ decodeHTMLStrict; },\n/* harmony export */   decodeXML: function() { return /* binding */ decodeXML; },\n/* harmony export */   determineBranch: function() { return /* binding */ determineBranch; },\n/* harmony export */   fromCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.fromCodePoint; },\n/* harmony export */   htmlDecodeTree: function() { return /* reexport safe */ _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   replaceCodePoint: function() { return /* reexport safe */ _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.replaceCodePoint; },\n/* harmony export */   xmlDecodeTree: function() { return /* reexport safe */ _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generated/decode-data-html.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-html.js\");\n/* harmony import */ var _generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generated/decode-data-xml.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-xml.js\");\n/* harmony import */ var _decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./decode_codepoint.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/decode_codepoint.js\");\n\n\n\n// Re-export for use by eg. htmlparser2\n\n\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n    CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n    CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n    CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 0b100000;\nvar BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction isNumber(code) {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));\n}\nfunction isAsciiAlphaNumeric(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code));\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n    EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n    EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n    EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nvar DecodingMode;\n(function (DecodingMode) {\n    /** Entities in text nodes that can end with any character. */\n    DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n    /** Only allow entities terminated with a semicolon. */\n    DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n    /** Entities in attributes have limitations on ending characters. */\n    DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode || (DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nclass EntityDecoder {\n    constructor(\n    /** The tree used to decode entities. */\n    decodeTree, \n    /**\n     * The function that is called when a codepoint is decoded.\n     *\n     * For multi-byte named entities, this will be called multiple times,\n     * with the second codepoint, and the same `consumed` value.\n     *\n     * @param codepoint The decoded codepoint.\n     * @param consumed The number of bytes consumed by the decoder.\n     */\n    emitCodePoint, \n    /** An object that is used to produce errors. */\n    errors) {\n        this.decodeTree = decodeTree;\n        this.emitCodePoint = emitCodePoint;\n        this.errors = errors;\n        /** The current state of the decoder. */\n        this.state = EntityDecoderState.EntityStart;\n        /** Characters that were consumed while parsing an entity. */\n        this.consumed = 1;\n        /**\n         * The result of the entity.\n         *\n         * Either the result index of a numeric entity, or the codepoint of a\n         * numeric entity.\n         */\n        this.result = 0;\n        /** The current index in the decode tree. */\n        this.treeIndex = 0;\n        /** The number of characters that were consumed in excess. */\n        this.excess = 1;\n        /** The mode in which the decoder is operating. */\n        this.decodeMode = DecodingMode.Strict;\n    }\n    /** Resets the instance to make it reusable. */\n    startEntity(decodeMode) {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n    }\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param string The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    write(str, offset) {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (str.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(str, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(str, offset);\n            }\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(str, offset);\n            }\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(str, offset);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(str, offset);\n            }\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(str, offset);\n            }\n        }\n    }\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericStart(str, offset) {\n        if (offset >= str.length) {\n            return -1;\n        }\n        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(str, offset + 1);\n        }\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(str, offset);\n    }\n    addToNumericResult(str, start, end, base) {\n        if (start !== end) {\n            const digitCount = end - start;\n            this.result =\n                this.result * Math.pow(base, digitCount) +\n                    parseInt(str.substr(start, digitCount), base);\n            this.consumed += digitCount;\n        }\n    }\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericHex(str, offset) {\n        const startIdx = offset;\n        while (offset < str.length) {\n            const char = str.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 16);\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return -1;\n    }\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericDecimal(str, offset) {\n        const startIdx = offset;\n        while (offset < str.length) {\n            const char = str.charCodeAt(offset);\n            if (isNumber(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 10);\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return -1;\n    }\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    emitNumericEntity(lastCp, expectedLength) {\n        var _a;\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n            return 0;\n        }\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        }\n        else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n        this.emitCodePoint((0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.replaceCodePoint)(this.result), this.consumed);\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n        return this.consumed;\n    }\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNamedEntity(str, offset) {\n        const { decodeTree } = this;\n        let current = decodeTree[this.treeIndex];\n        // The mask is the number of bytes of the value, including the current byte.\n        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n        for (; offset < str.length; offset++, this.excess++) {\n            const char = str.charCodeAt(offset);\n            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n                }\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNotTerminatedNamedEntity() {\n        var _a;\n        const { result, decodeTree } = this;\n        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n        return this.consumed;\n    }\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNamedEntityData(result, valueLength, consumed) {\n        const { decodeTree } = this;\n        this.emitCodePoint(valueLength === 1\n            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH\n            : decodeTree[result + 1], consumed);\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n        return consumed;\n    }\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    end() {\n        var _a;\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    }\n}\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n    let ret = \"\";\n    const decoder = new EntityDecoder(decodeTree, (str) => (ret += (0,_decode_codepoint_js__WEBPACK_IMPORTED_MODULE_2__.fromCodePoint)(str)));\n    return function decodeWithTrie(str, decodeMode) {\n        let lastIndex = 0;\n        let offset = 0;\n        while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n            ret += str.slice(lastIndex, offset);\n            decoder.startEntity(decodeMode);\n            const len = decoder.write(str, \n            // Skip the \"&\"\n            offset + 1);\n            if (len < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n            lastIndex = offset + len;\n            // If `len` is 0, skip the current `&` and continue.\n            offset = len === 0 ? lastIndex + 1 : lastIndex;\n        }\n        const result = ret + str.slice(lastIndex);\n        // Make sure we don't keep a reference to the final string.\n        ret = \"\";\n        return result;\n    };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        const value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    let lo = nodeIdx;\n    let hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nconst htmlDecoder = getDecoder(_generated_decode_data_html_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\nconst xmlDecoder = getDecoder(_generated_decode_data_xml_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nfunction decodeHTML(str, mode = DecodingMode.Legacy) {\n    return htmlDecoder(str, mode);\n}\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLAttribute(str) {\n    return htmlDecoder(str, DecodingMode.Attribute);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLStrict(str) {\n    return htmlDecoder(str, DecodingMode.Strict);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeXML(str) {\n    return xmlDecoder(str, DecodingMode.Strict);\n}\n//# sourceMappingURL=decode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2RlY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0Y7QUFDK0I7QUFDMUY7QUFDMEQ7QUFDYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQzFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzRUFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxtRUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0VBQWM7QUFDN0MsOEJBQThCLHFFQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9lc20vZGVjb2RlLmpzP2U2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0bWxEZWNvZGVUcmVlIGZyb20gXCIuL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzXCI7XG5pbXBvcnQgeG1sRGVjb2RlVHJlZSBmcm9tIFwiLi9nZW5lcmF0ZWQvZGVjb2RlLWRhdGEteG1sLmpzXCI7XG5pbXBvcnQgZGVjb2RlQ29kZVBvaW50LCB7IHJlcGxhY2VDb2RlUG9pbnQsIGZyb21Db2RlUG9pbnQsIH0gZnJvbSBcIi4vZGVjb2RlX2NvZGVwb2ludC5qc1wiO1xuLy8gUmUtZXhwb3J0IGZvciB1c2UgYnkgZWcuIGh0bWxwYXJzZXIyXG5leHBvcnQgeyBodG1sRGVjb2RlVHJlZSwgeG1sRGVjb2RlVHJlZSwgZGVjb2RlQ29kZVBvaW50IH07XG5leHBvcnQgeyByZXBsYWNlQ29kZVBvaW50LCBmcm9tQ29kZVBvaW50IH0gZnJvbSBcIi4vZGVjb2RlX2NvZGVwb2ludC5qc1wiO1xudmFyIENoYXJDb2RlcztcbihmdW5jdGlvbiAoQ2hhckNvZGVzKSB7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIk5VTVwiXSA9IDM1XSA9IFwiTlVNXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlNFTUlcIl0gPSA1OV0gPSBcIlNFTUlcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiRVFVQUxTXCJdID0gNjFdID0gXCJFUVVBTFNcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiWkVST1wiXSA9IDQ4XSA9IFwiWkVST1wiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJOSU5FXCJdID0gNTddID0gXCJOSU5FXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIkxPV0VSX0FcIl0gPSA5N10gPSBcIkxPV0VSX0FcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTE9XRVJfRlwiXSA9IDEwMl0gPSBcIkxPV0VSX0ZcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTE9XRVJfWFwiXSA9IDEyMF0gPSBcIkxPV0VSX1hcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiTE9XRVJfWlwiXSA9IDEyMl0gPSBcIkxPV0VSX1pcIjtcbiAgICBDaGFyQ29kZXNbQ2hhckNvZGVzW1wiVVBQRVJfQVwiXSA9IDY1XSA9IFwiVVBQRVJfQVwiO1xuICAgIENoYXJDb2Rlc1tDaGFyQ29kZXNbXCJVUFBFUl9GXCJdID0gNzBdID0gXCJVUFBFUl9GXCI7XG4gICAgQ2hhckNvZGVzW0NoYXJDb2Rlc1tcIlVQUEVSX1pcIl0gPSA5MF0gPSBcIlVQUEVSX1pcIjtcbn0pKENoYXJDb2RlcyB8fCAoQ2hhckNvZGVzID0ge30pKTtcbi8qKiBCaXQgdGhhdCBuZWVkcyB0byBiZSBzZXQgdG8gY29udmVydCBhbiB1cHBlciBjYXNlIEFTQ0lJIGNoYXJhY3RlciB0byBsb3dlciBjYXNlICovXG5jb25zdCBUT19MT1dFUl9CSVQgPSAwYjEwMDAwMDtcbmV4cG9ydCB2YXIgQmluVHJpZUZsYWdzO1xuKGZ1bmN0aW9uIChCaW5UcmllRmxhZ3MpIHtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiVkFMVUVfTEVOR1RIXCJdID0gNDkxNTJdID0gXCJWQUxVRV9MRU5HVEhcIjtcbiAgICBCaW5UcmllRmxhZ3NbQmluVHJpZUZsYWdzW1wiQlJBTkNIX0xFTkdUSFwiXSA9IDE2MjU2XSA9IFwiQlJBTkNIX0xFTkdUSFwiO1xuICAgIEJpblRyaWVGbGFnc1tCaW5UcmllRmxhZ3NbXCJKVU1QX1RBQkxFXCJdID0gMTI3XSA9IFwiSlVNUF9UQUJMRVwiO1xufSkoQmluVHJpZUZsYWdzIHx8IChCaW5UcmllRmxhZ3MgPSB7fSkpO1xuZnVuY3Rpb24gaXNOdW1iZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IENoYXJDb2Rlcy5aRVJPICYmIGNvZGUgPD0gQ2hhckNvZGVzLk5JTkU7XG59XG5mdW5jdGlvbiBpc0hleGFkZWNpbWFsQ2hhcmFjdGVyKGNvZGUpIHtcbiAgICByZXR1cm4gKChjb2RlID49IENoYXJDb2Rlcy5VUFBFUl9BICYmIGNvZGUgPD0gQ2hhckNvZGVzLlVQUEVSX0YpIHx8XG4gICAgICAgIChjb2RlID49IENoYXJDb2Rlcy5MT1dFUl9BICYmIGNvZGUgPD0gQ2hhckNvZGVzLkxPV0VSX0YpKTtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlBbHBoYU51bWVyaWMoY29kZSkge1xuICAgIHJldHVybiAoKGNvZGUgPj0gQ2hhckNvZGVzLlVQUEVSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuVVBQRVJfWikgfHxcbiAgICAgICAgKGNvZGUgPj0gQ2hhckNvZGVzLkxPV0VSX0EgJiYgY29kZSA8PSBDaGFyQ29kZXMuTE9XRVJfWikgfHxcbiAgICAgICAgaXNOdW1iZXIoY29kZSkpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNoYXJhY3RlciBpcyBhIHZhbGlkIGVuZCBjaGFyYWN0ZXIgZm9yIGFuIGVudGl0eSBpbiBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQXR0cmlidXRlIHZhbHVlcyB0aGF0IGFyZW4ndCB0ZXJtaW5hdGVkIHByb3Blcmx5IGFyZW4ndCBwYXJzZWQsIGFuZCBzaG91bGRuJ3QgbGVhZCB0byBhIHBhcnNlciBlcnJvci5cbiAqIFNlZSB0aGUgZXhhbXBsZSBpbiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZS1zdGF0ZVxuICovXG5mdW5jdGlvbiBpc0VudGl0eUluQXR0cmlidXRlSW52YWxpZEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IENoYXJDb2Rlcy5FUVVBTFMgfHwgaXNBc2NpaUFscGhhTnVtZXJpYyhjb2RlKTtcbn1cbnZhciBFbnRpdHlEZWNvZGVyU3RhdGU7XG4oZnVuY3Rpb24gKEVudGl0eURlY29kZXJTdGF0ZSkge1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJFbnRpdHlTdGFydFwiXSA9IDBdID0gXCJFbnRpdHlTdGFydFwiO1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJOdW1lcmljU3RhcnRcIl0gPSAxXSA9IFwiTnVtZXJpY1N0YXJ0XCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk51bWVyaWNEZWNpbWFsXCJdID0gMl0gPSBcIk51bWVyaWNEZWNpbWFsXCI7XG4gICAgRW50aXR5RGVjb2RlclN0YXRlW0VudGl0eURlY29kZXJTdGF0ZVtcIk51bWVyaWNIZXhcIl0gPSAzXSA9IFwiTnVtZXJpY0hleFwiO1xuICAgIEVudGl0eURlY29kZXJTdGF0ZVtFbnRpdHlEZWNvZGVyU3RhdGVbXCJOYW1lZEVudGl0eVwiXSA9IDRdID0gXCJOYW1lZEVudGl0eVwiO1xufSkoRW50aXR5RGVjb2RlclN0YXRlIHx8IChFbnRpdHlEZWNvZGVyU3RhdGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWNvZGluZ01vZGU7XG4oZnVuY3Rpb24gKERlY29kaW5nTW9kZSkge1xuICAgIC8qKiBFbnRpdGllcyBpbiB0ZXh0IG5vZGVzIHRoYXQgY2FuIGVuZCB3aXRoIGFueSBjaGFyYWN0ZXIuICovXG4gICAgRGVjb2RpbmdNb2RlW0RlY29kaW5nTW9kZVtcIkxlZ2FjeVwiXSA9IDBdID0gXCJMZWdhY3lcIjtcbiAgICAvKiogT25seSBhbGxvdyBlbnRpdGllcyB0ZXJtaW5hdGVkIHdpdGggYSBzZW1pY29sb24uICovXG4gICAgRGVjb2RpbmdNb2RlW0RlY29kaW5nTW9kZVtcIlN0cmljdFwiXSA9IDFdID0gXCJTdHJpY3RcIjtcbiAgICAvKiogRW50aXRpZXMgaW4gYXR0cmlidXRlcyBoYXZlIGxpbWl0YXRpb25zIG9uIGVuZGluZyBjaGFyYWN0ZXJzLiAqL1xuICAgIERlY29kaW5nTW9kZVtEZWNvZGluZ01vZGVbXCJBdHRyaWJ1dGVcIl0gPSAyXSA9IFwiQXR0cmlidXRlXCI7XG59KShEZWNvZGluZ01vZGUgfHwgKERlY29kaW5nTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRva2VuIGRlY29kZXIgd2l0aCBzdXBwb3J0IG9mIHdyaXRpbmcgcGFydGlhbCBlbnRpdGllcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudGl0eURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgdHJlZSB1c2VkIHRvIGRlY29kZSBlbnRpdGllcy4gKi9cbiAgICBkZWNvZGVUcmVlLCBcbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvZGVwb2ludCBpcyBkZWNvZGVkLlxuICAgICAqXG4gICAgICogRm9yIG11bHRpLWJ5dGUgbmFtZWQgZW50aXRpZXMsIHRoaXMgd2lsbCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsXG4gICAgICogd2l0aCB0aGUgc2Vjb25kIGNvZGVwb2ludCwgYW5kIHRoZSBzYW1lIGBjb25zdW1lZGAgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZXBvaW50IFRoZSBkZWNvZGVkIGNvZGVwb2ludC5cbiAgICAgKiBAcGFyYW0gY29uc3VtZWQgVGhlIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZGVjb2Rlci5cbiAgICAgKi9cbiAgICBlbWl0Q29kZVBvaW50LCBcbiAgICAvKiogQW4gb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBwcm9kdWNlIGVycm9ycy4gKi9cbiAgICBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVUcmVlID0gZGVjb2RlVHJlZTtcbiAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50ID0gZW1pdENvZGVQb2ludDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGVjb2Rlci4gKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDtcbiAgICAgICAgLyoqIENoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkIHdoaWxlIHBhcnNpbmcgYW4gZW50aXR5LiAqL1xuICAgICAgICB0aGlzLmNvbnN1bWVkID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXN1bHQgb2YgdGhlIGVudGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogRWl0aGVyIHRoZSByZXN1bHQgaW5kZXggb2YgYSBudW1lcmljIGVudGl0eSwgb3IgdGhlIGNvZGVwb2ludCBvZiBhXG4gICAgICAgICAqIG51bWVyaWMgZW50aXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXN1bHQgPSAwO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGRlY29kZSB0cmVlLiAqL1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZXJlIGNvbnN1bWVkIGluIGV4Y2Vzcy4gKi9cbiAgICAgICAgdGhpcy5leGNlc3MgPSAxO1xuICAgICAgICAvKiogVGhlIG1vZGUgaW4gd2hpY2ggdGhlIGRlY29kZXIgaXMgb3BlcmF0aW5nLiAqL1xuICAgICAgICB0aGlzLmRlY29kZU1vZGUgPSBEZWNvZGluZ01vZGUuU3RyaWN0O1xuICAgIH1cbiAgICAvKiogUmVzZXRzIHRoZSBpbnN0YW5jZSB0byBtYWtlIGl0IHJldXNhYmxlLiAqL1xuICAgIHN0YXJ0RW50aXR5KGRlY29kZU1vZGUpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVNb2RlID0gZGVjb2RlTW9kZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5FbnRpdHlTdGFydDtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSAwO1xuICAgICAgICB0aGlzLnRyZWVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZXhjZXNzID0gMTtcbiAgICAgICAgdGhpcy5jb25zdW1lZCA9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGFuIGVudGl0eSB0byB0aGUgZGVjb2Rlci4gVGhpcyBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggcGFydGlhbCBlbnRpdGllcy5cbiAgICAgKiBJZiB0aGUgZW50aXR5IGlzIGluY29tcGxldGUsIHRoZSBkZWNvZGVyIHdpbGwgcmV0dXJuIC0xLlxuICAgICAqXG4gICAgICogTWlycm9ycyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYGdldERlY29kZXJgLCBidXQgd2l0aCB0aGUgYWJpbGl0eSB0byBzdG9wIGRlY29kaW5nIGlmIHRoZVxuICAgICAqIGVudGl0eSBpcyBpbmNvbXBsZXRlLCBhbmQgcmVzdW1lIHdoZW4gdGhlIG5leHQgc3RyaW5nIGlzIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyaW5nIFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgZW50aXR5IChvciBhIGNvbnRpbnVhdGlvbiBvZiB0aGUgZW50aXR5KS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVudGl0eSBiZWdpbnMuIFNob3VsZCBiZSAwIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBjYWxsLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICB3cml0ZShzdHIsIG9mZnNldCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLkVudGl0eVN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KG9mZnNldCkgPT09IENoYXJDb2Rlcy5OVU0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1lcmljU3RhcnQoc3RyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEVudGl0eURlY29kZXJTdGF0ZS5OYW1lZEVudGl0eTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU5hbWVkRW50aXR5KHN0ciwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNTdGFydDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlTnVtZXJpY1N0YXJ0KHN0ciwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNEZWNpbWFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1lcmljRGVjaW1hbChzdHIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVudGl0eURlY29kZXJTdGF0ZS5OdW1lcmljSGV4OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1lcmljSGV4KHN0ciwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk5hbWVkRW50aXR5OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOYW1lZEVudGl0eShzdHIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgYmV0d2VlbiB0aGUgbnVtZXJpYyBkZWNpbWFsIGFuZCBoZXhhZGVjaW1hbCBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgTnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlIHN0YXRlYCBpbiB0aGUgSFRNTCBzcGVjLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGl0eSAob3IgYSBjb250aW51YXRpb24gb2YgdGhlIGVudGl0eSkuXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgY3VycmVudCBvZmZzZXQuXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBjb25zdW1lZCwgb3IgLTEgaWYgdGhlIGVudGl0eSBpcyBpbmNvbXBsZXRlLlxuICAgICAqL1xuICAgIHN0YXRlTnVtZXJpY1N0YXJ0KHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPj0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RyLmNoYXJDb2RlQXQob2Zmc2V0KSB8IFRPX0xPV0VSX0JJVCkgPT09IENoYXJDb2Rlcy5MT1dFUl9YKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNIZXg7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWVyaWNIZXgoc3RyLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNEZWNpbWFsO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWVyaWNEZWNpbWFsKHN0ciwgb2Zmc2V0KTtcbiAgICB9XG4gICAgYWRkVG9OdW1lcmljUmVzdWx0KHN0ciwgc3RhcnQsIGVuZCwgYmFzZSkge1xuICAgICAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgZGlnaXRDb3VudCA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPVxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ICogTWF0aC5wb3coYmFzZSwgZGlnaXRDb3VudCkgK1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChzdHIuc3Vic3RyKHN0YXJ0LCBkaWdpdENvdW50KSwgYmFzZSk7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IGRpZ2l0Q291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgaGV4YWRlY2ltYWwgbnVtZXJpYyBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgSGV4YWRlbWljYWwgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpdHkgKG9yIGEgY29udGludWF0aW9uIG9mIHRoZSBlbnRpdHkpLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICBzdGF0ZU51bWVyaWNIZXgoc3RyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihjaGFyKSB8fCBpc0hleGFkZWNpbWFsQ2hhcmFjdGVyKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRvTnVtZXJpY1Jlc3VsdChzdHIsIHN0YXJ0SWR4LCBvZmZzZXQsIDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eShjaGFyLCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRvTnVtZXJpY1Jlc3VsdChzdHIsIHN0YXJ0SWR4LCBvZmZzZXQsIDE2KTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBkZWNpbWFsIG51bWVyaWMgZW50aXR5LlxuICAgICAqXG4gICAgICogRXF1aXZhbGVudCB0byB0aGUgYERlY2ltYWwgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpdHkgKG9yIGEgY29udGludWF0aW9uIG9mIHRoZSBlbnRpdHkpLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICBzdGF0ZU51bWVyaWNEZWNpbWFsKHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9OdW1lcmljUmVzdWx0KHN0ciwgc3RhcnRJZHgsIG9mZnNldCwgMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXROdW1lcmljRW50aXR5KGNoYXIsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVG9OdW1lcmljUmVzdWx0KHN0ciwgc3RhcnRJZHgsIG9mZnNldCwgMTApO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGFuZCBlbWl0IGEgbnVtZXJpYyBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBsb2dpYyBmcm9tIHRoZSBgSGV4YWRlbWljYWwgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGFydFxuICAgICAqIHN0YXRlYCBhbmQgYE51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZSBlbmQgc3RhdGVgIGluIHRoZSBIVE1MIHNwZWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFzdENwIFRoZSBsYXN0IGNvZGUgcG9pbnQgb2YgdGhlIGVudGl0eS4gVXNlZCB0byBzZWUgaWYgdGhlXG4gICAgICogICAgICAgICAgICAgICBlbnRpdHkgd2FzIHRlcm1pbmF0ZWQgd2l0aCBhIHNlbWljb2xvbi5cbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggVGhlIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgY29uc3VtZWQuIFVzZWQgdG8gdmFsaWRhdGUgdGhhdCBhdCBsZWFzdCBvbmUgZGlnaXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgd2FzIGNvbnN1bWVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQuXG4gICAgICovXG4gICAgZW1pdE51bWVyaWNFbnRpdHkobGFzdENwLCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBjb25zdW1lZCBhdCBsZWFzdCBvbmUgZGlnaXQuXG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVkIDw9IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmVycm9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFic2VuY2VPZkRpZ2l0c0luTnVtZXJpY0NoYXJhY3RlclJlZmVyZW5jZSh0aGlzLmNvbnN1bWVkKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBhIGxlZ2l0IGVuZCBvZiB0aGUgZW50aXR5XG4gICAgICAgIGlmIChsYXN0Q3AgPT09IENoYXJDb2Rlcy5TRU1JKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVkICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZWNvZGVNb2RlID09PSBEZWNvZGluZ01vZGUuU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRDb2RlUG9pbnQocmVwbGFjZUNvZGVQb2ludCh0aGlzLnJlc3VsdCksIHRoaXMuY29uc3VtZWQpO1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0Q3AgIT09IENoYXJDb2Rlcy5TRU1JKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMubWlzc2luZ1NlbWljb2xvbkFmdGVyQ2hhcmFjdGVyUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9ycy52YWxpZGF0ZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UodGhpcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBuYW1lZCBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBFcXVpdmFsZW50IHRvIHRoZSBgTmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBzdGF0ZWAgaW4gdGhlIEhUTUwgc3BlYy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBlbnRpdHkgKG9yIGEgY29udGludWF0aW9uIG9mIHRoZSBlbnRpdHkpLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIGN1cnJlbnQgb2Zmc2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IHdlcmUgY29uc3VtZWQsIG9yIC0xIGlmIHRoZSBlbnRpdHkgaXMgaW5jb21wbGV0ZS5cbiAgICAgKi9cbiAgICBzdGF0ZU5hbWVkRW50aXR5KHN0ciwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHsgZGVjb2RlVHJlZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBkZWNvZGVUcmVlW3RoaXMudHJlZUluZGV4XTtcbiAgICAgICAgLy8gVGhlIG1hc2sgaXMgdGhlIG51bWJlciBvZiBieXRlcyBvZiB0aGUgdmFsdWUsIGluY2x1ZGluZyB0aGUgY3VycmVudCBieXRlLlxuICAgICAgICBsZXQgdmFsdWVMZW5ndGggPSAoY3VycmVudCAmIEJpblRyaWVGbGFncy5WQUxVRV9MRU5HVEgpID4+IDE0O1xuICAgICAgICBmb3IgKDsgb2Zmc2V0IDwgc3RyLmxlbmd0aDsgb2Zmc2V0KyssIHRoaXMuZXhjZXNzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy50cmVlSW5kZXggPSBkZXRlcm1pbmVCcmFuY2goZGVjb2RlVHJlZSwgY3VycmVudCwgdGhpcy50cmVlSW5kZXggKyBNYXRoLm1heCgxLCB2YWx1ZUxlbmd0aCksIGNoYXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJlZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgcGFyc2luZyBhbiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb2RlTW9kZSA9PT0gRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkbid0IGhhdmUgY29uc3VtZWQgYW55IGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh2YWx1ZUxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCB0aGVyZSBzaG91bGQgYmUgbm8gaW52YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRW50aXR5SW5BdHRyaWJ1dGVJbnZhbGlkRW5kKGNoYXIpKSlcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5lbWl0Tm90VGVybWluYXRlZE5hbWVkRW50aXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gZGVjb2RlVHJlZVt0aGlzLnRyZWVJbmRleF07XG4gICAgICAgICAgICB2YWx1ZUxlbmd0aCA9IChjdXJyZW50ICYgQmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSCkgPj4gMTQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYnJhbmNoIGlzIGEgdmFsdWUsIHN0b3JlIGl0IGFuZCBjb250aW51ZVxuICAgICAgICAgICAgaWYgKHZhbHVlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVudGl0eSBpcyB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uLCB3ZSBhcmUgZG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gQ2hhckNvZGVzLlNFTUkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdE5hbWVkRW50aXR5RGF0YSh0aGlzLnRyZWVJbmRleCwgdmFsdWVMZW5ndGgsIHRoaXMuY29uc3VtZWQgKyB0aGlzLmV4Y2Vzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIG5vbi10ZXJtaW5hdGVkIChsZWdhY3kpIGVudGl0eSB3aGlsZSBwYXJzaW5nIHN0cmljdGx5LCB0aGVuIGlnbm9yZSBpdC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVNb2RlICE9PSBEZWNvZGluZ01vZGUuU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy50cmVlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZWQgKz0gdGhpcy5leGNlc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhjZXNzID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGEgbmFtZWQgZW50aXR5IHRoYXQgd2FzIG5vdCB0ZXJtaW5hdGVkIHdpdGggYSBzZW1pY29sb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29uc3VtZWQuXG4gICAgICovXG4gICAgZW1pdE5vdFRlcm1pbmF0ZWROYW1lZEVudGl0eSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHJlc3VsdCwgZGVjb2RlVHJlZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdmFsdWVMZW5ndGggPSAoZGVjb2RlVHJlZVtyZXN1bHRdICYgQmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSCkgPj4gMTQ7XG4gICAgICAgIHRoaXMuZW1pdE5hbWVkRW50aXR5RGF0YShyZXN1bHQsIHZhbHVlTGVuZ3RoLCB0aGlzLmNvbnN1bWVkKTtcbiAgICAgICAgKF9hID0gdGhpcy5lcnJvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5taXNzaW5nU2VtaWNvbG9uQWZ0ZXJDaGFyYWN0ZXJSZWZlcmVuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYSBuYW1lZCBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSBpbmRleCBvZiB0aGUgZW50aXR5IGluIHRoZSBkZWNvZGUgdHJlZS5cbiAgICAgKiBAcGFyYW0gdmFsdWVMZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgZW50aXR5LlxuICAgICAqIEBwYXJhbSBjb25zdW1lZCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29uc3VtZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29uc3VtZWQuXG4gICAgICovXG4gICAgZW1pdE5hbWVkRW50aXR5RGF0YShyZXN1bHQsIHZhbHVlTGVuZ3RoLCBjb25zdW1lZCkge1xuICAgICAgICBjb25zdCB7IGRlY29kZVRyZWUgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdENvZGVQb2ludCh2YWx1ZUxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBkZWNvZGVUcmVlW3Jlc3VsdF0gJiB+QmluVHJpZUZsYWdzLlZBTFVFX0xFTkdUSFxuICAgICAgICAgICAgOiBkZWNvZGVUcmVlW3Jlc3VsdCArIDFdLCBjb25zdW1lZCk7XG4gICAgICAgIGlmICh2YWx1ZUxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gRm9yIG11bHRpLWJ5dGUgdmFsdWVzLCB3ZSBuZWVkIHRvIGVtaXQgdGhlIHNlY29uZCBieXRlLlxuICAgICAgICAgICAgdGhpcy5lbWl0Q29kZVBvaW50KGRlY29kZVRyZWVbcmVzdWx0ICsgMl0sIGNvbnN1bWVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3VtZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCB0byB0aGUgcGFyc2VyIHRoYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgd2FzIHJlYWNoZWQuXG4gICAgICpcbiAgICAgKiBSZW1haW5pbmcgZGF0YSB3aWxsIGJlIGVtaXR0ZWQgYW5kIHJlbGV2YW50IGVycm9ycyB3aWxsIGJlIHByb2R1Y2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnN1bWVkLlxuICAgICAqL1xuICAgIGVuZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk5hbWVkRW50aXR5OiB7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCBhIG5hbWVkIGVudGl0eSBpZiB3ZSBoYXZlIG9uZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb2RlTW9kZSAhPT0gRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPT09IHRoaXMudHJlZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZW1pdE5vdFRlcm1pbmF0ZWROYW1lZEVudGl0eSgpXG4gICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZW1pdCBhIG51bWVyaWMgZW50aXR5IGlmIHdlIGhhdmUgb25lLlxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuTnVtZXJpY0RlY2ltYWw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eSgwLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNIZXg6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0TnVtZXJpY0VudGl0eSgwLCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRW50aXR5RGVjb2RlclN0YXRlLk51bWVyaWNTdGFydDoge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZXJyb3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWJzZW5jZU9mRGlnaXRzSW5OdW1lcmljQ2hhcmFjdGVyUmVmZXJlbmNlKHRoaXMuY29uc3VtZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFbnRpdHlEZWNvZGVyU3RhdGUuRW50aXR5U3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gMCBpZiB3ZSBoYXZlIG5vIGVudGl0eS5cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZGVjb2RlcyBlbnRpdGllcyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gZGVjb2RlVHJlZSBUaGUgZGVjb2RlIHRyZWUuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZGVjb2RlcyBlbnRpdGllcyBpbiBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVjb2RlcihkZWNvZGVUcmVlKSB7XG4gICAgbGV0IHJldCA9IFwiXCI7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBFbnRpdHlEZWNvZGVyKGRlY29kZVRyZWUsIChzdHIpID0+IChyZXQgKz0gZnJvbUNvZGVQb2ludChzdHIpKSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29kZVdpdGhUcmllKHN0ciwgZGVjb2RlTW9kZSkge1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlICgob2Zmc2V0ID0gc3RyLmluZGV4T2YoXCImXCIsIG9mZnNldCkpID49IDApIHtcbiAgICAgICAgICAgIHJldCArPSBzdHIuc2xpY2UobGFzdEluZGV4LCBvZmZzZXQpO1xuICAgICAgICAgICAgZGVjb2Rlci5zdGFydEVudGl0eShkZWNvZGVNb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGRlY29kZXIud3JpdGUoc3RyLCBcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIFwiJlwiXG4gICAgICAgICAgICBvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgIGlmIChsZW4gPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gb2Zmc2V0ICsgZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG9mZnNldCArIGxlbjtcbiAgICAgICAgICAgIC8vIElmIGBsZW5gIGlzIDAsIHNraXAgdGhlIGN1cnJlbnQgYCZgIGFuZCBjb250aW51ZS5cbiAgICAgICAgICAgIG9mZnNldCA9IGxlbiA9PT0gMCA/IGxhc3RJbmRleCArIDEgOiBsYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmV0ICsgc3RyLnNsaWNlKGxhc3RJbmRleCk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAgIHJldCA9IFwiXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYnJhbmNoIG9mIHRoZSBjdXJyZW50IG5vZGUgdGhhdCBpcyB0YWtlbiBnaXZlbiB0aGUgY3VycmVudFxuICogY2hhcmFjdGVyLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIHRyaWUuXG4gKlxuICogQHBhcmFtIGRlY29kZVRyZWUgVGhlIHRyaWUuXG4gKiBAcGFyYW0gY3VycmVudCBUaGUgY3VycmVudCBub2RlLlxuICogQHBhcmFtIG5vZGVJZHggVGhlIGluZGV4IHJpZ2h0IGFmdGVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGl0cyB2YWx1ZS5cbiAqIEBwYXJhbSBjaGFyIFRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgbmV4dCBub2RlLCBvciAtMSBpZiBubyBicmFuY2ggaXMgdGFrZW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVCcmFuY2goZGVjb2RlVHJlZSwgY3VycmVudCwgbm9kZUlkeCwgY2hhcikge1xuICAgIGNvbnN0IGJyYW5jaENvdW50ID0gKGN1cnJlbnQgJiBCaW5UcmllRmxhZ3MuQlJBTkNIX0xFTkdUSCkgPj4gNztcbiAgICBjb25zdCBqdW1wT2Zmc2V0ID0gY3VycmVudCAmIEJpblRyaWVGbGFncy5KVU1QX1RBQkxFO1xuICAgIC8vIENhc2UgMTogU2luZ2xlIGJyYW5jaCBlbmNvZGVkIGluIGp1bXAgb2Zmc2V0XG4gICAgaWYgKGJyYW5jaENvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBqdW1wT2Zmc2V0ICE9PSAwICYmIGNoYXIgPT09IGp1bXBPZmZzZXQgPyBub2RlSWR4IDogLTE7XG4gICAgfVxuICAgIC8vIENhc2UgMjogTXVsdGlwbGUgYnJhbmNoZXMgZW5jb2RlZCBpbiBqdW1wIHRhYmxlXG4gICAgaWYgKGp1bXBPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFyIC0ganVtcE9mZnNldDtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSBicmFuY2hDb3VudFxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiBkZWNvZGVUcmVlW25vZGVJZHggKyB2YWx1ZV0gLSAxO1xuICAgIH1cbiAgICAvLyBDYXNlIDM6IE11bHRpcGxlIGJyYW5jaGVzIGVuY29kZWQgaW4gZGljdGlvbmFyeVxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIHRoZSBjaGFyYWN0ZXIuXG4gICAgbGV0IGxvID0gbm9kZUlkeDtcbiAgICBsZXQgaGkgPSBsbyArIGJyYW5jaENvdW50IC0gMTtcbiAgICB3aGlsZSAobG8gPD0gaGkpIHtcbiAgICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgICBjb25zdCBtaWRWYWwgPSBkZWNvZGVUcmVlW21pZF07XG4gICAgICAgIGlmIChtaWRWYWwgPCBjaGFyKSB7XG4gICAgICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWlkVmFsID4gY2hhcikge1xuICAgICAgICAgICAgaGkgPSBtaWQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVRyZWVbbWlkICsgYnJhbmNoQ291bnRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmNvbnN0IGh0bWxEZWNvZGVyID0gZ2V0RGVjb2RlcihodG1sRGVjb2RlVHJlZSk7XG5jb25zdCB4bWxEZWNvZGVyID0gZ2V0RGVjb2Rlcih4bWxEZWNvZGVUcmVlKTtcbi8qKlxuICogRGVjb2RlcyBhbiBIVE1MIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIG1vZGUgVGhlIGRlY29kaW5nIG1vZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVIVE1MKHN0ciwgbW9kZSA9IERlY29kaW5nTW9kZS5MZWdhY3kpIHtcbiAgICByZXR1cm4gaHRtbERlY29kZXIoc3RyLCBtb2RlKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhbiBIVE1MIHN0cmluZyBpbiBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUhUTUxBdHRyaWJ1dGUoc3RyKSB7XG4gICAgcmV0dXJuIGh0bWxEZWNvZGVyKHN0ciwgRGVjb2RpbmdNb2RlLkF0dHJpYnV0ZSk7XG59XG4vKipcbiAqIERlY29kZXMgYW4gSFRNTCBzdHJpbmcsIHJlcXVpcmluZyBhbGwgZW50aXRpZXMgdG8gYmUgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBzdHJpbmcgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlSFRNTFN0cmljdChzdHIpIHtcbiAgICByZXR1cm4gaHRtbERlY29kZXIoc3RyLCBEZWNvZGluZ01vZGUuU3RyaWN0KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhbiBYTUwgc3RyaW5nLCByZXF1aXJpbmcgYWxsIGVudGl0aWVzIHRvIGJlIHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24uXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVhNTChzdHIpIHtcbiAgICByZXR1cm4geG1sRGVjb2RlcihzdHIsIERlY29kaW5nTW9kZS5TdHJpY3QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/decode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/decode_codepoint.js":
/*!***********************************************************!*\
  !*** ./node_modules/entities/lib/esm/decode_codepoint.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ decodeCodePoint; },\n/* harmony export */   fromCodePoint: function() { return /* binding */ fromCodePoint; },\n/* harmony export */   replaceCodePoint: function() { return /* binding */ replaceCodePoint; }\n/* harmony export */ });\n// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134\nvar _a;\nconst decodeMap = new Map([\n    [0, 65533],\n    // C1 Unicode control character reference replacements\n    [128, 8364],\n    [130, 8218],\n    [131, 402],\n    [132, 8222],\n    [133, 8230],\n    [134, 8224],\n    [135, 8225],\n    [136, 710],\n    [137, 8240],\n    [138, 352],\n    [139, 8249],\n    [140, 338],\n    [142, 381],\n    [145, 8216],\n    [146, 8217],\n    [147, 8220],\n    [148, 8221],\n    [149, 8226],\n    [150, 8211],\n    [151, 8212],\n    [152, 732],\n    [153, 8482],\n    [154, 353],\n    [155, 8250],\n    [156, 339],\n    [158, 382],\n    [159, 376],\n]);\n/**\n * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.\n */\nconst fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins\n(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {\n    let output = \"\";\n    if (codePoint > 0xffff) {\n        codePoint -= 0x10000;\n        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n        codePoint = 0xdc00 | (codePoint & 0x3ff);\n    }\n    output += String.fromCharCode(codePoint);\n    return output;\n};\n/**\n * Replace the given code point with a replacement character if it is a\n * surrogate or is outside the valid range. Otherwise return the code\n * point unchanged.\n */\nfunction replaceCodePoint(codePoint) {\n    var _a;\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return 0xfffd;\n    }\n    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;\n}\n/**\n * Replace the code point if relevant, then convert it to a string.\n *\n * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.\n * @param codePoint The code point to decode.\n * @returns The decoded code point.\n */\nfunction decodeCodePoint(codePoint) {\n    return fromCodePoint(replaceCodePoint(codePoint));\n}\n//# sourceMappingURL=decode_codepoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2RlY29kZV9jb2RlcG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2VzbS9kZWNvZGVfY29kZXBvaW50LmpzPzZkYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvMzZhZmUxNzkzOTIyMjZjZjFiNmNjZGIxNmViYmI3YTVhODQ0ZDkzYS9zcmMvaGUuanMjTDEwNi1MMTM0XG52YXIgX2E7XG5jb25zdCBkZWNvZGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbMCwgNjU1MzNdLFxuICAgIC8vIEMxIFVuaWNvZGUgY29udHJvbCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHJlcGxhY2VtZW50c1xuICAgIFsxMjgsIDgzNjRdLFxuICAgIFsxMzAsIDgyMThdLFxuICAgIFsxMzEsIDQwMl0sXG4gICAgWzEzMiwgODIyMl0sXG4gICAgWzEzMywgODIzMF0sXG4gICAgWzEzNCwgODIyNF0sXG4gICAgWzEzNSwgODIyNV0sXG4gICAgWzEzNiwgNzEwXSxcbiAgICBbMTM3LCA4MjQwXSxcbiAgICBbMTM4LCAzNTJdLFxuICAgIFsxMzksIDgyNDldLFxuICAgIFsxNDAsIDMzOF0sXG4gICAgWzE0MiwgMzgxXSxcbiAgICBbMTQ1LCA4MjE2XSxcbiAgICBbMTQ2LCA4MjE3XSxcbiAgICBbMTQ3LCA4MjIwXSxcbiAgICBbMTQ4LCA4MjIxXSxcbiAgICBbMTQ5LCA4MjI2XSxcbiAgICBbMTUwLCA4MjExXSxcbiAgICBbMTUxLCA4MjEyXSxcbiAgICBbMTUyLCA3MzJdLFxuICAgIFsxNTMsIDg0ODJdLFxuICAgIFsxNTQsIDM1M10sXG4gICAgWzE1NSwgODI1MF0sXG4gICAgWzE1NiwgMzM5XSxcbiAgICBbMTU4LCAzODJdLFxuICAgIFsxNTksIDM3Nl0sXG5dKTtcbi8qKlxuICogUG9seWZpbGwgZm9yIGBTdHJpbmcuZnJvbUNvZGVQb2ludGAuIEl0IGlzIHVzZWQgdG8gY3JlYXRlIGEgc3RyaW5nIGZyb20gYSBVbmljb2RlIGNvZGUgcG9pbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQ29kZVBvaW50ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9lcy1idWlsdGluc1xuKF9hID0gU3RyaW5nLmZyb21Db2RlUG9pbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmKSB7XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcbiAgICAgICAgY29kZVBvaW50ID0gMHhkYzAwIHwgKGNvZGVQb2ludCAmIDB4M2ZmKTtcbiAgICB9XG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogUmVwbGFjZSB0aGUgZ2l2ZW4gY29kZSBwb2ludCB3aXRoIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlmIGl0IGlzIGFcbiAqIHN1cnJvZ2F0ZSBvciBpcyBvdXRzaWRlIHRoZSB2YWxpZCByYW5nZS4gT3RoZXJ3aXNlIHJldHVybiB0aGUgY29kZVxuICogcG9pbnQgdW5jaGFuZ2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRmZmYpIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiAweGZmZmQ7XG4gICAgfVxuICAgIHJldHVybiAoX2EgPSBkZWNvZGVNYXAuZ2V0KGNvZGVQb2ludCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvZGVQb2ludDtcbn1cbi8qKlxuICogUmVwbGFjZSB0aGUgY29kZSBwb2ludCBpZiByZWxldmFudCwgdGhlbiBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgZnJvbUNvZGVQb2ludChyZXBsYWNlQ29kZVBvaW50KGNvZGVQb2ludCkpYCBpbnN0ZWFkLlxuICogQHBhcmFtIGNvZGVQb2ludCBUaGUgY29kZSBwb2ludCB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBjb2RlIHBvaW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQocmVwbGFjZUNvZGVQb2ludChjb2RlUG9pbnQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZV9jb2RlcG9pbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/decode_codepoint.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/encode.js":
/*!*************************************************!*\
  !*** ./node_modules/entities/lib/esm/encode.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeHTML: function() { return /* binding */ encodeHTML; },\n/* harmony export */   encodeNonAsciiHTML: function() { return /* binding */ encodeNonAsciiHTML; }\n/* harmony export */ });\n/* harmony import */ var _generated_encode_html_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generated/encode-html.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/generated/encode-html.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./escape.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/escape.js\");\n\n\nconst htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeHTML(data) {\n    return encodeHTMLTrieRe(htmlReplacer, data);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeNonAsciiHTML(data) {\n    return encodeHTMLTrieRe(_escape_js__WEBPACK_IMPORTED_MODULE_1__.xmlReplacer, data);\n}\nfunction encodeHTMLTrieRe(regExp, str) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let match;\n    while ((match = regExp.exec(str)) !== null) {\n        const i = match.index;\n        ret += str.substring(lastIdx, i);\n        const char = str.charCodeAt(i);\n        let next = _generated_encode_html_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(char);\n        if (typeof next === \"object\") {\n            // We are in a branch. Try to match the next char.\n            if (i + 1 < str.length) {\n                const nextChar = str.charCodeAt(i + 1);\n                const value = typeof next.n === \"number\"\n                    ? next.n === nextChar\n                        ? next.o\n                        : undefined\n                    : next.n.get(nextChar);\n                if (value !== undefined) {\n                    ret += value;\n                    lastIdx = regExp.lastIndex += 1;\n                    continue;\n                }\n            }\n            next = next.v;\n        }\n        // We might have a tree node without a value; skip and use a numeric entity.\n        if (next !== undefined) {\n            ret += next;\n            lastIdx = i + 1;\n        }\n        else {\n            const cp = (0,_escape_js__WEBPACK_IMPORTED_MODULE_1__.getCodePoint)(str, i);\n            ret += `&#x${cp.toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = regExp.lastIndex += Number(cp !== char);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n//# sourceMappingURL=encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2VuY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtEO0FBQ007QUFDeEQseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ087QUFDUCw0QkFBNEIsbURBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlFQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQyx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2VuY29kZS5qcz84MjBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodG1sVHJpZSBmcm9tIFwiLi9nZW5lcmF0ZWQvZW5jb2RlLWh0bWwuanNcIjtcbmltcG9ydCB7IHhtbFJlcGxhY2VyLCBnZXRDb2RlUG9pbnQgfSBmcm9tIFwiLi9lc2NhcGUuanNcIjtcbmNvbnN0IGh0bWxSZXBsYWNlciA9IC9bXFx0XFxuIS0sLi86LUBbLWBcXGZ7LX0kXFx4ODAtXFx1RkZGRl0vZztcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdXNpbmcgSFRNTCBlbnRpdGllcy4gVGhpcyBpbmNsdWRlc1xuICogY2hhcmFjdGVycyB0aGF0IGFyZSB2YWxpZCBBU0NJSSBjaGFyYWN0ZXJzIGluIEhUTUwgZG9jdW1lbnRzLCBzdWNoIGFzIGAjYC5cbiAqXG4gKiBUbyBnZXQgYSBtb3JlIGNvbXBhY3Qgb3V0cHV0LCBjb25zaWRlciB1c2luZyB0aGUgYGVuY29kZU5vbkFzY2lpSFRNTGBcbiAqIGZ1bmN0aW9uLCB3aGljaCB3aWxsIG9ubHkgZW5jb2RlIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IHZhbGlkIGluIEhUTUxcbiAqIGRvY3VtZW50cywgYXMgd2VsbCBhcyBub24tQVNDSUkgY2hhcmFjdGVycy5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGEgbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2VcbiAqIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUhUTUwoZGF0YSkge1xuICAgIHJldHVybiBlbmNvZGVIVE1MVHJpZVJlKGh0bWxSZXBsYWNlciwgZGF0YSk7XG59XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIEhUTUxcbiAqIGRvY3VtZW50cyB1c2luZyBIVE1MIGVudGl0aWVzLiBUaGlzIGZ1bmN0aW9uIHdpbGwgbm90IGVuY29kZSBjaGFyYWN0ZXJzIHRoYXRcbiAqIGFyZSB2YWxpZCBpbiBIVE1MIGRvY3VtZW50cywgc3VjaCBhcyBgI2AuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlXG4gKiAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVOb25Bc2NpaUhUTUwoZGF0YSkge1xuICAgIHJldHVybiBlbmNvZGVIVE1MVHJpZVJlKHhtbFJlcGxhY2VyLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUhUTUxUcmllUmUocmVnRXhwLCBzdHIpIHtcbiAgICBsZXQgcmV0ID0gXCJcIjtcbiAgICBsZXQgbGFzdElkeCA9IDA7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBpID0gbWF0Y2guaW5kZXg7XG4gICAgICAgIHJldCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJZHgsIGkpO1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGxldCBuZXh0ID0gaHRtbFRyaWUuZ2V0KGNoYXIpO1xuICAgICAgICBpZiAodHlwZW9mIG5leHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBpbiBhIGJyYW5jaC4gVHJ5IHRvIG1hdGNoIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgICBpZiAoaSArIDEgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgbmV4dC5uID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgID8gbmV4dC5uID09PSBuZXh0Q2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0Lm9cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogbmV4dC5uLmdldChuZXh0Q2hhcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsYXN0SWR4ID0gcmVnRXhwLmxhc3RJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC52O1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgYSB0cmVlIG5vZGUgd2l0aG91dCBhIHZhbHVlOyBza2lwIGFuZCB1c2UgYSBudW1lcmljIGVudGl0eS5cbiAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0ICs9IG5leHQ7XG4gICAgICAgICAgICBsYXN0SWR4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjcCA9IGdldENvZGVQb2ludChzdHIsIGkpO1xuICAgICAgICAgICAgcmV0ICs9IGAmI3gke2NwLnRvU3RyaW5nKDE2KX07YDtcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGJ5IDEgaWYgd2UgaGF2ZSBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICBsYXN0SWR4ID0gcmVnRXhwLmxhc3RJbmRleCArPSBOdW1iZXIoY3AgIT09IGNoYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQgKyBzdHIuc3Vic3RyKGxhc3RJZHgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/encode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/escape.js":
/*!*************************************************!*\
  !*** ./node_modules/entities/lib/esm/escape.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeXML: function() { return /* binding */ encodeXML; },\n/* harmony export */   escape: function() { return /* binding */ escape; },\n/* harmony export */   escapeAttribute: function() { return /* binding */ escapeAttribute; },\n/* harmony export */   escapeText: function() { return /* binding */ escapeText; },\n/* harmony export */   escapeUTF8: function() { return /* binding */ escapeUTF8; },\n/* harmony export */   getCodePoint: function() { return /* binding */ getCodePoint; },\n/* harmony export */   xmlReplacer: function() { return /* binding */ xmlReplacer; }\n/* harmony export */ });\nconst xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nconst xmlCodeMap = new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [39, \"&apos;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n]);\n// For compatibility with node < 4, we wrap `codePointAt`\nconst getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? (str, index) => str.codePointAt(index)\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800\n            ? (c.charCodeAt(index) - 0xd800) * 0x400 +\n                c.charCodeAt(index + 1) -\n                0xdc00 +\n                0x10000\n            : c.charCodeAt(index);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nfunction encodeXML(str) {\n    let ret = \"\";\n    let lastIdx = 0;\n    let match;\n    while ((match = xmlReplacer.exec(str)) !== null) {\n        const i = match.index;\n        const char = str.charCodeAt(i);\n        const next = xmlCodeMap.get(char);\n        if (next !== undefined) {\n            ret += str.substring(lastIdx, i) + next;\n            lastIdx = i + 1;\n        }\n        else {\n            ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nconst escape = encodeXML;\n/**\n * Creates a function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n *\n * @param regex Regular expression to match characters to escape.\n * @param map Map of characters to escape to their entities.\n *\n * @returns Function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n */\nfunction getEscaper(regex, map) {\n    return function escape(data) {\n        let match;\n        let lastIdx = 0;\n        let result = \"\";\n        while ((match = regex.exec(data))) {\n            if (lastIdx !== match.index) {\n                result += data.substring(lastIdx, match.index);\n            }\n            // We know that this character will be in the map.\n            result += map.get(match[0].charCodeAt(0));\n            // Every match will be of length 1\n            lastIdx = match.index + 1;\n        }\n        return result + data.substring(lastIdx);\n    };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nconst escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nconst escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [160, \"&nbsp;\"],\n]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nconst escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([\n    [38, \"&amp;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n    [160, \"&nbsp;\"],\n]));\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2VzY2FwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxjQUFjO0FBQ2Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCLEtBQUssbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGNBQWMseUVBQXlFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5RUFBeUU7QUFDdkY7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2VzbS9lc2NhcGUuanM/MWY0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgeG1sUmVwbGFjZXIgPSAvW1wiJic8PiRcXHg4MC1cXHVGRkZGXS9nO1xuY29uc3QgeG1sQ29kZU1hcCA9IG5ldyBNYXAoW1xuICAgIFszNCwgXCImcXVvdDtcIl0sXG4gICAgWzM4LCBcIiZhbXA7XCJdLFxuICAgIFszOSwgXCImYXBvcztcIl0sXG4gICAgWzYwLCBcIiZsdDtcIl0sXG4gICAgWzYyLCBcIiZndDtcIl0sXG5dKTtcbi8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9kZSA8IDQsIHdlIHdyYXAgYGNvZGVQb2ludEF0YFxuZXhwb3J0IGNvbnN0IGdldENvZGVQb2ludCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQgIT0gbnVsbFxuICAgID8gKHN0ciwgaW5kZXgpID0+IHN0ci5jb2RlUG9pbnRBdChpbmRleClcbiAgICA6IC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIChjLCBpbmRleCkgPT4gKGMuY2hhckNvZGVBdChpbmRleCkgJiAweGZjMDApID09PSAweGQ4MDBcbiAgICAgICAgICAgID8gKGMuY2hhckNvZGVBdChpbmRleCkgLSAweGQ4MDApICogMHg0MDAgK1xuICAgICAgICAgICAgICAgIGMuY2hhckNvZGVBdChpbmRleCArIDEpIC1cbiAgICAgICAgICAgICAgICAweGRjMDAgK1xuICAgICAgICAgICAgICAgIDB4MTAwMDBcbiAgICAgICAgICAgIDogYy5jaGFyQ29kZUF0KGluZGV4KTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlWE1MKHN0cikge1xuICAgIGxldCByZXQgPSBcIlwiO1xuICAgIGxldCBsYXN0SWR4ID0gMDtcbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHhtbFJlcGxhY2VyLmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaSA9IG1hdGNoLmluZGV4O1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNvbnN0IG5leHQgPSB4bWxDb2RlTWFwLmdldChjaGFyKTtcbiAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0ICs9IHN0ci5zdWJzdHJpbmcobGFzdElkeCwgaSkgKyBuZXh0O1xuICAgICAgICAgICAgbGFzdElkeCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGAke3N0ci5zdWJzdHJpbmcobGFzdElkeCwgaSl9JiN4JHtnZXRDb2RlUG9pbnQoc3RyLCBpKS50b1N0cmluZygxNil9O2A7XG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBieSAxIGlmIHdlIGhhdmUgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgbGFzdElkeCA9IHhtbFJlcGxhY2VyLmxhc3RJbmRleCArPSBOdW1iZXIoKGNoYXIgJiAweGZjMDApID09PSAweGQ4MDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQgKyBzdHIuc3Vic3RyKGxhc3RJZHgpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCBgZXNjYXBlVVRGOGAgaWYgeW91IHdhbnQgYSBtb3JlIGNvbmNpc2Ugb3V0cHV0IGF0IHRoZSBleHBlbnNlXG4gKiBvZiByZWR1Y2VkIHRyYW5zcG9ydGFiaWxpdHkuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZSA9IGVuY29kZVhNTDtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZXNjYXBlcyBhbGwgY2hhcmFjdGVycyBtYXRjaGVkIGJ5IHRoZSBnaXZlbiByZWd1bGFyXG4gKiBleHByZXNzaW9uIHVzaW5nIHRoZSBnaXZlbiBtYXAgb2YgY2hhcmFjdGVycyB0byBlc2NhcGUgdG8gdGhlaXIgZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIHJlZ2V4IFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBjaGFyYWN0ZXJzIHRvIGVzY2FwZS5cbiAqIEBwYXJhbSBtYXAgTWFwIG9mIGNoYXJhY3RlcnMgdG8gZXNjYXBlIHRvIHRoZWlyIGVudGl0aWVzLlxuICpcbiAqIEByZXR1cm5zIEZ1bmN0aW9uIHRoYXQgZXNjYXBlcyBhbGwgY2hhcmFjdGVycyBtYXRjaGVkIGJ5IHRoZSBnaXZlbiByZWd1bGFyXG4gKiBleHByZXNzaW9uIHVzaW5nIHRoZSBnaXZlbiBtYXAgb2YgY2hhcmFjdGVycyB0byBlc2NhcGUgdG8gdGhlaXIgZW50aXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEVzY2FwZXIocmVnZXgsIG1hcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBlc2NhcGUoZGF0YSkge1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBsYXN0SWR4ID0gMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGRhdGEpKSkge1xuICAgICAgICAgICAgaWYgKGxhc3RJZHggIT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGRhdGEuc3Vic3RyaW5nKGxhc3RJZHgsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCB0aGlzIGNoYXJhY3RlciB3aWxsIGJlIGluIHRoZSBtYXAuXG4gICAgICAgICAgICByZXN1bHQgKz0gbWFwLmdldChtYXRjaFswXS5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICAgIC8vIEV2ZXJ5IG1hdGNoIHdpbGwgYmUgb2YgbGVuZ3RoIDFcbiAgICAgICAgICAgIGxhc3RJZHggPSBtYXRjaC5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIGRhdGEuc3Vic3RyaW5nKGxhc3RJZHgpO1xuICAgIH07XG59XG4vKipcbiAqIEVuY29kZXMgYWxsIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTCBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb3V0cHV0IHdpbGwgYmUgY2hhcmFjdGVyLXNldCBkZXBlbmRlbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZVVURjggPSBnZXRFc2NhcGVyKC9bJjw+J1wiXS9nLCB4bWxDb2RlTWFwKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZCBpbiBIVE1MIGF0dHJpYnV0ZXMsXG4gKiBmb2xsb3dpbmcge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlc2NhcGluZ1N0cmluZ30uXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZUF0dHJpYnV0ZSA9IGdldEVzY2FwZXIoL1tcIiZcXHUwMEEwXS9nLCBuZXcgTWFwKFtcbiAgICBbMzQsIFwiJnF1b3Q7XCJdLFxuICAgIFszOCwgXCImYW1wO1wiXSxcbiAgICBbMTYwLCBcIiZuYnNwO1wiXSxcbl0pKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZCBpbiBIVE1MIHRleHQsXG4gKiBmb2xsb3dpbmcge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlc2NhcGluZ1N0cmluZ30uXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVzY2FwZVRleHQgPSBnZXRFc2NhcGVyKC9bJjw+XFx1MDBBMF0vZywgbmV3IE1hcChbXG4gICAgWzM4LCBcIiZhbXA7XCJdLFxuICAgIFs2MCwgXCImbHQ7XCJdLFxuICAgIFs2MiwgXCImZ3Q7XCJdLFxuICAgIFsxNjAsIFwiJm5ic3A7XCJdLFxuXSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/escape.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-html.js":
/*!*********************************************************************!*\
  !*** ./node_modules/entities/lib/esm/generated/decode-data-html.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Generated using scripts/write-decode-map.ts\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Uint16Array(\n// prettier-ignore\n\"\\u1d41<\\xd5\\u0131\\u028a\\u049d\\u057b\\u05d0\\u0675\\u06de\\u07a2\\u07d6\\u080f\\u0a4a\\u0a91\\u0da1\\u0e6d\\u0f09\\u0f26\\u10ca\\u1228\\u12e1\\u1415\\u149d\\u14c3\\u14df\\u1525\\0\\0\\0\\0\\0\\0\\u156b\\u16cd\\u198d\\u1c12\\u1ddd\\u1f7e\\u2060\\u21b0\\u228d\\u23c0\\u23fb\\u2442\\u2824\\u2912\\u2d08\\u2e48\\u2fce\\u3016\\u32ba\\u3639\\u37ac\\u38fe\\u3a28\\u3a71\\u3ae0\\u3b2e\\u0800EMabcfglmnoprstu\\\\bfms\\x7f\\x84\\x8b\\x90\\x95\\x98\\xa6\\xb3\\xb9\\xc8\\xcflig\\u803b\\xc6\\u40c6P\\u803b&\\u4026cute\\u803b\\xc1\\u40c1reve;\\u4102\\u0100iyx}rc\\u803b\\xc2\\u40c2;\\u4410r;\\uc000\\ud835\\udd04rave\\u803b\\xc0\\u40c0pha;\\u4391acr;\\u4100d;\\u6a53\\u0100gp\\x9d\\xa1on;\\u4104f;\\uc000\\ud835\\udd38plyFunction;\\u6061ing\\u803b\\xc5\\u40c5\\u0100cs\\xbe\\xc3r;\\uc000\\ud835\\udc9cign;\\u6254ilde\\u803b\\xc3\\u40c3ml\\u803b\\xc4\\u40c4\\u0400aceforsu\\xe5\\xfb\\xfe\\u0117\\u011c\\u0122\\u0127\\u012a\\u0100cr\\xea\\xf2kslash;\\u6216\\u0176\\xf6\\xf8;\\u6ae7ed;\\u6306y;\\u4411\\u0180crt\\u0105\\u010b\\u0114ause;\\u6235noullis;\\u612ca;\\u4392r;\\uc000\\ud835\\udd05pf;\\uc000\\ud835\\udd39eve;\\u42d8c\\xf2\\u0113mpeq;\\u624e\\u0700HOacdefhilorsu\\u014d\\u0151\\u0156\\u0180\\u019e\\u01a2\\u01b5\\u01b7\\u01ba\\u01dc\\u0215\\u0273\\u0278\\u027ecy;\\u4427PY\\u803b\\xa9\\u40a9\\u0180cpy\\u015d\\u0162\\u017aute;\\u4106\\u0100;i\\u0167\\u0168\\u62d2talDifferentialD;\\u6145leys;\\u612d\\u0200aeio\\u0189\\u018e\\u0194\\u0198ron;\\u410cdil\\u803b\\xc7\\u40c7rc;\\u4108nint;\\u6230ot;\\u410a\\u0100dn\\u01a7\\u01adilla;\\u40b8terDot;\\u40b7\\xf2\\u017fi;\\u43a7rcle\\u0200DMPT\\u01c7\\u01cb\\u01d1\\u01d6ot;\\u6299inus;\\u6296lus;\\u6295imes;\\u6297o\\u0100cs\\u01e2\\u01f8kwiseContourIntegral;\\u6232eCurly\\u0100DQ\\u0203\\u020foubleQuote;\\u601duote;\\u6019\\u0200lnpu\\u021e\\u0228\\u0247\\u0255on\\u0100;e\\u0225\\u0226\\u6237;\\u6a74\\u0180git\\u022f\\u0236\\u023aruent;\\u6261nt;\\u622fourIntegral;\\u622e\\u0100fr\\u024c\\u024e;\\u6102oduct;\\u6210nterClockwiseContourIntegral;\\u6233oss;\\u6a2fcr;\\uc000\\ud835\\udc9ep\\u0100;C\\u0284\\u0285\\u62d3ap;\\u624d\\u0580DJSZacefios\\u02a0\\u02ac\\u02b0\\u02b4\\u02b8\\u02cb\\u02d7\\u02e1\\u02e6\\u0333\\u048d\\u0100;o\\u0179\\u02a5trahd;\\u6911cy;\\u4402cy;\\u4405cy;\\u440f\\u0180grs\\u02bf\\u02c4\\u02c7ger;\\u6021r;\\u61a1hv;\\u6ae4\\u0100ay\\u02d0\\u02d5ron;\\u410e;\\u4414l\\u0100;t\\u02dd\\u02de\\u6207a;\\u4394r;\\uc000\\ud835\\udd07\\u0100af\\u02eb\\u0327\\u0100cm\\u02f0\\u0322ritical\\u0200ADGT\\u0300\\u0306\\u0316\\u031ccute;\\u40b4o\\u0174\\u030b\\u030d;\\u42d9bleAcute;\\u42ddrave;\\u4060ilde;\\u42dcond;\\u62c4ferentialD;\\u6146\\u0470\\u033d\\0\\0\\0\\u0342\\u0354\\0\\u0405f;\\uc000\\ud835\\udd3b\\u0180;DE\\u0348\\u0349\\u034d\\u40a8ot;\\u60dcqual;\\u6250ble\\u0300CDLRUV\\u0363\\u0372\\u0382\\u03cf\\u03e2\\u03f8ontourIntegra\\xec\\u0239o\\u0274\\u0379\\0\\0\\u037b\\xbb\\u0349nArrow;\\u61d3\\u0100eo\\u0387\\u03a4ft\\u0180ART\\u0390\\u0396\\u03a1rrow;\\u61d0ightArrow;\\u61d4e\\xe5\\u02cang\\u0100LR\\u03ab\\u03c4eft\\u0100AR\\u03b3\\u03b9rrow;\\u67f8ightArrow;\\u67faightArrow;\\u67f9ight\\u0100AT\\u03d8\\u03derrow;\\u61d2ee;\\u62a8p\\u0241\\u03e9\\0\\0\\u03efrrow;\\u61d1ownArrow;\\u61d5erticalBar;\\u6225n\\u0300ABLRTa\\u0412\\u042a\\u0430\\u045e\\u047f\\u037crrow\\u0180;BU\\u041d\\u041e\\u0422\\u6193ar;\\u6913pArrow;\\u61f5reve;\\u4311eft\\u02d2\\u043a\\0\\u0446\\0\\u0450ightVector;\\u6950eeVector;\\u695eector\\u0100;B\\u0459\\u045a\\u61bdar;\\u6956ight\\u01d4\\u0467\\0\\u0471eeVector;\\u695fector\\u0100;B\\u047a\\u047b\\u61c1ar;\\u6957ee\\u0100;A\\u0486\\u0487\\u62a4rrow;\\u61a7\\u0100ct\\u0492\\u0497r;\\uc000\\ud835\\udc9frok;\\u4110\\u0800NTacdfglmopqstux\\u04bd\\u04c0\\u04c4\\u04cb\\u04de\\u04e2\\u04e7\\u04ee\\u04f5\\u0521\\u052f\\u0536\\u0552\\u055d\\u0560\\u0565G;\\u414aH\\u803b\\xd0\\u40d0cute\\u803b\\xc9\\u40c9\\u0180aiy\\u04d2\\u04d7\\u04dcron;\\u411arc\\u803b\\xca\\u40ca;\\u442dot;\\u4116r;\\uc000\\ud835\\udd08rave\\u803b\\xc8\\u40c8ement;\\u6208\\u0100ap\\u04fa\\u04fecr;\\u4112ty\\u0253\\u0506\\0\\0\\u0512mallSquare;\\u65fberySmallSquare;\\u65ab\\u0100gp\\u0526\\u052aon;\\u4118f;\\uc000\\ud835\\udd3csilon;\\u4395u\\u0100ai\\u053c\\u0549l\\u0100;T\\u0542\\u0543\\u6a75ilde;\\u6242librium;\\u61cc\\u0100ci\\u0557\\u055ar;\\u6130m;\\u6a73a;\\u4397ml\\u803b\\xcb\\u40cb\\u0100ip\\u056a\\u056fsts;\\u6203onentialE;\\u6147\\u0280cfios\\u0585\\u0588\\u058d\\u05b2\\u05ccy;\\u4424r;\\uc000\\ud835\\udd09lled\\u0253\\u0597\\0\\0\\u05a3mallSquare;\\u65fcerySmallSquare;\\u65aa\\u0370\\u05ba\\0\\u05bf\\0\\0\\u05c4f;\\uc000\\ud835\\udd3dAll;\\u6200riertrf;\\u6131c\\xf2\\u05cb\\u0600JTabcdfgorst\\u05e8\\u05ec\\u05ef\\u05fa\\u0600\\u0612\\u0616\\u061b\\u061d\\u0623\\u066c\\u0672cy;\\u4403\\u803b>\\u403emma\\u0100;d\\u05f7\\u05f8\\u4393;\\u43dcreve;\\u411e\\u0180eiy\\u0607\\u060c\\u0610dil;\\u4122rc;\\u411c;\\u4413ot;\\u4120r;\\uc000\\ud835\\udd0a;\\u62d9pf;\\uc000\\ud835\\udd3eeater\\u0300EFGLST\\u0635\\u0644\\u064e\\u0656\\u065b\\u0666qual\\u0100;L\\u063e\\u063f\\u6265ess;\\u62dbullEqual;\\u6267reater;\\u6aa2ess;\\u6277lantEqual;\\u6a7eilde;\\u6273cr;\\uc000\\ud835\\udca2;\\u626b\\u0400Aacfiosu\\u0685\\u068b\\u0696\\u069b\\u069e\\u06aa\\u06be\\u06caRDcy;\\u442a\\u0100ct\\u0690\\u0694ek;\\u42c7;\\u405eirc;\\u4124r;\\u610clbertSpace;\\u610b\\u01f0\\u06af\\0\\u06b2f;\\u610dizontalLine;\\u6500\\u0100ct\\u06c3\\u06c5\\xf2\\u06a9rok;\\u4126mp\\u0144\\u06d0\\u06d8ownHum\\xf0\\u012fqual;\\u624f\\u0700EJOacdfgmnostu\\u06fa\\u06fe\\u0703\\u0707\\u070e\\u071a\\u071e\\u0721\\u0728\\u0744\\u0778\\u078b\\u078f\\u0795cy;\\u4415lig;\\u4132cy;\\u4401cute\\u803b\\xcd\\u40cd\\u0100iy\\u0713\\u0718rc\\u803b\\xce\\u40ce;\\u4418ot;\\u4130r;\\u6111rave\\u803b\\xcc\\u40cc\\u0180;ap\\u0720\\u072f\\u073f\\u0100cg\\u0734\\u0737r;\\u412ainaryI;\\u6148lie\\xf3\\u03dd\\u01f4\\u0749\\0\\u0762\\u0100;e\\u074d\\u074e\\u622c\\u0100gr\\u0753\\u0758ral;\\u622bsection;\\u62c2isible\\u0100CT\\u076c\\u0772omma;\\u6063imes;\\u6062\\u0180gpt\\u077f\\u0783\\u0788on;\\u412ef;\\uc000\\ud835\\udd40a;\\u4399cr;\\u6110ilde;\\u4128\\u01eb\\u079a\\0\\u079ecy;\\u4406l\\u803b\\xcf\\u40cf\\u0280cfosu\\u07ac\\u07b7\\u07bc\\u07c2\\u07d0\\u0100iy\\u07b1\\u07b5rc;\\u4134;\\u4419r;\\uc000\\ud835\\udd0dpf;\\uc000\\ud835\\udd41\\u01e3\\u07c7\\0\\u07ccr;\\uc000\\ud835\\udca5rcy;\\u4408kcy;\\u4404\\u0380HJacfos\\u07e4\\u07e8\\u07ec\\u07f1\\u07fd\\u0802\\u0808cy;\\u4425cy;\\u440cppa;\\u439a\\u0100ey\\u07f6\\u07fbdil;\\u4136;\\u441ar;\\uc000\\ud835\\udd0epf;\\uc000\\ud835\\udd42cr;\\uc000\\ud835\\udca6\\u0580JTaceflmost\\u0825\\u0829\\u082c\\u0850\\u0863\\u09b3\\u09b8\\u09c7\\u09cd\\u0a37\\u0a47cy;\\u4409\\u803b<\\u403c\\u0280cmnpr\\u0837\\u083c\\u0841\\u0844\\u084dute;\\u4139bda;\\u439bg;\\u67ealacetrf;\\u6112r;\\u619e\\u0180aey\\u0857\\u085c\\u0861ron;\\u413ddil;\\u413b;\\u441b\\u0100fs\\u0868\\u0970t\\u0500ACDFRTUVar\\u087e\\u08a9\\u08b1\\u08e0\\u08e6\\u08fc\\u092f\\u095b\\u0390\\u096a\\u0100nr\\u0883\\u088fgleBracket;\\u67e8row\\u0180;BR\\u0899\\u089a\\u089e\\u6190ar;\\u61e4ightArrow;\\u61c6eiling;\\u6308o\\u01f5\\u08b7\\0\\u08c3bleBracket;\\u67e6n\\u01d4\\u08c8\\0\\u08d2eeVector;\\u6961ector\\u0100;B\\u08db\\u08dc\\u61c3ar;\\u6959loor;\\u630aight\\u0100AV\\u08ef\\u08f5rrow;\\u6194ector;\\u694e\\u0100er\\u0901\\u0917e\\u0180;AV\\u0909\\u090a\\u0910\\u62a3rrow;\\u61a4ector;\\u695aiangle\\u0180;BE\\u0924\\u0925\\u0929\\u62b2ar;\\u69cfqual;\\u62b4p\\u0180DTV\\u0937\\u0942\\u094cownVector;\\u6951eeVector;\\u6960ector\\u0100;B\\u0956\\u0957\\u61bfar;\\u6958ector\\u0100;B\\u0965\\u0966\\u61bcar;\\u6952ight\\xe1\\u039cs\\u0300EFGLST\\u097e\\u098b\\u0995\\u099d\\u09a2\\u09adqualGreater;\\u62daullEqual;\\u6266reater;\\u6276ess;\\u6aa1lantEqual;\\u6a7dilde;\\u6272r;\\uc000\\ud835\\udd0f\\u0100;e\\u09bd\\u09be\\u62d8ftarrow;\\u61daidot;\\u413f\\u0180npw\\u09d4\\u0a16\\u0a1bg\\u0200LRlr\\u09de\\u09f7\\u0a02\\u0a10eft\\u0100AR\\u09e6\\u09ecrrow;\\u67f5ightArrow;\\u67f7ightArrow;\\u67f6eft\\u0100ar\\u03b3\\u0a0aight\\xe1\\u03bfight\\xe1\\u03caf;\\uc000\\ud835\\udd43er\\u0100LR\\u0a22\\u0a2ceftArrow;\\u6199ightArrow;\\u6198\\u0180cht\\u0a3e\\u0a40\\u0a42\\xf2\\u084c;\\u61b0rok;\\u4141;\\u626a\\u0400acefiosu\\u0a5a\\u0a5d\\u0a60\\u0a77\\u0a7c\\u0a85\\u0a8b\\u0a8ep;\\u6905y;\\u441c\\u0100dl\\u0a65\\u0a6fiumSpace;\\u605flintrf;\\u6133r;\\uc000\\ud835\\udd10nusPlus;\\u6213pf;\\uc000\\ud835\\udd44c\\xf2\\u0a76;\\u439c\\u0480Jacefostu\\u0aa3\\u0aa7\\u0aad\\u0ac0\\u0b14\\u0b19\\u0d91\\u0d97\\u0d9ecy;\\u440acute;\\u4143\\u0180aey\\u0ab4\\u0ab9\\u0aberon;\\u4147dil;\\u4145;\\u441d\\u0180gsw\\u0ac7\\u0af0\\u0b0eative\\u0180MTV\\u0ad3\\u0adf\\u0ae8ediumSpace;\\u600bhi\\u0100cn\\u0ae6\\u0ad8\\xeb\\u0ad9eryThi\\xee\\u0ad9ted\\u0100GL\\u0af8\\u0b06reaterGreate\\xf2\\u0673essLes\\xf3\\u0a48Line;\\u400ar;\\uc000\\ud835\\udd11\\u0200Bnpt\\u0b22\\u0b28\\u0b37\\u0b3areak;\\u6060BreakingSpace;\\u40a0f;\\u6115\\u0680;CDEGHLNPRSTV\\u0b55\\u0b56\\u0b6a\\u0b7c\\u0ba1\\u0beb\\u0c04\\u0c5e\\u0c84\\u0ca6\\u0cd8\\u0d61\\u0d85\\u6aec\\u0100ou\\u0b5b\\u0b64ngruent;\\u6262pCap;\\u626doubleVerticalBar;\\u6226\\u0180lqx\\u0b83\\u0b8a\\u0b9bement;\\u6209ual\\u0100;T\\u0b92\\u0b93\\u6260ilde;\\uc000\\u2242\\u0338ists;\\u6204reater\\u0380;EFGLST\\u0bb6\\u0bb7\\u0bbd\\u0bc9\\u0bd3\\u0bd8\\u0be5\\u626fqual;\\u6271ullEqual;\\uc000\\u2267\\u0338reater;\\uc000\\u226b\\u0338ess;\\u6279lantEqual;\\uc000\\u2a7e\\u0338ilde;\\u6275ump\\u0144\\u0bf2\\u0bfdownHump;\\uc000\\u224e\\u0338qual;\\uc000\\u224f\\u0338e\\u0100fs\\u0c0a\\u0c27tTriangle\\u0180;BE\\u0c1a\\u0c1b\\u0c21\\u62eaar;\\uc000\\u29cf\\u0338qual;\\u62ecs\\u0300;EGLST\\u0c35\\u0c36\\u0c3c\\u0c44\\u0c4b\\u0c58\\u626equal;\\u6270reater;\\u6278ess;\\uc000\\u226a\\u0338lantEqual;\\uc000\\u2a7d\\u0338ilde;\\u6274ested\\u0100GL\\u0c68\\u0c79reaterGreater;\\uc000\\u2aa2\\u0338essLess;\\uc000\\u2aa1\\u0338recedes\\u0180;ES\\u0c92\\u0c93\\u0c9b\\u6280qual;\\uc000\\u2aaf\\u0338lantEqual;\\u62e0\\u0100ei\\u0cab\\u0cb9verseElement;\\u620cghtTriangle\\u0180;BE\\u0ccb\\u0ccc\\u0cd2\\u62ebar;\\uc000\\u29d0\\u0338qual;\\u62ed\\u0100qu\\u0cdd\\u0d0cuareSu\\u0100bp\\u0ce8\\u0cf9set\\u0100;E\\u0cf0\\u0cf3\\uc000\\u228f\\u0338qual;\\u62e2erset\\u0100;E\\u0d03\\u0d06\\uc000\\u2290\\u0338qual;\\u62e3\\u0180bcp\\u0d13\\u0d24\\u0d4eset\\u0100;E\\u0d1b\\u0d1e\\uc000\\u2282\\u20d2qual;\\u6288ceeds\\u0200;EST\\u0d32\\u0d33\\u0d3b\\u0d46\\u6281qual;\\uc000\\u2ab0\\u0338lantEqual;\\u62e1ilde;\\uc000\\u227f\\u0338erset\\u0100;E\\u0d58\\u0d5b\\uc000\\u2283\\u20d2qual;\\u6289ilde\\u0200;EFT\\u0d6e\\u0d6f\\u0d75\\u0d7f\\u6241qual;\\u6244ullEqual;\\u6247ilde;\\u6249erticalBar;\\u6224cr;\\uc000\\ud835\\udca9ilde\\u803b\\xd1\\u40d1;\\u439d\\u0700Eacdfgmoprstuv\\u0dbd\\u0dc2\\u0dc9\\u0dd5\\u0ddb\\u0de0\\u0de7\\u0dfc\\u0e02\\u0e20\\u0e22\\u0e32\\u0e3f\\u0e44lig;\\u4152cute\\u803b\\xd3\\u40d3\\u0100iy\\u0dce\\u0dd3rc\\u803b\\xd4\\u40d4;\\u441eblac;\\u4150r;\\uc000\\ud835\\udd12rave\\u803b\\xd2\\u40d2\\u0180aei\\u0dee\\u0df2\\u0df6cr;\\u414cga;\\u43a9cron;\\u439fpf;\\uc000\\ud835\\udd46enCurly\\u0100DQ\\u0e0e\\u0e1aoubleQuote;\\u601cuote;\\u6018;\\u6a54\\u0100cl\\u0e27\\u0e2cr;\\uc000\\ud835\\udcaaash\\u803b\\xd8\\u40d8i\\u016c\\u0e37\\u0e3cde\\u803b\\xd5\\u40d5es;\\u6a37ml\\u803b\\xd6\\u40d6er\\u0100BP\\u0e4b\\u0e60\\u0100ar\\u0e50\\u0e53r;\\u603eac\\u0100ek\\u0e5a\\u0e5c;\\u63deet;\\u63b4arenthesis;\\u63dc\\u0480acfhilors\\u0e7f\\u0e87\\u0e8a\\u0e8f\\u0e92\\u0e94\\u0e9d\\u0eb0\\u0efcrtialD;\\u6202y;\\u441fr;\\uc000\\ud835\\udd13i;\\u43a6;\\u43a0usMinus;\\u40b1\\u0100ip\\u0ea2\\u0eadncareplan\\xe5\\u069df;\\u6119\\u0200;eio\\u0eb9\\u0eba\\u0ee0\\u0ee4\\u6abbcedes\\u0200;EST\\u0ec8\\u0ec9\\u0ecf\\u0eda\\u627aqual;\\u6aaflantEqual;\\u627cilde;\\u627eme;\\u6033\\u0100dp\\u0ee9\\u0eeeuct;\\u620fortion\\u0100;a\\u0225\\u0ef9l;\\u621d\\u0100ci\\u0f01\\u0f06r;\\uc000\\ud835\\udcab;\\u43a8\\u0200Ufos\\u0f11\\u0f16\\u0f1b\\u0f1fOT\\u803b\\\"\\u4022r;\\uc000\\ud835\\udd14pf;\\u611acr;\\uc000\\ud835\\udcac\\u0600BEacefhiorsu\\u0f3e\\u0f43\\u0f47\\u0f60\\u0f73\\u0fa7\\u0faa\\u0fad\\u1096\\u10a9\\u10b4\\u10bearr;\\u6910G\\u803b\\xae\\u40ae\\u0180cnr\\u0f4e\\u0f53\\u0f56ute;\\u4154g;\\u67ebr\\u0100;t\\u0f5c\\u0f5d\\u61a0l;\\u6916\\u0180aey\\u0f67\\u0f6c\\u0f71ron;\\u4158dil;\\u4156;\\u4420\\u0100;v\\u0f78\\u0f79\\u611cerse\\u0100EU\\u0f82\\u0f99\\u0100lq\\u0f87\\u0f8eement;\\u620builibrium;\\u61cbpEquilibrium;\\u696fr\\xbb\\u0f79o;\\u43a1ght\\u0400ACDFTUVa\\u0fc1\\u0feb\\u0ff3\\u1022\\u1028\\u105b\\u1087\\u03d8\\u0100nr\\u0fc6\\u0fd2gleBracket;\\u67e9row\\u0180;BL\\u0fdc\\u0fdd\\u0fe1\\u6192ar;\\u61e5eftArrow;\\u61c4eiling;\\u6309o\\u01f5\\u0ff9\\0\\u1005bleBracket;\\u67e7n\\u01d4\\u100a\\0\\u1014eeVector;\\u695dector\\u0100;B\\u101d\\u101e\\u61c2ar;\\u6955loor;\\u630b\\u0100er\\u102d\\u1043e\\u0180;AV\\u1035\\u1036\\u103c\\u62a2rrow;\\u61a6ector;\\u695biangle\\u0180;BE\\u1050\\u1051\\u1055\\u62b3ar;\\u69d0qual;\\u62b5p\\u0180DTV\\u1063\\u106e\\u1078ownVector;\\u694feeVector;\\u695cector\\u0100;B\\u1082\\u1083\\u61bear;\\u6954ector\\u0100;B\\u1091\\u1092\\u61c0ar;\\u6953\\u0100pu\\u109b\\u109ef;\\u611dndImplies;\\u6970ightarrow;\\u61db\\u0100ch\\u10b9\\u10bcr;\\u611b;\\u61b1leDelayed;\\u69f4\\u0680HOacfhimoqstu\\u10e4\\u10f1\\u10f7\\u10fd\\u1119\\u111e\\u1151\\u1156\\u1161\\u1167\\u11b5\\u11bb\\u11bf\\u0100Cc\\u10e9\\u10eeHcy;\\u4429y;\\u4428FTcy;\\u442ccute;\\u415a\\u0280;aeiy\\u1108\\u1109\\u110e\\u1113\\u1117\\u6abcron;\\u4160dil;\\u415erc;\\u415c;\\u4421r;\\uc000\\ud835\\udd16ort\\u0200DLRU\\u112a\\u1134\\u113e\\u1149ownArrow\\xbb\\u041eeftArrow\\xbb\\u089aightArrow\\xbb\\u0fddpArrow;\\u6191gma;\\u43a3allCircle;\\u6218pf;\\uc000\\ud835\\udd4a\\u0272\\u116d\\0\\0\\u1170t;\\u621aare\\u0200;ISU\\u117b\\u117c\\u1189\\u11af\\u65a1ntersection;\\u6293u\\u0100bp\\u118f\\u119eset\\u0100;E\\u1197\\u1198\\u628fqual;\\u6291erset\\u0100;E\\u11a8\\u11a9\\u6290qual;\\u6292nion;\\u6294cr;\\uc000\\ud835\\udcaear;\\u62c6\\u0200bcmp\\u11c8\\u11db\\u1209\\u120b\\u0100;s\\u11cd\\u11ce\\u62d0et\\u0100;E\\u11cd\\u11d5qual;\\u6286\\u0100ch\\u11e0\\u1205eeds\\u0200;EST\\u11ed\\u11ee\\u11f4\\u11ff\\u627bqual;\\u6ab0lantEqual;\\u627dilde;\\u627fTh\\xe1\\u0f8c;\\u6211\\u0180;es\\u1212\\u1213\\u1223\\u62d1rset\\u0100;E\\u121c\\u121d\\u6283qual;\\u6287et\\xbb\\u1213\\u0580HRSacfhiors\\u123e\\u1244\\u1249\\u1255\\u125e\\u1271\\u1276\\u129f\\u12c2\\u12c8\\u12d1ORN\\u803b\\xde\\u40deADE;\\u6122\\u0100Hc\\u124e\\u1252cy;\\u440by;\\u4426\\u0100bu\\u125a\\u125c;\\u4009;\\u43a4\\u0180aey\\u1265\\u126a\\u126fron;\\u4164dil;\\u4162;\\u4422r;\\uc000\\ud835\\udd17\\u0100ei\\u127b\\u1289\\u01f2\\u1280\\0\\u1287efore;\\u6234a;\\u4398\\u0100cn\\u128e\\u1298kSpace;\\uc000\\u205f\\u200aSpace;\\u6009lde\\u0200;EFT\\u12ab\\u12ac\\u12b2\\u12bc\\u623cqual;\\u6243ullEqual;\\u6245ilde;\\u6248pf;\\uc000\\ud835\\udd4bipleDot;\\u60db\\u0100ct\\u12d6\\u12dbr;\\uc000\\ud835\\udcafrok;\\u4166\\u0ae1\\u12f7\\u130e\\u131a\\u1326\\0\\u132c\\u1331\\0\\0\\0\\0\\0\\u1338\\u133d\\u1377\\u1385\\0\\u13ff\\u1404\\u140a\\u1410\\u0100cr\\u12fb\\u1301ute\\u803b\\xda\\u40dar\\u0100;o\\u1307\\u1308\\u619fcir;\\u6949r\\u01e3\\u1313\\0\\u1316y;\\u440eve;\\u416c\\u0100iy\\u131e\\u1323rc\\u803b\\xdb\\u40db;\\u4423blac;\\u4170r;\\uc000\\ud835\\udd18rave\\u803b\\xd9\\u40d9acr;\\u416a\\u0100di\\u1341\\u1369er\\u0100BP\\u1348\\u135d\\u0100ar\\u134d\\u1350r;\\u405fac\\u0100ek\\u1357\\u1359;\\u63dfet;\\u63b5arenthesis;\\u63ddon\\u0100;P\\u1370\\u1371\\u62c3lus;\\u628e\\u0100gp\\u137b\\u137fon;\\u4172f;\\uc000\\ud835\\udd4c\\u0400ADETadps\\u1395\\u13ae\\u13b8\\u13c4\\u03e8\\u13d2\\u13d7\\u13f3rrow\\u0180;BD\\u1150\\u13a0\\u13a4ar;\\u6912ownArrow;\\u61c5ownArrow;\\u6195quilibrium;\\u696eee\\u0100;A\\u13cb\\u13cc\\u62a5rrow;\\u61a5own\\xe1\\u03f3er\\u0100LR\\u13de\\u13e8eftArrow;\\u6196ightArrow;\\u6197i\\u0100;l\\u13f9\\u13fa\\u43d2on;\\u43a5ing;\\u416ecr;\\uc000\\ud835\\udcb0ilde;\\u4168ml\\u803b\\xdc\\u40dc\\u0480Dbcdefosv\\u1427\\u142c\\u1430\\u1433\\u143e\\u1485\\u148a\\u1490\\u1496ash;\\u62abar;\\u6aeby;\\u4412ash\\u0100;l\\u143b\\u143c\\u62a9;\\u6ae6\\u0100er\\u1443\\u1445;\\u62c1\\u0180bty\\u144c\\u1450\\u147aar;\\u6016\\u0100;i\\u144f\\u1455cal\\u0200BLST\\u1461\\u1465\\u146a\\u1474ar;\\u6223ine;\\u407ceparator;\\u6758ilde;\\u6240ThinSpace;\\u600ar;\\uc000\\ud835\\udd19pf;\\uc000\\ud835\\udd4dcr;\\uc000\\ud835\\udcb1dash;\\u62aa\\u0280cefos\\u14a7\\u14ac\\u14b1\\u14b6\\u14bcirc;\\u4174dge;\\u62c0r;\\uc000\\ud835\\udd1apf;\\uc000\\ud835\\udd4ecr;\\uc000\\ud835\\udcb2\\u0200fios\\u14cb\\u14d0\\u14d2\\u14d8r;\\uc000\\ud835\\udd1b;\\u439epf;\\uc000\\ud835\\udd4fcr;\\uc000\\ud835\\udcb3\\u0480AIUacfosu\\u14f1\\u14f5\\u14f9\\u14fd\\u1504\\u150f\\u1514\\u151a\\u1520cy;\\u442fcy;\\u4407cy;\\u442ecute\\u803b\\xdd\\u40dd\\u0100iy\\u1509\\u150drc;\\u4176;\\u442br;\\uc000\\ud835\\udd1cpf;\\uc000\\ud835\\udd50cr;\\uc000\\ud835\\udcb4ml;\\u4178\\u0400Hacdefos\\u1535\\u1539\\u153f\\u154b\\u154f\\u155d\\u1560\\u1564cy;\\u4416cute;\\u4179\\u0100ay\\u1544\\u1549ron;\\u417d;\\u4417ot;\\u417b\\u01f2\\u1554\\0\\u155boWidt\\xe8\\u0ad9a;\\u4396r;\\u6128pf;\\u6124cr;\\uc000\\ud835\\udcb5\\u0be1\\u1583\\u158a\\u1590\\0\\u15b0\\u15b6\\u15bf\\0\\0\\0\\0\\u15c6\\u15db\\u15eb\\u165f\\u166d\\0\\u1695\\u169b\\u16b2\\u16b9\\0\\u16becute\\u803b\\xe1\\u40e1reve;\\u4103\\u0300;Ediuy\\u159c\\u159d\\u15a1\\u15a3\\u15a8\\u15ad\\u623e;\\uc000\\u223e\\u0333;\\u623frc\\u803b\\xe2\\u40e2te\\u80bb\\xb4\\u0306;\\u4430lig\\u803b\\xe6\\u40e6\\u0100;r\\xb2\\u15ba;\\uc000\\ud835\\udd1erave\\u803b\\xe0\\u40e0\\u0100ep\\u15ca\\u15d6\\u0100fp\\u15cf\\u15d4sym;\\u6135\\xe8\\u15d3ha;\\u43b1\\u0100ap\\u15dfc\\u0100cl\\u15e4\\u15e7r;\\u4101g;\\u6a3f\\u0264\\u15f0\\0\\0\\u160a\\u0280;adsv\\u15fa\\u15fb\\u15ff\\u1601\\u1607\\u6227nd;\\u6a55;\\u6a5clope;\\u6a58;\\u6a5a\\u0380;elmrsz\\u1618\\u1619\\u161b\\u161e\\u163f\\u164f\\u1659\\u6220;\\u69a4e\\xbb\\u1619sd\\u0100;a\\u1625\\u1626\\u6221\\u0461\\u1630\\u1632\\u1634\\u1636\\u1638\\u163a\\u163c\\u163e;\\u69a8;\\u69a9;\\u69aa;\\u69ab;\\u69ac;\\u69ad;\\u69ae;\\u69aft\\u0100;v\\u1645\\u1646\\u621fb\\u0100;d\\u164c\\u164d\\u62be;\\u699d\\u0100pt\\u1654\\u1657h;\\u6222\\xbb\\xb9arr;\\u637c\\u0100gp\\u1663\\u1667on;\\u4105f;\\uc000\\ud835\\udd52\\u0380;Eaeiop\\u12c1\\u167b\\u167d\\u1682\\u1684\\u1687\\u168a;\\u6a70cir;\\u6a6f;\\u624ad;\\u624bs;\\u4027rox\\u0100;e\\u12c1\\u1692\\xf1\\u1683ing\\u803b\\xe5\\u40e5\\u0180cty\\u16a1\\u16a6\\u16a8r;\\uc000\\ud835\\udcb6;\\u402amp\\u0100;e\\u12c1\\u16af\\xf1\\u0288ilde\\u803b\\xe3\\u40e3ml\\u803b\\xe4\\u40e4\\u0100ci\\u16c2\\u16c8onin\\xf4\\u0272nt;\\u6a11\\u0800Nabcdefiklnoprsu\\u16ed\\u16f1\\u1730\\u173c\\u1743\\u1748\\u1778\\u177d\\u17e0\\u17e6\\u1839\\u1850\\u170d\\u193d\\u1948\\u1970ot;\\u6aed\\u0100cr\\u16f6\\u171ek\\u0200ceps\\u1700\\u1705\\u170d\\u1713ong;\\u624cpsilon;\\u43f6rime;\\u6035im\\u0100;e\\u171a\\u171b\\u623dq;\\u62cd\\u0176\\u1722\\u1726ee;\\u62bded\\u0100;g\\u172c\\u172d\\u6305e\\xbb\\u172drk\\u0100;t\\u135c\\u1737brk;\\u63b6\\u0100oy\\u1701\\u1741;\\u4431quo;\\u601e\\u0280cmprt\\u1753\\u175b\\u1761\\u1764\\u1768aus\\u0100;e\\u010a\\u0109ptyv;\\u69b0s\\xe9\\u170cno\\xf5\\u0113\\u0180ahw\\u176f\\u1771\\u1773;\\u43b2;\\u6136een;\\u626cr;\\uc000\\ud835\\udd1fg\\u0380costuvw\\u178d\\u179d\\u17b3\\u17c1\\u17d5\\u17db\\u17de\\u0180aiu\\u1794\\u1796\\u179a\\xf0\\u0760rc;\\u65efp\\xbb\\u1371\\u0180dpt\\u17a4\\u17a8\\u17adot;\\u6a00lus;\\u6a01imes;\\u6a02\\u0271\\u17b9\\0\\0\\u17becup;\\u6a06ar;\\u6605riangle\\u0100du\\u17cd\\u17d2own;\\u65bdp;\\u65b3plus;\\u6a04e\\xe5\\u1444\\xe5\\u14adarow;\\u690d\\u0180ako\\u17ed\\u1826\\u1835\\u0100cn\\u17f2\\u1823k\\u0180lst\\u17fa\\u05ab\\u1802ozenge;\\u69ebriangle\\u0200;dlr\\u1812\\u1813\\u1818\\u181d\\u65b4own;\\u65beeft;\\u65c2ight;\\u65b8k;\\u6423\\u01b1\\u182b\\0\\u1833\\u01b2\\u182f\\0\\u1831;\\u6592;\\u65914;\\u6593ck;\\u6588\\u0100eo\\u183e\\u184d\\u0100;q\\u1843\\u1846\\uc000=\\u20e5uiv;\\uc000\\u2261\\u20e5t;\\u6310\\u0200ptwx\\u1859\\u185e\\u1867\\u186cf;\\uc000\\ud835\\udd53\\u0100;t\\u13cb\\u1863om\\xbb\\u13cctie;\\u62c8\\u0600DHUVbdhmptuv\\u1885\\u1896\\u18aa\\u18bb\\u18d7\\u18db\\u18ec\\u18ff\\u1905\\u190a\\u1910\\u1921\\u0200LRlr\\u188e\\u1890\\u1892\\u1894;\\u6557;\\u6554;\\u6556;\\u6553\\u0280;DUdu\\u18a1\\u18a2\\u18a4\\u18a6\\u18a8\\u6550;\\u6566;\\u6569;\\u6564;\\u6567\\u0200LRlr\\u18b3\\u18b5\\u18b7\\u18b9;\\u655d;\\u655a;\\u655c;\\u6559\\u0380;HLRhlr\\u18ca\\u18cb\\u18cd\\u18cf\\u18d1\\u18d3\\u18d5\\u6551;\\u656c;\\u6563;\\u6560;\\u656b;\\u6562;\\u655fox;\\u69c9\\u0200LRlr\\u18e4\\u18e6\\u18e8\\u18ea;\\u6555;\\u6552;\\u6510;\\u650c\\u0280;DUdu\\u06bd\\u18f7\\u18f9\\u18fb\\u18fd;\\u6565;\\u6568;\\u652c;\\u6534inus;\\u629flus;\\u629eimes;\\u62a0\\u0200LRlr\\u1919\\u191b\\u191d\\u191f;\\u655b;\\u6558;\\u6518;\\u6514\\u0380;HLRhlr\\u1930\\u1931\\u1933\\u1935\\u1937\\u1939\\u193b\\u6502;\\u656a;\\u6561;\\u655e;\\u653c;\\u6524;\\u651c\\u0100ev\\u0123\\u1942bar\\u803b\\xa6\\u40a6\\u0200ceio\\u1951\\u1956\\u195a\\u1960r;\\uc000\\ud835\\udcb7mi;\\u604fm\\u0100;e\\u171a\\u171cl\\u0180;bh\\u1968\\u1969\\u196b\\u405c;\\u69c5sub;\\u67c8\\u016c\\u1974\\u197el\\u0100;e\\u1979\\u197a\\u6022t\\xbb\\u197ap\\u0180;Ee\\u012f\\u1985\\u1987;\\u6aae\\u0100;q\\u06dc\\u06db\\u0ce1\\u19a7\\0\\u19e8\\u1a11\\u1a15\\u1a32\\0\\u1a37\\u1a50\\0\\0\\u1ab4\\0\\0\\u1ac1\\0\\0\\u1b21\\u1b2e\\u1b4d\\u1b52\\0\\u1bfd\\0\\u1c0c\\u0180cpr\\u19ad\\u19b2\\u19ddute;\\u4107\\u0300;abcds\\u19bf\\u19c0\\u19c4\\u19ca\\u19d5\\u19d9\\u6229nd;\\u6a44rcup;\\u6a49\\u0100au\\u19cf\\u19d2p;\\u6a4bp;\\u6a47ot;\\u6a40;\\uc000\\u2229\\ufe00\\u0100eo\\u19e2\\u19e5t;\\u6041\\xee\\u0693\\u0200aeiu\\u19f0\\u19fb\\u1a01\\u1a05\\u01f0\\u19f5\\0\\u19f8s;\\u6a4don;\\u410ddil\\u803b\\xe7\\u40e7rc;\\u4109ps\\u0100;s\\u1a0c\\u1a0d\\u6a4cm;\\u6a50ot;\\u410b\\u0180dmn\\u1a1b\\u1a20\\u1a26il\\u80bb\\xb8\\u01adptyv;\\u69b2t\\u8100\\xa2;e\\u1a2d\\u1a2e\\u40a2r\\xe4\\u01b2r;\\uc000\\ud835\\udd20\\u0180cei\\u1a3d\\u1a40\\u1a4dy;\\u4447ck\\u0100;m\\u1a47\\u1a48\\u6713ark\\xbb\\u1a48;\\u43c7r\\u0380;Ecefms\\u1a5f\\u1a60\\u1a62\\u1a6b\\u1aa4\\u1aaa\\u1aae\\u65cb;\\u69c3\\u0180;el\\u1a69\\u1a6a\\u1a6d\\u42c6q;\\u6257e\\u0261\\u1a74\\0\\0\\u1a88rrow\\u0100lr\\u1a7c\\u1a81eft;\\u61baight;\\u61bb\\u0280RSacd\\u1a92\\u1a94\\u1a96\\u1a9a\\u1a9f\\xbb\\u0f47;\\u64c8st;\\u629birc;\\u629aash;\\u629dnint;\\u6a10id;\\u6aefcir;\\u69c2ubs\\u0100;u\\u1abb\\u1abc\\u6663it\\xbb\\u1abc\\u02ec\\u1ac7\\u1ad4\\u1afa\\0\\u1b0aon\\u0100;e\\u1acd\\u1ace\\u403a\\u0100;q\\xc7\\xc6\\u026d\\u1ad9\\0\\0\\u1ae2a\\u0100;t\\u1ade\\u1adf\\u402c;\\u4040\\u0180;fl\\u1ae8\\u1ae9\\u1aeb\\u6201\\xee\\u1160e\\u0100mx\\u1af1\\u1af6ent\\xbb\\u1ae9e\\xf3\\u024d\\u01e7\\u1afe\\0\\u1b07\\u0100;d\\u12bb\\u1b02ot;\\u6a6dn\\xf4\\u0246\\u0180fry\\u1b10\\u1b14\\u1b17;\\uc000\\ud835\\udd54o\\xe4\\u0254\\u8100\\xa9;s\\u0155\\u1b1dr;\\u6117\\u0100ao\\u1b25\\u1b29rr;\\u61b5ss;\\u6717\\u0100cu\\u1b32\\u1b37r;\\uc000\\ud835\\udcb8\\u0100bp\\u1b3c\\u1b44\\u0100;e\\u1b41\\u1b42\\u6acf;\\u6ad1\\u0100;e\\u1b49\\u1b4a\\u6ad0;\\u6ad2dot;\\u62ef\\u0380delprvw\\u1b60\\u1b6c\\u1b77\\u1b82\\u1bac\\u1bd4\\u1bf9arr\\u0100lr\\u1b68\\u1b6a;\\u6938;\\u6935\\u0270\\u1b72\\0\\0\\u1b75r;\\u62dec;\\u62dfarr\\u0100;p\\u1b7f\\u1b80\\u61b6;\\u693d\\u0300;bcdos\\u1b8f\\u1b90\\u1b96\\u1ba1\\u1ba5\\u1ba8\\u622arcap;\\u6a48\\u0100au\\u1b9b\\u1b9ep;\\u6a46p;\\u6a4aot;\\u628dr;\\u6a45;\\uc000\\u222a\\ufe00\\u0200alrv\\u1bb5\\u1bbf\\u1bde\\u1be3rr\\u0100;m\\u1bbc\\u1bbd\\u61b7;\\u693cy\\u0180evw\\u1bc7\\u1bd4\\u1bd8q\\u0270\\u1bce\\0\\0\\u1bd2re\\xe3\\u1b73u\\xe3\\u1b75ee;\\u62ceedge;\\u62cfen\\u803b\\xa4\\u40a4earrow\\u0100lr\\u1bee\\u1bf3eft\\xbb\\u1b80ight\\xbb\\u1bbde\\xe4\\u1bdd\\u0100ci\\u1c01\\u1c07onin\\xf4\\u01f7nt;\\u6231lcty;\\u632d\\u0980AHabcdefhijlorstuwz\\u1c38\\u1c3b\\u1c3f\\u1c5d\\u1c69\\u1c75\\u1c8a\\u1c9e\\u1cac\\u1cb7\\u1cfb\\u1cff\\u1d0d\\u1d7b\\u1d91\\u1dab\\u1dbb\\u1dc6\\u1dcdr\\xf2\\u0381ar;\\u6965\\u0200glrs\\u1c48\\u1c4d\\u1c52\\u1c54ger;\\u6020eth;\\u6138\\xf2\\u1133h\\u0100;v\\u1c5a\\u1c5b\\u6010\\xbb\\u090a\\u016b\\u1c61\\u1c67arow;\\u690fa\\xe3\\u0315\\u0100ay\\u1c6e\\u1c73ron;\\u410f;\\u4434\\u0180;ao\\u0332\\u1c7c\\u1c84\\u0100gr\\u02bf\\u1c81r;\\u61catseq;\\u6a77\\u0180glm\\u1c91\\u1c94\\u1c98\\u803b\\xb0\\u40b0ta;\\u43b4ptyv;\\u69b1\\u0100ir\\u1ca3\\u1ca8sht;\\u697f;\\uc000\\ud835\\udd21ar\\u0100lr\\u1cb3\\u1cb5\\xbb\\u08dc\\xbb\\u101e\\u0280aegsv\\u1cc2\\u0378\\u1cd6\\u1cdc\\u1ce0m\\u0180;os\\u0326\\u1cca\\u1cd4nd\\u0100;s\\u0326\\u1cd1uit;\\u6666amma;\\u43ddin;\\u62f2\\u0180;io\\u1ce7\\u1ce8\\u1cf8\\u40f7de\\u8100\\xf7;o\\u1ce7\\u1cf0ntimes;\\u62c7n\\xf8\\u1cf7cy;\\u4452c\\u026f\\u1d06\\0\\0\\u1d0arn;\\u631eop;\\u630d\\u0280lptuw\\u1d18\\u1d1d\\u1d22\\u1d49\\u1d55lar;\\u4024f;\\uc000\\ud835\\udd55\\u0280;emps\\u030b\\u1d2d\\u1d37\\u1d3d\\u1d42q\\u0100;d\\u0352\\u1d33ot;\\u6251inus;\\u6238lus;\\u6214quare;\\u62a1blebarwedg\\xe5\\xfan\\u0180adh\\u112e\\u1d5d\\u1d67ownarrow\\xf3\\u1c83arpoon\\u0100lr\\u1d72\\u1d76ef\\xf4\\u1cb4igh\\xf4\\u1cb6\\u0162\\u1d7f\\u1d85karo\\xf7\\u0f42\\u026f\\u1d8a\\0\\0\\u1d8ern;\\u631fop;\\u630c\\u0180cot\\u1d98\\u1da3\\u1da6\\u0100ry\\u1d9d\\u1da1;\\uc000\\ud835\\udcb9;\\u4455l;\\u69f6rok;\\u4111\\u0100dr\\u1db0\\u1db4ot;\\u62f1i\\u0100;f\\u1dba\\u1816\\u65bf\\u0100ah\\u1dc0\\u1dc3r\\xf2\\u0429a\\xf2\\u0fa6angle;\\u69a6\\u0100ci\\u1dd2\\u1dd5y;\\u445fgrarr;\\u67ff\\u0900Dacdefglmnopqrstux\\u1e01\\u1e09\\u1e19\\u1e38\\u0578\\u1e3c\\u1e49\\u1e61\\u1e7e\\u1ea5\\u1eaf\\u1ebd\\u1ee1\\u1f2a\\u1f37\\u1f44\\u1f4e\\u1f5a\\u0100Do\\u1e06\\u1d34o\\xf4\\u1c89\\u0100cs\\u1e0e\\u1e14ute\\u803b\\xe9\\u40e9ter;\\u6a6e\\u0200aioy\\u1e22\\u1e27\\u1e31\\u1e36ron;\\u411br\\u0100;c\\u1e2d\\u1e2e\\u6256\\u803b\\xea\\u40ealon;\\u6255;\\u444dot;\\u4117\\u0100Dr\\u1e41\\u1e45ot;\\u6252;\\uc000\\ud835\\udd22\\u0180;rs\\u1e50\\u1e51\\u1e57\\u6a9aave\\u803b\\xe8\\u40e8\\u0100;d\\u1e5c\\u1e5d\\u6a96ot;\\u6a98\\u0200;ils\\u1e6a\\u1e6b\\u1e72\\u1e74\\u6a99nters;\\u63e7;\\u6113\\u0100;d\\u1e79\\u1e7a\\u6a95ot;\\u6a97\\u0180aps\\u1e85\\u1e89\\u1e97cr;\\u4113ty\\u0180;sv\\u1e92\\u1e93\\u1e95\\u6205et\\xbb\\u1e93p\\u01001;\\u1e9d\\u1ea4\\u0133\\u1ea1\\u1ea3;\\u6004;\\u6005\\u6003\\u0100gs\\u1eaa\\u1eac;\\u414bp;\\u6002\\u0100gp\\u1eb4\\u1eb8on;\\u4119f;\\uc000\\ud835\\udd56\\u0180als\\u1ec4\\u1ece\\u1ed2r\\u0100;s\\u1eca\\u1ecb\\u62d5l;\\u69e3us;\\u6a71i\\u0180;lv\\u1eda\\u1edb\\u1edf\\u43b5on\\xbb\\u1edb;\\u43f5\\u0200csuv\\u1eea\\u1ef3\\u1f0b\\u1f23\\u0100io\\u1eef\\u1e31rc\\xbb\\u1e2e\\u0269\\u1ef9\\0\\0\\u1efb\\xed\\u0548ant\\u0100gl\\u1f02\\u1f06tr\\xbb\\u1e5dess\\xbb\\u1e7a\\u0180aei\\u1f12\\u1f16\\u1f1als;\\u403dst;\\u625fv\\u0100;D\\u0235\\u1f20D;\\u6a78parsl;\\u69e5\\u0100Da\\u1f2f\\u1f33ot;\\u6253rr;\\u6971\\u0180cdi\\u1f3e\\u1f41\\u1ef8r;\\u612fo\\xf4\\u0352\\u0100ah\\u1f49\\u1f4b;\\u43b7\\u803b\\xf0\\u40f0\\u0100mr\\u1f53\\u1f57l\\u803b\\xeb\\u40ebo;\\u60ac\\u0180cip\\u1f61\\u1f64\\u1f67l;\\u4021s\\xf4\\u056e\\u0100eo\\u1f6c\\u1f74ctatio\\xee\\u0559nential\\xe5\\u0579\\u09e1\\u1f92\\0\\u1f9e\\0\\u1fa1\\u1fa7\\0\\0\\u1fc6\\u1fcc\\0\\u1fd3\\0\\u1fe6\\u1fea\\u2000\\0\\u2008\\u205allingdotse\\xf1\\u1e44y;\\u4444male;\\u6640\\u0180ilr\\u1fad\\u1fb3\\u1fc1lig;\\u8000\\ufb03\\u0269\\u1fb9\\0\\0\\u1fbdg;\\u8000\\ufb00ig;\\u8000\\ufb04;\\uc000\\ud835\\udd23lig;\\u8000\\ufb01lig;\\uc000fj\\u0180alt\\u1fd9\\u1fdc\\u1fe1t;\\u666dig;\\u8000\\ufb02ns;\\u65b1of;\\u4192\\u01f0\\u1fee\\0\\u1ff3f;\\uc000\\ud835\\udd57\\u0100ak\\u05bf\\u1ff7\\u0100;v\\u1ffc\\u1ffd\\u62d4;\\u6ad9artint;\\u6a0d\\u0100ao\\u200c\\u2055\\u0100cs\\u2011\\u2052\\u03b1\\u201a\\u2030\\u2038\\u2045\\u2048\\0\\u2050\\u03b2\\u2022\\u2025\\u2027\\u202a\\u202c\\0\\u202e\\u803b\\xbd\\u40bd;\\u6153\\u803b\\xbc\\u40bc;\\u6155;\\u6159;\\u615b\\u01b3\\u2034\\0\\u2036;\\u6154;\\u6156\\u02b4\\u203e\\u2041\\0\\0\\u2043\\u803b\\xbe\\u40be;\\u6157;\\u615c5;\\u6158\\u01b6\\u204c\\0\\u204e;\\u615a;\\u615d8;\\u615el;\\u6044wn;\\u6322cr;\\uc000\\ud835\\udcbb\\u0880Eabcdefgijlnorstv\\u2082\\u2089\\u209f\\u20a5\\u20b0\\u20b4\\u20f0\\u20f5\\u20fa\\u20ff\\u2103\\u2112\\u2138\\u0317\\u213e\\u2152\\u219e\\u0100;l\\u064d\\u2087;\\u6a8c\\u0180cmp\\u2090\\u2095\\u209dute;\\u41f5ma\\u0100;d\\u209c\\u1cda\\u43b3;\\u6a86reve;\\u411f\\u0100iy\\u20aa\\u20aerc;\\u411d;\\u4433ot;\\u4121\\u0200;lqs\\u063e\\u0642\\u20bd\\u20c9\\u0180;qs\\u063e\\u064c\\u20c4lan\\xf4\\u0665\\u0200;cdl\\u0665\\u20d2\\u20d5\\u20e5c;\\u6aa9ot\\u0100;o\\u20dc\\u20dd\\u6a80\\u0100;l\\u20e2\\u20e3\\u6a82;\\u6a84\\u0100;e\\u20ea\\u20ed\\uc000\\u22db\\ufe00s;\\u6a94r;\\uc000\\ud835\\udd24\\u0100;g\\u0673\\u061bmel;\\u6137cy;\\u4453\\u0200;Eaj\\u065a\\u210c\\u210e\\u2110;\\u6a92;\\u6aa5;\\u6aa4\\u0200Eaes\\u211b\\u211d\\u2129\\u2134;\\u6269p\\u0100;p\\u2123\\u2124\\u6a8arox\\xbb\\u2124\\u0100;q\\u212e\\u212f\\u6a88\\u0100;q\\u212e\\u211bim;\\u62e7pf;\\uc000\\ud835\\udd58\\u0100ci\\u2143\\u2146r;\\u610am\\u0180;el\\u066b\\u214e\\u2150;\\u6a8e;\\u6a90\\u8300>;cdlqr\\u05ee\\u2160\\u216a\\u216e\\u2173\\u2179\\u0100ci\\u2165\\u2167;\\u6aa7r;\\u6a7aot;\\u62d7Par;\\u6995uest;\\u6a7c\\u0280adels\\u2184\\u216a\\u2190\\u0656\\u219b\\u01f0\\u2189\\0\\u218epro\\xf8\\u209er;\\u6978q\\u0100lq\\u063f\\u2196les\\xf3\\u2088i\\xed\\u066b\\u0100en\\u21a3\\u21adrtneqq;\\uc000\\u2269\\ufe00\\xc5\\u21aa\\u0500Aabcefkosy\\u21c4\\u21c7\\u21f1\\u21f5\\u21fa\\u2218\\u221d\\u222f\\u2268\\u227dr\\xf2\\u03a0\\u0200ilmr\\u21d0\\u21d4\\u21d7\\u21dbrs\\xf0\\u1484f\\xbb\\u2024il\\xf4\\u06a9\\u0100dr\\u21e0\\u21e4cy;\\u444a\\u0180;cw\\u08f4\\u21eb\\u21efir;\\u6948;\\u61adar;\\u610firc;\\u4125\\u0180alr\\u2201\\u220e\\u2213rts\\u0100;u\\u2209\\u220a\\u6665it\\xbb\\u220alip;\\u6026con;\\u62b9r;\\uc000\\ud835\\udd25s\\u0100ew\\u2223\\u2229arow;\\u6925arow;\\u6926\\u0280amopr\\u223a\\u223e\\u2243\\u225e\\u2263rr;\\u61fftht;\\u623bk\\u0100lr\\u2249\\u2253eftarrow;\\u61a9ightarrow;\\u61aaf;\\uc000\\ud835\\udd59bar;\\u6015\\u0180clt\\u226f\\u2274\\u2278r;\\uc000\\ud835\\udcbdas\\xe8\\u21f4rok;\\u4127\\u0100bp\\u2282\\u2287ull;\\u6043hen\\xbb\\u1c5b\\u0ae1\\u22a3\\0\\u22aa\\0\\u22b8\\u22c5\\u22ce\\0\\u22d5\\u22f3\\0\\0\\u22f8\\u2322\\u2367\\u2362\\u237f\\0\\u2386\\u23aa\\u23b4cute\\u803b\\xed\\u40ed\\u0180;iy\\u0771\\u22b0\\u22b5rc\\u803b\\xee\\u40ee;\\u4438\\u0100cx\\u22bc\\u22bfy;\\u4435cl\\u803b\\xa1\\u40a1\\u0100fr\\u039f\\u22c9;\\uc000\\ud835\\udd26rave\\u803b\\xec\\u40ec\\u0200;ino\\u073e\\u22dd\\u22e9\\u22ee\\u0100in\\u22e2\\u22e6nt;\\u6a0ct;\\u622dfin;\\u69dcta;\\u6129lig;\\u4133\\u0180aop\\u22fe\\u231a\\u231d\\u0180cgt\\u2305\\u2308\\u2317r;\\u412b\\u0180elp\\u071f\\u230f\\u2313in\\xe5\\u078ear\\xf4\\u0720h;\\u4131f;\\u62b7ed;\\u41b5\\u0280;cfot\\u04f4\\u232c\\u2331\\u233d\\u2341are;\\u6105in\\u0100;t\\u2338\\u2339\\u621eie;\\u69dddo\\xf4\\u2319\\u0280;celp\\u0757\\u234c\\u2350\\u235b\\u2361al;\\u62ba\\u0100gr\\u2355\\u2359er\\xf3\\u1563\\xe3\\u234darhk;\\u6a17rod;\\u6a3c\\u0200cgpt\\u236f\\u2372\\u2376\\u237by;\\u4451on;\\u412ff;\\uc000\\ud835\\udd5aa;\\u43b9uest\\u803b\\xbf\\u40bf\\u0100ci\\u238a\\u238fr;\\uc000\\ud835\\udcben\\u0280;Edsv\\u04f4\\u239b\\u239d\\u23a1\\u04f3;\\u62f9ot;\\u62f5\\u0100;v\\u23a6\\u23a7\\u62f4;\\u62f3\\u0100;i\\u0777\\u23aelde;\\u4129\\u01eb\\u23b8\\0\\u23bccy;\\u4456l\\u803b\\xef\\u40ef\\u0300cfmosu\\u23cc\\u23d7\\u23dc\\u23e1\\u23e7\\u23f5\\u0100iy\\u23d1\\u23d5rc;\\u4135;\\u4439r;\\uc000\\ud835\\udd27ath;\\u4237pf;\\uc000\\ud835\\udd5b\\u01e3\\u23ec\\0\\u23f1r;\\uc000\\ud835\\udcbfrcy;\\u4458kcy;\\u4454\\u0400acfghjos\\u240b\\u2416\\u2422\\u2427\\u242d\\u2431\\u2435\\u243bppa\\u0100;v\\u2413\\u2414\\u43ba;\\u43f0\\u0100ey\\u241b\\u2420dil;\\u4137;\\u443ar;\\uc000\\ud835\\udd28reen;\\u4138cy;\\u4445cy;\\u445cpf;\\uc000\\ud835\\udd5ccr;\\uc000\\ud835\\udcc0\\u0b80ABEHabcdefghjlmnoprstuv\\u2470\\u2481\\u2486\\u248d\\u2491\\u250e\\u253d\\u255a\\u2580\\u264e\\u265e\\u2665\\u2679\\u267d\\u269a\\u26b2\\u26d8\\u275d\\u2768\\u278b\\u27c0\\u2801\\u2812\\u0180art\\u2477\\u247a\\u247cr\\xf2\\u09c6\\xf2\\u0395ail;\\u691barr;\\u690e\\u0100;g\\u0994\\u248b;\\u6a8bar;\\u6962\\u0963\\u24a5\\0\\u24aa\\0\\u24b1\\0\\0\\0\\0\\0\\u24b5\\u24ba\\0\\u24c6\\u24c8\\u24cd\\0\\u24f9ute;\\u413amptyv;\\u69b4ra\\xee\\u084cbda;\\u43bbg\\u0180;dl\\u088e\\u24c1\\u24c3;\\u6991\\xe5\\u088e;\\u6a85uo\\u803b\\xab\\u40abr\\u0400;bfhlpst\\u0899\\u24de\\u24e6\\u24e9\\u24eb\\u24ee\\u24f1\\u24f5\\u0100;f\\u089d\\u24e3s;\\u691fs;\\u691d\\xeb\\u2252p;\\u61abl;\\u6939im;\\u6973l;\\u61a2\\u0180;ae\\u24ff\\u2500\\u2504\\u6aabil;\\u6919\\u0100;s\\u2509\\u250a\\u6aad;\\uc000\\u2aad\\ufe00\\u0180abr\\u2515\\u2519\\u251drr;\\u690crk;\\u6772\\u0100ak\\u2522\\u252cc\\u0100ek\\u2528\\u252a;\\u407b;\\u405b\\u0100es\\u2531\\u2533;\\u698bl\\u0100du\\u2539\\u253b;\\u698f;\\u698d\\u0200aeuy\\u2546\\u254b\\u2556\\u2558ron;\\u413e\\u0100di\\u2550\\u2554il;\\u413c\\xec\\u08b0\\xe2\\u2529;\\u443b\\u0200cqrs\\u2563\\u2566\\u256d\\u257da;\\u6936uo\\u0100;r\\u0e19\\u1746\\u0100du\\u2572\\u2577har;\\u6967shar;\\u694bh;\\u61b2\\u0280;fgqs\\u258b\\u258c\\u0989\\u25f3\\u25ff\\u6264t\\u0280ahlrt\\u2598\\u25a4\\u25b7\\u25c2\\u25e8rrow\\u0100;t\\u0899\\u25a1a\\xe9\\u24f6arpoon\\u0100du\\u25af\\u25b4own\\xbb\\u045ap\\xbb\\u0966eftarrows;\\u61c7ight\\u0180ahs\\u25cd\\u25d6\\u25derrow\\u0100;s\\u08f4\\u08a7arpoon\\xf3\\u0f98quigarro\\xf7\\u21f0hreetimes;\\u62cb\\u0180;qs\\u258b\\u0993\\u25falan\\xf4\\u09ac\\u0280;cdgs\\u09ac\\u260a\\u260d\\u261d\\u2628c;\\u6aa8ot\\u0100;o\\u2614\\u2615\\u6a7f\\u0100;r\\u261a\\u261b\\u6a81;\\u6a83\\u0100;e\\u2622\\u2625\\uc000\\u22da\\ufe00s;\\u6a93\\u0280adegs\\u2633\\u2639\\u263d\\u2649\\u264bppro\\xf8\\u24c6ot;\\u62d6q\\u0100gq\\u2643\\u2645\\xf4\\u0989gt\\xf2\\u248c\\xf4\\u099bi\\xed\\u09b2\\u0180ilr\\u2655\\u08e1\\u265asht;\\u697c;\\uc000\\ud835\\udd29\\u0100;E\\u099c\\u2663;\\u6a91\\u0161\\u2669\\u2676r\\u0100du\\u25b2\\u266e\\u0100;l\\u0965\\u2673;\\u696alk;\\u6584cy;\\u4459\\u0280;acht\\u0a48\\u2688\\u268b\\u2691\\u2696r\\xf2\\u25c1orne\\xf2\\u1d08ard;\\u696bri;\\u65fa\\u0100io\\u269f\\u26a4dot;\\u4140ust\\u0100;a\\u26ac\\u26ad\\u63b0che\\xbb\\u26ad\\u0200Eaes\\u26bb\\u26bd\\u26c9\\u26d4;\\u6268p\\u0100;p\\u26c3\\u26c4\\u6a89rox\\xbb\\u26c4\\u0100;q\\u26ce\\u26cf\\u6a87\\u0100;q\\u26ce\\u26bbim;\\u62e6\\u0400abnoptwz\\u26e9\\u26f4\\u26f7\\u271a\\u272f\\u2741\\u2747\\u2750\\u0100nr\\u26ee\\u26f1g;\\u67ecr;\\u61fdr\\xeb\\u08c1g\\u0180lmr\\u26ff\\u270d\\u2714eft\\u0100ar\\u09e6\\u2707ight\\xe1\\u09f2apsto;\\u67fcight\\xe1\\u09fdparrow\\u0100lr\\u2725\\u2729ef\\xf4\\u24edight;\\u61ac\\u0180afl\\u2736\\u2739\\u273dr;\\u6985;\\uc000\\ud835\\udd5dus;\\u6a2dimes;\\u6a34\\u0161\\u274b\\u274fst;\\u6217\\xe1\\u134e\\u0180;ef\\u2757\\u2758\\u1800\\u65cange\\xbb\\u2758ar\\u0100;l\\u2764\\u2765\\u4028t;\\u6993\\u0280achmt\\u2773\\u2776\\u277c\\u2785\\u2787r\\xf2\\u08a8orne\\xf2\\u1d8car\\u0100;d\\u0f98\\u2783;\\u696d;\\u600eri;\\u62bf\\u0300achiqt\\u2798\\u279d\\u0a40\\u27a2\\u27ae\\u27bbquo;\\u6039r;\\uc000\\ud835\\udcc1m\\u0180;eg\\u09b2\\u27aa\\u27ac;\\u6a8d;\\u6a8f\\u0100bu\\u252a\\u27b3o\\u0100;r\\u0e1f\\u27b9;\\u601arok;\\u4142\\u8400<;cdhilqr\\u082b\\u27d2\\u2639\\u27dc\\u27e0\\u27e5\\u27ea\\u27f0\\u0100ci\\u27d7\\u27d9;\\u6aa6r;\\u6a79re\\xe5\\u25f2mes;\\u62c9arr;\\u6976uest;\\u6a7b\\u0100Pi\\u27f5\\u27f9ar;\\u6996\\u0180;ef\\u2800\\u092d\\u181b\\u65c3r\\u0100du\\u2807\\u280dshar;\\u694ahar;\\u6966\\u0100en\\u2817\\u2821rtneqq;\\uc000\\u2268\\ufe00\\xc5\\u281e\\u0700Dacdefhilnopsu\\u2840\\u2845\\u2882\\u288e\\u2893\\u28a0\\u28a5\\u28a8\\u28da\\u28e2\\u28e4\\u0a83\\u28f3\\u2902Dot;\\u623a\\u0200clpr\\u284e\\u2852\\u2863\\u287dr\\u803b\\xaf\\u40af\\u0100et\\u2857\\u2859;\\u6642\\u0100;e\\u285e\\u285f\\u6720se\\xbb\\u285f\\u0100;s\\u103b\\u2868to\\u0200;dlu\\u103b\\u2873\\u2877\\u287bow\\xee\\u048cef\\xf4\\u090f\\xf0\\u13d1ker;\\u65ae\\u0100oy\\u2887\\u288cmma;\\u6a29;\\u443cash;\\u6014asuredangle\\xbb\\u1626r;\\uc000\\ud835\\udd2ao;\\u6127\\u0180cdn\\u28af\\u28b4\\u28c9ro\\u803b\\xb5\\u40b5\\u0200;acd\\u1464\\u28bd\\u28c0\\u28c4s\\xf4\\u16a7ir;\\u6af0ot\\u80bb\\xb7\\u01b5us\\u0180;bd\\u28d2\\u1903\\u28d3\\u6212\\u0100;u\\u1d3c\\u28d8;\\u6a2a\\u0163\\u28de\\u28e1p;\\u6adb\\xf2\\u2212\\xf0\\u0a81\\u0100dp\\u28e9\\u28eeels;\\u62a7f;\\uc000\\ud835\\udd5e\\u0100ct\\u28f8\\u28fdr;\\uc000\\ud835\\udcc2pos\\xbb\\u159d\\u0180;lm\\u2909\\u290a\\u290d\\u43bctimap;\\u62b8\\u0c00GLRVabcdefghijlmoprstuvw\\u2942\\u2953\\u297e\\u2989\\u2998\\u29da\\u29e9\\u2a15\\u2a1a\\u2a58\\u2a5d\\u2a83\\u2a95\\u2aa4\\u2aa8\\u2b04\\u2b07\\u2b44\\u2b7f\\u2bae\\u2c34\\u2c67\\u2c7c\\u2ce9\\u0100gt\\u2947\\u294b;\\uc000\\u22d9\\u0338\\u0100;v\\u2950\\u0bcf\\uc000\\u226b\\u20d2\\u0180elt\\u295a\\u2972\\u2976ft\\u0100ar\\u2961\\u2967rrow;\\u61cdightarrow;\\u61ce;\\uc000\\u22d8\\u0338\\u0100;v\\u297b\\u0c47\\uc000\\u226a\\u20d2ightarrow;\\u61cf\\u0100Dd\\u298e\\u2993ash;\\u62afash;\\u62ae\\u0280bcnpt\\u29a3\\u29a7\\u29ac\\u29b1\\u29ccla\\xbb\\u02deute;\\u4144g;\\uc000\\u2220\\u20d2\\u0280;Eiop\\u0d84\\u29bc\\u29c0\\u29c5\\u29c8;\\uc000\\u2a70\\u0338d;\\uc000\\u224b\\u0338s;\\u4149ro\\xf8\\u0d84ur\\u0100;a\\u29d3\\u29d4\\u666el\\u0100;s\\u29d3\\u0b38\\u01f3\\u29df\\0\\u29e3p\\u80bb\\xa0\\u0b37mp\\u0100;e\\u0bf9\\u0c00\\u0280aeouy\\u29f4\\u29fe\\u2a03\\u2a10\\u2a13\\u01f0\\u29f9\\0\\u29fb;\\u6a43on;\\u4148dil;\\u4146ng\\u0100;d\\u0d7e\\u2a0aot;\\uc000\\u2a6d\\u0338p;\\u6a42;\\u443dash;\\u6013\\u0380;Aadqsx\\u0b92\\u2a29\\u2a2d\\u2a3b\\u2a41\\u2a45\\u2a50rr;\\u61d7r\\u0100hr\\u2a33\\u2a36k;\\u6924\\u0100;o\\u13f2\\u13f0ot;\\uc000\\u2250\\u0338ui\\xf6\\u0b63\\u0100ei\\u2a4a\\u2a4ear;\\u6928\\xed\\u0b98ist\\u0100;s\\u0ba0\\u0b9fr;\\uc000\\ud835\\udd2b\\u0200Eest\\u0bc5\\u2a66\\u2a79\\u2a7c\\u0180;qs\\u0bbc\\u2a6d\\u0be1\\u0180;qs\\u0bbc\\u0bc5\\u2a74lan\\xf4\\u0be2i\\xed\\u0bea\\u0100;r\\u0bb6\\u2a81\\xbb\\u0bb7\\u0180Aap\\u2a8a\\u2a8d\\u2a91r\\xf2\\u2971rr;\\u61aear;\\u6af2\\u0180;sv\\u0f8d\\u2a9c\\u0f8c\\u0100;d\\u2aa1\\u2aa2\\u62fc;\\u62facy;\\u445a\\u0380AEadest\\u2ab7\\u2aba\\u2abe\\u2ac2\\u2ac5\\u2af6\\u2af9r\\xf2\\u2966;\\uc000\\u2266\\u0338rr;\\u619ar;\\u6025\\u0200;fqs\\u0c3b\\u2ace\\u2ae3\\u2aeft\\u0100ar\\u2ad4\\u2ad9rro\\xf7\\u2ac1ightarro\\xf7\\u2a90\\u0180;qs\\u0c3b\\u2aba\\u2aealan\\xf4\\u0c55\\u0100;s\\u0c55\\u2af4\\xbb\\u0c36i\\xed\\u0c5d\\u0100;r\\u0c35\\u2afei\\u0100;e\\u0c1a\\u0c25i\\xe4\\u0d90\\u0100pt\\u2b0c\\u2b11f;\\uc000\\ud835\\udd5f\\u8180\\xac;in\\u2b19\\u2b1a\\u2b36\\u40acn\\u0200;Edv\\u0b89\\u2b24\\u2b28\\u2b2e;\\uc000\\u22f9\\u0338ot;\\uc000\\u22f5\\u0338\\u01e1\\u0b89\\u2b33\\u2b35;\\u62f7;\\u62f6i\\u0100;v\\u0cb8\\u2b3c\\u01e1\\u0cb8\\u2b41\\u2b43;\\u62fe;\\u62fd\\u0180aor\\u2b4b\\u2b63\\u2b69r\\u0200;ast\\u0b7b\\u2b55\\u2b5a\\u2b5flle\\xec\\u0b7bl;\\uc000\\u2afd\\u20e5;\\uc000\\u2202\\u0338lint;\\u6a14\\u0180;ce\\u0c92\\u2b70\\u2b73u\\xe5\\u0ca5\\u0100;c\\u0c98\\u2b78\\u0100;e\\u0c92\\u2b7d\\xf1\\u0c98\\u0200Aait\\u2b88\\u2b8b\\u2b9d\\u2ba7r\\xf2\\u2988rr\\u0180;cw\\u2b94\\u2b95\\u2b99\\u619b;\\uc000\\u2933\\u0338;\\uc000\\u219d\\u0338ghtarrow\\xbb\\u2b95ri\\u0100;e\\u0ccb\\u0cd6\\u0380chimpqu\\u2bbd\\u2bcd\\u2bd9\\u2b04\\u0b78\\u2be4\\u2bef\\u0200;cer\\u0d32\\u2bc6\\u0d37\\u2bc9u\\xe5\\u0d45;\\uc000\\ud835\\udcc3ort\\u026d\\u2b05\\0\\0\\u2bd6ar\\xe1\\u2b56m\\u0100;e\\u0d6e\\u2bdf\\u0100;q\\u0d74\\u0d73su\\u0100bp\\u2beb\\u2bed\\xe5\\u0cf8\\xe5\\u0d0b\\u0180bcp\\u2bf6\\u2c11\\u2c19\\u0200;Ees\\u2bff\\u2c00\\u0d22\\u2c04\\u6284;\\uc000\\u2ac5\\u0338et\\u0100;e\\u0d1b\\u2c0bq\\u0100;q\\u0d23\\u2c00c\\u0100;e\\u0d32\\u2c17\\xf1\\u0d38\\u0200;Ees\\u2c22\\u2c23\\u0d5f\\u2c27\\u6285;\\uc000\\u2ac6\\u0338et\\u0100;e\\u0d58\\u2c2eq\\u0100;q\\u0d60\\u2c23\\u0200gilr\\u2c3d\\u2c3f\\u2c45\\u2c47\\xec\\u0bd7lde\\u803b\\xf1\\u40f1\\xe7\\u0c43iangle\\u0100lr\\u2c52\\u2c5ceft\\u0100;e\\u0c1a\\u2c5a\\xf1\\u0c26ight\\u0100;e\\u0ccb\\u2c65\\xf1\\u0cd7\\u0100;m\\u2c6c\\u2c6d\\u43bd\\u0180;es\\u2c74\\u2c75\\u2c79\\u4023ro;\\u6116p;\\u6007\\u0480DHadgilrs\\u2c8f\\u2c94\\u2c99\\u2c9e\\u2ca3\\u2cb0\\u2cb6\\u2cd3\\u2ce3ash;\\u62adarr;\\u6904p;\\uc000\\u224d\\u20d2ash;\\u62ac\\u0100et\\u2ca8\\u2cac;\\uc000\\u2265\\u20d2;\\uc000>\\u20d2nfin;\\u69de\\u0180Aet\\u2cbd\\u2cc1\\u2cc5rr;\\u6902;\\uc000\\u2264\\u20d2\\u0100;r\\u2cca\\u2ccd\\uc000<\\u20d2ie;\\uc000\\u22b4\\u20d2\\u0100At\\u2cd8\\u2cdcrr;\\u6903rie;\\uc000\\u22b5\\u20d2im;\\uc000\\u223c\\u20d2\\u0180Aan\\u2cf0\\u2cf4\\u2d02rr;\\u61d6r\\u0100hr\\u2cfa\\u2cfdk;\\u6923\\u0100;o\\u13e7\\u13e5ear;\\u6927\\u1253\\u1a95\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\u2d2d\\0\\u2d38\\u2d48\\u2d60\\u2d65\\u2d72\\u2d84\\u1b07\\0\\0\\u2d8d\\u2dab\\0\\u2dc8\\u2dce\\0\\u2ddc\\u2e19\\u2e2b\\u2e3e\\u2e43\\u0100cs\\u2d31\\u1a97ute\\u803b\\xf3\\u40f3\\u0100iy\\u2d3c\\u2d45r\\u0100;c\\u1a9e\\u2d42\\u803b\\xf4\\u40f4;\\u443e\\u0280abios\\u1aa0\\u2d52\\u2d57\\u01c8\\u2d5alac;\\u4151v;\\u6a38old;\\u69bclig;\\u4153\\u0100cr\\u2d69\\u2d6dir;\\u69bf;\\uc000\\ud835\\udd2c\\u036f\\u2d79\\0\\0\\u2d7c\\0\\u2d82n;\\u42dbave\\u803b\\xf2\\u40f2;\\u69c1\\u0100bm\\u2d88\\u0df4ar;\\u69b5\\u0200acit\\u2d95\\u2d98\\u2da5\\u2da8r\\xf2\\u1a80\\u0100ir\\u2d9d\\u2da0r;\\u69beoss;\\u69bbn\\xe5\\u0e52;\\u69c0\\u0180aei\\u2db1\\u2db5\\u2db9cr;\\u414dga;\\u43c9\\u0180cdn\\u2dc0\\u2dc5\\u01cdron;\\u43bf;\\u69b6pf;\\uc000\\ud835\\udd60\\u0180ael\\u2dd4\\u2dd7\\u01d2r;\\u69b7rp;\\u69b9\\u0380;adiosv\\u2dea\\u2deb\\u2dee\\u2e08\\u2e0d\\u2e10\\u2e16\\u6228r\\xf2\\u1a86\\u0200;efm\\u2df7\\u2df8\\u2e02\\u2e05\\u6a5dr\\u0100;o\\u2dfe\\u2dff\\u6134f\\xbb\\u2dff\\u803b\\xaa\\u40aa\\u803b\\xba\\u40bagof;\\u62b6r;\\u6a56lope;\\u6a57;\\u6a5b\\u0180clo\\u2e1f\\u2e21\\u2e27\\xf2\\u2e01ash\\u803b\\xf8\\u40f8l;\\u6298i\\u016c\\u2e2f\\u2e34de\\u803b\\xf5\\u40f5es\\u0100;a\\u01db\\u2e3as;\\u6a36ml\\u803b\\xf6\\u40f6bar;\\u633d\\u0ae1\\u2e5e\\0\\u2e7d\\0\\u2e80\\u2e9d\\0\\u2ea2\\u2eb9\\0\\0\\u2ecb\\u0e9c\\0\\u2f13\\0\\0\\u2f2b\\u2fbc\\0\\u2fc8r\\u0200;ast\\u0403\\u2e67\\u2e72\\u0e85\\u8100\\xb6;l\\u2e6d\\u2e6e\\u40b6le\\xec\\u0403\\u0269\\u2e78\\0\\0\\u2e7bm;\\u6af3;\\u6afdy;\\u443fr\\u0280cimpt\\u2e8b\\u2e8f\\u2e93\\u1865\\u2e97nt;\\u4025od;\\u402eil;\\u6030enk;\\u6031r;\\uc000\\ud835\\udd2d\\u0180imo\\u2ea8\\u2eb0\\u2eb4\\u0100;v\\u2ead\\u2eae\\u43c6;\\u43d5ma\\xf4\\u0a76ne;\\u660e\\u0180;tv\\u2ebf\\u2ec0\\u2ec8\\u43c0chfork\\xbb\\u1ffd;\\u43d6\\u0100au\\u2ecf\\u2edfn\\u0100ck\\u2ed5\\u2eddk\\u0100;h\\u21f4\\u2edb;\\u610e\\xf6\\u21f4s\\u0480;abcdemst\\u2ef3\\u2ef4\\u1908\\u2ef9\\u2efd\\u2f04\\u2f06\\u2f0a\\u2f0e\\u402bcir;\\u6a23ir;\\u6a22\\u0100ou\\u1d40\\u2f02;\\u6a25;\\u6a72n\\u80bb\\xb1\\u0e9dim;\\u6a26wo;\\u6a27\\u0180ipu\\u2f19\\u2f20\\u2f25ntint;\\u6a15f;\\uc000\\ud835\\udd61nd\\u803b\\xa3\\u40a3\\u0500;Eaceinosu\\u0ec8\\u2f3f\\u2f41\\u2f44\\u2f47\\u2f81\\u2f89\\u2f92\\u2f7e\\u2fb6;\\u6ab3p;\\u6ab7u\\xe5\\u0ed9\\u0100;c\\u0ece\\u2f4c\\u0300;acens\\u0ec8\\u2f59\\u2f5f\\u2f66\\u2f68\\u2f7eppro\\xf8\\u2f43urlye\\xf1\\u0ed9\\xf1\\u0ece\\u0180aes\\u2f6f\\u2f76\\u2f7approx;\\u6ab9qq;\\u6ab5im;\\u62e8i\\xed\\u0edfme\\u0100;s\\u2f88\\u0eae\\u6032\\u0180Eas\\u2f78\\u2f90\\u2f7a\\xf0\\u2f75\\u0180dfp\\u0eec\\u2f99\\u2faf\\u0180als\\u2fa0\\u2fa5\\u2faalar;\\u632eine;\\u6312urf;\\u6313\\u0100;t\\u0efb\\u2fb4\\xef\\u0efbrel;\\u62b0\\u0100ci\\u2fc0\\u2fc5r;\\uc000\\ud835\\udcc5;\\u43c8ncsp;\\u6008\\u0300fiopsu\\u2fda\\u22e2\\u2fdf\\u2fe5\\u2feb\\u2ff1r;\\uc000\\ud835\\udd2epf;\\uc000\\ud835\\udd62rime;\\u6057cr;\\uc000\\ud835\\udcc6\\u0180aeo\\u2ff8\\u3009\\u3013t\\u0100ei\\u2ffe\\u3005rnion\\xf3\\u06b0nt;\\u6a16st\\u0100;e\\u3010\\u3011\\u403f\\xf1\\u1f19\\xf4\\u0f14\\u0a80ABHabcdefhilmnoprstux\\u3040\\u3051\\u3055\\u3059\\u30e0\\u310e\\u312b\\u3147\\u3162\\u3172\\u318e\\u3206\\u3215\\u3224\\u3229\\u3258\\u326e\\u3272\\u3290\\u32b0\\u32b7\\u0180art\\u3047\\u304a\\u304cr\\xf2\\u10b3\\xf2\\u03ddail;\\u691car\\xf2\\u1c65ar;\\u6964\\u0380cdenqrt\\u3068\\u3075\\u3078\\u307f\\u308f\\u3094\\u30cc\\u0100eu\\u306d\\u3071;\\uc000\\u223d\\u0331te;\\u4155i\\xe3\\u116emptyv;\\u69b3g\\u0200;del\\u0fd1\\u3089\\u308b\\u308d;\\u6992;\\u69a5\\xe5\\u0fd1uo\\u803b\\xbb\\u40bbr\\u0580;abcfhlpstw\\u0fdc\\u30ac\\u30af\\u30b7\\u30b9\\u30bc\\u30be\\u30c0\\u30c3\\u30c7\\u30cap;\\u6975\\u0100;f\\u0fe0\\u30b4s;\\u6920;\\u6933s;\\u691e\\xeb\\u225d\\xf0\\u272el;\\u6945im;\\u6974l;\\u61a3;\\u619d\\u0100ai\\u30d1\\u30d5il;\\u691ao\\u0100;n\\u30db\\u30dc\\u6236al\\xf3\\u0f1e\\u0180abr\\u30e7\\u30ea\\u30eer\\xf2\\u17e5rk;\\u6773\\u0100ak\\u30f3\\u30fdc\\u0100ek\\u30f9\\u30fb;\\u407d;\\u405d\\u0100es\\u3102\\u3104;\\u698cl\\u0100du\\u310a\\u310c;\\u698e;\\u6990\\u0200aeuy\\u3117\\u311c\\u3127\\u3129ron;\\u4159\\u0100di\\u3121\\u3125il;\\u4157\\xec\\u0ff2\\xe2\\u30fa;\\u4440\\u0200clqs\\u3134\\u3137\\u313d\\u3144a;\\u6937dhar;\\u6969uo\\u0100;r\\u020e\\u020dh;\\u61b3\\u0180acg\\u314e\\u315f\\u0f44l\\u0200;ips\\u0f78\\u3158\\u315b\\u109cn\\xe5\\u10bbar\\xf4\\u0fa9t;\\u65ad\\u0180ilr\\u3169\\u1023\\u316esht;\\u697d;\\uc000\\ud835\\udd2f\\u0100ao\\u3177\\u3186r\\u0100du\\u317d\\u317f\\xbb\\u047b\\u0100;l\\u1091\\u3184;\\u696c\\u0100;v\\u318b\\u318c\\u43c1;\\u43f1\\u0180gns\\u3195\\u31f9\\u31fcht\\u0300ahlrst\\u31a4\\u31b0\\u31c2\\u31d8\\u31e4\\u31eerrow\\u0100;t\\u0fdc\\u31ada\\xe9\\u30c8arpoon\\u0100du\\u31bb\\u31bfow\\xee\\u317ep\\xbb\\u1092eft\\u0100ah\\u31ca\\u31d0rrow\\xf3\\u0feaarpoon\\xf3\\u0551ightarrows;\\u61c9quigarro\\xf7\\u30cbhreetimes;\\u62ccg;\\u42daingdotse\\xf1\\u1f32\\u0180ahm\\u320d\\u3210\\u3213r\\xf2\\u0feaa\\xf2\\u0551;\\u600foust\\u0100;a\\u321e\\u321f\\u63b1che\\xbb\\u321fmid;\\u6aee\\u0200abpt\\u3232\\u323d\\u3240\\u3252\\u0100nr\\u3237\\u323ag;\\u67edr;\\u61fer\\xeb\\u1003\\u0180afl\\u3247\\u324a\\u324er;\\u6986;\\uc000\\ud835\\udd63us;\\u6a2eimes;\\u6a35\\u0100ap\\u325d\\u3267r\\u0100;g\\u3263\\u3264\\u4029t;\\u6994olint;\\u6a12ar\\xf2\\u31e3\\u0200achq\\u327b\\u3280\\u10bc\\u3285quo;\\u603ar;\\uc000\\ud835\\udcc7\\u0100bu\\u30fb\\u328ao\\u0100;r\\u0214\\u0213\\u0180hir\\u3297\\u329b\\u32a0re\\xe5\\u31f8mes;\\u62cai\\u0200;efl\\u32aa\\u1059\\u1821\\u32ab\\u65b9tri;\\u69celuhar;\\u6968;\\u611e\\u0d61\\u32d5\\u32db\\u32df\\u332c\\u3338\\u3371\\0\\u337a\\u33a4\\0\\0\\u33ec\\u33f0\\0\\u3428\\u3448\\u345a\\u34ad\\u34b1\\u34ca\\u34f1\\0\\u3616\\0\\0\\u3633cute;\\u415bqu\\xef\\u27ba\\u0500;Eaceinpsy\\u11ed\\u32f3\\u32f5\\u32ff\\u3302\\u330b\\u330f\\u331f\\u3326\\u3329;\\u6ab4\\u01f0\\u32fa\\0\\u32fc;\\u6ab8on;\\u4161u\\xe5\\u11fe\\u0100;d\\u11f3\\u3307il;\\u415frc;\\u415d\\u0180Eas\\u3316\\u3318\\u331b;\\u6ab6p;\\u6abaim;\\u62e9olint;\\u6a13i\\xed\\u1204;\\u4441ot\\u0180;be\\u3334\\u1d47\\u3335\\u62c5;\\u6a66\\u0380Aacmstx\\u3346\\u334a\\u3357\\u335b\\u335e\\u3363\\u336drr;\\u61d8r\\u0100hr\\u3350\\u3352\\xeb\\u2228\\u0100;o\\u0a36\\u0a34t\\u803b\\xa7\\u40a7i;\\u403bwar;\\u6929m\\u0100in\\u3369\\xf0nu\\xf3\\xf1t;\\u6736r\\u0100;o\\u3376\\u2055\\uc000\\ud835\\udd30\\u0200acoy\\u3382\\u3386\\u3391\\u33a0rp;\\u666f\\u0100hy\\u338b\\u338fcy;\\u4449;\\u4448rt\\u026d\\u3399\\0\\0\\u339ci\\xe4\\u1464ara\\xec\\u2e6f\\u803b\\xad\\u40ad\\u0100gm\\u33a8\\u33b4ma\\u0180;fv\\u33b1\\u33b2\\u33b2\\u43c3;\\u43c2\\u0400;deglnpr\\u12ab\\u33c5\\u33c9\\u33ce\\u33d6\\u33de\\u33e1\\u33e6ot;\\u6a6a\\u0100;q\\u12b1\\u12b0\\u0100;E\\u33d3\\u33d4\\u6a9e;\\u6aa0\\u0100;E\\u33db\\u33dc\\u6a9d;\\u6a9fe;\\u6246lus;\\u6a24arr;\\u6972ar\\xf2\\u113d\\u0200aeit\\u33f8\\u3408\\u340f\\u3417\\u0100ls\\u33fd\\u3404lsetm\\xe9\\u336ahp;\\u6a33parsl;\\u69e4\\u0100dl\\u1463\\u3414e;\\u6323\\u0100;e\\u341c\\u341d\\u6aaa\\u0100;s\\u3422\\u3423\\u6aac;\\uc000\\u2aac\\ufe00\\u0180flp\\u342e\\u3433\\u3442tcy;\\u444c\\u0100;b\\u3438\\u3439\\u402f\\u0100;a\\u343e\\u343f\\u69c4r;\\u633ff;\\uc000\\ud835\\udd64a\\u0100dr\\u344d\\u0402es\\u0100;u\\u3454\\u3455\\u6660it\\xbb\\u3455\\u0180csu\\u3460\\u3479\\u349f\\u0100au\\u3465\\u346fp\\u0100;s\\u1188\\u346b;\\uc000\\u2293\\ufe00p\\u0100;s\\u11b4\\u3475;\\uc000\\u2294\\ufe00u\\u0100bp\\u347f\\u348f\\u0180;es\\u1197\\u119c\\u3486et\\u0100;e\\u1197\\u348d\\xf1\\u119d\\u0180;es\\u11a8\\u11ad\\u3496et\\u0100;e\\u11a8\\u349d\\xf1\\u11ae\\u0180;af\\u117b\\u34a6\\u05b0r\\u0165\\u34ab\\u05b1\\xbb\\u117car\\xf2\\u1148\\u0200cemt\\u34b9\\u34be\\u34c2\\u34c5r;\\uc000\\ud835\\udcc8tm\\xee\\xf1i\\xec\\u3415ar\\xe6\\u11be\\u0100ar\\u34ce\\u34d5r\\u0100;f\\u34d4\\u17bf\\u6606\\u0100an\\u34da\\u34edight\\u0100ep\\u34e3\\u34eapsilo\\xee\\u1ee0h\\xe9\\u2eafs\\xbb\\u2852\\u0280bcmnp\\u34fb\\u355e\\u1209\\u358b\\u358e\\u0480;Edemnprs\\u350e\\u350f\\u3511\\u3515\\u351e\\u3523\\u352c\\u3531\\u3536\\u6282;\\u6ac5ot;\\u6abd\\u0100;d\\u11da\\u351aot;\\u6ac3ult;\\u6ac1\\u0100Ee\\u3528\\u352a;\\u6acb;\\u628alus;\\u6abfarr;\\u6979\\u0180eiu\\u353d\\u3552\\u3555t\\u0180;en\\u350e\\u3545\\u354bq\\u0100;q\\u11da\\u350feq\\u0100;q\\u352b\\u3528m;\\u6ac7\\u0100bp\\u355a\\u355c;\\u6ad5;\\u6ad3c\\u0300;acens\\u11ed\\u356c\\u3572\\u3579\\u357b\\u3326ppro\\xf8\\u32faurlye\\xf1\\u11fe\\xf1\\u11f3\\u0180aes\\u3582\\u3588\\u331bppro\\xf8\\u331aq\\xf1\\u3317g;\\u666a\\u0680123;Edehlmnps\\u35a9\\u35ac\\u35af\\u121c\\u35b2\\u35b4\\u35c0\\u35c9\\u35d5\\u35da\\u35df\\u35e8\\u35ed\\u803b\\xb9\\u40b9\\u803b\\xb2\\u40b2\\u803b\\xb3\\u40b3;\\u6ac6\\u0100os\\u35b9\\u35bct;\\u6abeub;\\u6ad8\\u0100;d\\u1222\\u35c5ot;\\u6ac4s\\u0100ou\\u35cf\\u35d2l;\\u67c9b;\\u6ad7arr;\\u697bult;\\u6ac2\\u0100Ee\\u35e4\\u35e6;\\u6acc;\\u628blus;\\u6ac0\\u0180eiu\\u35f4\\u3609\\u360ct\\u0180;en\\u121c\\u35fc\\u3602q\\u0100;q\\u1222\\u35b2eq\\u0100;q\\u35e7\\u35e4m;\\u6ac8\\u0100bp\\u3611\\u3613;\\u6ad4;\\u6ad6\\u0180Aan\\u361c\\u3620\\u362drr;\\u61d9r\\u0100hr\\u3626\\u3628\\xeb\\u222e\\u0100;o\\u0a2b\\u0a29war;\\u692alig\\u803b\\xdf\\u40df\\u0be1\\u3651\\u365d\\u3660\\u12ce\\u3673\\u3679\\0\\u367e\\u36c2\\0\\0\\0\\0\\0\\u36db\\u3703\\0\\u3709\\u376c\\0\\0\\0\\u3787\\u0272\\u3656\\0\\0\\u365bget;\\u6316;\\u43c4r\\xeb\\u0e5f\\u0180aey\\u3666\\u366b\\u3670ron;\\u4165dil;\\u4163;\\u4442lrec;\\u6315r;\\uc000\\ud835\\udd31\\u0200eiko\\u3686\\u369d\\u36b5\\u36bc\\u01f2\\u368b\\0\\u3691e\\u01004f\\u1284\\u1281a\\u0180;sv\\u3698\\u3699\\u369b\\u43b8ym;\\u43d1\\u0100cn\\u36a2\\u36b2k\\u0100as\\u36a8\\u36aeppro\\xf8\\u12c1im\\xbb\\u12acs\\xf0\\u129e\\u0100as\\u36ba\\u36ae\\xf0\\u12c1rn\\u803b\\xfe\\u40fe\\u01ec\\u031f\\u36c6\\u22e7es\\u8180\\xd7;bd\\u36cf\\u36d0\\u36d8\\u40d7\\u0100;a\\u190f\\u36d5r;\\u6a31;\\u6a30\\u0180eps\\u36e1\\u36e3\\u3700\\xe1\\u2a4d\\u0200;bcf\\u0486\\u36ec\\u36f0\\u36f4ot;\\u6336ir;\\u6af1\\u0100;o\\u36f9\\u36fc\\uc000\\ud835\\udd65rk;\\u6ada\\xe1\\u3362rime;\\u6034\\u0180aip\\u370f\\u3712\\u3764d\\xe5\\u1248\\u0380adempst\\u3721\\u374d\\u3740\\u3751\\u3757\\u375c\\u375fngle\\u0280;dlqr\\u3730\\u3731\\u3736\\u3740\\u3742\\u65b5own\\xbb\\u1dbbeft\\u0100;e\\u2800\\u373e\\xf1\\u092e;\\u625cight\\u0100;e\\u32aa\\u374b\\xf1\\u105aot;\\u65ecinus;\\u6a3alus;\\u6a39b;\\u69cdime;\\u6a3bezium;\\u63e2\\u0180cht\\u3772\\u377d\\u3781\\u0100ry\\u3777\\u377b;\\uc000\\ud835\\udcc9;\\u4446cy;\\u445brok;\\u4167\\u0100io\\u378b\\u378ex\\xf4\\u1777head\\u0100lr\\u3797\\u37a0eftarro\\xf7\\u084fightarrow\\xbb\\u0f5d\\u0900AHabcdfghlmoprstuw\\u37d0\\u37d3\\u37d7\\u37e4\\u37f0\\u37fc\\u380e\\u381c\\u3823\\u3834\\u3851\\u385d\\u386b\\u38a9\\u38cc\\u38d2\\u38ea\\u38f6r\\xf2\\u03edar;\\u6963\\u0100cr\\u37dc\\u37e2ute\\u803b\\xfa\\u40fa\\xf2\\u1150r\\u01e3\\u37ea\\0\\u37edy;\\u445eve;\\u416d\\u0100iy\\u37f5\\u37farc\\u803b\\xfb\\u40fb;\\u4443\\u0180abh\\u3803\\u3806\\u380br\\xf2\\u13adlac;\\u4171a\\xf2\\u13c3\\u0100ir\\u3813\\u3818sht;\\u697e;\\uc000\\ud835\\udd32rave\\u803b\\xf9\\u40f9\\u0161\\u3827\\u3831r\\u0100lr\\u382c\\u382e\\xbb\\u0957\\xbb\\u1083lk;\\u6580\\u0100ct\\u3839\\u384d\\u026f\\u383f\\0\\0\\u384arn\\u0100;e\\u3845\\u3846\\u631cr\\xbb\\u3846op;\\u630fri;\\u65f8\\u0100al\\u3856\\u385acr;\\u416b\\u80bb\\xa8\\u0349\\u0100gp\\u3862\\u3866on;\\u4173f;\\uc000\\ud835\\udd66\\u0300adhlsu\\u114b\\u3878\\u387d\\u1372\\u3891\\u38a0own\\xe1\\u13b3arpoon\\u0100lr\\u3888\\u388cef\\xf4\\u382digh\\xf4\\u382fi\\u0180;hl\\u3899\\u389a\\u389c\\u43c5\\xbb\\u13faon\\xbb\\u389aparrows;\\u61c8\\u0180cit\\u38b0\\u38c4\\u38c8\\u026f\\u38b6\\0\\0\\u38c1rn\\u0100;e\\u38bc\\u38bd\\u631dr\\xbb\\u38bdop;\\u630eng;\\u416fri;\\u65f9cr;\\uc000\\ud835\\udcca\\u0180dir\\u38d9\\u38dd\\u38e2ot;\\u62f0lde;\\u4169i\\u0100;f\\u3730\\u38e8\\xbb\\u1813\\u0100am\\u38ef\\u38f2r\\xf2\\u38a8l\\u803b\\xfc\\u40fcangle;\\u69a7\\u0780ABDacdeflnoprsz\\u391c\\u391f\\u3929\\u392d\\u39b5\\u39b8\\u39bd\\u39df\\u39e4\\u39e8\\u39f3\\u39f9\\u39fd\\u3a01\\u3a20r\\xf2\\u03f7ar\\u0100;v\\u3926\\u3927\\u6ae8;\\u6ae9as\\xe8\\u03e1\\u0100nr\\u3932\\u3937grt;\\u699c\\u0380eknprst\\u34e3\\u3946\\u394b\\u3952\\u395d\\u3964\\u3996app\\xe1\\u2415othin\\xe7\\u1e96\\u0180hir\\u34eb\\u2ec8\\u3959op\\xf4\\u2fb5\\u0100;h\\u13b7\\u3962\\xef\\u318d\\u0100iu\\u3969\\u396dgm\\xe1\\u33b3\\u0100bp\\u3972\\u3984setneq\\u0100;q\\u397d\\u3980\\uc000\\u228a\\ufe00;\\uc000\\u2acb\\ufe00setneq\\u0100;q\\u398f\\u3992\\uc000\\u228b\\ufe00;\\uc000\\u2acc\\ufe00\\u0100hr\\u399b\\u399fet\\xe1\\u369ciangle\\u0100lr\\u39aa\\u39afeft\\xbb\\u0925ight\\xbb\\u1051y;\\u4432ash\\xbb\\u1036\\u0180elr\\u39c4\\u39d2\\u39d7\\u0180;be\\u2dea\\u39cb\\u39cfar;\\u62bbq;\\u625alip;\\u62ee\\u0100bt\\u39dc\\u1468a\\xf2\\u1469r;\\uc000\\ud835\\udd33tr\\xe9\\u39aesu\\u0100bp\\u39ef\\u39f1\\xbb\\u0d1c\\xbb\\u0d59pf;\\uc000\\ud835\\udd67ro\\xf0\\u0efbtr\\xe9\\u39b4\\u0100cu\\u3a06\\u3a0br;\\uc000\\ud835\\udccb\\u0100bp\\u3a10\\u3a18n\\u0100Ee\\u3980\\u3a16\\xbb\\u397en\\u0100Ee\\u3992\\u3a1e\\xbb\\u3990igzag;\\u699a\\u0380cefoprs\\u3a36\\u3a3b\\u3a56\\u3a5b\\u3a54\\u3a61\\u3a6airc;\\u4175\\u0100di\\u3a40\\u3a51\\u0100bg\\u3a45\\u3a49ar;\\u6a5fe\\u0100;q\\u15fa\\u3a4f;\\u6259erp;\\u6118r;\\uc000\\ud835\\udd34pf;\\uc000\\ud835\\udd68\\u0100;e\\u1479\\u3a66at\\xe8\\u1479cr;\\uc000\\ud835\\udccc\\u0ae3\\u178e\\u3a87\\0\\u3a8b\\0\\u3a90\\u3a9b\\0\\0\\u3a9d\\u3aa8\\u3aab\\u3aaf\\0\\0\\u3ac3\\u3ace\\0\\u3ad8\\u17dc\\u17dftr\\xe9\\u17d1r;\\uc000\\ud835\\udd35\\u0100Aa\\u3a94\\u3a97r\\xf2\\u03c3r\\xf2\\u09f6;\\u43be\\u0100Aa\\u3aa1\\u3aa4r\\xf2\\u03b8r\\xf2\\u09eba\\xf0\\u2713is;\\u62fb\\u0180dpt\\u17a4\\u3ab5\\u3abe\\u0100fl\\u3aba\\u17a9;\\uc000\\ud835\\udd69im\\xe5\\u17b2\\u0100Aa\\u3ac7\\u3acar\\xf2\\u03cer\\xf2\\u0a01\\u0100cq\\u3ad2\\u17b8r;\\uc000\\ud835\\udccd\\u0100pt\\u17d6\\u3adcr\\xe9\\u17d4\\u0400acefiosu\\u3af0\\u3afd\\u3b08\\u3b0c\\u3b11\\u3b15\\u3b1b\\u3b21c\\u0100uy\\u3af6\\u3afbte\\u803b\\xfd\\u40fd;\\u444f\\u0100iy\\u3b02\\u3b06rc;\\u4177;\\u444bn\\u803b\\xa5\\u40a5r;\\uc000\\ud835\\udd36cy;\\u4457pf;\\uc000\\ud835\\udd6acr;\\uc000\\ud835\\udcce\\u0100cm\\u3b26\\u3b29y;\\u444el\\u803b\\xff\\u40ff\\u0500acdefhiosw\\u3b42\\u3b48\\u3b54\\u3b58\\u3b64\\u3b69\\u3b6d\\u3b74\\u3b7a\\u3b80cute;\\u417a\\u0100ay\\u3b4d\\u3b52ron;\\u417e;\\u4437ot;\\u417c\\u0100et\\u3b5d\\u3b61tr\\xe6\\u155fa;\\u43b6r;\\uc000\\ud835\\udd37cy;\\u4436grarr;\\u61ddpf;\\uc000\\ud835\\udd6bcr;\\uc000\\ud835\\udccf\\u0100jn\\u3b85\\u3b87;\\u600dj;\\u600c\"\n    .split(\"\")\n    .map((c) => c.charCodeAt(0))));\n//# sourceMappingURL=decode-data-html.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBLCtEQUFlO0FBQ2Y7QUFDQSxzY0FBc2MsZ0JBQWdCLG1CQUFtQixRQUFRLDBDQUEwQyxVQUFVLFFBQVEseUJBQXlCLFFBQVEsOEJBQThCLDJDQUEyQyxzQkFBc0IsMkhBQTJILHFCQUFxQixTQUFTLFFBQVEsc0NBQXNDLGNBQWMsUUFBUSxRQUFRLHFCQUFxQixzQkFBc0Isc0JBQXNCLGlIQUFpSCx1REFBdUQsYUFBYSxvQ0FBb0MsV0FBVyw0Q0FBNEMsNEJBQTRCLFdBQVcsU0FBUywrQkFBK0IsYUFBYSxrQkFBa0IsK0NBQStDLFdBQVcsVUFBVSxXQUFXLGdEQUFnRCwyQ0FBMkMsV0FBVyxpREFBaUQsb0JBQW9CLHVDQUF1QyxTQUFTLGtCQUFrQiwyQkFBMkIsWUFBWSxtQ0FBbUMsVUFBVSxTQUFTLDBCQUEwQixzQkFBc0IsZ0dBQWdHLG1CQUFtQixTQUFTLFNBQVMsU0FBUyxxQ0FBcUMsUUFBUSxTQUFTLDhCQUE4QixPQUFPLGNBQWMscUJBQXFCLFFBQVEsd0dBQXdHLDBCQUEwQixlQUFlLFdBQVcsV0FBVyxVQUFVLGlCQUFpQiw4Q0FBOEMseUJBQXlCLDZCQUE2QixXQUFXLHdIQUF3SCw0REFBNEQsZ0JBQWdCLG1FQUFtRSxnQkFBZ0IsZ0JBQWdCLG1DQUFtQyxTQUFTLGtDQUFrQyxlQUFlLGlCQUFpQixrRUFBa0UsNkJBQTZCLGFBQWEsV0FBVyxnREFBZ0QsZUFBZSxrQkFBa0Isc0JBQXNCLHVDQUF1QyxrQkFBa0Isc0JBQXNCLGVBQWUsd0JBQXdCLDRCQUE0QixzQkFBc0IsOEhBQThILDBFQUEwRSx5QkFBeUIsU0FBUyxRQUFRLDRDQUE0Qyw2QkFBNkIseUNBQXlDLHFCQUFxQiw2QkFBNkIsUUFBUSx3QkFBd0IsbUNBQW1DLHdCQUF3QixjQUFjLDRCQUE0QixRQUFRLFFBQVEsZ0RBQWdELGdCQUFnQixpREFBaUQsUUFBUSx1REFBdUQscUJBQXFCLHNDQUFzQyxzQkFBc0IsY0FBYyw4R0FBOEcsNkJBQTZCLG9CQUFvQixXQUFXLHFDQUFxQyxTQUFTLE9BQU8sU0FBUyxRQUFRLG1CQUFtQixTQUFTLGtGQUFrRix1QkFBdUIsZUFBZSxhQUFhLFVBQVUsZ0JBQWdCLFdBQVcsU0FBUyxtQkFBbUIseUVBQXlFLDZCQUE2QixPQUFPLFVBQVUsUUFBUSxpQkFBaUIsNEJBQTRCLGtCQUFrQix3Q0FBd0MsK0NBQStDLGlIQUFpSCxVQUFVLFNBQVMsaUVBQWlFLFNBQVMsUUFBUSxpQ0FBaUMsMENBQTBDLGFBQWEsOENBQThDLDJDQUEyQyxjQUFjLHFDQUFxQyxXQUFXLG9DQUFvQyxRQUFRLG9CQUFvQixTQUFTLFdBQVcsNkJBQTZCLHVGQUF1RixPQUFPLFFBQVEscUJBQXFCLHdDQUF3QyxzQkFBc0IsVUFBVSxnRUFBZ0UsU0FBUyxVQUFVLDhCQUE4QixPQUFPLFFBQVEscUJBQXFCLHFCQUFxQix3R0FBd0csZ0VBQWdFLFVBQVUsUUFBUSxjQUFjLFFBQVEscUNBQXFDLFVBQVUsT0FBTyxzSUFBc0ksZ0JBQWdCLDZCQUE2QixnQkFBZ0IsYUFBYSxzQ0FBc0Msb0NBQW9DLGtCQUFrQixzQkFBc0IsV0FBVyxtQ0FBbUMsWUFBWSxrQ0FBa0MsK0JBQStCLFlBQVksbUJBQW1CLDZCQUE2QixXQUFXLDRDQUE0QyxlQUFlLGtCQUFrQixzQkFBc0Isa0JBQWtCLHNCQUFzQixpRkFBaUYsZUFBZSxhQUFhLFVBQVUsZ0JBQWdCLFdBQVcsUUFBUSx5QkFBeUIsMkJBQTJCLFdBQVcsZ0dBQWdHLGdCQUFnQixnQkFBZ0IsMkRBQTJELGlEQUFpRCxnQkFBZ0IsNENBQTRDLFVBQVUsT0FBTyxzRUFBc0UsUUFBUSxtQ0FBbUMsYUFBYSxRQUFRLDBCQUEwQixTQUFTLDhCQUE4Qiw4RUFBOEUsV0FBVyxxQ0FBcUMsVUFBVSxPQUFPLDRFQUE0RSx3SEFBd0gsUUFBUSx5REFBeUQsb0JBQW9CLFFBQVEsYUFBYSw0SEFBNEgsV0FBVyx1QkFBdUIsdUNBQXVDLGdCQUFnQix3QkFBd0IsdUJBQXVCLG1CQUFtQiwyREFBMkQsZUFBZSx5QkFBeUIsc0JBQXNCLGdCQUFnQix1QkFBdUIsbUNBQW1DLHVCQUF1Qix1REFBdUQsNkJBQTZCLHVCQUF1QixjQUFjLG9EQUFvRCxhQUFhLFVBQVUsNEJBQTRCLHVCQUF1Qiw2Q0FBNkMsMEJBQTBCLGdDQUFnQywrQkFBK0IsNEJBQTRCLHVDQUF1Qyx3QkFBd0IsNkJBQTZCLHVCQUF1Qiw4REFBOEQsb0NBQW9DLGtCQUFrQixvQ0FBb0MsMkNBQTJDLG9DQUFvQyxrQkFBa0Isc0NBQXNDLDRCQUE0QixXQUFXLDhCQUE4QixvQ0FBb0MsaUJBQWlCLHNDQUFzQyxlQUFlLFdBQVcsaUJBQWlCLFNBQVMsdUNBQXVDLGtIQUFrSCxpRUFBaUUsV0FBVyxRQUFRLG9FQUFvRSxTQUFTLFdBQVcsU0FBUyx3REFBd0QsV0FBVyxPQUFPLDRCQUE0Qiw2RUFBNkUsb0VBQW9FLDZCQUE2QixTQUFTLGlCQUFpQixrRkFBa0YsUUFBUSxRQUFRLG9CQUFvQixPQUFPLGNBQWMsK0NBQStDLGFBQWEsNkNBQTZDLHNDQUFzQyxnQkFBZ0IsV0FBVyxTQUFTLDhCQUE4QixtQkFBbUIsZUFBZSw0QkFBNEIsbUJBQW1CLDBEQUEwRCxxQkFBcUIsU0FBUyxnSEFBZ0gsc0RBQXNELFFBQVEsY0FBYyxxQkFBcUIscUNBQXFDLFVBQVUsT0FBTyxhQUFhLHFFQUFxRSxnQkFBZ0IsbUJBQW1CLG1CQUFtQixzR0FBc0csZ0JBQWdCLDZCQUE2QixlQUFlLGFBQWEsc0NBQXNDLG9DQUFvQyxrQkFBa0Isc0JBQXNCLFdBQVcsa0NBQWtDLCtCQUErQixZQUFZLG1CQUFtQiw2QkFBNkIsV0FBVyw0Q0FBNEMsZUFBZSxrQkFBa0Isc0JBQXNCLGtCQUFrQixzQkFBc0IsNEJBQTRCLGdCQUFnQixnQkFBZ0IsNEJBQTRCLE9BQU8sZ0JBQWdCLCtIQUErSCxRQUFRLFdBQVcsV0FBVyxhQUFhLDRDQUE0QyxVQUFVLFNBQVMsT0FBTyxRQUFRLHFIQUFxSCxVQUFVLGdCQUFnQixTQUFTLDBDQUEwQyxnQkFBZ0IsNkNBQTZDLHFDQUFxQyx3QkFBd0Isa0JBQWtCLHdCQUF3QixXQUFXLFNBQVMscUJBQXFCLCtDQUErQyw0QkFBNEIsa0JBQWtCLHFDQUFxQyxzQ0FBc0MsZ0JBQWdCLFdBQVcsbUJBQW1CLGFBQWEscUNBQXFDLHdCQUF3Qiw0SEFBNEgsNkJBQTZCLFFBQVEsMkJBQTJCLE9BQU8scUNBQXFDLFVBQVUsT0FBTyxRQUFRLGdFQUFnRSxRQUFRLGlDQUFpQyx3QkFBd0IsZ0JBQWdCLHNDQUFzQyxlQUFlLFdBQVcsU0FBUywwQkFBMEIsNEJBQTRCLHNCQUFzQiw2SkFBNkosdUJBQXVCLDZCQUE2QixTQUFTLDZDQUE2QyxXQUFXLFFBQVEsMENBQTBDLHNFQUFzRSw2QkFBNkIsU0FBUyxpQkFBaUIsZUFBZSx1QkFBdUIsNkJBQTZCLFFBQVEsMkZBQTJGLHVCQUF1QixlQUFlLGVBQWUsaUJBQWlCLGVBQWUsd0JBQXdCLGtEQUFrRCxnQkFBZ0IsY0FBYyxzQkFBc0IsVUFBVSxTQUFTLHVCQUF1QixpR0FBaUcsU0FBUyxRQUFRLGdCQUFnQixvQkFBb0IsMkJBQTJCLG9DQUFvQyxhQUFhLHFEQUFxRCxVQUFVLGVBQWUsV0FBVyxnQkFBZ0IsUUFBUSxxQkFBcUIscUJBQXFCLHVCQUF1QixtREFBbUQsVUFBVSxRQUFRLHFCQUFxQixxQkFBcUIsc0RBQXNELG1CQUFtQixTQUFTLHFCQUFxQiwwRkFBMEYsU0FBUyxTQUFTLGlEQUFpRCxPQUFPLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsdUVBQXVFLFdBQVcsOEJBQThCLE9BQU8sU0FBUywyQ0FBMkMsUUFBUSxTQUFTLFNBQVMsK0pBQStKLGFBQWEsZ0RBQWdELG1CQUFtQiwyQ0FBMkMsZ0NBQWdDLFlBQVksa0ZBQWtGLG1CQUFtQiwyQ0FBMkMsUUFBUSxtQ0FBbUMsMkNBQTJDLE9BQU8sV0FBVyxPQUFPLGFBQWEsdURBQXVELDBCQUEwQiwwRUFBMEUsT0FBTyxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxjQUFjLDJCQUEyQixvQkFBb0IsNEJBQTRCLGtCQUFrQiw2QkFBNkIsUUFBUSx5QkFBeUIsaURBQWlELFVBQVUsT0FBTyxRQUFRLFFBQVEsZ0JBQWdCLHVFQUF1RSxtQkFBbUIsZUFBZSxrR0FBa0csK0hBQStILGlFQUFpRSxhQUFhLFdBQVcsZUFBZSxxQkFBcUIsMkJBQTJCLGVBQWUsdUNBQXVDLGlCQUFpQiwyQkFBMkIsVUFBVSx5REFBeUQsa0JBQWtCLHlEQUF5RCxPQUFPLFVBQVUsUUFBUSxrSEFBa0gsK0NBQStDLFVBQVUsV0FBVyxnQ0FBZ0MsU0FBUyxxQ0FBcUMsUUFBUSxXQUFXLGdDQUFnQyx3RkFBd0Ysb0JBQW9CLHFDQUFxQyxVQUFVLFdBQVcsUUFBUSwrQ0FBK0MsT0FBTyxRQUFRLFNBQVMsaUNBQWlDLDhCQUE4QixvQkFBb0IsMENBQTBDLHlCQUF5Qiw2QkFBNkIsbUlBQW1JLE9BQU8sT0FBTyxPQUFPLGFBQWEseUNBQXlDLE9BQU8sT0FBTyxPQUFPLHlDQUF5QyxPQUFPLE9BQU8sT0FBTyxhQUFhLHVEQUF1RCxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sU0FBUyx5Q0FBeUMsT0FBTyxPQUFPLE9BQU8sYUFBYSxtQ0FBbUMsT0FBTyxPQUFPLE9BQU8sV0FBVyxVQUFVLFdBQVcseUNBQXlDLE9BQU8sT0FBTyxPQUFPLGFBQWEsdURBQXVELE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxpRkFBaUYscUJBQXFCLGNBQWMscUJBQXFCLDJCQUEyQixVQUFVLGdDQUFnQyxzQ0FBc0MscUJBQXFCLGFBQWEsZ0tBQWdLLGFBQWEsa0RBQWtELFdBQVcsNEJBQTRCLFFBQVEsU0FBUyxPQUFPLHdDQUF3Qyx3RUFBd0UsU0FBUyw0QkFBNEIsZUFBZSxxQkFBcUIsU0FBUyx3REFBd0Qsa0JBQWtCLGdDQUFnQywrQ0FBK0MsZUFBZSxpQ0FBaUMsY0FBYyx1REFBdUQsYUFBYSw0QkFBNEIseURBQXlELFdBQVcsMERBQTBELFNBQVMsVUFBVSxVQUFVLFdBQVcsU0FBUyxVQUFVLGdCQUFnQix3RUFBd0UsMEJBQTBCLHVDQUF1QyxvQkFBb0IsYUFBYSw0R0FBNEcsZ0JBQWdCLDZDQUE2Qyx3Q0FBd0MsZUFBZSw2QkFBNkIsU0FBUyw0QkFBNEIsNkNBQTZDLG9CQUFvQixhQUFhLG9CQUFvQixVQUFVLHFGQUFxRixPQUFPLDhCQUE4QixRQUFRLGdCQUFnQixvQkFBb0IsYUFBYSxvREFBb0QsNEJBQTRCLFFBQVEsU0FBUyxRQUFRLE9BQU8sNkRBQTZELG9CQUFvQixtRkFBbUYsV0FBVyw2SEFBNkgsV0FBVywrSkFBK0osNENBQTRDLFVBQVUsd0JBQXdCLG9EQUFvRCx5Q0FBeUMsT0FBTyxhQUFhLDBDQUEwQyxXQUFXLG9EQUFvRCxXQUFXLDhCQUE4QixPQUFPLDZHQUE2Ryw2QkFBNkIsaUJBQWlCLFdBQVcsU0FBUyxhQUFhLHVDQUF1QyxvQkFBb0Isb0JBQW9CLGdDQUFnQyxTQUFTLG1EQUFtRCxRQUFRLHlCQUF5QiwwQ0FBMEMsZ0JBQWdCLFdBQVcsVUFBVSxZQUFZLGtMQUFrTCxTQUFTLHNEQUFzRCxtQkFBbUIsUUFBUSxVQUFVLDZCQUE2QixjQUFjLG1FQUFtRSw0QkFBNEIsWUFBWSxvTkFBb04sNENBQTRDLGNBQWMsdUNBQXVDLE9BQU8sU0FBUyw2QkFBNkIsT0FBTyx5QkFBeUIsb0RBQW9ELHNCQUFzQixhQUFhLHVDQUF1QyxPQUFPLGFBQWEsc0JBQXNCLG9DQUFvQyxlQUFlLCtDQUErQywrQkFBK0IsT0FBTyxpQ0FBaUMsUUFBUSw2QkFBNkIsUUFBUSxxREFBcUQscUJBQXFCLFNBQVMsY0FBYyx1Q0FBdUMsc0xBQXNMLFNBQVMsY0FBYyxlQUFlLFlBQVksNkJBQTZCLFNBQVMsbUNBQW1DLHNDQUFzQyw2REFBNkQsbUNBQW1DLHdMQUF3TCxXQUFXLHFDQUFxQyxvQ0FBb0MsZUFBZSxhQUFhLHNCQUFzQixnQkFBZ0IscUNBQXFDLFNBQVMsZUFBZSxTQUFTLDRCQUE0Qiw2Q0FBNkMsb0JBQW9CLGFBQWEsdUpBQXVKLHVCQUF1QixPQUFPLE9BQU8sMkJBQTJCLE9BQU8sbURBQW1ELE9BQU8sUUFBUSwyQkFBMkIsT0FBTyxRQUFRLFFBQVEsU0FBUyxTQUFTLHNKQUFzSixjQUFjLHFDQUFxQyxlQUFlLG9CQUFvQixXQUFXLDZCQUE2QixPQUFPLFNBQVMsYUFBYSxrQ0FBa0Msd0NBQXdDLDZCQUE2QixlQUFlLDBCQUEwQixvQkFBb0IsYUFBYSxpQ0FBaUMsUUFBUSx5QkFBeUIsaUJBQWlCLFNBQVMsYUFBYSw0QkFBNEIsT0FBTyxPQUFPLHlDQUF5QyxjQUFjLHVDQUF1QywwQkFBMEIsZ0JBQWdCLFNBQVMsd0NBQXdDLGNBQWMscUJBQXFCLE9BQU8sY0FBYyw4REFBOEQsUUFBUSxTQUFTLFVBQVUsV0FBVyxrRkFBa0YsOEVBQThFLCtNQUErTSxhQUFhLHVCQUF1QixPQUFPLFNBQVMsVUFBVSwyQ0FBMkMsbUNBQW1DLFVBQVUsUUFBUSw0Q0FBNEMsV0FBVyxrREFBa0QsVUFBVSxvQ0FBb0MsZ0JBQWdCLFFBQVEsc0JBQXNCLG1DQUFtQyxrQ0FBa0MsOEJBQThCLDBKQUEwSix1Q0FBdUMsNEJBQTRCLDZDQUE2Qyw2Q0FBNkMsa0RBQWtELFFBQVEsVUFBVSxTQUFTLFVBQVUsOERBQThELDJEQUEyRCxRQUFRLFNBQVMsYUFBYSxzQ0FBc0MsZUFBZSxzQkFBc0IseUJBQXlCLHFDQUFxQyxxREFBcUQsVUFBVSwwQ0FBMEMsU0FBUyxRQUFRLG9CQUFvQixnREFBZ0QsMEJBQTBCLG1DQUFtQyxTQUFTLGFBQWEsb0JBQW9CLGFBQWEsaUJBQWlCLDZCQUE2Qiw4RkFBOEYsT0FBTyxRQUFRLHNCQUFzQixTQUFTLHdDQUF3QyxzQkFBc0IsVUFBVSw4RUFBOEUsb0JBQW9CLDhCQUE4QixPQUFPLFFBQVEsdUJBQXVCLFNBQVMsU0FBUyxTQUFTLHFCQUFxQiw2T0FBNk8sVUFBVSxhQUFhLGNBQWMsU0FBUyx3RkFBd0YsWUFBWSxzQkFBc0IsY0FBYyxxQkFBcUIsaUJBQWlCLGdDQUFnQyw4REFBOEQsZUFBZSxRQUFRLGtCQUFrQixRQUFRLFNBQVMsUUFBUSxhQUFhLDZCQUE2QixhQUFhLG9CQUFvQixnREFBZ0QsU0FBUyxnREFBZ0QsT0FBTywyQkFBMkIsNEJBQTRCLE9BQU8sNENBQTRDLDZCQUE2QiwyQkFBMkIsMENBQTBDLGVBQWUscUNBQXFDLFdBQVcsUUFBUSxhQUFhLDZGQUE2RixvRkFBb0YsZ0RBQWdELHlEQUF5RCxhQUFhLHdDQUF3QyxvQ0FBb0MsZUFBZSwwQkFBMEIsb0JBQW9CLGFBQWEsaUNBQWlDLGdFQUFnRSxxR0FBcUcsT0FBTyx5QkFBeUIsY0FBYyxvREFBb0QsY0FBYyxTQUFTLFNBQVMsYUFBYSwrREFBK0QsU0FBUyw4QkFBOEIsZ0JBQWdCLG1FQUFtRSxjQUFjLHVDQUF1QywwQkFBMEIsZ0JBQWdCLDBGQUEwRixRQUFRLHdGQUF3RiwrREFBK0QsbUNBQW1DLE9BQU8scUJBQXFCLFdBQVcsMkJBQTJCLHVCQUF1QixnREFBZ0QscUJBQXFCLGlGQUFpRixjQUFjLE9BQU8sU0FBUywwREFBMEQsUUFBUSwwQkFBMEIscUJBQXFCLE9BQU8sa0NBQWtDLGNBQWMsVUFBVSxjQUFjLDRFQUE0RSxRQUFRLHNCQUFzQixVQUFVLFdBQVcsNkJBQTZCLGFBQWEsb0RBQW9ELFVBQVUsaUNBQWlDLHdJQUF3SSw4RUFBOEUsYUFBYSxzQ0FBc0Msc0JBQXNCLGlFQUFpRSw4QkFBOEIsT0FBTyxVQUFVLDZCQUE2QixvQkFBb0IsMERBQTBELHlDQUF5QyxpQ0FBaUMsaUNBQWlDLGNBQWMsMEJBQTBCLGtEQUFrRCxRQUFRLHdDQUF3QyxzQ0FBc0MsZ0NBQWdDLHlNQUF5TSx5QkFBeUIscUZBQXFGLGdCQUFnQixPQUFPLHlCQUF5Qix5Q0FBeUMsOEJBQThCLFVBQVUsK0RBQStELFFBQVEseUJBQXlCLG1DQUFtQyxvQkFBb0Isb0JBQW9CLDJCQUEyQiwyQkFBMkIsMkRBQTJELDJFQUEyRSxTQUFTLFVBQVUsZUFBZSxnQkFBZ0Isb0JBQW9CLE9BQU8sVUFBVSxhQUFhLG1EQUFtRCw2QkFBNkIsYUFBYSxnQkFBZ0IscURBQXFELDBCQUEwQixlQUFlLDJEQUEyRCwyQkFBMkIsbURBQW1ELGdFQUFnRSxTQUFTLGFBQWEsMkJBQTJCLG9CQUFvQixTQUFTLHlFQUF5RSxxQkFBcUIsUUFBUSxhQUFhLHNGQUFzRix3Q0FBd0MseUNBQXlDLHFCQUFxQiw4Q0FBOEMsNkJBQTZCLGtDQUFrQyw0QkFBNEIscUJBQXFCLDJDQUEyQyxPQUFPLGNBQWMsc0NBQXNDLE9BQU8seUNBQXlDLDBDQUEwQyxtQkFBbUIsdUJBQXVCLGFBQWEsc0NBQXNDLG9CQUFvQiw2RUFBNkUsMkJBQTJCLG1CQUFtQiw2Q0FBNkMsMkVBQTJFLHVDQUF1QywrREFBK0Qsb0JBQW9CLHlGQUF5RixrQ0FBa0MsMkJBQTJCLHFCQUFxQixxQkFBcUIsOEJBQThCLGtDQUFrQywyQkFBMkIscUJBQXFCLDBIQUEwSCxrQ0FBa0MsOEJBQThCLDBCQUEwQiw2QkFBNkIsUUFBUSwrRUFBK0UsVUFBVSxRQUFRLHNCQUFzQiwyQkFBMkIsbUJBQW1CLGtCQUFrQixvQ0FBb0MsT0FBTyx5QkFBeUIsNkJBQTZCLHlDQUF5QyxVQUFVLHFCQUFxQixnREFBZ0QsNkJBQTZCLGFBQWEsaUJBQWlCLCtOQUErTiw4QkFBOEIsbURBQW1ELFFBQVEsVUFBVSxVQUFVLDZCQUE2QixPQUFPLGtEQUFrRCwwQkFBMEIsNkJBQTZCLHlFQUF5RSxVQUFVLGtCQUFrQixvQ0FBb0MsU0FBUyxxQ0FBcUMsT0FBTyxTQUFTLCtDQUErQyxTQUFTLGFBQWEsd0VBQXdFLHlDQUF5QyxrRUFBa0UsUUFBUSxXQUFXLE9BQU8sZ0VBQWdFLG9EQUFvRCxlQUFlLDRCQUE0Qiw4R0FBOEcsc0NBQXNDLHVEQUF1RCxPQUFPLFFBQVEsbURBQW1ELFNBQVMsU0FBUyxVQUFVLFFBQVEsb0RBQW9ELG9CQUFvQixxQkFBcUIsYUFBYSwyQ0FBMkMsdURBQXVELGNBQWMsd0JBQXdCLHdFQUF3RSxTQUFTLDJCQUEyQixPQUFPLDBCQUEwQixTQUFTLHVDQUF1QyxRQUFRLDJDQUEyQyxzRUFBc0UsUUFBUSx3QkFBd0Isb0JBQW9CLGlIQUFpSCxTQUFTLFNBQVMsMEJBQTBCLGtIQUFrSCxVQUFVLFVBQVUsYUFBYSwyQkFBMkIsNEJBQTRCLG1CQUFtQixXQUFXLHdEQUF3RCxxQkFBcUIsdUJBQXVCLFNBQVMsb0ZBQW9GLGVBQWUsb1BBQW9QLHFCQUFxQixrRkFBa0YscUJBQXFCLHVCQUF1QixjQUFjLDRCQUE0QixPQUFPLDBDQUEwQyw4RUFBOEUsYUFBYSxlQUFlLE9BQU8sUUFBUSw0QkFBNEIsU0FBUyxRQUFRLE9BQU8sNkJBQTZCLGNBQWMsd0VBQXdFLGdEQUFnRCxPQUFPLDJCQUEyQiw0QkFBNEIsT0FBTyw0Q0FBNEMsNkJBQTZCLDJCQUEyQiwwQ0FBMEMsV0FBVyxlQUFlLGVBQWUseUNBQXlDLG9EQUFvRCxxQ0FBcUMsT0FBTyw0RUFBNEUsY0FBYyxhQUFhLG9CQUFvQiw4RkFBOEYseUlBQXlJLGtDQUFrQyxRQUFRLDBFQUEwRSxpQkFBaUIsb0NBQW9DLDhEQUE4RCxRQUFRLDhDQUE4QyxPQUFPLHFCQUFxQixXQUFXLGtDQUFrQyxxQkFBcUIsWUFBWSx3REFBd0QsUUFBUSw4Q0FBOEMsd0RBQXdELGNBQWMscUNBQXFDLFlBQVksT0FBTyxpSkFBaUoseUJBQXlCLHNFQUFzRSwyQkFBMkIsU0FBUyx3QkFBd0IsZ0JBQWdCLFNBQVMsa0NBQWtDLFFBQVEsU0FBUyxZQUFZLGtCQUFrQixlQUFlLDJCQUEyQixnRUFBZ0UsNENBQTRDLGdDQUFnQyxVQUFVLHFDQUFxQyxjQUFjLG9FQUFvRSw2QkFBNkIsT0FBTyxtR0FBbUcsMkJBQTJCLGFBQWEsMERBQTBELGFBQWEsb0JBQW9CLG9CQUFvQixhQUFhLG9CQUFvQixRQUFRLFVBQVUsVUFBVSwwRkFBMEYsWUFBWSw0QkFBNEIsYUFBYSwwQkFBMEIsb0JBQW9CLGlEQUFpRCxhQUFhLDBCQUEwQixxQkFBcUIsUUFBUSxnREFBZ0Qsc0ZBQXNGLGNBQWMsMEJBQTBCLGNBQWMsOENBQThDLDZCQUE2Qiw4QkFBOEIsNkJBQTZCLDhCQUE4QixpR0FBaUcsK0VBQStFLG9KQUFvSixxRUFBcUUsU0FBUyxhQUFhLGdCQUFnQixVQUFVLDJCQUEyQixPQUFPLFVBQVUsVUFBVSx5Q0FBeUMsNEJBQTRCLHNCQUFzQixlQUFlLDJCQUEyQixPQUFPLGNBQWMsc0lBQXNJLGdCQUFnQix3SUFBd0ksNEJBQTRCLFNBQVMsYUFBYSxnQkFBZ0IsNkJBQTZCLFFBQVEsVUFBVSxVQUFVLDJCQUEyQixPQUFPLFVBQVUseUNBQXlDLDRCQUE0QixzQkFBc0IsZUFBZSwyQkFBMkIsT0FBTyxvQ0FBb0MsNENBQTRDLGlCQUFpQiwySkFBMkosT0FBTyxnREFBZ0QsVUFBVSxPQUFPLFdBQVcsUUFBUSxxR0FBcUcsNkJBQTZCLHlLQUF5SyxpQ0FBaUMsZUFBZSxPQUFPLGtEQUFrRCw4QkFBOEIsU0FBUyxhQUFhLGtDQUFrQyxxQkFBcUIsOEdBQThHLCtEQUErRCx3QkFBd0IsaUJBQWlCLDBCQUEwQixXQUFXLFVBQVUsUUFBUSxVQUFVLFlBQVksc0RBQXNELG1CQUFtQixTQUFTLFVBQVUsbVBBQW1QLDhFQUE4RSxTQUFTLDZDQUE2QyxnREFBZ0QseUNBQXlDLE9BQU8sb0dBQW9HLHlEQUF5RCxpQ0FBaUMsU0FBUyw2QkFBNkIsNkNBQTZDLFFBQVEsMElBQTBJLHdEQUF3RCxnRUFBZ0UsaUNBQWlDLFNBQVMsU0FBUyxTQUFTLGdEQUFnRCxVQUFVLGNBQWMsNkVBQTZFLHlJQUF5SSxvQkFBb0IsMENBQTBDLHVJQUF1SSx3RkFBd0YsZ0NBQWdDLCtCQUErQixnQ0FBZ0MseUdBQXlHLHFEQUFxRCx1QkFBdUIsUUFBUSxVQUFVLHVDQUF1QywyRUFBMkUsZ0VBQWdFLDBHQUEwRyxpRUFBaUUsaURBQWlELGNBQWMsY0FBYyxVQUFVLFFBQVEscUJBQXFCLHlCQUF5Qiw0QkFBNEIsd0lBQXdJLDZEQUE2RCw4REFBOEQsc0RBQXNELDhGQUE4Rix1SkFBdUosNkJBQTZCLE9BQU8seUJBQXlCLHFCQUFxQixTQUFTLHFCQUFxQix3Q0FBd0Msd0dBQXdHLDhCQUE4QixPQUFPLFNBQVMsd0NBQXdDLFFBQVEscUJBQXFCLFlBQVksU0FBUyxxQkFBcUIsdUNBQXVDLFFBQVE7QUFDcDY4QztBQUNBLGlDQUFpQyxFQUFDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS1odG1sLmpzPzFhMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIHVzaW5nIHNjcmlwdHMvd3JpdGUtZGVjb2RlLW1hcC50c1xuZXhwb3J0IGRlZmF1bHQgbmV3IFVpbnQxNkFycmF5KFxuLy8gcHJldHRpZXItaWdub3JlXG5cIlxcdTFkNDE8XFx4ZDVcXHUwMTMxXFx1MDI4YVxcdTA0OWRcXHUwNTdiXFx1MDVkMFxcdTA2NzVcXHUwNmRlXFx1MDdhMlxcdTA3ZDZcXHUwODBmXFx1MGE0YVxcdTBhOTFcXHUwZGExXFx1MGU2ZFxcdTBmMDlcXHUwZjI2XFx1MTBjYVxcdTEyMjhcXHUxMmUxXFx1MTQxNVxcdTE0OWRcXHUxNGMzXFx1MTRkZlxcdTE1MjVcXDBcXDBcXDBcXDBcXDBcXDBcXHUxNTZiXFx1MTZjZFxcdTE5OGRcXHUxYzEyXFx1MWRkZFxcdTFmN2VcXHUyMDYwXFx1MjFiMFxcdTIyOGRcXHUyM2MwXFx1MjNmYlxcdTI0NDJcXHUyODI0XFx1MjkxMlxcdTJkMDhcXHUyZTQ4XFx1MmZjZVxcdTMwMTZcXHUzMmJhXFx1MzYzOVxcdTM3YWNcXHUzOGZlXFx1M2EyOFxcdTNhNzFcXHUzYWUwXFx1M2IyZVxcdTA4MDBFTWFiY2ZnbG1ub3Byc3R1XFxcXGJmbXNcXHg3ZlxceDg0XFx4OGJcXHg5MFxceDk1XFx4OThcXHhhNlxceGIzXFx4YjlcXHhjOFxceGNmbGlnXFx1ODAzYlxceGM2XFx1NDBjNlBcXHU4MDNiJlxcdTQwMjZjdXRlXFx1ODAzYlxceGMxXFx1NDBjMXJldmU7XFx1NDEwMlxcdTAxMDBpeXh9cmNcXHU4MDNiXFx4YzJcXHU0MGMyO1xcdTQ0MTByO1xcdWMwMDBcXHVkODM1XFx1ZGQwNHJhdmVcXHU4MDNiXFx4YzBcXHU0MGMwcGhhO1xcdTQzOTFhY3I7XFx1NDEwMGQ7XFx1NmE1M1xcdTAxMDBncFxceDlkXFx4YTFvbjtcXHU0MTA0ZjtcXHVjMDAwXFx1ZDgzNVxcdWRkMzhwbHlGdW5jdGlvbjtcXHU2MDYxaW5nXFx1ODAzYlxceGM1XFx1NDBjNVxcdTAxMDBjc1xceGJlXFx4YzNyO1xcdWMwMDBcXHVkODM1XFx1ZGM5Y2lnbjtcXHU2MjU0aWxkZVxcdTgwM2JcXHhjM1xcdTQwYzNtbFxcdTgwM2JcXHhjNFxcdTQwYzRcXHUwNDAwYWNlZm9yc3VcXHhlNVxceGZiXFx4ZmVcXHUwMTE3XFx1MDExY1xcdTAxMjJcXHUwMTI3XFx1MDEyYVxcdTAxMDBjclxceGVhXFx4ZjJrc2xhc2g7XFx1NjIxNlxcdTAxNzZcXHhmNlxceGY4O1xcdTZhZTdlZDtcXHU2MzA2eTtcXHU0NDExXFx1MDE4MGNydFxcdTAxMDVcXHUwMTBiXFx1MDExNGF1c2U7XFx1NjIzNW5vdWxsaXM7XFx1NjEyY2E7XFx1NDM5MnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDA1cGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDM5ZXZlO1xcdTQyZDhjXFx4ZjJcXHUwMTEzbXBlcTtcXHU2MjRlXFx1MDcwMEhPYWNkZWZoaWxvcnN1XFx1MDE0ZFxcdTAxNTFcXHUwMTU2XFx1MDE4MFxcdTAxOWVcXHUwMWEyXFx1MDFiNVxcdTAxYjdcXHUwMWJhXFx1MDFkY1xcdTAyMTVcXHUwMjczXFx1MDI3OFxcdTAyN2VjeTtcXHU0NDI3UFlcXHU4MDNiXFx4YTlcXHU0MGE5XFx1MDE4MGNweVxcdTAxNWRcXHUwMTYyXFx1MDE3YXV0ZTtcXHU0MTA2XFx1MDEwMDtpXFx1MDE2N1xcdTAxNjhcXHU2MmQydGFsRGlmZmVyZW50aWFsRDtcXHU2MTQ1bGV5cztcXHU2MTJkXFx1MDIwMGFlaW9cXHUwMTg5XFx1MDE4ZVxcdTAxOTRcXHUwMTk4cm9uO1xcdTQxMGNkaWxcXHU4MDNiXFx4YzdcXHU0MGM3cmM7XFx1NDEwOG5pbnQ7XFx1NjIzMG90O1xcdTQxMGFcXHUwMTAwZG5cXHUwMWE3XFx1MDFhZGlsbGE7XFx1NDBiOHRlckRvdDtcXHU0MGI3XFx4ZjJcXHUwMTdmaTtcXHU0M2E3cmNsZVxcdTAyMDBETVBUXFx1MDFjN1xcdTAxY2JcXHUwMWQxXFx1MDFkNm90O1xcdTYyOTlpbnVzO1xcdTYyOTZsdXM7XFx1NjI5NWltZXM7XFx1NjI5N29cXHUwMTAwY3NcXHUwMWUyXFx1MDFmOGt3aXNlQ29udG91ckludGVncmFsO1xcdTYyMzJlQ3VybHlcXHUwMTAwRFFcXHUwMjAzXFx1MDIwZm91YmxlUXVvdGU7XFx1NjAxZHVvdGU7XFx1NjAxOVxcdTAyMDBsbnB1XFx1MDIxZVxcdTAyMjhcXHUwMjQ3XFx1MDI1NW9uXFx1MDEwMDtlXFx1MDIyNVxcdTAyMjZcXHU2MjM3O1xcdTZhNzRcXHUwMTgwZ2l0XFx1MDIyZlxcdTAyMzZcXHUwMjNhcnVlbnQ7XFx1NjI2MW50O1xcdTYyMmZvdXJJbnRlZ3JhbDtcXHU2MjJlXFx1MDEwMGZyXFx1MDI0Y1xcdTAyNGU7XFx1NjEwMm9kdWN0O1xcdTYyMTBudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsO1xcdTYyMzNvc3M7XFx1NmEyZmNyO1xcdWMwMDBcXHVkODM1XFx1ZGM5ZXBcXHUwMTAwO0NcXHUwMjg0XFx1MDI4NVxcdTYyZDNhcDtcXHU2MjRkXFx1MDU4MERKU1phY2VmaW9zXFx1MDJhMFxcdTAyYWNcXHUwMmIwXFx1MDJiNFxcdTAyYjhcXHUwMmNiXFx1MDJkN1xcdTAyZTFcXHUwMmU2XFx1MDMzM1xcdTA0OGRcXHUwMTAwO29cXHUwMTc5XFx1MDJhNXRyYWhkO1xcdTY5MTFjeTtcXHU0NDAyY3k7XFx1NDQwNWN5O1xcdTQ0MGZcXHUwMTgwZ3JzXFx1MDJiZlxcdTAyYzRcXHUwMmM3Z2VyO1xcdTYwMjFyO1xcdTYxYTFodjtcXHU2YWU0XFx1MDEwMGF5XFx1MDJkMFxcdTAyZDVyb247XFx1NDEwZTtcXHU0NDE0bFxcdTAxMDA7dFxcdTAyZGRcXHUwMmRlXFx1NjIwN2E7XFx1NDM5NHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDA3XFx1MDEwMGFmXFx1MDJlYlxcdTAzMjdcXHUwMTAwY21cXHUwMmYwXFx1MDMyMnJpdGljYWxcXHUwMjAwQURHVFxcdTAzMDBcXHUwMzA2XFx1MDMxNlxcdTAzMWNjdXRlO1xcdTQwYjRvXFx1MDE3NFxcdTAzMGJcXHUwMzBkO1xcdTQyZDlibGVBY3V0ZTtcXHU0MmRkcmF2ZTtcXHU0MDYwaWxkZTtcXHU0MmRjb25kO1xcdTYyYzRmZXJlbnRpYWxEO1xcdTYxNDZcXHUwNDcwXFx1MDMzZFxcMFxcMFxcMFxcdTAzNDJcXHUwMzU0XFwwXFx1MDQwNWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDNiXFx1MDE4MDtERVxcdTAzNDhcXHUwMzQ5XFx1MDM0ZFxcdTQwYThvdDtcXHU2MGRjcXVhbDtcXHU2MjUwYmxlXFx1MDMwMENETFJVVlxcdTAzNjNcXHUwMzcyXFx1MDM4MlxcdTAzY2ZcXHUwM2UyXFx1MDNmOG9udG91ckludGVncmFcXHhlY1xcdTAyMzlvXFx1MDI3NFxcdTAzNzlcXDBcXDBcXHUwMzdiXFx4YmJcXHUwMzQ5bkFycm93O1xcdTYxZDNcXHUwMTAwZW9cXHUwMzg3XFx1MDNhNGZ0XFx1MDE4MEFSVFxcdTAzOTBcXHUwMzk2XFx1MDNhMXJyb3c7XFx1NjFkMGlnaHRBcnJvdztcXHU2MWQ0ZVxceGU1XFx1MDJjYW5nXFx1MDEwMExSXFx1MDNhYlxcdTAzYzRlZnRcXHUwMTAwQVJcXHUwM2IzXFx1MDNiOXJyb3c7XFx1NjdmOGlnaHRBcnJvdztcXHU2N2ZhaWdodEFycm93O1xcdTY3ZjlpZ2h0XFx1MDEwMEFUXFx1MDNkOFxcdTAzZGVycm93O1xcdTYxZDJlZTtcXHU2MmE4cFxcdTAyNDFcXHUwM2U5XFwwXFwwXFx1MDNlZnJyb3c7XFx1NjFkMW93bkFycm93O1xcdTYxZDVlcnRpY2FsQmFyO1xcdTYyMjVuXFx1MDMwMEFCTFJUYVxcdTA0MTJcXHUwNDJhXFx1MDQzMFxcdTA0NWVcXHUwNDdmXFx1MDM3Y3Jyb3dcXHUwMTgwO0JVXFx1MDQxZFxcdTA0MWVcXHUwNDIyXFx1NjE5M2FyO1xcdTY5MTNwQXJyb3c7XFx1NjFmNXJldmU7XFx1NDMxMWVmdFxcdTAyZDJcXHUwNDNhXFwwXFx1MDQ0NlxcMFxcdTA0NTBpZ2h0VmVjdG9yO1xcdTY5NTBlZVZlY3RvcjtcXHU2OTVlZWN0b3JcXHUwMTAwO0JcXHUwNDU5XFx1MDQ1YVxcdTYxYmRhcjtcXHU2OTU2aWdodFxcdTAxZDRcXHUwNDY3XFwwXFx1MDQ3MWVlVmVjdG9yO1xcdTY5NWZlY3RvclxcdTAxMDA7QlxcdTA0N2FcXHUwNDdiXFx1NjFjMWFyO1xcdTY5NTdlZVxcdTAxMDA7QVxcdTA0ODZcXHUwNDg3XFx1NjJhNHJyb3c7XFx1NjFhN1xcdTAxMDBjdFxcdTA0OTJcXHUwNDk3cjtcXHVjMDAwXFx1ZDgzNVxcdWRjOWZyb2s7XFx1NDExMFxcdTA4MDBOVGFjZGZnbG1vcHFzdHV4XFx1MDRiZFxcdTA0YzBcXHUwNGM0XFx1MDRjYlxcdTA0ZGVcXHUwNGUyXFx1MDRlN1xcdTA0ZWVcXHUwNGY1XFx1MDUyMVxcdTA1MmZcXHUwNTM2XFx1MDU1MlxcdTA1NWRcXHUwNTYwXFx1MDU2NUc7XFx1NDE0YUhcXHU4MDNiXFx4ZDBcXHU0MGQwY3V0ZVxcdTgwM2JcXHhjOVxcdTQwYzlcXHUwMTgwYWl5XFx1MDRkMlxcdTA0ZDdcXHUwNGRjcm9uO1xcdTQxMWFyY1xcdTgwM2JcXHhjYVxcdTQwY2E7XFx1NDQyZG90O1xcdTQxMTZyO1xcdWMwMDBcXHVkODM1XFx1ZGQwOHJhdmVcXHU4MDNiXFx4YzhcXHU0MGM4ZW1lbnQ7XFx1NjIwOFxcdTAxMDBhcFxcdTA0ZmFcXHUwNGZlY3I7XFx1NDExMnR5XFx1MDI1M1xcdTA1MDZcXDBcXDBcXHUwNTEybWFsbFNxdWFyZTtcXHU2NWZiZXJ5U21hbGxTcXVhcmU7XFx1NjVhYlxcdTAxMDBncFxcdTA1MjZcXHUwNTJhb247XFx1NDExOGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDNjc2lsb247XFx1NDM5NXVcXHUwMTAwYWlcXHUwNTNjXFx1MDU0OWxcXHUwMTAwO1RcXHUwNTQyXFx1MDU0M1xcdTZhNzVpbGRlO1xcdTYyNDJsaWJyaXVtO1xcdTYxY2NcXHUwMTAwY2lcXHUwNTU3XFx1MDU1YXI7XFx1NjEzMG07XFx1NmE3M2E7XFx1NDM5N21sXFx1ODAzYlxceGNiXFx1NDBjYlxcdTAxMDBpcFxcdTA1NmFcXHUwNTZmc3RzO1xcdTYyMDNvbmVudGlhbEU7XFx1NjE0N1xcdTAyODBjZmlvc1xcdTA1ODVcXHUwNTg4XFx1MDU4ZFxcdTA1YjJcXHUwNWNjeTtcXHU0NDI0cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMDlsbGVkXFx1MDI1M1xcdTA1OTdcXDBcXDBcXHUwNWEzbWFsbFNxdWFyZTtcXHU2NWZjZXJ5U21hbGxTcXVhcmU7XFx1NjVhYVxcdTAzNzBcXHUwNWJhXFwwXFx1MDViZlxcMFxcMFxcdTA1YzRmO1xcdWMwMDBcXHVkODM1XFx1ZGQzZEFsbDtcXHU2MjAwcmllcnRyZjtcXHU2MTMxY1xceGYyXFx1MDVjYlxcdTA2MDBKVGFiY2RmZ29yc3RcXHUwNWU4XFx1MDVlY1xcdTA1ZWZcXHUwNWZhXFx1MDYwMFxcdTA2MTJcXHUwNjE2XFx1MDYxYlxcdTA2MWRcXHUwNjIzXFx1MDY2Y1xcdTA2NzJjeTtcXHU0NDAzXFx1ODAzYj5cXHU0MDNlbW1hXFx1MDEwMDtkXFx1MDVmN1xcdTA1ZjhcXHU0MzkzO1xcdTQzZGNyZXZlO1xcdTQxMWVcXHUwMTgwZWl5XFx1MDYwN1xcdTA2MGNcXHUwNjEwZGlsO1xcdTQxMjJyYztcXHU0MTFjO1xcdTQ0MTNvdDtcXHU0MTIwcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMGE7XFx1NjJkOXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQzZWVhdGVyXFx1MDMwMEVGR0xTVFxcdTA2MzVcXHUwNjQ0XFx1MDY0ZVxcdTA2NTZcXHUwNjViXFx1MDY2NnF1YWxcXHUwMTAwO0xcXHUwNjNlXFx1MDYzZlxcdTYyNjVlc3M7XFx1NjJkYnVsbEVxdWFsO1xcdTYyNjdyZWF0ZXI7XFx1NmFhMmVzcztcXHU2Mjc3bGFudEVxdWFsO1xcdTZhN2VpbGRlO1xcdTYyNzNjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYTI7XFx1NjI2YlxcdTA0MDBBYWNmaW9zdVxcdTA2ODVcXHUwNjhiXFx1MDY5NlxcdTA2OWJcXHUwNjllXFx1MDZhYVxcdTA2YmVcXHUwNmNhUkRjeTtcXHU0NDJhXFx1MDEwMGN0XFx1MDY5MFxcdTA2OTRlaztcXHU0MmM3O1xcdTQwNWVpcmM7XFx1NDEyNHI7XFx1NjEwY2xiZXJ0U3BhY2U7XFx1NjEwYlxcdTAxZjBcXHUwNmFmXFwwXFx1MDZiMmY7XFx1NjEwZGl6b250YWxMaW5lO1xcdTY1MDBcXHUwMTAwY3RcXHUwNmMzXFx1MDZjNVxceGYyXFx1MDZhOXJvaztcXHU0MTI2bXBcXHUwMTQ0XFx1MDZkMFxcdTA2ZDhvd25IdW1cXHhmMFxcdTAxMmZxdWFsO1xcdTYyNGZcXHUwNzAwRUpPYWNkZmdtbm9zdHVcXHUwNmZhXFx1MDZmZVxcdTA3MDNcXHUwNzA3XFx1MDcwZVxcdTA3MWFcXHUwNzFlXFx1MDcyMVxcdTA3MjhcXHUwNzQ0XFx1MDc3OFxcdTA3OGJcXHUwNzhmXFx1MDc5NWN5O1xcdTQ0MTVsaWc7XFx1NDEzMmN5O1xcdTQ0MDFjdXRlXFx1ODAzYlxceGNkXFx1NDBjZFxcdTAxMDBpeVxcdTA3MTNcXHUwNzE4cmNcXHU4MDNiXFx4Y2VcXHU0MGNlO1xcdTQ0MThvdDtcXHU0MTMwcjtcXHU2MTExcmF2ZVxcdTgwM2JcXHhjY1xcdTQwY2NcXHUwMTgwO2FwXFx1MDcyMFxcdTA3MmZcXHUwNzNmXFx1MDEwMGNnXFx1MDczNFxcdTA3MzdyO1xcdTQxMmFpbmFyeUk7XFx1NjE0OGxpZVxceGYzXFx1MDNkZFxcdTAxZjRcXHUwNzQ5XFwwXFx1MDc2MlxcdTAxMDA7ZVxcdTA3NGRcXHUwNzRlXFx1NjIyY1xcdTAxMDBnclxcdTA3NTNcXHUwNzU4cmFsO1xcdTYyMmJzZWN0aW9uO1xcdTYyYzJpc2libGVcXHUwMTAwQ1RcXHUwNzZjXFx1MDc3Mm9tbWE7XFx1NjA2M2ltZXM7XFx1NjA2MlxcdTAxODBncHRcXHUwNzdmXFx1MDc4M1xcdTA3ODhvbjtcXHU0MTJlZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNDBhO1xcdTQzOTljcjtcXHU2MTEwaWxkZTtcXHU0MTI4XFx1MDFlYlxcdTA3OWFcXDBcXHUwNzllY3k7XFx1NDQwNmxcXHU4MDNiXFx4Y2ZcXHU0MGNmXFx1MDI4MGNmb3N1XFx1MDdhY1xcdTA3YjdcXHUwN2JjXFx1MDdjMlxcdTA3ZDBcXHUwMTAwaXlcXHUwN2IxXFx1MDdiNXJjO1xcdTQxMzQ7XFx1NDQxOXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDBkcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDQxXFx1MDFlM1xcdTA3YzdcXDBcXHUwN2NjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYTVyY3k7XFx1NDQwOGtjeTtcXHU0NDA0XFx1MDM4MEhKYWNmb3NcXHUwN2U0XFx1MDdlOFxcdTA3ZWNcXHUwN2YxXFx1MDdmZFxcdTA4MDJcXHUwODA4Y3k7XFx1NDQyNWN5O1xcdTQ0MGNwcGE7XFx1NDM5YVxcdTAxMDBleVxcdTA3ZjZcXHUwN2ZiZGlsO1xcdTQxMzY7XFx1NDQxYXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDBlcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDQyY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2E2XFx1MDU4MEpUYWNlZmxtb3N0XFx1MDgyNVxcdTA4MjlcXHUwODJjXFx1MDg1MFxcdTA4NjNcXHUwOWIzXFx1MDliOFxcdTA5YzdcXHUwOWNkXFx1MGEzN1xcdTBhNDdjeTtcXHU0NDA5XFx1ODAzYjxcXHU0MDNjXFx1MDI4MGNtbnByXFx1MDgzN1xcdTA4M2NcXHUwODQxXFx1MDg0NFxcdTA4NGR1dGU7XFx1NDEzOWJkYTtcXHU0MzliZztcXHU2N2VhbGFjZXRyZjtcXHU2MTEycjtcXHU2MTllXFx1MDE4MGFleVxcdTA4NTdcXHUwODVjXFx1MDg2MXJvbjtcXHU0MTNkZGlsO1xcdTQxM2I7XFx1NDQxYlxcdTAxMDBmc1xcdTA4NjhcXHUwOTcwdFxcdTA1MDBBQ0RGUlRVVmFyXFx1MDg3ZVxcdTA4YTlcXHUwOGIxXFx1MDhlMFxcdTA4ZTZcXHUwOGZjXFx1MDkyZlxcdTA5NWJcXHUwMzkwXFx1MDk2YVxcdTAxMDBuclxcdTA4ODNcXHUwODhmZ2xlQnJhY2tldDtcXHU2N2U4cm93XFx1MDE4MDtCUlxcdTA4OTlcXHUwODlhXFx1MDg5ZVxcdTYxOTBhcjtcXHU2MWU0aWdodEFycm93O1xcdTYxYzZlaWxpbmc7XFx1NjMwOG9cXHUwMWY1XFx1MDhiN1xcMFxcdTA4YzNibGVCcmFja2V0O1xcdTY3ZTZuXFx1MDFkNFxcdTA4YzhcXDBcXHUwOGQyZWVWZWN0b3I7XFx1Njk2MWVjdG9yXFx1MDEwMDtCXFx1MDhkYlxcdTA4ZGNcXHU2MWMzYXI7XFx1Njk1OWxvb3I7XFx1NjMwYWlnaHRcXHUwMTAwQVZcXHUwOGVmXFx1MDhmNXJyb3c7XFx1NjE5NGVjdG9yO1xcdTY5NGVcXHUwMTAwZXJcXHUwOTAxXFx1MDkxN2VcXHUwMTgwO0FWXFx1MDkwOVxcdTA5MGFcXHUwOTEwXFx1NjJhM3Jyb3c7XFx1NjFhNGVjdG9yO1xcdTY5NWFpYW5nbGVcXHUwMTgwO0JFXFx1MDkyNFxcdTA5MjVcXHUwOTI5XFx1NjJiMmFyO1xcdTY5Y2ZxdWFsO1xcdTYyYjRwXFx1MDE4MERUVlxcdTA5MzdcXHUwOTQyXFx1MDk0Y293blZlY3RvcjtcXHU2OTUxZWVWZWN0b3I7XFx1Njk2MGVjdG9yXFx1MDEwMDtCXFx1MDk1NlxcdTA5NTdcXHU2MWJmYXI7XFx1Njk1OGVjdG9yXFx1MDEwMDtCXFx1MDk2NVxcdTA5NjZcXHU2MWJjYXI7XFx1Njk1MmlnaHRcXHhlMVxcdTAzOWNzXFx1MDMwMEVGR0xTVFxcdTA5N2VcXHUwOThiXFx1MDk5NVxcdTA5OWRcXHUwOWEyXFx1MDlhZHF1YWxHcmVhdGVyO1xcdTYyZGF1bGxFcXVhbDtcXHU2MjY2cmVhdGVyO1xcdTYyNzZlc3M7XFx1NmFhMWxhbnRFcXVhbDtcXHU2YTdkaWxkZTtcXHU2MjcycjtcXHVjMDAwXFx1ZDgzNVxcdWRkMGZcXHUwMTAwO2VcXHUwOWJkXFx1MDliZVxcdTYyZDhmdGFycm93O1xcdTYxZGFpZG90O1xcdTQxM2ZcXHUwMTgwbnB3XFx1MDlkNFxcdTBhMTZcXHUwYTFiZ1xcdTAyMDBMUmxyXFx1MDlkZVxcdTA5ZjdcXHUwYTAyXFx1MGExMGVmdFxcdTAxMDBBUlxcdTA5ZTZcXHUwOWVjcnJvdztcXHU2N2Y1aWdodEFycm93O1xcdTY3ZjdpZ2h0QXJyb3c7XFx1NjdmNmVmdFxcdTAxMDBhclxcdTAzYjNcXHUwYTBhaWdodFxceGUxXFx1MDNiZmlnaHRcXHhlMVxcdTAzY2FmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0M2VyXFx1MDEwMExSXFx1MGEyMlxcdTBhMmNlZnRBcnJvdztcXHU2MTk5aWdodEFycm93O1xcdTYxOThcXHUwMTgwY2h0XFx1MGEzZVxcdTBhNDBcXHUwYTQyXFx4ZjJcXHUwODRjO1xcdTYxYjByb2s7XFx1NDE0MTtcXHU2MjZhXFx1MDQwMGFjZWZpb3N1XFx1MGE1YVxcdTBhNWRcXHUwYTYwXFx1MGE3N1xcdTBhN2NcXHUwYTg1XFx1MGE4YlxcdTBhOGVwO1xcdTY5MDV5O1xcdTQ0MWNcXHUwMTAwZGxcXHUwYTY1XFx1MGE2Zml1bVNwYWNlO1xcdTYwNWZsaW50cmY7XFx1NjEzM3I7XFx1YzAwMFxcdWQ4MzVcXHVkZDEwbnVzUGx1cztcXHU2MjEzcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDQ0Y1xceGYyXFx1MGE3NjtcXHU0MzljXFx1MDQ4MEphY2Vmb3N0dVxcdTBhYTNcXHUwYWE3XFx1MGFhZFxcdTBhYzBcXHUwYjE0XFx1MGIxOVxcdTBkOTFcXHUwZDk3XFx1MGQ5ZWN5O1xcdTQ0MGFjdXRlO1xcdTQxNDNcXHUwMTgwYWV5XFx1MGFiNFxcdTBhYjlcXHUwYWJlcm9uO1xcdTQxNDdkaWw7XFx1NDE0NTtcXHU0NDFkXFx1MDE4MGdzd1xcdTBhYzdcXHUwYWYwXFx1MGIwZWF0aXZlXFx1MDE4ME1UVlxcdTBhZDNcXHUwYWRmXFx1MGFlOGVkaXVtU3BhY2U7XFx1NjAwYmhpXFx1MDEwMGNuXFx1MGFlNlxcdTBhZDhcXHhlYlxcdTBhZDllcnlUaGlcXHhlZVxcdTBhZDl0ZWRcXHUwMTAwR0xcXHUwYWY4XFx1MGIwNnJlYXRlckdyZWF0ZVxceGYyXFx1MDY3M2Vzc0xlc1xceGYzXFx1MGE0OExpbmU7XFx1NDAwYXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDExXFx1MDIwMEJucHRcXHUwYjIyXFx1MGIyOFxcdTBiMzdcXHUwYjNhcmVhaztcXHU2MDYwQnJlYWtpbmdTcGFjZTtcXHU0MGEwZjtcXHU2MTE1XFx1MDY4MDtDREVHSExOUFJTVFZcXHUwYjU1XFx1MGI1NlxcdTBiNmFcXHUwYjdjXFx1MGJhMVxcdTBiZWJcXHUwYzA0XFx1MGM1ZVxcdTBjODRcXHUwY2E2XFx1MGNkOFxcdTBkNjFcXHUwZDg1XFx1NmFlY1xcdTAxMDBvdVxcdTBiNWJcXHUwYjY0bmdydWVudDtcXHU2MjYycENhcDtcXHU2MjZkb3VibGVWZXJ0aWNhbEJhcjtcXHU2MjI2XFx1MDE4MGxxeFxcdTBiODNcXHUwYjhhXFx1MGI5YmVtZW50O1xcdTYyMDl1YWxcXHUwMTAwO1RcXHUwYjkyXFx1MGI5M1xcdTYyNjBpbGRlO1xcdWMwMDBcXHUyMjQyXFx1MDMzOGlzdHM7XFx1NjIwNHJlYXRlclxcdTAzODA7RUZHTFNUXFx1MGJiNlxcdTBiYjdcXHUwYmJkXFx1MGJjOVxcdTBiZDNcXHUwYmQ4XFx1MGJlNVxcdTYyNmZxdWFsO1xcdTYyNzF1bGxFcXVhbDtcXHVjMDAwXFx1MjI2N1xcdTAzMzhyZWF0ZXI7XFx1YzAwMFxcdTIyNmJcXHUwMzM4ZXNzO1xcdTYyNzlsYW50RXF1YWw7XFx1YzAwMFxcdTJhN2VcXHUwMzM4aWxkZTtcXHU2Mjc1dW1wXFx1MDE0NFxcdTBiZjJcXHUwYmZkb3duSHVtcDtcXHVjMDAwXFx1MjI0ZVxcdTAzMzhxdWFsO1xcdWMwMDBcXHUyMjRmXFx1MDMzOGVcXHUwMTAwZnNcXHUwYzBhXFx1MGMyN3RUcmlhbmdsZVxcdTAxODA7QkVcXHUwYzFhXFx1MGMxYlxcdTBjMjFcXHU2MmVhYXI7XFx1YzAwMFxcdTI5Y2ZcXHUwMzM4cXVhbDtcXHU2MmVjc1xcdTAzMDA7RUdMU1RcXHUwYzM1XFx1MGMzNlxcdTBjM2NcXHUwYzQ0XFx1MGM0YlxcdTBjNThcXHU2MjZlcXVhbDtcXHU2MjcwcmVhdGVyO1xcdTYyNzhlc3M7XFx1YzAwMFxcdTIyNmFcXHUwMzM4bGFudEVxdWFsO1xcdWMwMDBcXHUyYTdkXFx1MDMzOGlsZGU7XFx1NjI3NGVzdGVkXFx1MDEwMEdMXFx1MGM2OFxcdTBjNzlyZWF0ZXJHcmVhdGVyO1xcdWMwMDBcXHUyYWEyXFx1MDMzOGVzc0xlc3M7XFx1YzAwMFxcdTJhYTFcXHUwMzM4cmVjZWRlc1xcdTAxODA7RVNcXHUwYzkyXFx1MGM5M1xcdTBjOWJcXHU2MjgwcXVhbDtcXHVjMDAwXFx1MmFhZlxcdTAzMzhsYW50RXF1YWw7XFx1NjJlMFxcdTAxMDBlaVxcdTBjYWJcXHUwY2I5dmVyc2VFbGVtZW50O1xcdTYyMGNnaHRUcmlhbmdsZVxcdTAxODA7QkVcXHUwY2NiXFx1MGNjY1xcdTBjZDJcXHU2MmViYXI7XFx1YzAwMFxcdTI5ZDBcXHUwMzM4cXVhbDtcXHU2MmVkXFx1MDEwMHF1XFx1MGNkZFxcdTBkMGN1YXJlU3VcXHUwMTAwYnBcXHUwY2U4XFx1MGNmOXNldFxcdTAxMDA7RVxcdTBjZjBcXHUwY2YzXFx1YzAwMFxcdTIyOGZcXHUwMzM4cXVhbDtcXHU2MmUyZXJzZXRcXHUwMTAwO0VcXHUwZDAzXFx1MGQwNlxcdWMwMDBcXHUyMjkwXFx1MDMzOHF1YWw7XFx1NjJlM1xcdTAxODBiY3BcXHUwZDEzXFx1MGQyNFxcdTBkNGVzZXRcXHUwMTAwO0VcXHUwZDFiXFx1MGQxZVxcdWMwMDBcXHUyMjgyXFx1MjBkMnF1YWw7XFx1NjI4OGNlZWRzXFx1MDIwMDtFU1RcXHUwZDMyXFx1MGQzM1xcdTBkM2JcXHUwZDQ2XFx1NjI4MXF1YWw7XFx1YzAwMFxcdTJhYjBcXHUwMzM4bGFudEVxdWFsO1xcdTYyZTFpbGRlO1xcdWMwMDBcXHUyMjdmXFx1MDMzOGVyc2V0XFx1MDEwMDtFXFx1MGQ1OFxcdTBkNWJcXHVjMDAwXFx1MjI4M1xcdTIwZDJxdWFsO1xcdTYyODlpbGRlXFx1MDIwMDtFRlRcXHUwZDZlXFx1MGQ2ZlxcdTBkNzVcXHUwZDdmXFx1NjI0MXF1YWw7XFx1NjI0NHVsbEVxdWFsO1xcdTYyNDdpbGRlO1xcdTYyNDllcnRpY2FsQmFyO1xcdTYyMjRjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYTlpbGRlXFx1ODAzYlxceGQxXFx1NDBkMTtcXHU0MzlkXFx1MDcwMEVhY2RmZ21vcHJzdHV2XFx1MGRiZFxcdTBkYzJcXHUwZGM5XFx1MGRkNVxcdTBkZGJcXHUwZGUwXFx1MGRlN1xcdTBkZmNcXHUwZTAyXFx1MGUyMFxcdTBlMjJcXHUwZTMyXFx1MGUzZlxcdTBlNDRsaWc7XFx1NDE1MmN1dGVcXHU4MDNiXFx4ZDNcXHU0MGQzXFx1MDEwMGl5XFx1MGRjZVxcdTBkZDNyY1xcdTgwM2JcXHhkNFxcdTQwZDQ7XFx1NDQxZWJsYWM7XFx1NDE1MHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDEycmF2ZVxcdTgwM2JcXHhkMlxcdTQwZDJcXHUwMTgwYWVpXFx1MGRlZVxcdTBkZjJcXHUwZGY2Y3I7XFx1NDE0Y2dhO1xcdTQzYTljcm9uO1xcdTQzOWZwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNDZlbkN1cmx5XFx1MDEwMERRXFx1MGUwZVxcdTBlMWFvdWJsZVF1b3RlO1xcdTYwMWN1b3RlO1xcdTYwMTg7XFx1NmE1NFxcdTAxMDBjbFxcdTBlMjdcXHUwZTJjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYWFhc2hcXHU4MDNiXFx4ZDhcXHU0MGQ4aVxcdTAxNmNcXHUwZTM3XFx1MGUzY2RlXFx1ODAzYlxceGQ1XFx1NDBkNWVzO1xcdTZhMzdtbFxcdTgwM2JcXHhkNlxcdTQwZDZlclxcdTAxMDBCUFxcdTBlNGJcXHUwZTYwXFx1MDEwMGFyXFx1MGU1MFxcdTBlNTNyO1xcdTYwM2VhY1xcdTAxMDBla1xcdTBlNWFcXHUwZTVjO1xcdTYzZGVldDtcXHU2M2I0YXJlbnRoZXNpcztcXHU2M2RjXFx1MDQ4MGFjZmhpbG9yc1xcdTBlN2ZcXHUwZTg3XFx1MGU4YVxcdTBlOGZcXHUwZTkyXFx1MGU5NFxcdTBlOWRcXHUwZWIwXFx1MGVmY3J0aWFsRDtcXHU2MjAyeTtcXHU0NDFmcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMTNpO1xcdTQzYTY7XFx1NDNhMHVzTWludXM7XFx1NDBiMVxcdTAxMDBpcFxcdTBlYTJcXHUwZWFkbmNhcmVwbGFuXFx4ZTVcXHUwNjlkZjtcXHU2MTE5XFx1MDIwMDtlaW9cXHUwZWI5XFx1MGViYVxcdTBlZTBcXHUwZWU0XFx1NmFiYmNlZGVzXFx1MDIwMDtFU1RcXHUwZWM4XFx1MGVjOVxcdTBlY2ZcXHUwZWRhXFx1NjI3YXF1YWw7XFx1NmFhZmxhbnRFcXVhbDtcXHU2MjdjaWxkZTtcXHU2MjdlbWU7XFx1NjAzM1xcdTAxMDBkcFxcdTBlZTlcXHUwZWVldWN0O1xcdTYyMGZvcnRpb25cXHUwMTAwO2FcXHUwMjI1XFx1MGVmOWw7XFx1NjIxZFxcdTAxMDBjaVxcdTBmMDFcXHUwZjA2cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYWI7XFx1NDNhOFxcdTAyMDBVZm9zXFx1MGYxMVxcdTBmMTZcXHUwZjFiXFx1MGYxZk9UXFx1ODAzYlxcXCJcXHU0MDIycjtcXHVjMDAwXFx1ZDgzNVxcdWRkMTRwZjtcXHU2MTFhY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2FjXFx1MDYwMEJFYWNlZmhpb3JzdVxcdTBmM2VcXHUwZjQzXFx1MGY0N1xcdTBmNjBcXHUwZjczXFx1MGZhN1xcdTBmYWFcXHUwZmFkXFx1MTA5NlxcdTEwYTlcXHUxMGI0XFx1MTBiZWFycjtcXHU2OTEwR1xcdTgwM2JcXHhhZVxcdTQwYWVcXHUwMTgwY25yXFx1MGY0ZVxcdTBmNTNcXHUwZjU2dXRlO1xcdTQxNTRnO1xcdTY3ZWJyXFx1MDEwMDt0XFx1MGY1Y1xcdTBmNWRcXHU2MWEwbDtcXHU2OTE2XFx1MDE4MGFleVxcdTBmNjdcXHUwZjZjXFx1MGY3MXJvbjtcXHU0MTU4ZGlsO1xcdTQxNTY7XFx1NDQyMFxcdTAxMDA7dlxcdTBmNzhcXHUwZjc5XFx1NjExY2Vyc2VcXHUwMTAwRVVcXHUwZjgyXFx1MGY5OVxcdTAxMDBscVxcdTBmODdcXHUwZjhlZW1lbnQ7XFx1NjIwYnVpbGlicml1bTtcXHU2MWNicEVxdWlsaWJyaXVtO1xcdTY5NmZyXFx4YmJcXHUwZjc5bztcXHU0M2ExZ2h0XFx1MDQwMEFDREZUVVZhXFx1MGZjMVxcdTBmZWJcXHUwZmYzXFx1MTAyMlxcdTEwMjhcXHUxMDViXFx1MTA4N1xcdTAzZDhcXHUwMTAwbnJcXHUwZmM2XFx1MGZkMmdsZUJyYWNrZXQ7XFx1NjdlOXJvd1xcdTAxODA7QkxcXHUwZmRjXFx1MGZkZFxcdTBmZTFcXHU2MTkyYXI7XFx1NjFlNWVmdEFycm93O1xcdTYxYzRlaWxpbmc7XFx1NjMwOW9cXHUwMWY1XFx1MGZmOVxcMFxcdTEwMDVibGVCcmFja2V0O1xcdTY3ZTduXFx1MDFkNFxcdTEwMGFcXDBcXHUxMDE0ZWVWZWN0b3I7XFx1Njk1ZGVjdG9yXFx1MDEwMDtCXFx1MTAxZFxcdTEwMWVcXHU2MWMyYXI7XFx1Njk1NWxvb3I7XFx1NjMwYlxcdTAxMDBlclxcdTEwMmRcXHUxMDQzZVxcdTAxODA7QVZcXHUxMDM1XFx1MTAzNlxcdTEwM2NcXHU2MmEycnJvdztcXHU2MWE2ZWN0b3I7XFx1Njk1YmlhbmdsZVxcdTAxODA7QkVcXHUxMDUwXFx1MTA1MVxcdTEwNTVcXHU2MmIzYXI7XFx1NjlkMHF1YWw7XFx1NjJiNXBcXHUwMTgwRFRWXFx1MTA2M1xcdTEwNmVcXHUxMDc4b3duVmVjdG9yO1xcdTY5NGZlZVZlY3RvcjtcXHU2OTVjZWN0b3JcXHUwMTAwO0JcXHUxMDgyXFx1MTA4M1xcdTYxYmVhcjtcXHU2OTU0ZWN0b3JcXHUwMTAwO0JcXHUxMDkxXFx1MTA5MlxcdTYxYzBhcjtcXHU2OTUzXFx1MDEwMHB1XFx1MTA5YlxcdTEwOWVmO1xcdTYxMWRuZEltcGxpZXM7XFx1Njk3MGlnaHRhcnJvdztcXHU2MWRiXFx1MDEwMGNoXFx1MTBiOVxcdTEwYmNyO1xcdTYxMWI7XFx1NjFiMWxlRGVsYXllZDtcXHU2OWY0XFx1MDY4MEhPYWNmaGltb3FzdHVcXHUxMGU0XFx1MTBmMVxcdTEwZjdcXHUxMGZkXFx1MTExOVxcdTExMWVcXHUxMTUxXFx1MTE1NlxcdTExNjFcXHUxMTY3XFx1MTFiNVxcdTExYmJcXHUxMWJmXFx1MDEwMENjXFx1MTBlOVxcdTEwZWVIY3k7XFx1NDQyOXk7XFx1NDQyOEZUY3k7XFx1NDQyY2N1dGU7XFx1NDE1YVxcdTAyODA7YWVpeVxcdTExMDhcXHUxMTA5XFx1MTEwZVxcdTExMTNcXHUxMTE3XFx1NmFiY3JvbjtcXHU0MTYwZGlsO1xcdTQxNWVyYztcXHU0MTVjO1xcdTQ0MjFyO1xcdWMwMDBcXHVkODM1XFx1ZGQxNm9ydFxcdTAyMDBETFJVXFx1MTEyYVxcdTExMzRcXHUxMTNlXFx1MTE0OW93bkFycm93XFx4YmJcXHUwNDFlZWZ0QXJyb3dcXHhiYlxcdTA4OWFpZ2h0QXJyb3dcXHhiYlxcdTBmZGRwQXJyb3c7XFx1NjE5MWdtYTtcXHU0M2EzYWxsQ2lyY2xlO1xcdTYyMThwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNGFcXHUwMjcyXFx1MTE2ZFxcMFxcMFxcdTExNzB0O1xcdTYyMWFhcmVcXHUwMjAwO0lTVVxcdTExN2JcXHUxMTdjXFx1MTE4OVxcdTExYWZcXHU2NWExbnRlcnNlY3Rpb247XFx1NjI5M3VcXHUwMTAwYnBcXHUxMThmXFx1MTE5ZXNldFxcdTAxMDA7RVxcdTExOTdcXHUxMTk4XFx1NjI4ZnF1YWw7XFx1NjI5MWVyc2V0XFx1MDEwMDtFXFx1MTFhOFxcdTExYTlcXHU2MjkwcXVhbDtcXHU2MjkybmlvbjtcXHU2Mjk0Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2FlYXI7XFx1NjJjNlxcdTAyMDBiY21wXFx1MTFjOFxcdTExZGJcXHUxMjA5XFx1MTIwYlxcdTAxMDA7c1xcdTExY2RcXHUxMWNlXFx1NjJkMGV0XFx1MDEwMDtFXFx1MTFjZFxcdTExZDVxdWFsO1xcdTYyODZcXHUwMTAwY2hcXHUxMWUwXFx1MTIwNWVlZHNcXHUwMjAwO0VTVFxcdTExZWRcXHUxMWVlXFx1MTFmNFxcdTExZmZcXHU2MjdicXVhbDtcXHU2YWIwbGFudEVxdWFsO1xcdTYyN2RpbGRlO1xcdTYyN2ZUaFxceGUxXFx1MGY4YztcXHU2MjExXFx1MDE4MDtlc1xcdTEyMTJcXHUxMjEzXFx1MTIyM1xcdTYyZDFyc2V0XFx1MDEwMDtFXFx1MTIxY1xcdTEyMWRcXHU2MjgzcXVhbDtcXHU2Mjg3ZXRcXHhiYlxcdTEyMTNcXHUwNTgwSFJTYWNmaGlvcnNcXHUxMjNlXFx1MTI0NFxcdTEyNDlcXHUxMjU1XFx1MTI1ZVxcdTEyNzFcXHUxMjc2XFx1MTI5ZlxcdTEyYzJcXHUxMmM4XFx1MTJkMU9STlxcdTgwM2JcXHhkZVxcdTQwZGVBREU7XFx1NjEyMlxcdTAxMDBIY1xcdTEyNGVcXHUxMjUyY3k7XFx1NDQwYnk7XFx1NDQyNlxcdTAxMDBidVxcdTEyNWFcXHUxMjVjO1xcdTQwMDk7XFx1NDNhNFxcdTAxODBhZXlcXHUxMjY1XFx1MTI2YVxcdTEyNmZyb247XFx1NDE2NGRpbDtcXHU0MTYyO1xcdTQ0MjJyO1xcdWMwMDBcXHVkODM1XFx1ZGQxN1xcdTAxMDBlaVxcdTEyN2JcXHUxMjg5XFx1MDFmMlxcdTEyODBcXDBcXHUxMjg3ZWZvcmU7XFx1NjIzNGE7XFx1NDM5OFxcdTAxMDBjblxcdTEyOGVcXHUxMjk4a1NwYWNlO1xcdWMwMDBcXHUyMDVmXFx1MjAwYVNwYWNlO1xcdTYwMDlsZGVcXHUwMjAwO0VGVFxcdTEyYWJcXHUxMmFjXFx1MTJiMlxcdTEyYmNcXHU2MjNjcXVhbDtcXHU2MjQzdWxsRXF1YWw7XFx1NjI0NWlsZGU7XFx1NjI0OHBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0YmlwbGVEb3Q7XFx1NjBkYlxcdTAxMDBjdFxcdTEyZDZcXHUxMmRicjtcXHVjMDAwXFx1ZDgzNVxcdWRjYWZyb2s7XFx1NDE2NlxcdTBhZTFcXHUxMmY3XFx1MTMwZVxcdTEzMWFcXHUxMzI2XFwwXFx1MTMyY1xcdTEzMzFcXDBcXDBcXDBcXDBcXDBcXHUxMzM4XFx1MTMzZFxcdTEzNzdcXHUxMzg1XFwwXFx1MTNmZlxcdTE0MDRcXHUxNDBhXFx1MTQxMFxcdTAxMDBjclxcdTEyZmJcXHUxMzAxdXRlXFx1ODAzYlxceGRhXFx1NDBkYXJcXHUwMTAwO29cXHUxMzA3XFx1MTMwOFxcdTYxOWZjaXI7XFx1Njk0OXJcXHUwMWUzXFx1MTMxM1xcMFxcdTEzMTZ5O1xcdTQ0MGV2ZTtcXHU0MTZjXFx1MDEwMGl5XFx1MTMxZVxcdTEzMjNyY1xcdTgwM2JcXHhkYlxcdTQwZGI7XFx1NDQyM2JsYWM7XFx1NDE3MHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDE4cmF2ZVxcdTgwM2JcXHhkOVxcdTQwZDlhY3I7XFx1NDE2YVxcdTAxMDBkaVxcdTEzNDFcXHUxMzY5ZXJcXHUwMTAwQlBcXHUxMzQ4XFx1MTM1ZFxcdTAxMDBhclxcdTEzNGRcXHUxMzUwcjtcXHU0MDVmYWNcXHUwMTAwZWtcXHUxMzU3XFx1MTM1OTtcXHU2M2RmZXQ7XFx1NjNiNWFyZW50aGVzaXM7XFx1NjNkZG9uXFx1MDEwMDtQXFx1MTM3MFxcdTEzNzFcXHU2MmMzbHVzO1xcdTYyOGVcXHUwMTAwZ3BcXHUxMzdiXFx1MTM3Zm9uO1xcdTQxNzJmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0Y1xcdTA0MDBBREVUYWRwc1xcdTEzOTVcXHUxM2FlXFx1MTNiOFxcdTEzYzRcXHUwM2U4XFx1MTNkMlxcdTEzZDdcXHUxM2YzcnJvd1xcdTAxODA7QkRcXHUxMTUwXFx1MTNhMFxcdTEzYTRhcjtcXHU2OTEyb3duQXJyb3c7XFx1NjFjNW93bkFycm93O1xcdTYxOTVxdWlsaWJyaXVtO1xcdTY5NmVlZVxcdTAxMDA7QVxcdTEzY2JcXHUxM2NjXFx1NjJhNXJyb3c7XFx1NjFhNW93blxceGUxXFx1MDNmM2VyXFx1MDEwMExSXFx1MTNkZVxcdTEzZThlZnRBcnJvdztcXHU2MTk2aWdodEFycm93O1xcdTYxOTdpXFx1MDEwMDtsXFx1MTNmOVxcdTEzZmFcXHU0M2Qyb247XFx1NDNhNWluZztcXHU0MTZlY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2IwaWxkZTtcXHU0MTY4bWxcXHU4MDNiXFx4ZGNcXHU0MGRjXFx1MDQ4MERiY2RlZm9zdlxcdTE0MjdcXHUxNDJjXFx1MTQzMFxcdTE0MzNcXHUxNDNlXFx1MTQ4NVxcdTE0OGFcXHUxNDkwXFx1MTQ5NmFzaDtcXHU2MmFiYXI7XFx1NmFlYnk7XFx1NDQxMmFzaFxcdTAxMDA7bFxcdTE0M2JcXHUxNDNjXFx1NjJhOTtcXHU2YWU2XFx1MDEwMGVyXFx1MTQ0M1xcdTE0NDU7XFx1NjJjMVxcdTAxODBidHlcXHUxNDRjXFx1MTQ1MFxcdTE0N2FhcjtcXHU2MDE2XFx1MDEwMDtpXFx1MTQ0ZlxcdTE0NTVjYWxcXHUwMjAwQkxTVFxcdTE0NjFcXHUxNDY1XFx1MTQ2YVxcdTE0NzRhcjtcXHU2MjIzaW5lO1xcdTQwN2NlcGFyYXRvcjtcXHU2NzU4aWxkZTtcXHU2MjQwVGhpblNwYWNlO1xcdTYwMGFyO1xcdWMwMDBcXHVkODM1XFx1ZGQxOXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0ZGNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiMWRhc2g7XFx1NjJhYVxcdTAyODBjZWZvc1xcdTE0YTdcXHUxNGFjXFx1MTRiMVxcdTE0YjZcXHUxNGJjaXJjO1xcdTQxNzRkZ2U7XFx1NjJjMHI7XFx1YzAwMFxcdWQ4MzVcXHVkZDFhcGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDRlY3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2IyXFx1MDIwMGZpb3NcXHUxNGNiXFx1MTRkMFxcdTE0ZDJcXHUxNGQ4cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMWI7XFx1NDM5ZXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ0ZmNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiM1xcdTA0ODBBSVVhY2Zvc3VcXHUxNGYxXFx1MTRmNVxcdTE0ZjlcXHUxNGZkXFx1MTUwNFxcdTE1MGZcXHUxNTE0XFx1MTUxYVxcdTE1MjBjeTtcXHU0NDJmY3k7XFx1NDQwN2N5O1xcdTQ0MmVjdXRlXFx1ODAzYlxceGRkXFx1NDBkZFxcdTAxMDBpeVxcdTE1MDlcXHUxNTBkcmM7XFx1NDE3NjtcXHU0NDJicjtcXHVjMDAwXFx1ZDgzNVxcdWRkMWNwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNTBjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjRtbDtcXHU0MTc4XFx1MDQwMEhhY2RlZm9zXFx1MTUzNVxcdTE1MzlcXHUxNTNmXFx1MTU0YlxcdTE1NGZcXHUxNTVkXFx1MTU2MFxcdTE1NjRjeTtcXHU0NDE2Y3V0ZTtcXHU0MTc5XFx1MDEwMGF5XFx1MTU0NFxcdTE1NDlyb247XFx1NDE3ZDtcXHU0NDE3b3Q7XFx1NDE3YlxcdTAxZjJcXHUxNTU0XFwwXFx1MTU1Ym9XaWR0XFx4ZThcXHUwYWQ5YTtcXHU0Mzk2cjtcXHU2MTI4cGY7XFx1NjEyNGNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiNVxcdTBiZTFcXHUxNTgzXFx1MTU4YVxcdTE1OTBcXDBcXHUxNWIwXFx1MTViNlxcdTE1YmZcXDBcXDBcXDBcXDBcXHUxNWM2XFx1MTVkYlxcdTE1ZWJcXHUxNjVmXFx1MTY2ZFxcMFxcdTE2OTVcXHUxNjliXFx1MTZiMlxcdTE2YjlcXDBcXHUxNmJlY3V0ZVxcdTgwM2JcXHhlMVxcdTQwZTFyZXZlO1xcdTQxMDNcXHUwMzAwO0VkaXV5XFx1MTU5Y1xcdTE1OWRcXHUxNWExXFx1MTVhM1xcdTE1YThcXHUxNWFkXFx1NjIzZTtcXHVjMDAwXFx1MjIzZVxcdTAzMzM7XFx1NjIzZnJjXFx1ODAzYlxceGUyXFx1NDBlMnRlXFx1ODBiYlxceGI0XFx1MDMwNjtcXHU0NDMwbGlnXFx1ODAzYlxceGU2XFx1NDBlNlxcdTAxMDA7clxceGIyXFx1MTViYTtcXHVjMDAwXFx1ZDgzNVxcdWRkMWVyYXZlXFx1ODAzYlxceGUwXFx1NDBlMFxcdTAxMDBlcFxcdTE1Y2FcXHUxNWQ2XFx1MDEwMGZwXFx1MTVjZlxcdTE1ZDRzeW07XFx1NjEzNVxceGU4XFx1MTVkM2hhO1xcdTQzYjFcXHUwMTAwYXBcXHUxNWRmY1xcdTAxMDBjbFxcdTE1ZTRcXHUxNWU3cjtcXHU0MTAxZztcXHU2YTNmXFx1MDI2NFxcdTE1ZjBcXDBcXDBcXHUxNjBhXFx1MDI4MDthZHN2XFx1MTVmYVxcdTE1ZmJcXHUxNWZmXFx1MTYwMVxcdTE2MDdcXHU2MjI3bmQ7XFx1NmE1NTtcXHU2YTVjbG9wZTtcXHU2YTU4O1xcdTZhNWFcXHUwMzgwO2VsbXJzelxcdTE2MThcXHUxNjE5XFx1MTYxYlxcdTE2MWVcXHUxNjNmXFx1MTY0ZlxcdTE2NTlcXHU2MjIwO1xcdTY5YTRlXFx4YmJcXHUxNjE5c2RcXHUwMTAwO2FcXHUxNjI1XFx1MTYyNlxcdTYyMjFcXHUwNDYxXFx1MTYzMFxcdTE2MzJcXHUxNjM0XFx1MTYzNlxcdTE2MzhcXHUxNjNhXFx1MTYzY1xcdTE2M2U7XFx1NjlhODtcXHU2OWE5O1xcdTY5YWE7XFx1NjlhYjtcXHU2OWFjO1xcdTY5YWQ7XFx1NjlhZTtcXHU2OWFmdFxcdTAxMDA7dlxcdTE2NDVcXHUxNjQ2XFx1NjIxZmJcXHUwMTAwO2RcXHUxNjRjXFx1MTY0ZFxcdTYyYmU7XFx1Njk5ZFxcdTAxMDBwdFxcdTE2NTRcXHUxNjU3aDtcXHU2MjIyXFx4YmJcXHhiOWFycjtcXHU2MzdjXFx1MDEwMGdwXFx1MTY2M1xcdTE2NjdvbjtcXHU0MTA1ZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNTJcXHUwMzgwO0VhZWlvcFxcdTEyYzFcXHUxNjdiXFx1MTY3ZFxcdTE2ODJcXHUxNjg0XFx1MTY4N1xcdTE2OGE7XFx1NmE3MGNpcjtcXHU2YTZmO1xcdTYyNGFkO1xcdTYyNGJzO1xcdTQwMjdyb3hcXHUwMTAwO2VcXHUxMmMxXFx1MTY5MlxceGYxXFx1MTY4M2luZ1xcdTgwM2JcXHhlNVxcdTQwZTVcXHUwMTgwY3R5XFx1MTZhMVxcdTE2YTZcXHUxNmE4cjtcXHVjMDAwXFx1ZDgzNVxcdWRjYjY7XFx1NDAyYW1wXFx1MDEwMDtlXFx1MTJjMVxcdTE2YWZcXHhmMVxcdTAyODhpbGRlXFx1ODAzYlxceGUzXFx1NDBlM21sXFx1ODAzYlxceGU0XFx1NDBlNFxcdTAxMDBjaVxcdTE2YzJcXHUxNmM4b25pblxceGY0XFx1MDI3Mm50O1xcdTZhMTFcXHUwODAwTmFiY2RlZmlrbG5vcHJzdVxcdTE2ZWRcXHUxNmYxXFx1MTczMFxcdTE3M2NcXHUxNzQzXFx1MTc0OFxcdTE3NzhcXHUxNzdkXFx1MTdlMFxcdTE3ZTZcXHUxODM5XFx1MTg1MFxcdTE3MGRcXHUxOTNkXFx1MTk0OFxcdTE5NzBvdDtcXHU2YWVkXFx1MDEwMGNyXFx1MTZmNlxcdTE3MWVrXFx1MDIwMGNlcHNcXHUxNzAwXFx1MTcwNVxcdTE3MGRcXHUxNzEzb25nO1xcdTYyNGNwc2lsb247XFx1NDNmNnJpbWU7XFx1NjAzNWltXFx1MDEwMDtlXFx1MTcxYVxcdTE3MWJcXHU2MjNkcTtcXHU2MmNkXFx1MDE3NlxcdTE3MjJcXHUxNzI2ZWU7XFx1NjJiZGVkXFx1MDEwMDtnXFx1MTcyY1xcdTE3MmRcXHU2MzA1ZVxceGJiXFx1MTcyZHJrXFx1MDEwMDt0XFx1MTM1Y1xcdTE3Mzdicms7XFx1NjNiNlxcdTAxMDBveVxcdTE3MDFcXHUxNzQxO1xcdTQ0MzFxdW87XFx1NjAxZVxcdTAyODBjbXBydFxcdTE3NTNcXHUxNzViXFx1MTc2MVxcdTE3NjRcXHUxNzY4YXVzXFx1MDEwMDtlXFx1MDEwYVxcdTAxMDlwdHl2O1xcdTY5YjBzXFx4ZTlcXHUxNzBjbm9cXHhmNVxcdTAxMTNcXHUwMTgwYWh3XFx1MTc2ZlxcdTE3NzFcXHUxNzczO1xcdTQzYjI7XFx1NjEzNmVlbjtcXHU2MjZjcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMWZnXFx1MDM4MGNvc3R1dndcXHUxNzhkXFx1MTc5ZFxcdTE3YjNcXHUxN2MxXFx1MTdkNVxcdTE3ZGJcXHUxN2RlXFx1MDE4MGFpdVxcdTE3OTRcXHUxNzk2XFx1MTc5YVxceGYwXFx1MDc2MHJjO1xcdTY1ZWZwXFx4YmJcXHUxMzcxXFx1MDE4MGRwdFxcdTE3YTRcXHUxN2E4XFx1MTdhZG90O1xcdTZhMDBsdXM7XFx1NmEwMWltZXM7XFx1NmEwMlxcdTAyNzFcXHUxN2I5XFwwXFwwXFx1MTdiZWN1cDtcXHU2YTA2YXI7XFx1NjYwNXJpYW5nbGVcXHUwMTAwZHVcXHUxN2NkXFx1MTdkMm93bjtcXHU2NWJkcDtcXHU2NWIzcGx1cztcXHU2YTA0ZVxceGU1XFx1MTQ0NFxceGU1XFx1MTRhZGFyb3c7XFx1NjkwZFxcdTAxODBha29cXHUxN2VkXFx1MTgyNlxcdTE4MzVcXHUwMTAwY25cXHUxN2YyXFx1MTgyM2tcXHUwMTgwbHN0XFx1MTdmYVxcdTA1YWJcXHUxODAyb3plbmdlO1xcdTY5ZWJyaWFuZ2xlXFx1MDIwMDtkbHJcXHUxODEyXFx1MTgxM1xcdTE4MThcXHUxODFkXFx1NjViNG93bjtcXHU2NWJlZWZ0O1xcdTY1YzJpZ2h0O1xcdTY1YjhrO1xcdTY0MjNcXHUwMWIxXFx1MTgyYlxcMFxcdTE4MzNcXHUwMWIyXFx1MTgyZlxcMFxcdTE4MzE7XFx1NjU5MjtcXHU2NTkxNDtcXHU2NTkzY2s7XFx1NjU4OFxcdTAxMDBlb1xcdTE4M2VcXHUxODRkXFx1MDEwMDtxXFx1MTg0M1xcdTE4NDZcXHVjMDAwPVxcdTIwZTV1aXY7XFx1YzAwMFxcdTIyNjFcXHUyMGU1dDtcXHU2MzEwXFx1MDIwMHB0d3hcXHUxODU5XFx1MTg1ZVxcdTE4NjdcXHUxODZjZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNTNcXHUwMTAwO3RcXHUxM2NiXFx1MTg2M29tXFx4YmJcXHUxM2NjdGllO1xcdTYyYzhcXHUwNjAwREhVVmJkaG1wdHV2XFx1MTg4NVxcdTE4OTZcXHUxOGFhXFx1MThiYlxcdTE4ZDdcXHUxOGRiXFx1MThlY1xcdTE4ZmZcXHUxOTA1XFx1MTkwYVxcdTE5MTBcXHUxOTIxXFx1MDIwMExSbHJcXHUxODhlXFx1MTg5MFxcdTE4OTJcXHUxODk0O1xcdTY1NTc7XFx1NjU1NDtcXHU2NTU2O1xcdTY1NTNcXHUwMjgwO0RVZHVcXHUxOGExXFx1MThhMlxcdTE4YTRcXHUxOGE2XFx1MThhOFxcdTY1NTA7XFx1NjU2NjtcXHU2NTY5O1xcdTY1NjQ7XFx1NjU2N1xcdTAyMDBMUmxyXFx1MThiM1xcdTE4YjVcXHUxOGI3XFx1MThiOTtcXHU2NTVkO1xcdTY1NWE7XFx1NjU1YztcXHU2NTU5XFx1MDM4MDtITFJobHJcXHUxOGNhXFx1MThjYlxcdTE4Y2RcXHUxOGNmXFx1MThkMVxcdTE4ZDNcXHUxOGQ1XFx1NjU1MTtcXHU2NTZjO1xcdTY1NjM7XFx1NjU2MDtcXHU2NTZiO1xcdTY1NjI7XFx1NjU1Zm94O1xcdTY5YzlcXHUwMjAwTFJsclxcdTE4ZTRcXHUxOGU2XFx1MThlOFxcdTE4ZWE7XFx1NjU1NTtcXHU2NTUyO1xcdTY1MTA7XFx1NjUwY1xcdTAyODA7RFVkdVxcdTA2YmRcXHUxOGY3XFx1MThmOVxcdTE4ZmJcXHUxOGZkO1xcdTY1NjU7XFx1NjU2ODtcXHU2NTJjO1xcdTY1MzRpbnVzO1xcdTYyOWZsdXM7XFx1NjI5ZWltZXM7XFx1NjJhMFxcdTAyMDBMUmxyXFx1MTkxOVxcdTE5MWJcXHUxOTFkXFx1MTkxZjtcXHU2NTViO1xcdTY1NTg7XFx1NjUxODtcXHU2NTE0XFx1MDM4MDtITFJobHJcXHUxOTMwXFx1MTkzMVxcdTE5MzNcXHUxOTM1XFx1MTkzN1xcdTE5MzlcXHUxOTNiXFx1NjUwMjtcXHU2NTZhO1xcdTY1NjE7XFx1NjU1ZTtcXHU2NTNjO1xcdTY1MjQ7XFx1NjUxY1xcdTAxMDBldlxcdTAxMjNcXHUxOTQyYmFyXFx1ODAzYlxceGE2XFx1NDBhNlxcdTAyMDBjZWlvXFx1MTk1MVxcdTE5NTZcXHUxOTVhXFx1MTk2MHI7XFx1YzAwMFxcdWQ4MzVcXHVkY2I3bWk7XFx1NjA0Zm1cXHUwMTAwO2VcXHUxNzFhXFx1MTcxY2xcXHUwMTgwO2JoXFx1MTk2OFxcdTE5NjlcXHUxOTZiXFx1NDA1YztcXHU2OWM1c3ViO1xcdTY3YzhcXHUwMTZjXFx1MTk3NFxcdTE5N2VsXFx1MDEwMDtlXFx1MTk3OVxcdTE5N2FcXHU2MDIydFxceGJiXFx1MTk3YXBcXHUwMTgwO0VlXFx1MDEyZlxcdTE5ODVcXHUxOTg3O1xcdTZhYWVcXHUwMTAwO3FcXHUwNmRjXFx1MDZkYlxcdTBjZTFcXHUxOWE3XFwwXFx1MTllOFxcdTFhMTFcXHUxYTE1XFx1MWEzMlxcMFxcdTFhMzdcXHUxYTUwXFwwXFwwXFx1MWFiNFxcMFxcMFxcdTFhYzFcXDBcXDBcXHUxYjIxXFx1MWIyZVxcdTFiNGRcXHUxYjUyXFwwXFx1MWJmZFxcMFxcdTFjMGNcXHUwMTgwY3ByXFx1MTlhZFxcdTE5YjJcXHUxOWRkdXRlO1xcdTQxMDdcXHUwMzAwO2FiY2RzXFx1MTliZlxcdTE5YzBcXHUxOWM0XFx1MTljYVxcdTE5ZDVcXHUxOWQ5XFx1NjIyOW5kO1xcdTZhNDRyY3VwO1xcdTZhNDlcXHUwMTAwYXVcXHUxOWNmXFx1MTlkMnA7XFx1NmE0YnA7XFx1NmE0N290O1xcdTZhNDA7XFx1YzAwMFxcdTIyMjlcXHVmZTAwXFx1MDEwMGVvXFx1MTllMlxcdTE5ZTV0O1xcdTYwNDFcXHhlZVxcdTA2OTNcXHUwMjAwYWVpdVxcdTE5ZjBcXHUxOWZiXFx1MWEwMVxcdTFhMDVcXHUwMWYwXFx1MTlmNVxcMFxcdTE5ZjhzO1xcdTZhNGRvbjtcXHU0MTBkZGlsXFx1ODAzYlxceGU3XFx1NDBlN3JjO1xcdTQxMDlwc1xcdTAxMDA7c1xcdTFhMGNcXHUxYTBkXFx1NmE0Y207XFx1NmE1MG90O1xcdTQxMGJcXHUwMTgwZG1uXFx1MWExYlxcdTFhMjBcXHUxYTI2aWxcXHU4MGJiXFx4YjhcXHUwMWFkcHR5djtcXHU2OWIydFxcdTgxMDBcXHhhMjtlXFx1MWEyZFxcdTFhMmVcXHU0MGEyclxceGU0XFx1MDFiMnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDIwXFx1MDE4MGNlaVxcdTFhM2RcXHUxYTQwXFx1MWE0ZHk7XFx1NDQ0N2NrXFx1MDEwMDttXFx1MWE0N1xcdTFhNDhcXHU2NzEzYXJrXFx4YmJcXHUxYTQ4O1xcdTQzYzdyXFx1MDM4MDtFY2VmbXNcXHUxYTVmXFx1MWE2MFxcdTFhNjJcXHUxYTZiXFx1MWFhNFxcdTFhYWFcXHUxYWFlXFx1NjVjYjtcXHU2OWMzXFx1MDE4MDtlbFxcdTFhNjlcXHUxYTZhXFx1MWE2ZFxcdTQyYzZxO1xcdTYyNTdlXFx1MDI2MVxcdTFhNzRcXDBcXDBcXHUxYTg4cnJvd1xcdTAxMDBsclxcdTFhN2NcXHUxYTgxZWZ0O1xcdTYxYmFpZ2h0O1xcdTYxYmJcXHUwMjgwUlNhY2RcXHUxYTkyXFx1MWE5NFxcdTFhOTZcXHUxYTlhXFx1MWE5ZlxceGJiXFx1MGY0NztcXHU2NGM4c3Q7XFx1NjI5YmlyYztcXHU2MjlhYXNoO1xcdTYyOWRuaW50O1xcdTZhMTBpZDtcXHU2YWVmY2lyO1xcdTY5YzJ1YnNcXHUwMTAwO3VcXHUxYWJiXFx1MWFiY1xcdTY2NjNpdFxceGJiXFx1MWFiY1xcdTAyZWNcXHUxYWM3XFx1MWFkNFxcdTFhZmFcXDBcXHUxYjBhb25cXHUwMTAwO2VcXHUxYWNkXFx1MWFjZVxcdTQwM2FcXHUwMTAwO3FcXHhjN1xceGM2XFx1MDI2ZFxcdTFhZDlcXDBcXDBcXHUxYWUyYVxcdTAxMDA7dFxcdTFhZGVcXHUxYWRmXFx1NDAyYztcXHU0MDQwXFx1MDE4MDtmbFxcdTFhZThcXHUxYWU5XFx1MWFlYlxcdTYyMDFcXHhlZVxcdTExNjBlXFx1MDEwMG14XFx1MWFmMVxcdTFhZjZlbnRcXHhiYlxcdTFhZTllXFx4ZjNcXHUwMjRkXFx1MDFlN1xcdTFhZmVcXDBcXHUxYjA3XFx1MDEwMDtkXFx1MTJiYlxcdTFiMDJvdDtcXHU2YTZkblxceGY0XFx1MDI0NlxcdTAxODBmcnlcXHUxYjEwXFx1MWIxNFxcdTFiMTc7XFx1YzAwMFxcdWQ4MzVcXHVkZDU0b1xceGU0XFx1MDI1NFxcdTgxMDBcXHhhOTtzXFx1MDE1NVxcdTFiMWRyO1xcdTYxMTdcXHUwMTAwYW9cXHUxYjI1XFx1MWIyOXJyO1xcdTYxYjVzcztcXHU2NzE3XFx1MDEwMGN1XFx1MWIzMlxcdTFiMzdyO1xcdWMwMDBcXHVkODM1XFx1ZGNiOFxcdTAxMDBicFxcdTFiM2NcXHUxYjQ0XFx1MDEwMDtlXFx1MWI0MVxcdTFiNDJcXHU2YWNmO1xcdTZhZDFcXHUwMTAwO2VcXHUxYjQ5XFx1MWI0YVxcdTZhZDA7XFx1NmFkMmRvdDtcXHU2MmVmXFx1MDM4MGRlbHBydndcXHUxYjYwXFx1MWI2Y1xcdTFiNzdcXHUxYjgyXFx1MWJhY1xcdTFiZDRcXHUxYmY5YXJyXFx1MDEwMGxyXFx1MWI2OFxcdTFiNmE7XFx1NjkzODtcXHU2OTM1XFx1MDI3MFxcdTFiNzJcXDBcXDBcXHUxYjc1cjtcXHU2MmRlYztcXHU2MmRmYXJyXFx1MDEwMDtwXFx1MWI3ZlxcdTFiODBcXHU2MWI2O1xcdTY5M2RcXHUwMzAwO2JjZG9zXFx1MWI4ZlxcdTFiOTBcXHUxYjk2XFx1MWJhMVxcdTFiYTVcXHUxYmE4XFx1NjIyYXJjYXA7XFx1NmE0OFxcdTAxMDBhdVxcdTFiOWJcXHUxYjllcDtcXHU2YTQ2cDtcXHU2YTRhb3Q7XFx1NjI4ZHI7XFx1NmE0NTtcXHVjMDAwXFx1MjIyYVxcdWZlMDBcXHUwMjAwYWxydlxcdTFiYjVcXHUxYmJmXFx1MWJkZVxcdTFiZTNyclxcdTAxMDA7bVxcdTFiYmNcXHUxYmJkXFx1NjFiNztcXHU2OTNjeVxcdTAxODBldndcXHUxYmM3XFx1MWJkNFxcdTFiZDhxXFx1MDI3MFxcdTFiY2VcXDBcXDBcXHUxYmQycmVcXHhlM1xcdTFiNzN1XFx4ZTNcXHUxYjc1ZWU7XFx1NjJjZWVkZ2U7XFx1NjJjZmVuXFx1ODAzYlxceGE0XFx1NDBhNGVhcnJvd1xcdTAxMDBsclxcdTFiZWVcXHUxYmYzZWZ0XFx4YmJcXHUxYjgwaWdodFxceGJiXFx1MWJiZGVcXHhlNFxcdTFiZGRcXHUwMTAwY2lcXHUxYzAxXFx1MWMwN29uaW5cXHhmNFxcdTAxZjdudDtcXHU2MjMxbGN0eTtcXHU2MzJkXFx1MDk4MEFIYWJjZGVmaGlqbG9yc3R1d3pcXHUxYzM4XFx1MWMzYlxcdTFjM2ZcXHUxYzVkXFx1MWM2OVxcdTFjNzVcXHUxYzhhXFx1MWM5ZVxcdTFjYWNcXHUxY2I3XFx1MWNmYlxcdTFjZmZcXHUxZDBkXFx1MWQ3YlxcdTFkOTFcXHUxZGFiXFx1MWRiYlxcdTFkYzZcXHUxZGNkclxceGYyXFx1MDM4MWFyO1xcdTY5NjVcXHUwMjAwZ2xyc1xcdTFjNDhcXHUxYzRkXFx1MWM1MlxcdTFjNTRnZXI7XFx1NjAyMGV0aDtcXHU2MTM4XFx4ZjJcXHUxMTMzaFxcdTAxMDA7dlxcdTFjNWFcXHUxYzViXFx1NjAxMFxceGJiXFx1MDkwYVxcdTAxNmJcXHUxYzYxXFx1MWM2N2Fyb3c7XFx1NjkwZmFcXHhlM1xcdTAzMTVcXHUwMTAwYXlcXHUxYzZlXFx1MWM3M3JvbjtcXHU0MTBmO1xcdTQ0MzRcXHUwMTgwO2FvXFx1MDMzMlxcdTFjN2NcXHUxYzg0XFx1MDEwMGdyXFx1MDJiZlxcdTFjODFyO1xcdTYxY2F0c2VxO1xcdTZhNzdcXHUwMTgwZ2xtXFx1MWM5MVxcdTFjOTRcXHUxYzk4XFx1ODAzYlxceGIwXFx1NDBiMHRhO1xcdTQzYjRwdHl2O1xcdTY5YjFcXHUwMTAwaXJcXHUxY2EzXFx1MWNhOHNodDtcXHU2OTdmO1xcdWMwMDBcXHVkODM1XFx1ZGQyMWFyXFx1MDEwMGxyXFx1MWNiM1xcdTFjYjVcXHhiYlxcdTA4ZGNcXHhiYlxcdTEwMWVcXHUwMjgwYWVnc3ZcXHUxY2MyXFx1MDM3OFxcdTFjZDZcXHUxY2RjXFx1MWNlMG1cXHUwMTgwO29zXFx1MDMyNlxcdTFjY2FcXHUxY2Q0bmRcXHUwMTAwO3NcXHUwMzI2XFx1MWNkMXVpdDtcXHU2NjY2YW1tYTtcXHU0M2RkaW47XFx1NjJmMlxcdTAxODA7aW9cXHUxY2U3XFx1MWNlOFxcdTFjZjhcXHU0MGY3ZGVcXHU4MTAwXFx4Zjc7b1xcdTFjZTdcXHUxY2YwbnRpbWVzO1xcdTYyYzduXFx4ZjhcXHUxY2Y3Y3k7XFx1NDQ1MmNcXHUwMjZmXFx1MWQwNlxcMFxcMFxcdTFkMGFybjtcXHU2MzFlb3A7XFx1NjMwZFxcdTAyODBscHR1d1xcdTFkMThcXHUxZDFkXFx1MWQyMlxcdTFkNDlcXHUxZDU1bGFyO1xcdTQwMjRmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1NVxcdTAyODA7ZW1wc1xcdTAzMGJcXHUxZDJkXFx1MWQzN1xcdTFkM2RcXHUxZDQycVxcdTAxMDA7ZFxcdTAzNTJcXHUxZDMzb3Q7XFx1NjI1MWludXM7XFx1NjIzOGx1cztcXHU2MjE0cXVhcmU7XFx1NjJhMWJsZWJhcndlZGdcXHhlNVxceGZhblxcdTAxODBhZGhcXHUxMTJlXFx1MWQ1ZFxcdTFkNjdvd25hcnJvd1xceGYzXFx1MWM4M2FycG9vblxcdTAxMDBsclxcdTFkNzJcXHUxZDc2ZWZcXHhmNFxcdTFjYjRpZ2hcXHhmNFxcdTFjYjZcXHUwMTYyXFx1MWQ3ZlxcdTFkODVrYXJvXFx4ZjdcXHUwZjQyXFx1MDI2ZlxcdTFkOGFcXDBcXDBcXHUxZDhlcm47XFx1NjMxZm9wO1xcdTYzMGNcXHUwMTgwY290XFx1MWQ5OFxcdTFkYTNcXHUxZGE2XFx1MDEwMHJ5XFx1MWQ5ZFxcdTFkYTE7XFx1YzAwMFxcdWQ4MzVcXHVkY2I5O1xcdTQ0NTVsO1xcdTY5ZjZyb2s7XFx1NDExMVxcdTAxMDBkclxcdTFkYjBcXHUxZGI0b3Q7XFx1NjJmMWlcXHUwMTAwO2ZcXHUxZGJhXFx1MTgxNlxcdTY1YmZcXHUwMTAwYWhcXHUxZGMwXFx1MWRjM3JcXHhmMlxcdTA0MjlhXFx4ZjJcXHUwZmE2YW5nbGU7XFx1NjlhNlxcdTAxMDBjaVxcdTFkZDJcXHUxZGQ1eTtcXHU0NDVmZ3JhcnI7XFx1NjdmZlxcdTA5MDBEYWNkZWZnbG1ub3BxcnN0dXhcXHUxZTAxXFx1MWUwOVxcdTFlMTlcXHUxZTM4XFx1MDU3OFxcdTFlM2NcXHUxZTQ5XFx1MWU2MVxcdTFlN2VcXHUxZWE1XFx1MWVhZlxcdTFlYmRcXHUxZWUxXFx1MWYyYVxcdTFmMzdcXHUxZjQ0XFx1MWY0ZVxcdTFmNWFcXHUwMTAwRG9cXHUxZTA2XFx1MWQzNG9cXHhmNFxcdTFjODlcXHUwMTAwY3NcXHUxZTBlXFx1MWUxNHV0ZVxcdTgwM2JcXHhlOVxcdTQwZTl0ZXI7XFx1NmE2ZVxcdTAyMDBhaW95XFx1MWUyMlxcdTFlMjdcXHUxZTMxXFx1MWUzNnJvbjtcXHU0MTFiclxcdTAxMDA7Y1xcdTFlMmRcXHUxZTJlXFx1NjI1NlxcdTgwM2JcXHhlYVxcdTQwZWFsb247XFx1NjI1NTtcXHU0NDRkb3Q7XFx1NDExN1xcdTAxMDBEclxcdTFlNDFcXHUxZTQ1b3Q7XFx1NjI1MjtcXHVjMDAwXFx1ZDgzNVxcdWRkMjJcXHUwMTgwO3JzXFx1MWU1MFxcdTFlNTFcXHUxZTU3XFx1NmE5YWF2ZVxcdTgwM2JcXHhlOFxcdTQwZThcXHUwMTAwO2RcXHUxZTVjXFx1MWU1ZFxcdTZhOTZvdDtcXHU2YTk4XFx1MDIwMDtpbHNcXHUxZTZhXFx1MWU2YlxcdTFlNzJcXHUxZTc0XFx1NmE5OW50ZXJzO1xcdTYzZTc7XFx1NjExM1xcdTAxMDA7ZFxcdTFlNzlcXHUxZTdhXFx1NmE5NW90O1xcdTZhOTdcXHUwMTgwYXBzXFx1MWU4NVxcdTFlODlcXHUxZTk3Y3I7XFx1NDExM3R5XFx1MDE4MDtzdlxcdTFlOTJcXHUxZTkzXFx1MWU5NVxcdTYyMDVldFxceGJiXFx1MWU5M3BcXHUwMTAwMTtcXHUxZTlkXFx1MWVhNFxcdTAxMzNcXHUxZWExXFx1MWVhMztcXHU2MDA0O1xcdTYwMDVcXHU2MDAzXFx1MDEwMGdzXFx1MWVhYVxcdTFlYWM7XFx1NDE0YnA7XFx1NjAwMlxcdTAxMDBncFxcdTFlYjRcXHUxZWI4b247XFx1NDExOWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDU2XFx1MDE4MGFsc1xcdTFlYzRcXHUxZWNlXFx1MWVkMnJcXHUwMTAwO3NcXHUxZWNhXFx1MWVjYlxcdTYyZDVsO1xcdTY5ZTN1cztcXHU2YTcxaVxcdTAxODA7bHZcXHUxZWRhXFx1MWVkYlxcdTFlZGZcXHU0M2I1b25cXHhiYlxcdTFlZGI7XFx1NDNmNVxcdTAyMDBjc3V2XFx1MWVlYVxcdTFlZjNcXHUxZjBiXFx1MWYyM1xcdTAxMDBpb1xcdTFlZWZcXHUxZTMxcmNcXHhiYlxcdTFlMmVcXHUwMjY5XFx1MWVmOVxcMFxcMFxcdTFlZmJcXHhlZFxcdTA1NDhhbnRcXHUwMTAwZ2xcXHUxZjAyXFx1MWYwNnRyXFx4YmJcXHUxZTVkZXNzXFx4YmJcXHUxZTdhXFx1MDE4MGFlaVxcdTFmMTJcXHUxZjE2XFx1MWYxYWxzO1xcdTQwM2RzdDtcXHU2MjVmdlxcdTAxMDA7RFxcdTAyMzVcXHUxZjIwRDtcXHU2YTc4cGFyc2w7XFx1NjllNVxcdTAxMDBEYVxcdTFmMmZcXHUxZjMzb3Q7XFx1NjI1M3JyO1xcdTY5NzFcXHUwMTgwY2RpXFx1MWYzZVxcdTFmNDFcXHUxZWY4cjtcXHU2MTJmb1xceGY0XFx1MDM1MlxcdTAxMDBhaFxcdTFmNDlcXHUxZjRiO1xcdTQzYjdcXHU4MDNiXFx4ZjBcXHU0MGYwXFx1MDEwMG1yXFx1MWY1M1xcdTFmNTdsXFx1ODAzYlxceGViXFx1NDBlYm87XFx1NjBhY1xcdTAxODBjaXBcXHUxZjYxXFx1MWY2NFxcdTFmNjdsO1xcdTQwMjFzXFx4ZjRcXHUwNTZlXFx1MDEwMGVvXFx1MWY2Y1xcdTFmNzRjdGF0aW9cXHhlZVxcdTA1NTluZW50aWFsXFx4ZTVcXHUwNTc5XFx1MDllMVxcdTFmOTJcXDBcXHUxZjllXFwwXFx1MWZhMVxcdTFmYTdcXDBcXDBcXHUxZmM2XFx1MWZjY1xcMFxcdTFmZDNcXDBcXHUxZmU2XFx1MWZlYVxcdTIwMDBcXDBcXHUyMDA4XFx1MjA1YWxsaW5nZG90c2VcXHhmMVxcdTFlNDR5O1xcdTQ0NDRtYWxlO1xcdTY2NDBcXHUwMTgwaWxyXFx1MWZhZFxcdTFmYjNcXHUxZmMxbGlnO1xcdTgwMDBcXHVmYjAzXFx1MDI2OVxcdTFmYjlcXDBcXDBcXHUxZmJkZztcXHU4MDAwXFx1ZmIwMGlnO1xcdTgwMDBcXHVmYjA0O1xcdWMwMDBcXHVkODM1XFx1ZGQyM2xpZztcXHU4MDAwXFx1ZmIwMWxpZztcXHVjMDAwZmpcXHUwMTgwYWx0XFx1MWZkOVxcdTFmZGNcXHUxZmUxdDtcXHU2NjZkaWc7XFx1ODAwMFxcdWZiMDJucztcXHU2NWIxb2Y7XFx1NDE5MlxcdTAxZjBcXHUxZmVlXFwwXFx1MWZmM2Y7XFx1YzAwMFxcdWQ4MzVcXHVkZDU3XFx1MDEwMGFrXFx1MDViZlxcdTFmZjdcXHUwMTAwO3ZcXHUxZmZjXFx1MWZmZFxcdTYyZDQ7XFx1NmFkOWFydGludDtcXHU2YTBkXFx1MDEwMGFvXFx1MjAwY1xcdTIwNTVcXHUwMTAwY3NcXHUyMDExXFx1MjA1MlxcdTAzYjFcXHUyMDFhXFx1MjAzMFxcdTIwMzhcXHUyMDQ1XFx1MjA0OFxcMFxcdTIwNTBcXHUwM2IyXFx1MjAyMlxcdTIwMjVcXHUyMDI3XFx1MjAyYVxcdTIwMmNcXDBcXHUyMDJlXFx1ODAzYlxceGJkXFx1NDBiZDtcXHU2MTUzXFx1ODAzYlxceGJjXFx1NDBiYztcXHU2MTU1O1xcdTYxNTk7XFx1NjE1YlxcdTAxYjNcXHUyMDM0XFwwXFx1MjAzNjtcXHU2MTU0O1xcdTYxNTZcXHUwMmI0XFx1MjAzZVxcdTIwNDFcXDBcXDBcXHUyMDQzXFx1ODAzYlxceGJlXFx1NDBiZTtcXHU2MTU3O1xcdTYxNWM1O1xcdTYxNThcXHUwMWI2XFx1MjA0Y1xcMFxcdTIwNGU7XFx1NjE1YTtcXHU2MTVkODtcXHU2MTVlbDtcXHU2MDQ0d247XFx1NjMyMmNyO1xcdWMwMDBcXHVkODM1XFx1ZGNiYlxcdTA4ODBFYWJjZGVmZ2lqbG5vcnN0dlxcdTIwODJcXHUyMDg5XFx1MjA5ZlxcdTIwYTVcXHUyMGIwXFx1MjBiNFxcdTIwZjBcXHUyMGY1XFx1MjBmYVxcdTIwZmZcXHUyMTAzXFx1MjExMlxcdTIxMzhcXHUwMzE3XFx1MjEzZVxcdTIxNTJcXHUyMTllXFx1MDEwMDtsXFx1MDY0ZFxcdTIwODc7XFx1NmE4Y1xcdTAxODBjbXBcXHUyMDkwXFx1MjA5NVxcdTIwOWR1dGU7XFx1NDFmNW1hXFx1MDEwMDtkXFx1MjA5Y1xcdTFjZGFcXHU0M2IzO1xcdTZhODZyZXZlO1xcdTQxMWZcXHUwMTAwaXlcXHUyMGFhXFx1MjBhZXJjO1xcdTQxMWQ7XFx1NDQzM290O1xcdTQxMjFcXHUwMjAwO2xxc1xcdTA2M2VcXHUwNjQyXFx1MjBiZFxcdTIwYzlcXHUwMTgwO3FzXFx1MDYzZVxcdTA2NGNcXHUyMGM0bGFuXFx4ZjRcXHUwNjY1XFx1MDIwMDtjZGxcXHUwNjY1XFx1MjBkMlxcdTIwZDVcXHUyMGU1YztcXHU2YWE5b3RcXHUwMTAwO29cXHUyMGRjXFx1MjBkZFxcdTZhODBcXHUwMTAwO2xcXHUyMGUyXFx1MjBlM1xcdTZhODI7XFx1NmE4NFxcdTAxMDA7ZVxcdTIwZWFcXHUyMGVkXFx1YzAwMFxcdTIyZGJcXHVmZTAwcztcXHU2YTk0cjtcXHVjMDAwXFx1ZDgzNVxcdWRkMjRcXHUwMTAwO2dcXHUwNjczXFx1MDYxYm1lbDtcXHU2MTM3Y3k7XFx1NDQ1M1xcdTAyMDA7RWFqXFx1MDY1YVxcdTIxMGNcXHUyMTBlXFx1MjExMDtcXHU2YTkyO1xcdTZhYTU7XFx1NmFhNFxcdTAyMDBFYWVzXFx1MjExYlxcdTIxMWRcXHUyMTI5XFx1MjEzNDtcXHU2MjY5cFxcdTAxMDA7cFxcdTIxMjNcXHUyMTI0XFx1NmE4YXJveFxceGJiXFx1MjEyNFxcdTAxMDA7cVxcdTIxMmVcXHUyMTJmXFx1NmE4OFxcdTAxMDA7cVxcdTIxMmVcXHUyMTFiaW07XFx1NjJlN3BmO1xcdWMwMDBcXHVkODM1XFx1ZGQ1OFxcdTAxMDBjaVxcdTIxNDNcXHUyMTQ2cjtcXHU2MTBhbVxcdTAxODA7ZWxcXHUwNjZiXFx1MjE0ZVxcdTIxNTA7XFx1NmE4ZTtcXHU2YTkwXFx1ODMwMD47Y2RscXJcXHUwNWVlXFx1MjE2MFxcdTIxNmFcXHUyMTZlXFx1MjE3M1xcdTIxNzlcXHUwMTAwY2lcXHUyMTY1XFx1MjE2NztcXHU2YWE3cjtcXHU2YTdhb3Q7XFx1NjJkN1BhcjtcXHU2OTk1dWVzdDtcXHU2YTdjXFx1MDI4MGFkZWxzXFx1MjE4NFxcdTIxNmFcXHUyMTkwXFx1MDY1NlxcdTIxOWJcXHUwMWYwXFx1MjE4OVxcMFxcdTIxOGVwcm9cXHhmOFxcdTIwOWVyO1xcdTY5NzhxXFx1MDEwMGxxXFx1MDYzZlxcdTIxOTZsZXNcXHhmM1xcdTIwODhpXFx4ZWRcXHUwNjZiXFx1MDEwMGVuXFx1MjFhM1xcdTIxYWRydG5lcXE7XFx1YzAwMFxcdTIyNjlcXHVmZTAwXFx4YzVcXHUyMWFhXFx1MDUwMEFhYmNlZmtvc3lcXHUyMWM0XFx1MjFjN1xcdTIxZjFcXHUyMWY1XFx1MjFmYVxcdTIyMThcXHUyMjFkXFx1MjIyZlxcdTIyNjhcXHUyMjdkclxceGYyXFx1MDNhMFxcdTAyMDBpbG1yXFx1MjFkMFxcdTIxZDRcXHUyMWQ3XFx1MjFkYnJzXFx4ZjBcXHUxNDg0ZlxceGJiXFx1MjAyNGlsXFx4ZjRcXHUwNmE5XFx1MDEwMGRyXFx1MjFlMFxcdTIxZTRjeTtcXHU0NDRhXFx1MDE4MDtjd1xcdTA4ZjRcXHUyMWViXFx1MjFlZmlyO1xcdTY5NDg7XFx1NjFhZGFyO1xcdTYxMGZpcmM7XFx1NDEyNVxcdTAxODBhbHJcXHUyMjAxXFx1MjIwZVxcdTIyMTNydHNcXHUwMTAwO3VcXHUyMjA5XFx1MjIwYVxcdTY2NjVpdFxceGJiXFx1MjIwYWxpcDtcXHU2MDI2Y29uO1xcdTYyYjlyO1xcdWMwMDBcXHVkODM1XFx1ZGQyNXNcXHUwMTAwZXdcXHUyMjIzXFx1MjIyOWFyb3c7XFx1NjkyNWFyb3c7XFx1NjkyNlxcdTAyODBhbW9wclxcdTIyM2FcXHUyMjNlXFx1MjI0M1xcdTIyNWVcXHUyMjYzcnI7XFx1NjFmZnRodDtcXHU2MjNia1xcdTAxMDBsclxcdTIyNDlcXHUyMjUzZWZ0YXJyb3c7XFx1NjFhOWlnaHRhcnJvdztcXHU2MWFhZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNTliYXI7XFx1NjAxNVxcdTAxODBjbHRcXHUyMjZmXFx1MjI3NFxcdTIyNzhyO1xcdWMwMDBcXHVkODM1XFx1ZGNiZGFzXFx4ZThcXHUyMWY0cm9rO1xcdTQxMjdcXHUwMTAwYnBcXHUyMjgyXFx1MjI4N3VsbDtcXHU2MDQzaGVuXFx4YmJcXHUxYzViXFx1MGFlMVxcdTIyYTNcXDBcXHUyMmFhXFwwXFx1MjJiOFxcdTIyYzVcXHUyMmNlXFwwXFx1MjJkNVxcdTIyZjNcXDBcXDBcXHUyMmY4XFx1MjMyMlxcdTIzNjdcXHUyMzYyXFx1MjM3ZlxcMFxcdTIzODZcXHUyM2FhXFx1MjNiNGN1dGVcXHU4MDNiXFx4ZWRcXHU0MGVkXFx1MDE4MDtpeVxcdTA3NzFcXHUyMmIwXFx1MjJiNXJjXFx1ODAzYlxceGVlXFx1NDBlZTtcXHU0NDM4XFx1MDEwMGN4XFx1MjJiY1xcdTIyYmZ5O1xcdTQ0MzVjbFxcdTgwM2JcXHhhMVxcdTQwYTFcXHUwMTAwZnJcXHUwMzlmXFx1MjJjOTtcXHVjMDAwXFx1ZDgzNVxcdWRkMjZyYXZlXFx1ODAzYlxceGVjXFx1NDBlY1xcdTAyMDA7aW5vXFx1MDczZVxcdTIyZGRcXHUyMmU5XFx1MjJlZVxcdTAxMDBpblxcdTIyZTJcXHUyMmU2bnQ7XFx1NmEwY3Q7XFx1NjIyZGZpbjtcXHU2OWRjdGE7XFx1NjEyOWxpZztcXHU0MTMzXFx1MDE4MGFvcFxcdTIyZmVcXHUyMzFhXFx1MjMxZFxcdTAxODBjZ3RcXHUyMzA1XFx1MjMwOFxcdTIzMTdyO1xcdTQxMmJcXHUwMTgwZWxwXFx1MDcxZlxcdTIzMGZcXHUyMzEzaW5cXHhlNVxcdTA3OGVhclxceGY0XFx1MDcyMGg7XFx1NDEzMWY7XFx1NjJiN2VkO1xcdTQxYjVcXHUwMjgwO2Nmb3RcXHUwNGY0XFx1MjMyY1xcdTIzMzFcXHUyMzNkXFx1MjM0MWFyZTtcXHU2MTA1aW5cXHUwMTAwO3RcXHUyMzM4XFx1MjMzOVxcdTYyMWVpZTtcXHU2OWRkZG9cXHhmNFxcdTIzMTlcXHUwMjgwO2NlbHBcXHUwNzU3XFx1MjM0Y1xcdTIzNTBcXHUyMzViXFx1MjM2MWFsO1xcdTYyYmFcXHUwMTAwZ3JcXHUyMzU1XFx1MjM1OWVyXFx4ZjNcXHUxNTYzXFx4ZTNcXHUyMzRkYXJoaztcXHU2YTE3cm9kO1xcdTZhM2NcXHUwMjAwY2dwdFxcdTIzNmZcXHUyMzcyXFx1MjM3NlxcdTIzN2J5O1xcdTQ0NTFvbjtcXHU0MTJmZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNWFhO1xcdTQzYjl1ZXN0XFx1ODAzYlxceGJmXFx1NDBiZlxcdTAxMDBjaVxcdTIzOGFcXHUyMzhmcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYmVuXFx1MDI4MDtFZHN2XFx1MDRmNFxcdTIzOWJcXHUyMzlkXFx1MjNhMVxcdTA0ZjM7XFx1NjJmOW90O1xcdTYyZjVcXHUwMTAwO3ZcXHUyM2E2XFx1MjNhN1xcdTYyZjQ7XFx1NjJmM1xcdTAxMDA7aVxcdTA3NzdcXHUyM2FlbGRlO1xcdTQxMjlcXHUwMWViXFx1MjNiOFxcMFxcdTIzYmNjeTtcXHU0NDU2bFxcdTgwM2JcXHhlZlxcdTQwZWZcXHUwMzAwY2Ztb3N1XFx1MjNjY1xcdTIzZDdcXHUyM2RjXFx1MjNlMVxcdTIzZTdcXHUyM2Y1XFx1MDEwMGl5XFx1MjNkMVxcdTIzZDVyYztcXHU0MTM1O1xcdTQ0MzlyO1xcdWMwMDBcXHVkODM1XFx1ZGQyN2F0aDtcXHU0MjM3cGY7XFx1YzAwMFxcdWQ4MzVcXHVkZDViXFx1MDFlM1xcdTIzZWNcXDBcXHUyM2YxcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYmZyY3k7XFx1NDQ1OGtjeTtcXHU0NDU0XFx1MDQwMGFjZmdoam9zXFx1MjQwYlxcdTI0MTZcXHUyNDIyXFx1MjQyN1xcdTI0MmRcXHUyNDMxXFx1MjQzNVxcdTI0M2JwcGFcXHUwMTAwO3ZcXHUyNDEzXFx1MjQxNFxcdTQzYmE7XFx1NDNmMFxcdTAxMDBleVxcdTI0MWJcXHUyNDIwZGlsO1xcdTQxMzc7XFx1NDQzYXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDI4cmVlbjtcXHU0MTM4Y3k7XFx1NDQ0NWN5O1xcdTQ0NWNwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNWNjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzBcXHUwYjgwQUJFSGFiY2RlZmdoamxtbm9wcnN0dXZcXHUyNDcwXFx1MjQ4MVxcdTI0ODZcXHUyNDhkXFx1MjQ5MVxcdTI1MGVcXHUyNTNkXFx1MjU1YVxcdTI1ODBcXHUyNjRlXFx1MjY1ZVxcdTI2NjVcXHUyNjc5XFx1MjY3ZFxcdTI2OWFcXHUyNmIyXFx1MjZkOFxcdTI3NWRcXHUyNzY4XFx1Mjc4YlxcdTI3YzBcXHUyODAxXFx1MjgxMlxcdTAxODBhcnRcXHUyNDc3XFx1MjQ3YVxcdTI0N2NyXFx4ZjJcXHUwOWM2XFx4ZjJcXHUwMzk1YWlsO1xcdTY5MWJhcnI7XFx1NjkwZVxcdTAxMDA7Z1xcdTA5OTRcXHUyNDhiO1xcdTZhOGJhcjtcXHU2OTYyXFx1MDk2M1xcdTI0YTVcXDBcXHUyNGFhXFwwXFx1MjRiMVxcMFxcMFxcMFxcMFxcMFxcdTI0YjVcXHUyNGJhXFwwXFx1MjRjNlxcdTI0YzhcXHUyNGNkXFwwXFx1MjRmOXV0ZTtcXHU0MTNhbXB0eXY7XFx1NjliNHJhXFx4ZWVcXHUwODRjYmRhO1xcdTQzYmJnXFx1MDE4MDtkbFxcdTA4OGVcXHUyNGMxXFx1MjRjMztcXHU2OTkxXFx4ZTVcXHUwODhlO1xcdTZhODV1b1xcdTgwM2JcXHhhYlxcdTQwYWJyXFx1MDQwMDtiZmhscHN0XFx1MDg5OVxcdTI0ZGVcXHUyNGU2XFx1MjRlOVxcdTI0ZWJcXHUyNGVlXFx1MjRmMVxcdTI0ZjVcXHUwMTAwO2ZcXHUwODlkXFx1MjRlM3M7XFx1NjkxZnM7XFx1NjkxZFxceGViXFx1MjI1MnA7XFx1NjFhYmw7XFx1NjkzOWltO1xcdTY5NzNsO1xcdTYxYTJcXHUwMTgwO2FlXFx1MjRmZlxcdTI1MDBcXHUyNTA0XFx1NmFhYmlsO1xcdTY5MTlcXHUwMTAwO3NcXHUyNTA5XFx1MjUwYVxcdTZhYWQ7XFx1YzAwMFxcdTJhYWRcXHVmZTAwXFx1MDE4MGFiclxcdTI1MTVcXHUyNTE5XFx1MjUxZHJyO1xcdTY5MGNyaztcXHU2NzcyXFx1MDEwMGFrXFx1MjUyMlxcdTI1MmNjXFx1MDEwMGVrXFx1MjUyOFxcdTI1MmE7XFx1NDA3YjtcXHU0MDViXFx1MDEwMGVzXFx1MjUzMVxcdTI1MzM7XFx1Njk4YmxcXHUwMTAwZHVcXHUyNTM5XFx1MjUzYjtcXHU2OThmO1xcdTY5OGRcXHUwMjAwYWV1eVxcdTI1NDZcXHUyNTRiXFx1MjU1NlxcdTI1NThyb247XFx1NDEzZVxcdTAxMDBkaVxcdTI1NTBcXHUyNTU0aWw7XFx1NDEzY1xceGVjXFx1MDhiMFxceGUyXFx1MjUyOTtcXHU0NDNiXFx1MDIwMGNxcnNcXHUyNTYzXFx1MjU2NlxcdTI1NmRcXHUyNTdkYTtcXHU2OTM2dW9cXHUwMTAwO3JcXHUwZTE5XFx1MTc0NlxcdTAxMDBkdVxcdTI1NzJcXHUyNTc3aGFyO1xcdTY5NjdzaGFyO1xcdTY5NGJoO1xcdTYxYjJcXHUwMjgwO2ZncXNcXHUyNThiXFx1MjU4Y1xcdTA5ODlcXHUyNWYzXFx1MjVmZlxcdTYyNjR0XFx1MDI4MGFobHJ0XFx1MjU5OFxcdTI1YTRcXHUyNWI3XFx1MjVjMlxcdTI1ZThycm93XFx1MDEwMDt0XFx1MDg5OVxcdTI1YTFhXFx4ZTlcXHUyNGY2YXJwb29uXFx1MDEwMGR1XFx1MjVhZlxcdTI1YjRvd25cXHhiYlxcdTA0NWFwXFx4YmJcXHUwOTY2ZWZ0YXJyb3dzO1xcdTYxYzdpZ2h0XFx1MDE4MGFoc1xcdTI1Y2RcXHUyNWQ2XFx1MjVkZXJyb3dcXHUwMTAwO3NcXHUwOGY0XFx1MDhhN2FycG9vblxceGYzXFx1MGY5OHF1aWdhcnJvXFx4ZjdcXHUyMWYwaHJlZXRpbWVzO1xcdTYyY2JcXHUwMTgwO3FzXFx1MjU4YlxcdTA5OTNcXHUyNWZhbGFuXFx4ZjRcXHUwOWFjXFx1MDI4MDtjZGdzXFx1MDlhY1xcdTI2MGFcXHUyNjBkXFx1MjYxZFxcdTI2MjhjO1xcdTZhYThvdFxcdTAxMDA7b1xcdTI2MTRcXHUyNjE1XFx1NmE3ZlxcdTAxMDA7clxcdTI2MWFcXHUyNjFiXFx1NmE4MTtcXHU2YTgzXFx1MDEwMDtlXFx1MjYyMlxcdTI2MjVcXHVjMDAwXFx1MjJkYVxcdWZlMDBzO1xcdTZhOTNcXHUwMjgwYWRlZ3NcXHUyNjMzXFx1MjYzOVxcdTI2M2RcXHUyNjQ5XFx1MjY0YnBwcm9cXHhmOFxcdTI0YzZvdDtcXHU2MmQ2cVxcdTAxMDBncVxcdTI2NDNcXHUyNjQ1XFx4ZjRcXHUwOTg5Z3RcXHhmMlxcdTI0OGNcXHhmNFxcdTA5OWJpXFx4ZWRcXHUwOWIyXFx1MDE4MGlsclxcdTI2NTVcXHUwOGUxXFx1MjY1YXNodDtcXHU2OTdjO1xcdWMwMDBcXHVkODM1XFx1ZGQyOVxcdTAxMDA7RVxcdTA5OWNcXHUyNjYzO1xcdTZhOTFcXHUwMTYxXFx1MjY2OVxcdTI2NzZyXFx1MDEwMGR1XFx1MjViMlxcdTI2NmVcXHUwMTAwO2xcXHUwOTY1XFx1MjY3MztcXHU2OTZhbGs7XFx1NjU4NGN5O1xcdTQ0NTlcXHUwMjgwO2FjaHRcXHUwYTQ4XFx1MjY4OFxcdTI2OGJcXHUyNjkxXFx1MjY5NnJcXHhmMlxcdTI1YzFvcm5lXFx4ZjJcXHUxZDA4YXJkO1xcdTY5NmJyaTtcXHU2NWZhXFx1MDEwMGlvXFx1MjY5ZlxcdTI2YTRkb3Q7XFx1NDE0MHVzdFxcdTAxMDA7YVxcdTI2YWNcXHUyNmFkXFx1NjNiMGNoZVxceGJiXFx1MjZhZFxcdTAyMDBFYWVzXFx1MjZiYlxcdTI2YmRcXHUyNmM5XFx1MjZkNDtcXHU2MjY4cFxcdTAxMDA7cFxcdTI2YzNcXHUyNmM0XFx1NmE4OXJveFxceGJiXFx1MjZjNFxcdTAxMDA7cVxcdTI2Y2VcXHUyNmNmXFx1NmE4N1xcdTAxMDA7cVxcdTI2Y2VcXHUyNmJiaW07XFx1NjJlNlxcdTA0MDBhYm5vcHR3elxcdTI2ZTlcXHUyNmY0XFx1MjZmN1xcdTI3MWFcXHUyNzJmXFx1Mjc0MVxcdTI3NDdcXHUyNzUwXFx1MDEwMG5yXFx1MjZlZVxcdTI2ZjFnO1xcdTY3ZWNyO1xcdTYxZmRyXFx4ZWJcXHUwOGMxZ1xcdTAxODBsbXJcXHUyNmZmXFx1MjcwZFxcdTI3MTRlZnRcXHUwMTAwYXJcXHUwOWU2XFx1MjcwN2lnaHRcXHhlMVxcdTA5ZjJhcHN0bztcXHU2N2ZjaWdodFxceGUxXFx1MDlmZHBhcnJvd1xcdTAxMDBsclxcdTI3MjVcXHUyNzI5ZWZcXHhmNFxcdTI0ZWRpZ2h0O1xcdTYxYWNcXHUwMTgwYWZsXFx1MjczNlxcdTI3MzlcXHUyNzNkcjtcXHU2OTg1O1xcdWMwMDBcXHVkODM1XFx1ZGQ1ZHVzO1xcdTZhMmRpbWVzO1xcdTZhMzRcXHUwMTYxXFx1Mjc0YlxcdTI3NGZzdDtcXHU2MjE3XFx4ZTFcXHUxMzRlXFx1MDE4MDtlZlxcdTI3NTdcXHUyNzU4XFx1MTgwMFxcdTY1Y2FuZ2VcXHhiYlxcdTI3NThhclxcdTAxMDA7bFxcdTI3NjRcXHUyNzY1XFx1NDAyOHQ7XFx1Njk5M1xcdTAyODBhY2htdFxcdTI3NzNcXHUyNzc2XFx1Mjc3Y1xcdTI3ODVcXHUyNzg3clxceGYyXFx1MDhhOG9ybmVcXHhmMlxcdTFkOGNhclxcdTAxMDA7ZFxcdTBmOThcXHUyNzgzO1xcdTY5NmQ7XFx1NjAwZXJpO1xcdTYyYmZcXHUwMzAwYWNoaXF0XFx1Mjc5OFxcdTI3OWRcXHUwYTQwXFx1MjdhMlxcdTI3YWVcXHUyN2JicXVvO1xcdTYwMzlyO1xcdWMwMDBcXHVkODM1XFx1ZGNjMW1cXHUwMTgwO2VnXFx1MDliMlxcdTI3YWFcXHUyN2FjO1xcdTZhOGQ7XFx1NmE4ZlxcdTAxMDBidVxcdTI1MmFcXHUyN2Izb1xcdTAxMDA7clxcdTBlMWZcXHUyN2I5O1xcdTYwMWFyb2s7XFx1NDE0MlxcdTg0MDA8O2NkaGlscXJcXHUwODJiXFx1MjdkMlxcdTI2MzlcXHUyN2RjXFx1MjdlMFxcdTI3ZTVcXHUyN2VhXFx1MjdmMFxcdTAxMDBjaVxcdTI3ZDdcXHUyN2Q5O1xcdTZhYTZyO1xcdTZhNzlyZVxceGU1XFx1MjVmMm1lcztcXHU2MmM5YXJyO1xcdTY5NzZ1ZXN0O1xcdTZhN2JcXHUwMTAwUGlcXHUyN2Y1XFx1MjdmOWFyO1xcdTY5OTZcXHUwMTgwO2VmXFx1MjgwMFxcdTA5MmRcXHUxODFiXFx1NjVjM3JcXHUwMTAwZHVcXHUyODA3XFx1MjgwZHNoYXI7XFx1Njk0YWhhcjtcXHU2OTY2XFx1MDEwMGVuXFx1MjgxN1xcdTI4MjFydG5lcXE7XFx1YzAwMFxcdTIyNjhcXHVmZTAwXFx4YzVcXHUyODFlXFx1MDcwMERhY2RlZmhpbG5vcHN1XFx1Mjg0MFxcdTI4NDVcXHUyODgyXFx1Mjg4ZVxcdTI4OTNcXHUyOGEwXFx1MjhhNVxcdTI4YThcXHUyOGRhXFx1MjhlMlxcdTI4ZTRcXHUwYTgzXFx1MjhmM1xcdTI5MDJEb3Q7XFx1NjIzYVxcdTAyMDBjbHByXFx1Mjg0ZVxcdTI4NTJcXHUyODYzXFx1Mjg3ZHJcXHU4MDNiXFx4YWZcXHU0MGFmXFx1MDEwMGV0XFx1Mjg1N1xcdTI4NTk7XFx1NjY0MlxcdTAxMDA7ZVxcdTI4NWVcXHUyODVmXFx1NjcyMHNlXFx4YmJcXHUyODVmXFx1MDEwMDtzXFx1MTAzYlxcdTI4Njh0b1xcdTAyMDA7ZGx1XFx1MTAzYlxcdTI4NzNcXHUyODc3XFx1Mjg3Ym93XFx4ZWVcXHUwNDhjZWZcXHhmNFxcdTA5MGZcXHhmMFxcdTEzZDFrZXI7XFx1NjVhZVxcdTAxMDBveVxcdTI4ODdcXHUyODhjbW1hO1xcdTZhMjk7XFx1NDQzY2FzaDtcXHU2MDE0YXN1cmVkYW5nbGVcXHhiYlxcdTE2MjZyO1xcdWMwMDBcXHVkODM1XFx1ZGQyYW87XFx1NjEyN1xcdTAxODBjZG5cXHUyOGFmXFx1MjhiNFxcdTI4Yzlyb1xcdTgwM2JcXHhiNVxcdTQwYjVcXHUwMjAwO2FjZFxcdTE0NjRcXHUyOGJkXFx1MjhjMFxcdTI4YzRzXFx4ZjRcXHUxNmE3aXI7XFx1NmFmMG90XFx1ODBiYlxceGI3XFx1MDFiNXVzXFx1MDE4MDtiZFxcdTI4ZDJcXHUxOTAzXFx1MjhkM1xcdTYyMTJcXHUwMTAwO3VcXHUxZDNjXFx1MjhkODtcXHU2YTJhXFx1MDE2M1xcdTI4ZGVcXHUyOGUxcDtcXHU2YWRiXFx4ZjJcXHUyMjEyXFx4ZjBcXHUwYTgxXFx1MDEwMGRwXFx1MjhlOVxcdTI4ZWVlbHM7XFx1NjJhN2Y7XFx1YzAwMFxcdWQ4MzVcXHVkZDVlXFx1MDEwMGN0XFx1MjhmOFxcdTI4ZmRyO1xcdWMwMDBcXHVkODM1XFx1ZGNjMnBvc1xceGJiXFx1MTU5ZFxcdTAxODA7bG1cXHUyOTA5XFx1MjkwYVxcdTI5MGRcXHU0M2JjdGltYXA7XFx1NjJiOFxcdTBjMDBHTFJWYWJjZGVmZ2hpamxtb3Byc3R1dndcXHUyOTQyXFx1Mjk1M1xcdTI5N2VcXHUyOTg5XFx1Mjk5OFxcdTI5ZGFcXHUyOWU5XFx1MmExNVxcdTJhMWFcXHUyYTU4XFx1MmE1ZFxcdTJhODNcXHUyYTk1XFx1MmFhNFxcdTJhYThcXHUyYjA0XFx1MmIwN1xcdTJiNDRcXHUyYjdmXFx1MmJhZVxcdTJjMzRcXHUyYzY3XFx1MmM3Y1xcdTJjZTlcXHUwMTAwZ3RcXHUyOTQ3XFx1Mjk0YjtcXHVjMDAwXFx1MjJkOVxcdTAzMzhcXHUwMTAwO3ZcXHUyOTUwXFx1MGJjZlxcdWMwMDBcXHUyMjZiXFx1MjBkMlxcdTAxODBlbHRcXHUyOTVhXFx1Mjk3MlxcdTI5NzZmdFxcdTAxMDBhclxcdTI5NjFcXHUyOTY3cnJvdztcXHU2MWNkaWdodGFycm93O1xcdTYxY2U7XFx1YzAwMFxcdTIyZDhcXHUwMzM4XFx1MDEwMDt2XFx1Mjk3YlxcdTBjNDdcXHVjMDAwXFx1MjI2YVxcdTIwZDJpZ2h0YXJyb3c7XFx1NjFjZlxcdTAxMDBEZFxcdTI5OGVcXHUyOTkzYXNoO1xcdTYyYWZhc2g7XFx1NjJhZVxcdTAyODBiY25wdFxcdTI5YTNcXHUyOWE3XFx1MjlhY1xcdTI5YjFcXHUyOWNjbGFcXHhiYlxcdTAyZGV1dGU7XFx1NDE0NGc7XFx1YzAwMFxcdTIyMjBcXHUyMGQyXFx1MDI4MDtFaW9wXFx1MGQ4NFxcdTI5YmNcXHUyOWMwXFx1MjljNVxcdTI5Yzg7XFx1YzAwMFxcdTJhNzBcXHUwMzM4ZDtcXHVjMDAwXFx1MjI0YlxcdTAzMzhzO1xcdTQxNDlyb1xceGY4XFx1MGQ4NHVyXFx1MDEwMDthXFx1MjlkM1xcdTI5ZDRcXHU2NjZlbFxcdTAxMDA7c1xcdTI5ZDNcXHUwYjM4XFx1MDFmM1xcdTI5ZGZcXDBcXHUyOWUzcFxcdTgwYmJcXHhhMFxcdTBiMzdtcFxcdTAxMDA7ZVxcdTBiZjlcXHUwYzAwXFx1MDI4MGFlb3V5XFx1MjlmNFxcdTI5ZmVcXHUyYTAzXFx1MmExMFxcdTJhMTNcXHUwMWYwXFx1MjlmOVxcMFxcdTI5ZmI7XFx1NmE0M29uO1xcdTQxNDhkaWw7XFx1NDE0Nm5nXFx1MDEwMDtkXFx1MGQ3ZVxcdTJhMGFvdDtcXHVjMDAwXFx1MmE2ZFxcdTAzMzhwO1xcdTZhNDI7XFx1NDQzZGFzaDtcXHU2MDEzXFx1MDM4MDtBYWRxc3hcXHUwYjkyXFx1MmEyOVxcdTJhMmRcXHUyYTNiXFx1MmE0MVxcdTJhNDVcXHUyYTUwcnI7XFx1NjFkN3JcXHUwMTAwaHJcXHUyYTMzXFx1MmEzNms7XFx1NjkyNFxcdTAxMDA7b1xcdTEzZjJcXHUxM2Ywb3Q7XFx1YzAwMFxcdTIyNTBcXHUwMzM4dWlcXHhmNlxcdTBiNjNcXHUwMTAwZWlcXHUyYTRhXFx1MmE0ZWFyO1xcdTY5MjhcXHhlZFxcdTBiOThpc3RcXHUwMTAwO3NcXHUwYmEwXFx1MGI5ZnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDJiXFx1MDIwMEVlc3RcXHUwYmM1XFx1MmE2NlxcdTJhNzlcXHUyYTdjXFx1MDE4MDtxc1xcdTBiYmNcXHUyYTZkXFx1MGJlMVxcdTAxODA7cXNcXHUwYmJjXFx1MGJjNVxcdTJhNzRsYW5cXHhmNFxcdTBiZTJpXFx4ZWRcXHUwYmVhXFx1MDEwMDtyXFx1MGJiNlxcdTJhODFcXHhiYlxcdTBiYjdcXHUwMTgwQWFwXFx1MmE4YVxcdTJhOGRcXHUyYTkxclxceGYyXFx1Mjk3MXJyO1xcdTYxYWVhcjtcXHU2YWYyXFx1MDE4MDtzdlxcdTBmOGRcXHUyYTljXFx1MGY4Y1xcdTAxMDA7ZFxcdTJhYTFcXHUyYWEyXFx1NjJmYztcXHU2MmZhY3k7XFx1NDQ1YVxcdTAzODBBRWFkZXN0XFx1MmFiN1xcdTJhYmFcXHUyYWJlXFx1MmFjMlxcdTJhYzVcXHUyYWY2XFx1MmFmOXJcXHhmMlxcdTI5NjY7XFx1YzAwMFxcdTIyNjZcXHUwMzM4cnI7XFx1NjE5YXI7XFx1NjAyNVxcdTAyMDA7ZnFzXFx1MGMzYlxcdTJhY2VcXHUyYWUzXFx1MmFlZnRcXHUwMTAwYXJcXHUyYWQ0XFx1MmFkOXJyb1xceGY3XFx1MmFjMWlnaHRhcnJvXFx4ZjdcXHUyYTkwXFx1MDE4MDtxc1xcdTBjM2JcXHUyYWJhXFx1MmFlYWxhblxceGY0XFx1MGM1NVxcdTAxMDA7c1xcdTBjNTVcXHUyYWY0XFx4YmJcXHUwYzM2aVxceGVkXFx1MGM1ZFxcdTAxMDA7clxcdTBjMzVcXHUyYWZlaVxcdTAxMDA7ZVxcdTBjMWFcXHUwYzI1aVxceGU0XFx1MGQ5MFxcdTAxMDBwdFxcdTJiMGNcXHUyYjExZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNWZcXHU4MTgwXFx4YWM7aW5cXHUyYjE5XFx1MmIxYVxcdTJiMzZcXHU0MGFjblxcdTAyMDA7RWR2XFx1MGI4OVxcdTJiMjRcXHUyYjI4XFx1MmIyZTtcXHVjMDAwXFx1MjJmOVxcdTAzMzhvdDtcXHVjMDAwXFx1MjJmNVxcdTAzMzhcXHUwMWUxXFx1MGI4OVxcdTJiMzNcXHUyYjM1O1xcdTYyZjc7XFx1NjJmNmlcXHUwMTAwO3ZcXHUwY2I4XFx1MmIzY1xcdTAxZTFcXHUwY2I4XFx1MmI0MVxcdTJiNDM7XFx1NjJmZTtcXHU2MmZkXFx1MDE4MGFvclxcdTJiNGJcXHUyYjYzXFx1MmI2OXJcXHUwMjAwO2FzdFxcdTBiN2JcXHUyYjU1XFx1MmI1YVxcdTJiNWZsbGVcXHhlY1xcdTBiN2JsO1xcdWMwMDBcXHUyYWZkXFx1MjBlNTtcXHVjMDAwXFx1MjIwMlxcdTAzMzhsaW50O1xcdTZhMTRcXHUwMTgwO2NlXFx1MGM5MlxcdTJiNzBcXHUyYjczdVxceGU1XFx1MGNhNVxcdTAxMDA7Y1xcdTBjOThcXHUyYjc4XFx1MDEwMDtlXFx1MGM5MlxcdTJiN2RcXHhmMVxcdTBjOThcXHUwMjAwQWFpdFxcdTJiODhcXHUyYjhiXFx1MmI5ZFxcdTJiYTdyXFx4ZjJcXHUyOTg4cnJcXHUwMTgwO2N3XFx1MmI5NFxcdTJiOTVcXHUyYjk5XFx1NjE5YjtcXHVjMDAwXFx1MjkzM1xcdTAzMzg7XFx1YzAwMFxcdTIxOWRcXHUwMzM4Z2h0YXJyb3dcXHhiYlxcdTJiOTVyaVxcdTAxMDA7ZVxcdTBjY2JcXHUwY2Q2XFx1MDM4MGNoaW1wcXVcXHUyYmJkXFx1MmJjZFxcdTJiZDlcXHUyYjA0XFx1MGI3OFxcdTJiZTRcXHUyYmVmXFx1MDIwMDtjZXJcXHUwZDMyXFx1MmJjNlxcdTBkMzdcXHUyYmM5dVxceGU1XFx1MGQ0NTtcXHVjMDAwXFx1ZDgzNVxcdWRjYzNvcnRcXHUwMjZkXFx1MmIwNVxcMFxcMFxcdTJiZDZhclxceGUxXFx1MmI1Nm1cXHUwMTAwO2VcXHUwZDZlXFx1MmJkZlxcdTAxMDA7cVxcdTBkNzRcXHUwZDczc3VcXHUwMTAwYnBcXHUyYmViXFx1MmJlZFxceGU1XFx1MGNmOFxceGU1XFx1MGQwYlxcdTAxODBiY3BcXHUyYmY2XFx1MmMxMVxcdTJjMTlcXHUwMjAwO0Vlc1xcdTJiZmZcXHUyYzAwXFx1MGQyMlxcdTJjMDRcXHU2Mjg0O1xcdWMwMDBcXHUyYWM1XFx1MDMzOGV0XFx1MDEwMDtlXFx1MGQxYlxcdTJjMGJxXFx1MDEwMDtxXFx1MGQyM1xcdTJjMDBjXFx1MDEwMDtlXFx1MGQzMlxcdTJjMTdcXHhmMVxcdTBkMzhcXHUwMjAwO0Vlc1xcdTJjMjJcXHUyYzIzXFx1MGQ1ZlxcdTJjMjdcXHU2Mjg1O1xcdWMwMDBcXHUyYWM2XFx1MDMzOGV0XFx1MDEwMDtlXFx1MGQ1OFxcdTJjMmVxXFx1MDEwMDtxXFx1MGQ2MFxcdTJjMjNcXHUwMjAwZ2lsclxcdTJjM2RcXHUyYzNmXFx1MmM0NVxcdTJjNDdcXHhlY1xcdTBiZDdsZGVcXHU4MDNiXFx4ZjFcXHU0MGYxXFx4ZTdcXHUwYzQzaWFuZ2xlXFx1MDEwMGxyXFx1MmM1MlxcdTJjNWNlZnRcXHUwMTAwO2VcXHUwYzFhXFx1MmM1YVxceGYxXFx1MGMyNmlnaHRcXHUwMTAwO2VcXHUwY2NiXFx1MmM2NVxceGYxXFx1MGNkN1xcdTAxMDA7bVxcdTJjNmNcXHUyYzZkXFx1NDNiZFxcdTAxODA7ZXNcXHUyYzc0XFx1MmM3NVxcdTJjNzlcXHU0MDIzcm87XFx1NjExNnA7XFx1NjAwN1xcdTA0ODBESGFkZ2lscnNcXHUyYzhmXFx1MmM5NFxcdTJjOTlcXHUyYzllXFx1MmNhM1xcdTJjYjBcXHUyY2I2XFx1MmNkM1xcdTJjZTNhc2g7XFx1NjJhZGFycjtcXHU2OTA0cDtcXHVjMDAwXFx1MjI0ZFxcdTIwZDJhc2g7XFx1NjJhY1xcdTAxMDBldFxcdTJjYThcXHUyY2FjO1xcdWMwMDBcXHUyMjY1XFx1MjBkMjtcXHVjMDAwPlxcdTIwZDJuZmluO1xcdTY5ZGVcXHUwMTgwQWV0XFx1MmNiZFxcdTJjYzFcXHUyY2M1cnI7XFx1NjkwMjtcXHVjMDAwXFx1MjI2NFxcdTIwZDJcXHUwMTAwO3JcXHUyY2NhXFx1MmNjZFxcdWMwMDA8XFx1MjBkMmllO1xcdWMwMDBcXHUyMmI0XFx1MjBkMlxcdTAxMDBBdFxcdTJjZDhcXHUyY2RjcnI7XFx1NjkwM3JpZTtcXHVjMDAwXFx1MjJiNVxcdTIwZDJpbTtcXHVjMDAwXFx1MjIzY1xcdTIwZDJcXHUwMTgwQWFuXFx1MmNmMFxcdTJjZjRcXHUyZDAycnI7XFx1NjFkNnJcXHUwMTAwaHJcXHUyY2ZhXFx1MmNmZGs7XFx1NjkyM1xcdTAxMDA7b1xcdTEzZTdcXHUxM2U1ZWFyO1xcdTY5MjdcXHUxMjUzXFx1MWE5NVxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcdTJkMmRcXDBcXHUyZDM4XFx1MmQ0OFxcdTJkNjBcXHUyZDY1XFx1MmQ3MlxcdTJkODRcXHUxYjA3XFwwXFwwXFx1MmQ4ZFxcdTJkYWJcXDBcXHUyZGM4XFx1MmRjZVxcMFxcdTJkZGNcXHUyZTE5XFx1MmUyYlxcdTJlM2VcXHUyZTQzXFx1MDEwMGNzXFx1MmQzMVxcdTFhOTd1dGVcXHU4MDNiXFx4ZjNcXHU0MGYzXFx1MDEwMGl5XFx1MmQzY1xcdTJkNDVyXFx1MDEwMDtjXFx1MWE5ZVxcdTJkNDJcXHU4MDNiXFx4ZjRcXHU0MGY0O1xcdTQ0M2VcXHUwMjgwYWJpb3NcXHUxYWEwXFx1MmQ1MlxcdTJkNTdcXHUwMWM4XFx1MmQ1YWxhYztcXHU0MTUxdjtcXHU2YTM4b2xkO1xcdTY5YmNsaWc7XFx1NDE1M1xcdTAxMDBjclxcdTJkNjlcXHUyZDZkaXI7XFx1NjliZjtcXHVjMDAwXFx1ZDgzNVxcdWRkMmNcXHUwMzZmXFx1MmQ3OVxcMFxcMFxcdTJkN2NcXDBcXHUyZDgybjtcXHU0MmRiYXZlXFx1ODAzYlxceGYyXFx1NDBmMjtcXHU2OWMxXFx1MDEwMGJtXFx1MmQ4OFxcdTBkZjRhcjtcXHU2OWI1XFx1MDIwMGFjaXRcXHUyZDk1XFx1MmQ5OFxcdTJkYTVcXHUyZGE4clxceGYyXFx1MWE4MFxcdTAxMDBpclxcdTJkOWRcXHUyZGEwcjtcXHU2OWJlb3NzO1xcdTY5YmJuXFx4ZTVcXHUwZTUyO1xcdTY5YzBcXHUwMTgwYWVpXFx1MmRiMVxcdTJkYjVcXHUyZGI5Y3I7XFx1NDE0ZGdhO1xcdTQzYzlcXHUwMTgwY2RuXFx1MmRjMFxcdTJkYzVcXHUwMWNkcm9uO1xcdTQzYmY7XFx1NjliNnBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2MFxcdTAxODBhZWxcXHUyZGQ0XFx1MmRkN1xcdTAxZDJyO1xcdTY5YjdycDtcXHU2OWI5XFx1MDM4MDthZGlvc3ZcXHUyZGVhXFx1MmRlYlxcdTJkZWVcXHUyZTA4XFx1MmUwZFxcdTJlMTBcXHUyZTE2XFx1NjIyOHJcXHhmMlxcdTFhODZcXHUwMjAwO2VmbVxcdTJkZjdcXHUyZGY4XFx1MmUwMlxcdTJlMDVcXHU2YTVkclxcdTAxMDA7b1xcdTJkZmVcXHUyZGZmXFx1NjEzNGZcXHhiYlxcdTJkZmZcXHU4MDNiXFx4YWFcXHU0MGFhXFx1ODAzYlxceGJhXFx1NDBiYWdvZjtcXHU2MmI2cjtcXHU2YTU2bG9wZTtcXHU2YTU3O1xcdTZhNWJcXHUwMTgwY2xvXFx1MmUxZlxcdTJlMjFcXHUyZTI3XFx4ZjJcXHUyZTAxYXNoXFx1ODAzYlxceGY4XFx1NDBmOGw7XFx1NjI5OGlcXHUwMTZjXFx1MmUyZlxcdTJlMzRkZVxcdTgwM2JcXHhmNVxcdTQwZjVlc1xcdTAxMDA7YVxcdTAxZGJcXHUyZTNhcztcXHU2YTM2bWxcXHU4MDNiXFx4ZjZcXHU0MGY2YmFyO1xcdTYzM2RcXHUwYWUxXFx1MmU1ZVxcMFxcdTJlN2RcXDBcXHUyZTgwXFx1MmU5ZFxcMFxcdTJlYTJcXHUyZWI5XFwwXFwwXFx1MmVjYlxcdTBlOWNcXDBcXHUyZjEzXFwwXFwwXFx1MmYyYlxcdTJmYmNcXDBcXHUyZmM4clxcdTAyMDA7YXN0XFx1MDQwM1xcdTJlNjdcXHUyZTcyXFx1MGU4NVxcdTgxMDBcXHhiNjtsXFx1MmU2ZFxcdTJlNmVcXHU0MGI2bGVcXHhlY1xcdTA0MDNcXHUwMjY5XFx1MmU3OFxcMFxcMFxcdTJlN2JtO1xcdTZhZjM7XFx1NmFmZHk7XFx1NDQzZnJcXHUwMjgwY2ltcHRcXHUyZThiXFx1MmU4ZlxcdTJlOTNcXHUxODY1XFx1MmU5N250O1xcdTQwMjVvZDtcXHU0MDJlaWw7XFx1NjAzMGVuaztcXHU2MDMxcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMmRcXHUwMTgwaW1vXFx1MmVhOFxcdTJlYjBcXHUyZWI0XFx1MDEwMDt2XFx1MmVhZFxcdTJlYWVcXHU0M2M2O1xcdTQzZDVtYVxceGY0XFx1MGE3Nm5lO1xcdTY2MGVcXHUwMTgwO3R2XFx1MmViZlxcdTJlYzBcXHUyZWM4XFx1NDNjMGNoZm9ya1xceGJiXFx1MWZmZDtcXHU0M2Q2XFx1MDEwMGF1XFx1MmVjZlxcdTJlZGZuXFx1MDEwMGNrXFx1MmVkNVxcdTJlZGRrXFx1MDEwMDtoXFx1MjFmNFxcdTJlZGI7XFx1NjEwZVxceGY2XFx1MjFmNHNcXHUwNDgwO2FiY2RlbXN0XFx1MmVmM1xcdTJlZjRcXHUxOTA4XFx1MmVmOVxcdTJlZmRcXHUyZjA0XFx1MmYwNlxcdTJmMGFcXHUyZjBlXFx1NDAyYmNpcjtcXHU2YTIzaXI7XFx1NmEyMlxcdTAxMDBvdVxcdTFkNDBcXHUyZjAyO1xcdTZhMjU7XFx1NmE3Mm5cXHU4MGJiXFx4YjFcXHUwZTlkaW07XFx1NmEyNndvO1xcdTZhMjdcXHUwMTgwaXB1XFx1MmYxOVxcdTJmMjBcXHUyZjI1bnRpbnQ7XFx1NmExNWY7XFx1YzAwMFxcdWQ4MzVcXHVkZDYxbmRcXHU4MDNiXFx4YTNcXHU0MGEzXFx1MDUwMDtFYWNlaW5vc3VcXHUwZWM4XFx1MmYzZlxcdTJmNDFcXHUyZjQ0XFx1MmY0N1xcdTJmODFcXHUyZjg5XFx1MmY5MlxcdTJmN2VcXHUyZmI2O1xcdTZhYjNwO1xcdTZhYjd1XFx4ZTVcXHUwZWQ5XFx1MDEwMDtjXFx1MGVjZVxcdTJmNGNcXHUwMzAwO2FjZW5zXFx1MGVjOFxcdTJmNTlcXHUyZjVmXFx1MmY2NlxcdTJmNjhcXHUyZjdlcHByb1xceGY4XFx1MmY0M3VybHllXFx4ZjFcXHUwZWQ5XFx4ZjFcXHUwZWNlXFx1MDE4MGFlc1xcdTJmNmZcXHUyZjc2XFx1MmY3YXBwcm94O1xcdTZhYjlxcTtcXHU2YWI1aW07XFx1NjJlOGlcXHhlZFxcdTBlZGZtZVxcdTAxMDA7c1xcdTJmODhcXHUwZWFlXFx1NjAzMlxcdTAxODBFYXNcXHUyZjc4XFx1MmY5MFxcdTJmN2FcXHhmMFxcdTJmNzVcXHUwMTgwZGZwXFx1MGVlY1xcdTJmOTlcXHUyZmFmXFx1MDE4MGFsc1xcdTJmYTBcXHUyZmE1XFx1MmZhYWxhcjtcXHU2MzJlaW5lO1xcdTYzMTJ1cmY7XFx1NjMxM1xcdTAxMDA7dFxcdTBlZmJcXHUyZmI0XFx4ZWZcXHUwZWZicmVsO1xcdTYyYjBcXHUwMTAwY2lcXHUyZmMwXFx1MmZjNXI7XFx1YzAwMFxcdWQ4MzVcXHVkY2M1O1xcdTQzYzhuY3NwO1xcdTYwMDhcXHUwMzAwZmlvcHN1XFx1MmZkYVxcdTIyZTJcXHUyZmRmXFx1MmZlNVxcdTJmZWJcXHUyZmYxcjtcXHVjMDAwXFx1ZDgzNVxcdWRkMmVwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNjJyaW1lO1xcdTYwNTdjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzZcXHUwMTgwYWVvXFx1MmZmOFxcdTMwMDlcXHUzMDEzdFxcdTAxMDBlaVxcdTJmZmVcXHUzMDA1cm5pb25cXHhmM1xcdTA2YjBudDtcXHU2YTE2c3RcXHUwMTAwO2VcXHUzMDEwXFx1MzAxMVxcdTQwM2ZcXHhmMVxcdTFmMTlcXHhmNFxcdTBmMTRcXHUwYTgwQUJIYWJjZGVmaGlsbW5vcHJzdHV4XFx1MzA0MFxcdTMwNTFcXHUzMDU1XFx1MzA1OVxcdTMwZTBcXHUzMTBlXFx1MzEyYlxcdTMxNDdcXHUzMTYyXFx1MzE3MlxcdTMxOGVcXHUzMjA2XFx1MzIxNVxcdTMyMjRcXHUzMjI5XFx1MzI1OFxcdTMyNmVcXHUzMjcyXFx1MzI5MFxcdTMyYjBcXHUzMmI3XFx1MDE4MGFydFxcdTMwNDdcXHUzMDRhXFx1MzA0Y3JcXHhmMlxcdTEwYjNcXHhmMlxcdTAzZGRhaWw7XFx1NjkxY2FyXFx4ZjJcXHUxYzY1YXI7XFx1Njk2NFxcdTAzODBjZGVucXJ0XFx1MzA2OFxcdTMwNzVcXHUzMDc4XFx1MzA3ZlxcdTMwOGZcXHUzMDk0XFx1MzBjY1xcdTAxMDBldVxcdTMwNmRcXHUzMDcxO1xcdWMwMDBcXHUyMjNkXFx1MDMzMXRlO1xcdTQxNTVpXFx4ZTNcXHUxMTZlbXB0eXY7XFx1NjliM2dcXHUwMjAwO2RlbFxcdTBmZDFcXHUzMDg5XFx1MzA4YlxcdTMwOGQ7XFx1Njk5MjtcXHU2OWE1XFx4ZTVcXHUwZmQxdW9cXHU4MDNiXFx4YmJcXHU0MGJiclxcdTA1ODA7YWJjZmhscHN0d1xcdTBmZGNcXHUzMGFjXFx1MzBhZlxcdTMwYjdcXHUzMGI5XFx1MzBiY1xcdTMwYmVcXHUzMGMwXFx1MzBjM1xcdTMwYzdcXHUzMGNhcDtcXHU2OTc1XFx1MDEwMDtmXFx1MGZlMFxcdTMwYjRzO1xcdTY5MjA7XFx1NjkzM3M7XFx1NjkxZVxceGViXFx1MjI1ZFxceGYwXFx1MjcyZWw7XFx1Njk0NWltO1xcdTY5NzRsO1xcdTYxYTM7XFx1NjE5ZFxcdTAxMDBhaVxcdTMwZDFcXHUzMGQ1aWw7XFx1NjkxYW9cXHUwMTAwO25cXHUzMGRiXFx1MzBkY1xcdTYyMzZhbFxceGYzXFx1MGYxZVxcdTAxODBhYnJcXHUzMGU3XFx1MzBlYVxcdTMwZWVyXFx4ZjJcXHUxN2U1cms7XFx1Njc3M1xcdTAxMDBha1xcdTMwZjNcXHUzMGZkY1xcdTAxMDBla1xcdTMwZjlcXHUzMGZiO1xcdTQwN2Q7XFx1NDA1ZFxcdTAxMDBlc1xcdTMxMDJcXHUzMTA0O1xcdTY5OGNsXFx1MDEwMGR1XFx1MzEwYVxcdTMxMGM7XFx1Njk4ZTtcXHU2OTkwXFx1MDIwMGFldXlcXHUzMTE3XFx1MzExY1xcdTMxMjdcXHUzMTI5cm9uO1xcdTQxNTlcXHUwMTAwZGlcXHUzMTIxXFx1MzEyNWlsO1xcdTQxNTdcXHhlY1xcdTBmZjJcXHhlMlxcdTMwZmE7XFx1NDQ0MFxcdTAyMDBjbHFzXFx1MzEzNFxcdTMxMzdcXHUzMTNkXFx1MzE0NGE7XFx1NjkzN2RoYXI7XFx1Njk2OXVvXFx1MDEwMDtyXFx1MDIwZVxcdTAyMGRoO1xcdTYxYjNcXHUwMTgwYWNnXFx1MzE0ZVxcdTMxNWZcXHUwZjQ0bFxcdTAyMDA7aXBzXFx1MGY3OFxcdTMxNThcXHUzMTViXFx1MTA5Y25cXHhlNVxcdTEwYmJhclxceGY0XFx1MGZhOXQ7XFx1NjVhZFxcdTAxODBpbHJcXHUzMTY5XFx1MTAyM1xcdTMxNmVzaHQ7XFx1Njk3ZDtcXHVjMDAwXFx1ZDgzNVxcdWRkMmZcXHUwMTAwYW9cXHUzMTc3XFx1MzE4NnJcXHUwMTAwZHVcXHUzMTdkXFx1MzE3ZlxceGJiXFx1MDQ3YlxcdTAxMDA7bFxcdTEwOTFcXHUzMTg0O1xcdTY5NmNcXHUwMTAwO3ZcXHUzMThiXFx1MzE4Y1xcdTQzYzE7XFx1NDNmMVxcdTAxODBnbnNcXHUzMTk1XFx1MzFmOVxcdTMxZmNodFxcdTAzMDBhaGxyc3RcXHUzMWE0XFx1MzFiMFxcdTMxYzJcXHUzMWQ4XFx1MzFlNFxcdTMxZWVycm93XFx1MDEwMDt0XFx1MGZkY1xcdTMxYWRhXFx4ZTlcXHUzMGM4YXJwb29uXFx1MDEwMGR1XFx1MzFiYlxcdTMxYmZvd1xceGVlXFx1MzE3ZXBcXHhiYlxcdTEwOTJlZnRcXHUwMTAwYWhcXHUzMWNhXFx1MzFkMHJyb3dcXHhmM1xcdTBmZWFhcnBvb25cXHhmM1xcdTA1NTFpZ2h0YXJyb3dzO1xcdTYxYzlxdWlnYXJyb1xceGY3XFx1MzBjYmhyZWV0aW1lcztcXHU2MmNjZztcXHU0MmRhaW5nZG90c2VcXHhmMVxcdTFmMzJcXHUwMTgwYWhtXFx1MzIwZFxcdTMyMTBcXHUzMjEzclxceGYyXFx1MGZlYWFcXHhmMlxcdTA1NTE7XFx1NjAwZm91c3RcXHUwMTAwO2FcXHUzMjFlXFx1MzIxZlxcdTYzYjFjaGVcXHhiYlxcdTMyMWZtaWQ7XFx1NmFlZVxcdTAyMDBhYnB0XFx1MzIzMlxcdTMyM2RcXHUzMjQwXFx1MzI1MlxcdTAxMDBuclxcdTMyMzdcXHUzMjNhZztcXHU2N2VkcjtcXHU2MWZlclxceGViXFx1MTAwM1xcdTAxODBhZmxcXHUzMjQ3XFx1MzI0YVxcdTMyNGVyO1xcdTY5ODY7XFx1YzAwMFxcdWQ4MzVcXHVkZDYzdXM7XFx1NmEyZWltZXM7XFx1NmEzNVxcdTAxMDBhcFxcdTMyNWRcXHUzMjY3clxcdTAxMDA7Z1xcdTMyNjNcXHUzMjY0XFx1NDAyOXQ7XFx1Njk5NG9saW50O1xcdTZhMTJhclxceGYyXFx1MzFlM1xcdTAyMDBhY2hxXFx1MzI3YlxcdTMyODBcXHUxMGJjXFx1MzI4NXF1bztcXHU2MDNhcjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzdcXHUwMTAwYnVcXHUzMGZiXFx1MzI4YW9cXHUwMTAwO3JcXHUwMjE0XFx1MDIxM1xcdTAxODBoaXJcXHUzMjk3XFx1MzI5YlxcdTMyYTByZVxceGU1XFx1MzFmOG1lcztcXHU2MmNhaVxcdTAyMDA7ZWZsXFx1MzJhYVxcdTEwNTlcXHUxODIxXFx1MzJhYlxcdTY1Yjl0cmk7XFx1NjljZWx1aGFyO1xcdTY5Njg7XFx1NjExZVxcdTBkNjFcXHUzMmQ1XFx1MzJkYlxcdTMyZGZcXHUzMzJjXFx1MzMzOFxcdTMzNzFcXDBcXHUzMzdhXFx1MzNhNFxcMFxcMFxcdTMzZWNcXHUzM2YwXFwwXFx1MzQyOFxcdTM0NDhcXHUzNDVhXFx1MzRhZFxcdTM0YjFcXHUzNGNhXFx1MzRmMVxcMFxcdTM2MTZcXDBcXDBcXHUzNjMzY3V0ZTtcXHU0MTVicXVcXHhlZlxcdTI3YmFcXHUwNTAwO0VhY2VpbnBzeVxcdTExZWRcXHUzMmYzXFx1MzJmNVxcdTMyZmZcXHUzMzAyXFx1MzMwYlxcdTMzMGZcXHUzMzFmXFx1MzMyNlxcdTMzMjk7XFx1NmFiNFxcdTAxZjBcXHUzMmZhXFwwXFx1MzJmYztcXHU2YWI4b247XFx1NDE2MXVcXHhlNVxcdTExZmVcXHUwMTAwO2RcXHUxMWYzXFx1MzMwN2lsO1xcdTQxNWZyYztcXHU0MTVkXFx1MDE4MEVhc1xcdTMzMTZcXHUzMzE4XFx1MzMxYjtcXHU2YWI2cDtcXHU2YWJhaW07XFx1NjJlOW9saW50O1xcdTZhMTNpXFx4ZWRcXHUxMjA0O1xcdTQ0NDFvdFxcdTAxODA7YmVcXHUzMzM0XFx1MWQ0N1xcdTMzMzVcXHU2MmM1O1xcdTZhNjZcXHUwMzgwQWFjbXN0eFxcdTMzNDZcXHUzMzRhXFx1MzM1N1xcdTMzNWJcXHUzMzVlXFx1MzM2M1xcdTMzNmRycjtcXHU2MWQ4clxcdTAxMDBoclxcdTMzNTBcXHUzMzUyXFx4ZWJcXHUyMjI4XFx1MDEwMDtvXFx1MGEzNlxcdTBhMzR0XFx1ODAzYlxceGE3XFx1NDBhN2k7XFx1NDAzYndhcjtcXHU2OTI5bVxcdTAxMDBpblxcdTMzNjlcXHhmMG51XFx4ZjNcXHhmMXQ7XFx1NjczNnJcXHUwMTAwO29cXHUzMzc2XFx1MjA1NVxcdWMwMDBcXHVkODM1XFx1ZGQzMFxcdTAyMDBhY295XFx1MzM4MlxcdTMzODZcXHUzMzkxXFx1MzNhMHJwO1xcdTY2NmZcXHUwMTAwaHlcXHUzMzhiXFx1MzM4ZmN5O1xcdTQ0NDk7XFx1NDQ0OHJ0XFx1MDI2ZFxcdTMzOTlcXDBcXDBcXHUzMzljaVxceGU0XFx1MTQ2NGFyYVxceGVjXFx1MmU2ZlxcdTgwM2JcXHhhZFxcdTQwYWRcXHUwMTAwZ21cXHUzM2E4XFx1MzNiNG1hXFx1MDE4MDtmdlxcdTMzYjFcXHUzM2IyXFx1MzNiMlxcdTQzYzM7XFx1NDNjMlxcdTA0MDA7ZGVnbG5wclxcdTEyYWJcXHUzM2M1XFx1MzNjOVxcdTMzY2VcXHUzM2Q2XFx1MzNkZVxcdTMzZTFcXHUzM2U2b3Q7XFx1NmE2YVxcdTAxMDA7cVxcdTEyYjFcXHUxMmIwXFx1MDEwMDtFXFx1MzNkM1xcdTMzZDRcXHU2YTllO1xcdTZhYTBcXHUwMTAwO0VcXHUzM2RiXFx1MzNkY1xcdTZhOWQ7XFx1NmE5ZmU7XFx1NjI0Nmx1cztcXHU2YTI0YXJyO1xcdTY5NzJhclxceGYyXFx1MTEzZFxcdTAyMDBhZWl0XFx1MzNmOFxcdTM0MDhcXHUzNDBmXFx1MzQxN1xcdTAxMDBsc1xcdTMzZmRcXHUzNDA0bHNldG1cXHhlOVxcdTMzNmFocDtcXHU2YTMzcGFyc2w7XFx1NjllNFxcdTAxMDBkbFxcdTE0NjNcXHUzNDE0ZTtcXHU2MzIzXFx1MDEwMDtlXFx1MzQxY1xcdTM0MWRcXHU2YWFhXFx1MDEwMDtzXFx1MzQyMlxcdTM0MjNcXHU2YWFjO1xcdWMwMDBcXHUyYWFjXFx1ZmUwMFxcdTAxODBmbHBcXHUzNDJlXFx1MzQzM1xcdTM0NDJ0Y3k7XFx1NDQ0Y1xcdTAxMDA7YlxcdTM0MzhcXHUzNDM5XFx1NDAyZlxcdTAxMDA7YVxcdTM0M2VcXHUzNDNmXFx1NjljNHI7XFx1NjMzZmY7XFx1YzAwMFxcdWQ4MzVcXHVkZDY0YVxcdTAxMDBkclxcdTM0NGRcXHUwNDAyZXNcXHUwMTAwO3VcXHUzNDU0XFx1MzQ1NVxcdTY2NjBpdFxceGJiXFx1MzQ1NVxcdTAxODBjc3VcXHUzNDYwXFx1MzQ3OVxcdTM0OWZcXHUwMTAwYXVcXHUzNDY1XFx1MzQ2ZnBcXHUwMTAwO3NcXHUxMTg4XFx1MzQ2YjtcXHVjMDAwXFx1MjI5M1xcdWZlMDBwXFx1MDEwMDtzXFx1MTFiNFxcdTM0NzU7XFx1YzAwMFxcdTIyOTRcXHVmZTAwdVxcdTAxMDBicFxcdTM0N2ZcXHUzNDhmXFx1MDE4MDtlc1xcdTExOTdcXHUxMTljXFx1MzQ4NmV0XFx1MDEwMDtlXFx1MTE5N1xcdTM0OGRcXHhmMVxcdTExOWRcXHUwMTgwO2VzXFx1MTFhOFxcdTExYWRcXHUzNDk2ZXRcXHUwMTAwO2VcXHUxMWE4XFx1MzQ5ZFxceGYxXFx1MTFhZVxcdTAxODA7YWZcXHUxMTdiXFx1MzRhNlxcdTA1YjByXFx1MDE2NVxcdTM0YWJcXHUwNWIxXFx4YmJcXHUxMTdjYXJcXHhmMlxcdTExNDhcXHUwMjAwY2VtdFxcdTM0YjlcXHUzNGJlXFx1MzRjMlxcdTM0YzVyO1xcdWMwMDBcXHVkODM1XFx1ZGNjOHRtXFx4ZWVcXHhmMWlcXHhlY1xcdTM0MTVhclxceGU2XFx1MTFiZVxcdTAxMDBhclxcdTM0Y2VcXHUzNGQ1clxcdTAxMDA7ZlxcdTM0ZDRcXHUxN2JmXFx1NjYwNlxcdTAxMDBhblxcdTM0ZGFcXHUzNGVkaWdodFxcdTAxMDBlcFxcdTM0ZTNcXHUzNGVhcHNpbG9cXHhlZVxcdTFlZTBoXFx4ZTlcXHUyZWFmc1xceGJiXFx1Mjg1MlxcdTAyODBiY21ucFxcdTM0ZmJcXHUzNTVlXFx1MTIwOVxcdTM1OGJcXHUzNThlXFx1MDQ4MDtFZGVtbnByc1xcdTM1MGVcXHUzNTBmXFx1MzUxMVxcdTM1MTVcXHUzNTFlXFx1MzUyM1xcdTM1MmNcXHUzNTMxXFx1MzUzNlxcdTYyODI7XFx1NmFjNW90O1xcdTZhYmRcXHUwMTAwO2RcXHUxMWRhXFx1MzUxYW90O1xcdTZhYzN1bHQ7XFx1NmFjMVxcdTAxMDBFZVxcdTM1MjhcXHUzNTJhO1xcdTZhY2I7XFx1NjI4YWx1cztcXHU2YWJmYXJyO1xcdTY5NzlcXHUwMTgwZWl1XFx1MzUzZFxcdTM1NTJcXHUzNTU1dFxcdTAxODA7ZW5cXHUzNTBlXFx1MzU0NVxcdTM1NGJxXFx1MDEwMDtxXFx1MTFkYVxcdTM1MGZlcVxcdTAxMDA7cVxcdTM1MmJcXHUzNTI4bTtcXHU2YWM3XFx1MDEwMGJwXFx1MzU1YVxcdTM1NWM7XFx1NmFkNTtcXHU2YWQzY1xcdTAzMDA7YWNlbnNcXHUxMWVkXFx1MzU2Y1xcdTM1NzJcXHUzNTc5XFx1MzU3YlxcdTMzMjZwcHJvXFx4ZjhcXHUzMmZhdXJseWVcXHhmMVxcdTExZmVcXHhmMVxcdTExZjNcXHUwMTgwYWVzXFx1MzU4MlxcdTM1ODhcXHUzMzFicHByb1xceGY4XFx1MzMxYXFcXHhmMVxcdTMzMTdnO1xcdTY2NmFcXHUwNjgwMTIzO0VkZWhsbW5wc1xcdTM1YTlcXHUzNWFjXFx1MzVhZlxcdTEyMWNcXHUzNWIyXFx1MzViNFxcdTM1YzBcXHUzNWM5XFx1MzVkNVxcdTM1ZGFcXHUzNWRmXFx1MzVlOFxcdTM1ZWRcXHU4MDNiXFx4YjlcXHU0MGI5XFx1ODAzYlxceGIyXFx1NDBiMlxcdTgwM2JcXHhiM1xcdTQwYjM7XFx1NmFjNlxcdTAxMDBvc1xcdTM1YjlcXHUzNWJjdDtcXHU2YWJldWI7XFx1NmFkOFxcdTAxMDA7ZFxcdTEyMjJcXHUzNWM1b3Q7XFx1NmFjNHNcXHUwMTAwb3VcXHUzNWNmXFx1MzVkMmw7XFx1NjdjOWI7XFx1NmFkN2FycjtcXHU2OTdidWx0O1xcdTZhYzJcXHUwMTAwRWVcXHUzNWU0XFx1MzVlNjtcXHU2YWNjO1xcdTYyOGJsdXM7XFx1NmFjMFxcdTAxODBlaXVcXHUzNWY0XFx1MzYwOVxcdTM2MGN0XFx1MDE4MDtlblxcdTEyMWNcXHUzNWZjXFx1MzYwMnFcXHUwMTAwO3FcXHUxMjIyXFx1MzViMmVxXFx1MDEwMDtxXFx1MzVlN1xcdTM1ZTRtO1xcdTZhYzhcXHUwMTAwYnBcXHUzNjExXFx1MzYxMztcXHU2YWQ0O1xcdTZhZDZcXHUwMTgwQWFuXFx1MzYxY1xcdTM2MjBcXHUzNjJkcnI7XFx1NjFkOXJcXHUwMTAwaHJcXHUzNjI2XFx1MzYyOFxceGViXFx1MjIyZVxcdTAxMDA7b1xcdTBhMmJcXHUwYTI5d2FyO1xcdTY5MmFsaWdcXHU4MDNiXFx4ZGZcXHU0MGRmXFx1MGJlMVxcdTM2NTFcXHUzNjVkXFx1MzY2MFxcdTEyY2VcXHUzNjczXFx1MzY3OVxcMFxcdTM2N2VcXHUzNmMyXFwwXFwwXFwwXFwwXFwwXFx1MzZkYlxcdTM3MDNcXDBcXHUzNzA5XFx1Mzc2Y1xcMFxcMFxcMFxcdTM3ODdcXHUwMjcyXFx1MzY1NlxcMFxcMFxcdTM2NWJnZXQ7XFx1NjMxNjtcXHU0M2M0clxceGViXFx1MGU1ZlxcdTAxODBhZXlcXHUzNjY2XFx1MzY2YlxcdTM2NzByb247XFx1NDE2NWRpbDtcXHU0MTYzO1xcdTQ0NDJscmVjO1xcdTYzMTVyO1xcdWMwMDBcXHVkODM1XFx1ZGQzMVxcdTAyMDBlaWtvXFx1MzY4NlxcdTM2OWRcXHUzNmI1XFx1MzZiY1xcdTAxZjJcXHUzNjhiXFwwXFx1MzY5MWVcXHUwMTAwNGZcXHUxMjg0XFx1MTI4MWFcXHUwMTgwO3N2XFx1MzY5OFxcdTM2OTlcXHUzNjliXFx1NDNiOHltO1xcdTQzZDFcXHUwMTAwY25cXHUzNmEyXFx1MzZiMmtcXHUwMTAwYXNcXHUzNmE4XFx1MzZhZXBwcm9cXHhmOFxcdTEyYzFpbVxceGJiXFx1MTJhY3NcXHhmMFxcdTEyOWVcXHUwMTAwYXNcXHUzNmJhXFx1MzZhZVxceGYwXFx1MTJjMXJuXFx1ODAzYlxceGZlXFx1NDBmZVxcdTAxZWNcXHUwMzFmXFx1MzZjNlxcdTIyZTdlc1xcdTgxODBcXHhkNztiZFxcdTM2Y2ZcXHUzNmQwXFx1MzZkOFxcdTQwZDdcXHUwMTAwO2FcXHUxOTBmXFx1MzZkNXI7XFx1NmEzMTtcXHU2YTMwXFx1MDE4MGVwc1xcdTM2ZTFcXHUzNmUzXFx1MzcwMFxceGUxXFx1MmE0ZFxcdTAyMDA7YmNmXFx1MDQ4NlxcdTM2ZWNcXHUzNmYwXFx1MzZmNG90O1xcdTYzMzZpcjtcXHU2YWYxXFx1MDEwMDtvXFx1MzZmOVxcdTM2ZmNcXHVjMDAwXFx1ZDgzNVxcdWRkNjVyaztcXHU2YWRhXFx4ZTFcXHUzMzYycmltZTtcXHU2MDM0XFx1MDE4MGFpcFxcdTM3MGZcXHUzNzEyXFx1Mzc2NGRcXHhlNVxcdTEyNDhcXHUwMzgwYWRlbXBzdFxcdTM3MjFcXHUzNzRkXFx1Mzc0MFxcdTM3NTFcXHUzNzU3XFx1Mzc1Y1xcdTM3NWZuZ2xlXFx1MDI4MDtkbHFyXFx1MzczMFxcdTM3MzFcXHUzNzM2XFx1Mzc0MFxcdTM3NDJcXHU2NWI1b3duXFx4YmJcXHUxZGJiZWZ0XFx1MDEwMDtlXFx1MjgwMFxcdTM3M2VcXHhmMVxcdTA5MmU7XFx1NjI1Y2lnaHRcXHUwMTAwO2VcXHUzMmFhXFx1Mzc0YlxceGYxXFx1MTA1YW90O1xcdTY1ZWNpbnVzO1xcdTZhM2FsdXM7XFx1NmEzOWI7XFx1NjljZGltZTtcXHU2YTNiZXppdW07XFx1NjNlMlxcdTAxODBjaHRcXHUzNzcyXFx1Mzc3ZFxcdTM3ODFcXHUwMTAwcnlcXHUzNzc3XFx1Mzc3YjtcXHVjMDAwXFx1ZDgzNVxcdWRjYzk7XFx1NDQ0NmN5O1xcdTQ0NWJyb2s7XFx1NDE2N1xcdTAxMDBpb1xcdTM3OGJcXHUzNzhleFxceGY0XFx1MTc3N2hlYWRcXHUwMTAwbHJcXHUzNzk3XFx1MzdhMGVmdGFycm9cXHhmN1xcdTA4NGZpZ2h0YXJyb3dcXHhiYlxcdTBmNWRcXHUwOTAwQUhhYmNkZmdobG1vcHJzdHV3XFx1MzdkMFxcdTM3ZDNcXHUzN2Q3XFx1MzdlNFxcdTM3ZjBcXHUzN2ZjXFx1MzgwZVxcdTM4MWNcXHUzODIzXFx1MzgzNFxcdTM4NTFcXHUzODVkXFx1Mzg2YlxcdTM4YTlcXHUzOGNjXFx1MzhkMlxcdTM4ZWFcXHUzOGY2clxceGYyXFx1MDNlZGFyO1xcdTY5NjNcXHUwMTAwY3JcXHUzN2RjXFx1MzdlMnV0ZVxcdTgwM2JcXHhmYVxcdTQwZmFcXHhmMlxcdTExNTByXFx1MDFlM1xcdTM3ZWFcXDBcXHUzN2VkeTtcXHU0NDVldmU7XFx1NDE2ZFxcdTAxMDBpeVxcdTM3ZjVcXHUzN2ZhcmNcXHU4MDNiXFx4ZmJcXHU0MGZiO1xcdTQ0NDNcXHUwMTgwYWJoXFx1MzgwM1xcdTM4MDZcXHUzODBiclxceGYyXFx1MTNhZGxhYztcXHU0MTcxYVxceGYyXFx1MTNjM1xcdTAxMDBpclxcdTM4MTNcXHUzODE4c2h0O1xcdTY5N2U7XFx1YzAwMFxcdWQ4MzVcXHVkZDMycmF2ZVxcdTgwM2JcXHhmOVxcdTQwZjlcXHUwMTYxXFx1MzgyN1xcdTM4MzFyXFx1MDEwMGxyXFx1MzgyY1xcdTM4MmVcXHhiYlxcdTA5NTdcXHhiYlxcdTEwODNsaztcXHU2NTgwXFx1MDEwMGN0XFx1MzgzOVxcdTM4NGRcXHUwMjZmXFx1MzgzZlxcMFxcMFxcdTM4NGFyblxcdTAxMDA7ZVxcdTM4NDVcXHUzODQ2XFx1NjMxY3JcXHhiYlxcdTM4NDZvcDtcXHU2MzBmcmk7XFx1NjVmOFxcdTAxMDBhbFxcdTM4NTZcXHUzODVhY3I7XFx1NDE2YlxcdTgwYmJcXHhhOFxcdTAzNDlcXHUwMTAwZ3BcXHUzODYyXFx1Mzg2Nm9uO1xcdTQxNzNmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2NlxcdTAzMDBhZGhsc3VcXHUxMTRiXFx1Mzg3OFxcdTM4N2RcXHUxMzcyXFx1Mzg5MVxcdTM4YTBvd25cXHhlMVxcdTEzYjNhcnBvb25cXHUwMTAwbHJcXHUzODg4XFx1Mzg4Y2VmXFx4ZjRcXHUzODJkaWdoXFx4ZjRcXHUzODJmaVxcdTAxODA7aGxcXHUzODk5XFx1Mzg5YVxcdTM4OWNcXHU0M2M1XFx4YmJcXHUxM2Zhb25cXHhiYlxcdTM4OWFwYXJyb3dzO1xcdTYxYzhcXHUwMTgwY2l0XFx1MzhiMFxcdTM4YzRcXHUzOGM4XFx1MDI2ZlxcdTM4YjZcXDBcXDBcXHUzOGMxcm5cXHUwMTAwO2VcXHUzOGJjXFx1MzhiZFxcdTYzMWRyXFx4YmJcXHUzOGJkb3A7XFx1NjMwZW5nO1xcdTQxNmZyaTtcXHU2NWY5Y3I7XFx1YzAwMFxcdWQ4MzVcXHVkY2NhXFx1MDE4MGRpclxcdTM4ZDlcXHUzOGRkXFx1MzhlMm90O1xcdTYyZjBsZGU7XFx1NDE2OWlcXHUwMTAwO2ZcXHUzNzMwXFx1MzhlOFxceGJiXFx1MTgxM1xcdTAxMDBhbVxcdTM4ZWZcXHUzOGYyclxceGYyXFx1MzhhOGxcXHU4MDNiXFx4ZmNcXHU0MGZjYW5nbGU7XFx1NjlhN1xcdTA3ODBBQkRhY2RlZmxub3Byc3pcXHUzOTFjXFx1MzkxZlxcdTM5MjlcXHUzOTJkXFx1MzliNVxcdTM5YjhcXHUzOWJkXFx1MzlkZlxcdTM5ZTRcXHUzOWU4XFx1MzlmM1xcdTM5ZjlcXHUzOWZkXFx1M2EwMVxcdTNhMjByXFx4ZjJcXHUwM2Y3YXJcXHUwMTAwO3ZcXHUzOTI2XFx1MzkyN1xcdTZhZTg7XFx1NmFlOWFzXFx4ZThcXHUwM2UxXFx1MDEwMG5yXFx1MzkzMlxcdTM5MzdncnQ7XFx1Njk5Y1xcdTAzODBla25wcnN0XFx1MzRlM1xcdTM5NDZcXHUzOTRiXFx1Mzk1MlxcdTM5NWRcXHUzOTY0XFx1Mzk5NmFwcFxceGUxXFx1MjQxNW90aGluXFx4ZTdcXHUxZTk2XFx1MDE4MGhpclxcdTM0ZWJcXHUyZWM4XFx1Mzk1OW9wXFx4ZjRcXHUyZmI1XFx1MDEwMDtoXFx1MTNiN1xcdTM5NjJcXHhlZlxcdTMxOGRcXHUwMTAwaXVcXHUzOTY5XFx1Mzk2ZGdtXFx4ZTFcXHUzM2IzXFx1MDEwMGJwXFx1Mzk3MlxcdTM5ODRzZXRuZXFcXHUwMTAwO3FcXHUzOTdkXFx1Mzk4MFxcdWMwMDBcXHUyMjhhXFx1ZmUwMDtcXHVjMDAwXFx1MmFjYlxcdWZlMDBzZXRuZXFcXHUwMTAwO3FcXHUzOThmXFx1Mzk5MlxcdWMwMDBcXHUyMjhiXFx1ZmUwMDtcXHVjMDAwXFx1MmFjY1xcdWZlMDBcXHUwMTAwaHJcXHUzOTliXFx1Mzk5ZmV0XFx4ZTFcXHUzNjljaWFuZ2xlXFx1MDEwMGxyXFx1MzlhYVxcdTM5YWZlZnRcXHhiYlxcdTA5MjVpZ2h0XFx4YmJcXHUxMDUxeTtcXHU0NDMyYXNoXFx4YmJcXHUxMDM2XFx1MDE4MGVsclxcdTM5YzRcXHUzOWQyXFx1MzlkN1xcdTAxODA7YmVcXHUyZGVhXFx1MzljYlxcdTM5Y2ZhcjtcXHU2MmJicTtcXHU2MjVhbGlwO1xcdTYyZWVcXHUwMTAwYnRcXHUzOWRjXFx1MTQ2OGFcXHhmMlxcdTE0NjlyO1xcdWMwMDBcXHVkODM1XFx1ZGQzM3RyXFx4ZTlcXHUzOWFlc3VcXHUwMTAwYnBcXHUzOWVmXFx1MzlmMVxceGJiXFx1MGQxY1xceGJiXFx1MGQ1OXBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2N3JvXFx4ZjBcXHUwZWZidHJcXHhlOVxcdTM5YjRcXHUwMTAwY3VcXHUzYTA2XFx1M2EwYnI7XFx1YzAwMFxcdWQ4MzVcXHVkY2NiXFx1MDEwMGJwXFx1M2ExMFxcdTNhMThuXFx1MDEwMEVlXFx1Mzk4MFxcdTNhMTZcXHhiYlxcdTM5N2VuXFx1MDEwMEVlXFx1Mzk5MlxcdTNhMWVcXHhiYlxcdTM5OTBpZ3phZztcXHU2OTlhXFx1MDM4MGNlZm9wcnNcXHUzYTM2XFx1M2EzYlxcdTNhNTZcXHUzYTViXFx1M2E1NFxcdTNhNjFcXHUzYTZhaXJjO1xcdTQxNzVcXHUwMTAwZGlcXHUzYTQwXFx1M2E1MVxcdTAxMDBiZ1xcdTNhNDVcXHUzYTQ5YXI7XFx1NmE1ZmVcXHUwMTAwO3FcXHUxNWZhXFx1M2E0ZjtcXHU2MjU5ZXJwO1xcdTYxMThyO1xcdWMwMDBcXHVkODM1XFx1ZGQzNHBmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2OFxcdTAxMDA7ZVxcdTE0NzlcXHUzYTY2YXRcXHhlOFxcdTE0NzljcjtcXHVjMDAwXFx1ZDgzNVxcdWRjY2NcXHUwYWUzXFx1MTc4ZVxcdTNhODdcXDBcXHUzYThiXFwwXFx1M2E5MFxcdTNhOWJcXDBcXDBcXHUzYTlkXFx1M2FhOFxcdTNhYWJcXHUzYWFmXFwwXFwwXFx1M2FjM1xcdTNhY2VcXDBcXHUzYWQ4XFx1MTdkY1xcdTE3ZGZ0clxceGU5XFx1MTdkMXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDM1XFx1MDEwMEFhXFx1M2E5NFxcdTNhOTdyXFx4ZjJcXHUwM2MzclxceGYyXFx1MDlmNjtcXHU0M2JlXFx1MDEwMEFhXFx1M2FhMVxcdTNhYTRyXFx4ZjJcXHUwM2I4clxceGYyXFx1MDllYmFcXHhmMFxcdTI3MTNpcztcXHU2MmZiXFx1MDE4MGRwdFxcdTE3YTRcXHUzYWI1XFx1M2FiZVxcdTAxMDBmbFxcdTNhYmFcXHUxN2E5O1xcdWMwMDBcXHVkODM1XFx1ZGQ2OWltXFx4ZTVcXHUxN2IyXFx1MDEwMEFhXFx1M2FjN1xcdTNhY2FyXFx4ZjJcXHUwM2NlclxceGYyXFx1MGEwMVxcdTAxMDBjcVxcdTNhZDJcXHUxN2I4cjtcXHVjMDAwXFx1ZDgzNVxcdWRjY2RcXHUwMTAwcHRcXHUxN2Q2XFx1M2FkY3JcXHhlOVxcdTE3ZDRcXHUwNDAwYWNlZmlvc3VcXHUzYWYwXFx1M2FmZFxcdTNiMDhcXHUzYjBjXFx1M2IxMVxcdTNiMTVcXHUzYjFiXFx1M2IyMWNcXHUwMTAwdXlcXHUzYWY2XFx1M2FmYnRlXFx1ODAzYlxceGZkXFx1NDBmZDtcXHU0NDRmXFx1MDEwMGl5XFx1M2IwMlxcdTNiMDZyYztcXHU0MTc3O1xcdTQ0NGJuXFx1ODAzYlxceGE1XFx1NDBhNXI7XFx1YzAwMFxcdWQ4MzVcXHVkZDM2Y3k7XFx1NDQ1N3BmO1xcdWMwMDBcXHVkODM1XFx1ZGQ2YWNyO1xcdWMwMDBcXHVkODM1XFx1ZGNjZVxcdTAxMDBjbVxcdTNiMjZcXHUzYjI5eTtcXHU0NDRlbFxcdTgwM2JcXHhmZlxcdTQwZmZcXHUwNTAwYWNkZWZoaW9zd1xcdTNiNDJcXHUzYjQ4XFx1M2I1NFxcdTNiNThcXHUzYjY0XFx1M2I2OVxcdTNiNmRcXHUzYjc0XFx1M2I3YVxcdTNiODBjdXRlO1xcdTQxN2FcXHUwMTAwYXlcXHUzYjRkXFx1M2I1MnJvbjtcXHU0MTdlO1xcdTQ0MzdvdDtcXHU0MTdjXFx1MDEwMGV0XFx1M2I1ZFxcdTNiNjF0clxceGU2XFx1MTU1ZmE7XFx1NDNiNnI7XFx1YzAwMFxcdWQ4MzVcXHVkZDM3Y3k7XFx1NDQzNmdyYXJyO1xcdTYxZGRwZjtcXHVjMDAwXFx1ZDgzNVxcdWRkNmJjcjtcXHVjMDAwXFx1ZDgzNVxcdWRjY2ZcXHUwMTAwam5cXHUzYjg1XFx1M2I4NztcXHU2MDBkajtcXHU2MDBjXCJcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1kYXRhLWh0bWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-xml.js":
/*!********************************************************************!*\
  !*** ./node_modules/entities/lib/esm/generated/decode-data-xml.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Generated using scripts/write-decode-map.ts\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Uint16Array(\n// prettier-ignore\n\"\\u0200aglq\\t\\x15\\x18\\x1b\\u026d\\x0f\\0\\0\\x12p;\\u4026os;\\u4027t;\\u403et;\\u403cuot;\\u4022\"\n    .split(\"\")\n    .map((c) => c.charCodeAt(0))));\n//# sourceMappingURL=decode-data-xml.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2dlbmVyYXRlZC9kZWNvZGUtZGF0YS14bWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsK0RBQWU7QUFDZjtBQUNBLDZDQUE2QyxTQUFTLFFBQVEsUUFBUSxVQUFVO0FBQ2hGO0FBQ0EsaUNBQWlDLEVBQUM7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9lc20vZ2VuZXJhdGVkL2RlY29kZS1kYXRhLXhtbC5qcz80OGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCB1c2luZyBzY3JpcHRzL3dyaXRlLWRlY29kZS1tYXAudHNcbmV4cG9ydCBkZWZhdWx0IG5ldyBVaW50MTZBcnJheShcbi8vIHByZXR0aWVyLWlnbm9yZVxuXCJcXHUwMjAwYWdscVxcdFxceDE1XFx4MThcXHgxYlxcdTAyNmRcXHgwZlxcMFxcMFxceDEycDtcXHU0MDI2b3M7XFx1NDAyN3Q7XFx1NDAzZXQ7XFx1NDAzY3VvdDtcXHU0MDIyXCJcbiAgICAuc3BsaXQoXCJcIilcbiAgICAubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZS1kYXRhLXhtbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/generated/decode-data-xml.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/generated/encode-html.js":
/*!****************************************************************!*\
  !*** ./node_modules/entities/lib/esm/generated/encode-html.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Generated using scripts/write-encode-map.ts\nfunction restoreDiff(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        arr[i][0] += arr[i - 1][0] + 1;\n    }\n    return arr;\n}\n// prettier-ignore\n/* harmony default export */ __webpack_exports__[\"default\"] = (new Map(/* #__PURE__ */ restoreDiff([[9, \"&Tab;\"], [0, \"&NewLine;\"], [22, \"&excl;\"], [0, \"&quot;\"], [0, \"&num;\"], [0, \"&dollar;\"], [0, \"&percnt;\"], [0, \"&amp;\"], [0, \"&apos;\"], [0, \"&lpar;\"], [0, \"&rpar;\"], [0, \"&ast;\"], [0, \"&plus;\"], [0, \"&comma;\"], [1, \"&period;\"], [0, \"&sol;\"], [10, \"&colon;\"], [0, \"&semi;\"], [0, { v: \"&lt;\", n: 8402, o: \"&nvlt;\" }], [0, { v: \"&equals;\", n: 8421, o: \"&bne;\" }], [0, { v: \"&gt;\", n: 8402, o: \"&nvgt;\" }], [0, \"&quest;\"], [0, \"&commat;\"], [26, \"&lbrack;\"], [0, \"&bsol;\"], [0, \"&rbrack;\"], [0, \"&Hat;\"], [0, \"&lowbar;\"], [0, \"&DiacriticalGrave;\"], [5, { n: 106, o: \"&fjlig;\" }], [20, \"&lbrace;\"], [0, \"&verbar;\"], [0, \"&rbrace;\"], [34, \"&nbsp;\"], [0, \"&iexcl;\"], [0, \"&cent;\"], [0, \"&pound;\"], [0, \"&curren;\"], [0, \"&yen;\"], [0, \"&brvbar;\"], [0, \"&sect;\"], [0, \"&die;\"], [0, \"&copy;\"], [0, \"&ordf;\"], [0, \"&laquo;\"], [0, \"&not;\"], [0, \"&shy;\"], [0, \"&circledR;\"], [0, \"&macr;\"], [0, \"&deg;\"], [0, \"&PlusMinus;\"], [0, \"&sup2;\"], [0, \"&sup3;\"], [0, \"&acute;\"], [0, \"&micro;\"], [0, \"&para;\"], [0, \"&centerdot;\"], [0, \"&cedil;\"], [0, \"&sup1;\"], [0, \"&ordm;\"], [0, \"&raquo;\"], [0, \"&frac14;\"], [0, \"&frac12;\"], [0, \"&frac34;\"], [0, \"&iquest;\"], [0, \"&Agrave;\"], [0, \"&Aacute;\"], [0, \"&Acirc;\"], [0, \"&Atilde;\"], [0, \"&Auml;\"], [0, \"&angst;\"], [0, \"&AElig;\"], [0, \"&Ccedil;\"], [0, \"&Egrave;\"], [0, \"&Eacute;\"], [0, \"&Ecirc;\"], [0, \"&Euml;\"], [0, \"&Igrave;\"], [0, \"&Iacute;\"], [0, \"&Icirc;\"], [0, \"&Iuml;\"], [0, \"&ETH;\"], [0, \"&Ntilde;\"], [0, \"&Ograve;\"], [0, \"&Oacute;\"], [0, \"&Ocirc;\"], [0, \"&Otilde;\"], [0, \"&Ouml;\"], [0, \"&times;\"], [0, \"&Oslash;\"], [0, \"&Ugrave;\"], [0, \"&Uacute;\"], [0, \"&Ucirc;\"], [0, \"&Uuml;\"], [0, \"&Yacute;\"], [0, \"&THORN;\"], [0, \"&szlig;\"], [0, \"&agrave;\"], [0, \"&aacute;\"], [0, \"&acirc;\"], [0, \"&atilde;\"], [0, \"&auml;\"], [0, \"&aring;\"], [0, \"&aelig;\"], [0, \"&ccedil;\"], [0, \"&egrave;\"], [0, \"&eacute;\"], [0, \"&ecirc;\"], [0, \"&euml;\"], [0, \"&igrave;\"], [0, \"&iacute;\"], [0, \"&icirc;\"], [0, \"&iuml;\"], [0, \"&eth;\"], [0, \"&ntilde;\"], [0, \"&ograve;\"], [0, \"&oacute;\"], [0, \"&ocirc;\"], [0, \"&otilde;\"], [0, \"&ouml;\"], [0, \"&div;\"], [0, \"&oslash;\"], [0, \"&ugrave;\"], [0, \"&uacute;\"], [0, \"&ucirc;\"], [0, \"&uuml;\"], [0, \"&yacute;\"], [0, \"&thorn;\"], [0, \"&yuml;\"], [0, \"&Amacr;\"], [0, \"&amacr;\"], [0, \"&Abreve;\"], [0, \"&abreve;\"], [0, \"&Aogon;\"], [0, \"&aogon;\"], [0, \"&Cacute;\"], [0, \"&cacute;\"], [0, \"&Ccirc;\"], [0, \"&ccirc;\"], [0, \"&Cdot;\"], [0, \"&cdot;\"], [0, \"&Ccaron;\"], [0, \"&ccaron;\"], [0, \"&Dcaron;\"], [0, \"&dcaron;\"], [0, \"&Dstrok;\"], [0, \"&dstrok;\"], [0, \"&Emacr;\"], [0, \"&emacr;\"], [2, \"&Edot;\"], [0, \"&edot;\"], [0, \"&Eogon;\"], [0, \"&eogon;\"], [0, \"&Ecaron;\"], [0, \"&ecaron;\"], [0, \"&Gcirc;\"], [0, \"&gcirc;\"], [0, \"&Gbreve;\"], [0, \"&gbreve;\"], [0, \"&Gdot;\"], [0, \"&gdot;\"], [0, \"&Gcedil;\"], [1, \"&Hcirc;\"], [0, \"&hcirc;\"], [0, \"&Hstrok;\"], [0, \"&hstrok;\"], [0, \"&Itilde;\"], [0, \"&itilde;\"], [0, \"&Imacr;\"], [0, \"&imacr;\"], [2, \"&Iogon;\"], [0, \"&iogon;\"], [0, \"&Idot;\"], [0, \"&imath;\"], [0, \"&IJlig;\"], [0, \"&ijlig;\"], [0, \"&Jcirc;\"], [0, \"&jcirc;\"], [0, \"&Kcedil;\"], [0, \"&kcedil;\"], [0, \"&kgreen;\"], [0, \"&Lacute;\"], [0, \"&lacute;\"], [0, \"&Lcedil;\"], [0, \"&lcedil;\"], [0, \"&Lcaron;\"], [0, \"&lcaron;\"], [0, \"&Lmidot;\"], [0, \"&lmidot;\"], [0, \"&Lstrok;\"], [0, \"&lstrok;\"], [0, \"&Nacute;\"], [0, \"&nacute;\"], [0, \"&Ncedil;\"], [0, \"&ncedil;\"], [0, \"&Ncaron;\"], [0, \"&ncaron;\"], [0, \"&napos;\"], [0, \"&ENG;\"], [0, \"&eng;\"], [0, \"&Omacr;\"], [0, \"&omacr;\"], [2, \"&Odblac;\"], [0, \"&odblac;\"], [0, \"&OElig;\"], [0, \"&oelig;\"], [0, \"&Racute;\"], [0, \"&racute;\"], [0, \"&Rcedil;\"], [0, \"&rcedil;\"], [0, \"&Rcaron;\"], [0, \"&rcaron;\"], [0, \"&Sacute;\"], [0, \"&sacute;\"], [0, \"&Scirc;\"], [0, \"&scirc;\"], [0, \"&Scedil;\"], [0, \"&scedil;\"], [0, \"&Scaron;\"], [0, \"&scaron;\"], [0, \"&Tcedil;\"], [0, \"&tcedil;\"], [0, \"&Tcaron;\"], [0, \"&tcaron;\"], [0, \"&Tstrok;\"], [0, \"&tstrok;\"], [0, \"&Utilde;\"], [0, \"&utilde;\"], [0, \"&Umacr;\"], [0, \"&umacr;\"], [0, \"&Ubreve;\"], [0, \"&ubreve;\"], [0, \"&Uring;\"], [0, \"&uring;\"], [0, \"&Udblac;\"], [0, \"&udblac;\"], [0, \"&Uogon;\"], [0, \"&uogon;\"], [0, \"&Wcirc;\"], [0, \"&wcirc;\"], [0, \"&Ycirc;\"], [0, \"&ycirc;\"], [0, \"&Yuml;\"], [0, \"&Zacute;\"], [0, \"&zacute;\"], [0, \"&Zdot;\"], [0, \"&zdot;\"], [0, \"&Zcaron;\"], [0, \"&zcaron;\"], [19, \"&fnof;\"], [34, \"&imped;\"], [63, \"&gacute;\"], [65, \"&jmath;\"], [142, \"&circ;\"], [0, \"&caron;\"], [16, \"&breve;\"], [0, \"&DiacriticalDot;\"], [0, \"&ring;\"], [0, \"&ogon;\"], [0, \"&DiacriticalTilde;\"], [0, \"&dblac;\"], [51, \"&DownBreve;\"], [127, \"&Alpha;\"], [0, \"&Beta;\"], [0, \"&Gamma;\"], [0, \"&Delta;\"], [0, \"&Epsilon;\"], [0, \"&Zeta;\"], [0, \"&Eta;\"], [0, \"&Theta;\"], [0, \"&Iota;\"], [0, \"&Kappa;\"], [0, \"&Lambda;\"], [0, \"&Mu;\"], [0, \"&Nu;\"], [0, \"&Xi;\"], [0, \"&Omicron;\"], [0, \"&Pi;\"], [0, \"&Rho;\"], [1, \"&Sigma;\"], [0, \"&Tau;\"], [0, \"&Upsilon;\"], [0, \"&Phi;\"], [0, \"&Chi;\"], [0, \"&Psi;\"], [0, \"&ohm;\"], [7, \"&alpha;\"], [0, \"&beta;\"], [0, \"&gamma;\"], [0, \"&delta;\"], [0, \"&epsi;\"], [0, \"&zeta;\"], [0, \"&eta;\"], [0, \"&theta;\"], [0, \"&iota;\"], [0, \"&kappa;\"], [0, \"&lambda;\"], [0, \"&mu;\"], [0, \"&nu;\"], [0, \"&xi;\"], [0, \"&omicron;\"], [0, \"&pi;\"], [0, \"&rho;\"], [0, \"&sigmaf;\"], [0, \"&sigma;\"], [0, \"&tau;\"], [0, \"&upsi;\"], [0, \"&phi;\"], [0, \"&chi;\"], [0, \"&psi;\"], [0, \"&omega;\"], [7, \"&thetasym;\"], [0, \"&Upsi;\"], [2, \"&phiv;\"], [0, \"&piv;\"], [5, \"&Gammad;\"], [0, \"&digamma;\"], [18, \"&kappav;\"], [0, \"&rhov;\"], [3, \"&epsiv;\"], [0, \"&backepsilon;\"], [10, \"&IOcy;\"], [0, \"&DJcy;\"], [0, \"&GJcy;\"], [0, \"&Jukcy;\"], [0, \"&DScy;\"], [0, \"&Iukcy;\"], [0, \"&YIcy;\"], [0, \"&Jsercy;\"], [0, \"&LJcy;\"], [0, \"&NJcy;\"], [0, \"&TSHcy;\"], [0, \"&KJcy;\"], [1, \"&Ubrcy;\"], [0, \"&DZcy;\"], [0, \"&Acy;\"], [0, \"&Bcy;\"], [0, \"&Vcy;\"], [0, \"&Gcy;\"], [0, \"&Dcy;\"], [0, \"&IEcy;\"], [0, \"&ZHcy;\"], [0, \"&Zcy;\"], [0, \"&Icy;\"], [0, \"&Jcy;\"], [0, \"&Kcy;\"], [0, \"&Lcy;\"], [0, \"&Mcy;\"], [0, \"&Ncy;\"], [0, \"&Ocy;\"], [0, \"&Pcy;\"], [0, \"&Rcy;\"], [0, \"&Scy;\"], [0, \"&Tcy;\"], [0, \"&Ucy;\"], [0, \"&Fcy;\"], [0, \"&KHcy;\"], [0, \"&TScy;\"], [0, \"&CHcy;\"], [0, \"&SHcy;\"], [0, \"&SHCHcy;\"], [0, \"&HARDcy;\"], [0, \"&Ycy;\"], [0, \"&SOFTcy;\"], [0, \"&Ecy;\"], [0, \"&YUcy;\"], [0, \"&YAcy;\"], [0, \"&acy;\"], [0, \"&bcy;\"], [0, \"&vcy;\"], [0, \"&gcy;\"], [0, \"&dcy;\"], [0, \"&iecy;\"], [0, \"&zhcy;\"], [0, \"&zcy;\"], [0, \"&icy;\"], [0, \"&jcy;\"], [0, \"&kcy;\"], [0, \"&lcy;\"], [0, \"&mcy;\"], [0, \"&ncy;\"], [0, \"&ocy;\"], [0, \"&pcy;\"], [0, \"&rcy;\"], [0, \"&scy;\"], [0, \"&tcy;\"], [0, \"&ucy;\"], [0, \"&fcy;\"], [0, \"&khcy;\"], [0, \"&tscy;\"], [0, \"&chcy;\"], [0, \"&shcy;\"], [0, \"&shchcy;\"], [0, \"&hardcy;\"], [0, \"&ycy;\"], [0, \"&softcy;\"], [0, \"&ecy;\"], [0, \"&yucy;\"], [0, \"&yacy;\"], [1, \"&iocy;\"], [0, \"&djcy;\"], [0, \"&gjcy;\"], [0, \"&jukcy;\"], [0, \"&dscy;\"], [0, \"&iukcy;\"], [0, \"&yicy;\"], [0, \"&jsercy;\"], [0, \"&ljcy;\"], [0, \"&njcy;\"], [0, \"&tshcy;\"], [0, \"&kjcy;\"], [1, \"&ubrcy;\"], [0, \"&dzcy;\"], [7074, \"&ensp;\"], [0, \"&emsp;\"], [0, \"&emsp13;\"], [0, \"&emsp14;\"], [1, \"&numsp;\"], [0, \"&puncsp;\"], [0, \"&ThinSpace;\"], [0, \"&hairsp;\"], [0, \"&NegativeMediumSpace;\"], [0, \"&zwnj;\"], [0, \"&zwj;\"], [0, \"&lrm;\"], [0, \"&rlm;\"], [0, \"&dash;\"], [2, \"&ndash;\"], [0, \"&mdash;\"], [0, \"&horbar;\"], [0, \"&Verbar;\"], [1, \"&lsquo;\"], [0, \"&CloseCurlyQuote;\"], [0, \"&lsquor;\"], [1, \"&ldquo;\"], [0, \"&CloseCurlyDoubleQuote;\"], [0, \"&bdquo;\"], [1, \"&dagger;\"], [0, \"&Dagger;\"], [0, \"&bull;\"], [2, \"&nldr;\"], [0, \"&hellip;\"], [9, \"&permil;\"], [0, \"&pertenk;\"], [0, \"&prime;\"], [0, \"&Prime;\"], [0, \"&tprime;\"], [0, \"&backprime;\"], [3, \"&lsaquo;\"], [0, \"&rsaquo;\"], [3, \"&oline;\"], [2, \"&caret;\"], [1, \"&hybull;\"], [0, \"&frasl;\"], [10, \"&bsemi;\"], [7, \"&qprime;\"], [7, { v: \"&MediumSpace;\", n: 8202, o: \"&ThickSpace;\" }], [0, \"&NoBreak;\"], [0, \"&af;\"], [0, \"&InvisibleTimes;\"], [0, \"&ic;\"], [72, \"&euro;\"], [46, \"&tdot;\"], [0, \"&DotDot;\"], [37, \"&complexes;\"], [2, \"&incare;\"], [4, \"&gscr;\"], [0, \"&hamilt;\"], [0, \"&Hfr;\"], [0, \"&Hopf;\"], [0, \"&planckh;\"], [0, \"&hbar;\"], [0, \"&imagline;\"], [0, \"&Ifr;\"], [0, \"&lagran;\"], [0, \"&ell;\"], [1, \"&naturals;\"], [0, \"&numero;\"], [0, \"&copysr;\"], [0, \"&weierp;\"], [0, \"&Popf;\"], [0, \"&Qopf;\"], [0, \"&realine;\"], [0, \"&real;\"], [0, \"&reals;\"], [0, \"&rx;\"], [3, \"&trade;\"], [1, \"&integers;\"], [2, \"&mho;\"], [0, \"&zeetrf;\"], [0, \"&iiota;\"], [2, \"&bernou;\"], [0, \"&Cayleys;\"], [1, \"&escr;\"], [0, \"&Escr;\"], [0, \"&Fouriertrf;\"], [1, \"&Mellintrf;\"], [0, \"&order;\"], [0, \"&alefsym;\"], [0, \"&beth;\"], [0, \"&gimel;\"], [0, \"&daleth;\"], [12, \"&CapitalDifferentialD;\"], [0, \"&dd;\"], [0, \"&ee;\"], [0, \"&ii;\"], [10, \"&frac13;\"], [0, \"&frac23;\"], [0, \"&frac15;\"], [0, \"&frac25;\"], [0, \"&frac35;\"], [0, \"&frac45;\"], [0, \"&frac16;\"], [0, \"&frac56;\"], [0, \"&frac18;\"], [0, \"&frac38;\"], [0, \"&frac58;\"], [0, \"&frac78;\"], [49, \"&larr;\"], [0, \"&ShortUpArrow;\"], [0, \"&rarr;\"], [0, \"&darr;\"], [0, \"&harr;\"], [0, \"&updownarrow;\"], [0, \"&nwarr;\"], [0, \"&nearr;\"], [0, \"&LowerRightArrow;\"], [0, \"&LowerLeftArrow;\"], [0, \"&nlarr;\"], [0, \"&nrarr;\"], [1, { v: \"&rarrw;\", n: 824, o: \"&nrarrw;\" }], [0, \"&Larr;\"], [0, \"&Uarr;\"], [0, \"&Rarr;\"], [0, \"&Darr;\"], [0, \"&larrtl;\"], [0, \"&rarrtl;\"], [0, \"&LeftTeeArrow;\"], [0, \"&mapstoup;\"], [0, \"&map;\"], [0, \"&DownTeeArrow;\"], [1, \"&hookleftarrow;\"], [0, \"&hookrightarrow;\"], [0, \"&larrlp;\"], [0, \"&looparrowright;\"], [0, \"&harrw;\"], [0, \"&nharr;\"], [1, \"&lsh;\"], [0, \"&rsh;\"], [0, \"&ldsh;\"], [0, \"&rdsh;\"], [1, \"&crarr;\"], [0, \"&cularr;\"], [0, \"&curarr;\"], [2, \"&circlearrowleft;\"], [0, \"&circlearrowright;\"], [0, \"&leftharpoonup;\"], [0, \"&DownLeftVector;\"], [0, \"&RightUpVector;\"], [0, \"&LeftUpVector;\"], [0, \"&rharu;\"], [0, \"&DownRightVector;\"], [0, \"&dharr;\"], [0, \"&dharl;\"], [0, \"&RightArrowLeftArrow;\"], [0, \"&udarr;\"], [0, \"&LeftArrowRightArrow;\"], [0, \"&leftleftarrows;\"], [0, \"&upuparrows;\"], [0, \"&rightrightarrows;\"], [0, \"&ddarr;\"], [0, \"&leftrightharpoons;\"], [0, \"&Equilibrium;\"], [0, \"&nlArr;\"], [0, \"&nhArr;\"], [0, \"&nrArr;\"], [0, \"&DoubleLeftArrow;\"], [0, \"&DoubleUpArrow;\"], [0, \"&DoubleRightArrow;\"], [0, \"&dArr;\"], [0, \"&DoubleLeftRightArrow;\"], [0, \"&DoubleUpDownArrow;\"], [0, \"&nwArr;\"], [0, \"&neArr;\"], [0, \"&seArr;\"], [0, \"&swArr;\"], [0, \"&lAarr;\"], [0, \"&rAarr;\"], [1, \"&zigrarr;\"], [6, \"&larrb;\"], [0, \"&rarrb;\"], [15, \"&DownArrowUpArrow;\"], [7, \"&loarr;\"], [0, \"&roarr;\"], [0, \"&hoarr;\"], [0, \"&forall;\"], [0, \"&comp;\"], [0, { v: \"&part;\", n: 824, o: \"&npart;\" }], [0, \"&exist;\"], [0, \"&nexist;\"], [0, \"&empty;\"], [1, \"&Del;\"], [0, \"&Element;\"], [0, \"&NotElement;\"], [1, \"&ni;\"], [0, \"&notni;\"], [2, \"&prod;\"], [0, \"&coprod;\"], [0, \"&sum;\"], [0, \"&minus;\"], [0, \"&MinusPlus;\"], [0, \"&dotplus;\"], [1, \"&Backslash;\"], [0, \"&lowast;\"], [0, \"&compfn;\"], [1, \"&radic;\"], [2, \"&prop;\"], [0, \"&infin;\"], [0, \"&angrt;\"], [0, { v: \"&ang;\", n: 8402, o: \"&nang;\" }], [0, \"&angmsd;\"], [0, \"&angsph;\"], [0, \"&mid;\"], [0, \"&nmid;\"], [0, \"&DoubleVerticalBar;\"], [0, \"&NotDoubleVerticalBar;\"], [0, \"&and;\"], [0, \"&or;\"], [0, { v: \"&cap;\", n: 65024, o: \"&caps;\" }], [0, { v: \"&cup;\", n: 65024, o: \"&cups;\" }], [0, \"&int;\"], [0, \"&Int;\"], [0, \"&iiint;\"], [0, \"&conint;\"], [0, \"&Conint;\"], [0, \"&Cconint;\"], [0, \"&cwint;\"], [0, \"&ClockwiseContourIntegral;\"], [0, \"&awconint;\"], [0, \"&there4;\"], [0, \"&becaus;\"], [0, \"&ratio;\"], [0, \"&Colon;\"], [0, \"&dotminus;\"], [1, \"&mDDot;\"], [0, \"&homtht;\"], [0, { v: \"&sim;\", n: 8402, o: \"&nvsim;\" }], [0, { v: \"&backsim;\", n: 817, o: \"&race;\" }], [0, { v: \"&ac;\", n: 819, o: \"&acE;\" }], [0, \"&acd;\"], [0, \"&VerticalTilde;\"], [0, \"&NotTilde;\"], [0, { v: \"&eqsim;\", n: 824, o: \"&nesim;\" }], [0, \"&sime;\"], [0, \"&NotTildeEqual;\"], [0, \"&cong;\"], [0, \"&simne;\"], [0, \"&ncong;\"], [0, \"&ap;\"], [0, \"&nap;\"], [0, \"&ape;\"], [0, { v: \"&apid;\", n: 824, o: \"&napid;\" }], [0, \"&backcong;\"], [0, { v: \"&asympeq;\", n: 8402, o: \"&nvap;\" }], [0, { v: \"&bump;\", n: 824, o: \"&nbump;\" }], [0, { v: \"&bumpe;\", n: 824, o: \"&nbumpe;\" }], [0, { v: \"&doteq;\", n: 824, o: \"&nedot;\" }], [0, \"&doteqdot;\"], [0, \"&efDot;\"], [0, \"&erDot;\"], [0, \"&Assign;\"], [0, \"&ecolon;\"], [0, \"&ecir;\"], [0, \"&circeq;\"], [1, \"&wedgeq;\"], [0, \"&veeeq;\"], [1, \"&triangleq;\"], [2, \"&equest;\"], [0, \"&ne;\"], [0, { v: \"&Congruent;\", n: 8421, o: \"&bnequiv;\" }], [0, \"&nequiv;\"], [1, { v: \"&le;\", n: 8402, o: \"&nvle;\" }], [0, { v: \"&ge;\", n: 8402, o: \"&nvge;\" }], [0, { v: \"&lE;\", n: 824, o: \"&nlE;\" }], [0, { v: \"&gE;\", n: 824, o: \"&ngE;\" }], [0, { v: \"&lnE;\", n: 65024, o: \"&lvertneqq;\" }], [0, { v: \"&gnE;\", n: 65024, o: \"&gvertneqq;\" }], [0, { v: \"&ll;\", n: new Map(/* #__PURE__ */ restoreDiff([[824, \"&nLtv;\"], [7577, \"&nLt;\"]])) }], [0, { v: \"&gg;\", n: new Map(/* #__PURE__ */ restoreDiff([[824, \"&nGtv;\"], [7577, \"&nGt;\"]])) }], [0, \"&between;\"], [0, \"&NotCupCap;\"], [0, \"&nless;\"], [0, \"&ngt;\"], [0, \"&nle;\"], [0, \"&nge;\"], [0, \"&lesssim;\"], [0, \"&GreaterTilde;\"], [0, \"&nlsim;\"], [0, \"&ngsim;\"], [0, \"&LessGreater;\"], [0, \"&gl;\"], [0, \"&NotLessGreater;\"], [0, \"&NotGreaterLess;\"], [0, \"&pr;\"], [0, \"&sc;\"], [0, \"&prcue;\"], [0, \"&sccue;\"], [0, \"&PrecedesTilde;\"], [0, { v: \"&scsim;\", n: 824, o: \"&NotSucceedsTilde;\" }], [0, \"&NotPrecedes;\"], [0, \"&NotSucceeds;\"], [0, { v: \"&sub;\", n: 8402, o: \"&NotSubset;\" }], [0, { v: \"&sup;\", n: 8402, o: \"&NotSuperset;\" }], [0, \"&nsub;\"], [0, \"&nsup;\"], [0, \"&sube;\"], [0, \"&supe;\"], [0, \"&NotSubsetEqual;\"], [0, \"&NotSupersetEqual;\"], [0, { v: \"&subne;\", n: 65024, o: \"&varsubsetneq;\" }], [0, { v: \"&supne;\", n: 65024, o: \"&varsupsetneq;\" }], [1, \"&cupdot;\"], [0, \"&UnionPlus;\"], [0, { v: \"&sqsub;\", n: 824, o: \"&NotSquareSubset;\" }], [0, { v: \"&sqsup;\", n: 824, o: \"&NotSquareSuperset;\" }], [0, \"&sqsube;\"], [0, \"&sqsupe;\"], [0, { v: \"&sqcap;\", n: 65024, o: \"&sqcaps;\" }], [0, { v: \"&sqcup;\", n: 65024, o: \"&sqcups;\" }], [0, \"&CirclePlus;\"], [0, \"&CircleMinus;\"], [0, \"&CircleTimes;\"], [0, \"&osol;\"], [0, \"&CircleDot;\"], [0, \"&circledcirc;\"], [0, \"&circledast;\"], [1, \"&circleddash;\"], [0, \"&boxplus;\"], [0, \"&boxminus;\"], [0, \"&boxtimes;\"], [0, \"&dotsquare;\"], [0, \"&RightTee;\"], [0, \"&dashv;\"], [0, \"&DownTee;\"], [0, \"&bot;\"], [1, \"&models;\"], [0, \"&DoubleRightTee;\"], [0, \"&Vdash;\"], [0, \"&Vvdash;\"], [0, \"&VDash;\"], [0, \"&nvdash;\"], [0, \"&nvDash;\"], [0, \"&nVdash;\"], [0, \"&nVDash;\"], [0, \"&prurel;\"], [1, \"&LeftTriangle;\"], [0, \"&RightTriangle;\"], [0, { v: \"&LeftTriangleEqual;\", n: 8402, o: \"&nvltrie;\" }], [0, { v: \"&RightTriangleEqual;\", n: 8402, o: \"&nvrtrie;\" }], [0, \"&origof;\"], [0, \"&imof;\"], [0, \"&multimap;\"], [0, \"&hercon;\"], [0, \"&intcal;\"], [0, \"&veebar;\"], [1, \"&barvee;\"], [0, \"&angrtvb;\"], [0, \"&lrtri;\"], [0, \"&bigwedge;\"], [0, \"&bigvee;\"], [0, \"&bigcap;\"], [0, \"&bigcup;\"], [0, \"&diam;\"], [0, \"&sdot;\"], [0, \"&sstarf;\"], [0, \"&divideontimes;\"], [0, \"&bowtie;\"], [0, \"&ltimes;\"], [0, \"&rtimes;\"], [0, \"&leftthreetimes;\"], [0, \"&rightthreetimes;\"], [0, \"&backsimeq;\"], [0, \"&curlyvee;\"], [0, \"&curlywedge;\"], [0, \"&Sub;\"], [0, \"&Sup;\"], [0, \"&Cap;\"], [0, \"&Cup;\"], [0, \"&fork;\"], [0, \"&epar;\"], [0, \"&lessdot;\"], [0, \"&gtdot;\"], [0, { v: \"&Ll;\", n: 824, o: \"&nLl;\" }], [0, { v: \"&Gg;\", n: 824, o: \"&nGg;\" }], [0, { v: \"&leg;\", n: 65024, o: \"&lesg;\" }], [0, { v: \"&gel;\", n: 65024, o: \"&gesl;\" }], [2, \"&cuepr;\"], [0, \"&cuesc;\"], [0, \"&NotPrecedesSlantEqual;\"], [0, \"&NotSucceedsSlantEqual;\"], [0, \"&NotSquareSubsetEqual;\"], [0, \"&NotSquareSupersetEqual;\"], [2, \"&lnsim;\"], [0, \"&gnsim;\"], [0, \"&precnsim;\"], [0, \"&scnsim;\"], [0, \"&nltri;\"], [0, \"&NotRightTriangle;\"], [0, \"&nltrie;\"], [0, \"&NotRightTriangleEqual;\"], [0, \"&vellip;\"], [0, \"&ctdot;\"], [0, \"&utdot;\"], [0, \"&dtdot;\"], [0, \"&disin;\"], [0, \"&isinsv;\"], [0, \"&isins;\"], [0, { v: \"&isindot;\", n: 824, o: \"&notindot;\" }], [0, \"&notinvc;\"], [0, \"&notinvb;\"], [1, { v: \"&isinE;\", n: 824, o: \"&notinE;\" }], [0, \"&nisd;\"], [0, \"&xnis;\"], [0, \"&nis;\"], [0, \"&notnivc;\"], [0, \"&notnivb;\"], [6, \"&barwed;\"], [0, \"&Barwed;\"], [1, \"&lceil;\"], [0, \"&rceil;\"], [0, \"&LeftFloor;\"], [0, \"&rfloor;\"], [0, \"&drcrop;\"], [0, \"&dlcrop;\"], [0, \"&urcrop;\"], [0, \"&ulcrop;\"], [0, \"&bnot;\"], [1, \"&profline;\"], [0, \"&profsurf;\"], [1, \"&telrec;\"], [0, \"&target;\"], [5, \"&ulcorn;\"], [0, \"&urcorn;\"], [0, \"&dlcorn;\"], [0, \"&drcorn;\"], [2, \"&frown;\"], [0, \"&smile;\"], [9, \"&cylcty;\"], [0, \"&profalar;\"], [7, \"&topbot;\"], [6, \"&ovbar;\"], [1, \"&solbar;\"], [60, \"&angzarr;\"], [51, \"&lmoustache;\"], [0, \"&rmoustache;\"], [2, \"&OverBracket;\"], [0, \"&bbrk;\"], [0, \"&bbrktbrk;\"], [37, \"&OverParenthesis;\"], [0, \"&UnderParenthesis;\"], [0, \"&OverBrace;\"], [0, \"&UnderBrace;\"], [2, \"&trpezium;\"], [4, \"&elinters;\"], [59, \"&blank;\"], [164, \"&circledS;\"], [55, \"&boxh;\"], [1, \"&boxv;\"], [9, \"&boxdr;\"], [3, \"&boxdl;\"], [3, \"&boxur;\"], [3, \"&boxul;\"], [3, \"&boxvr;\"], [7, \"&boxvl;\"], [7, \"&boxhd;\"], [7, \"&boxhu;\"], [7, \"&boxvh;\"], [19, \"&boxH;\"], [0, \"&boxV;\"], [0, \"&boxdR;\"], [0, \"&boxDr;\"], [0, \"&boxDR;\"], [0, \"&boxdL;\"], [0, \"&boxDl;\"], [0, \"&boxDL;\"], [0, \"&boxuR;\"], [0, \"&boxUr;\"], [0, \"&boxUR;\"], [0, \"&boxuL;\"], [0, \"&boxUl;\"], [0, \"&boxUL;\"], [0, \"&boxvR;\"], [0, \"&boxVr;\"], [0, \"&boxVR;\"], [0, \"&boxvL;\"], [0, \"&boxVl;\"], [0, \"&boxVL;\"], [0, \"&boxHd;\"], [0, \"&boxhD;\"], [0, \"&boxHD;\"], [0, \"&boxHu;\"], [0, \"&boxhU;\"], [0, \"&boxHU;\"], [0, \"&boxvH;\"], [0, \"&boxVh;\"], [0, \"&boxVH;\"], [19, \"&uhblk;\"], [3, \"&lhblk;\"], [3, \"&block;\"], [8, \"&blk14;\"], [0, \"&blk12;\"], [0, \"&blk34;\"], [13, \"&square;\"], [8, \"&blacksquare;\"], [0, \"&EmptyVerySmallSquare;\"], [1, \"&rect;\"], [0, \"&marker;\"], [2, \"&fltns;\"], [1, \"&bigtriangleup;\"], [0, \"&blacktriangle;\"], [0, \"&triangle;\"], [2, \"&blacktriangleright;\"], [0, \"&rtri;\"], [3, \"&bigtriangledown;\"], [0, \"&blacktriangledown;\"], [0, \"&dtri;\"], [2, \"&blacktriangleleft;\"], [0, \"&ltri;\"], [6, \"&loz;\"], [0, \"&cir;\"], [32, \"&tridot;\"], [2, \"&bigcirc;\"], [8, \"&ultri;\"], [0, \"&urtri;\"], [0, \"&lltri;\"], [0, \"&EmptySmallSquare;\"], [0, \"&FilledSmallSquare;\"], [8, \"&bigstar;\"], [0, \"&star;\"], [7, \"&phone;\"], [49, \"&female;\"], [1, \"&male;\"], [29, \"&spades;\"], [2, \"&clubs;\"], [1, \"&hearts;\"], [0, \"&diamondsuit;\"], [3, \"&sung;\"], [2, \"&flat;\"], [0, \"&natural;\"], [0, \"&sharp;\"], [163, \"&check;\"], [3, \"&cross;\"], [8, \"&malt;\"], [21, \"&sext;\"], [33, \"&VerticalSeparator;\"], [25, \"&lbbrk;\"], [0, \"&rbbrk;\"], [84, \"&bsolhsub;\"], [0, \"&suphsol;\"], [28, \"&LeftDoubleBracket;\"], [0, \"&RightDoubleBracket;\"], [0, \"&lang;\"], [0, \"&rang;\"], [0, \"&Lang;\"], [0, \"&Rang;\"], [0, \"&loang;\"], [0, \"&roang;\"], [7, \"&longleftarrow;\"], [0, \"&longrightarrow;\"], [0, \"&longleftrightarrow;\"], [0, \"&DoubleLongLeftArrow;\"], [0, \"&DoubleLongRightArrow;\"], [0, \"&DoubleLongLeftRightArrow;\"], [1, \"&longmapsto;\"], [2, \"&dzigrarr;\"], [258, \"&nvlArr;\"], [0, \"&nvrArr;\"], [0, \"&nvHarr;\"], [0, \"&Map;\"], [6, \"&lbarr;\"], [0, \"&bkarow;\"], [0, \"&lBarr;\"], [0, \"&dbkarow;\"], [0, \"&drbkarow;\"], [0, \"&DDotrahd;\"], [0, \"&UpArrowBar;\"], [0, \"&DownArrowBar;\"], [2, \"&Rarrtl;\"], [2, \"&latail;\"], [0, \"&ratail;\"], [0, \"&lAtail;\"], [0, \"&rAtail;\"], [0, \"&larrfs;\"], [0, \"&rarrfs;\"], [0, \"&larrbfs;\"], [0, \"&rarrbfs;\"], [2, \"&nwarhk;\"], [0, \"&nearhk;\"], [0, \"&hksearow;\"], [0, \"&hkswarow;\"], [0, \"&nwnear;\"], [0, \"&nesear;\"], [0, \"&seswar;\"], [0, \"&swnwar;\"], [8, { v: \"&rarrc;\", n: 824, o: \"&nrarrc;\" }], [1, \"&cudarrr;\"], [0, \"&ldca;\"], [0, \"&rdca;\"], [0, \"&cudarrl;\"], [0, \"&larrpl;\"], [2, \"&curarrm;\"], [0, \"&cularrp;\"], [7, \"&rarrpl;\"], [2, \"&harrcir;\"], [0, \"&Uarrocir;\"], [0, \"&lurdshar;\"], [0, \"&ldrushar;\"], [2, \"&LeftRightVector;\"], [0, \"&RightUpDownVector;\"], [0, \"&DownLeftRightVector;\"], [0, \"&LeftUpDownVector;\"], [0, \"&LeftVectorBar;\"], [0, \"&RightVectorBar;\"], [0, \"&RightUpVectorBar;\"], [0, \"&RightDownVectorBar;\"], [0, \"&DownLeftVectorBar;\"], [0, \"&DownRightVectorBar;\"], [0, \"&LeftUpVectorBar;\"], [0, \"&LeftDownVectorBar;\"], [0, \"&LeftTeeVector;\"], [0, \"&RightTeeVector;\"], [0, \"&RightUpTeeVector;\"], [0, \"&RightDownTeeVector;\"], [0, \"&DownLeftTeeVector;\"], [0, \"&DownRightTeeVector;\"], [0, \"&LeftUpTeeVector;\"], [0, \"&LeftDownTeeVector;\"], [0, \"&lHar;\"], [0, \"&uHar;\"], [0, \"&rHar;\"], [0, \"&dHar;\"], [0, \"&luruhar;\"], [0, \"&ldrdhar;\"], [0, \"&ruluhar;\"], [0, \"&rdldhar;\"], [0, \"&lharul;\"], [0, \"&llhard;\"], [0, \"&rharul;\"], [0, \"&lrhard;\"], [0, \"&udhar;\"], [0, \"&duhar;\"], [0, \"&RoundImplies;\"], [0, \"&erarr;\"], [0, \"&simrarr;\"], [0, \"&larrsim;\"], [0, \"&rarrsim;\"], [0, \"&rarrap;\"], [0, \"&ltlarr;\"], [1, \"&gtrarr;\"], [0, \"&subrarr;\"], [1, \"&suplarr;\"], [0, \"&lfisht;\"], [0, \"&rfisht;\"], [0, \"&ufisht;\"], [0, \"&dfisht;\"], [5, \"&lopar;\"], [0, \"&ropar;\"], [4, \"&lbrke;\"], [0, \"&rbrke;\"], [0, \"&lbrkslu;\"], [0, \"&rbrksld;\"], [0, \"&lbrksld;\"], [0, \"&rbrkslu;\"], [0, \"&langd;\"], [0, \"&rangd;\"], [0, \"&lparlt;\"], [0, \"&rpargt;\"], [0, \"&gtlPar;\"], [0, \"&ltrPar;\"], [3, \"&vzigzag;\"], [1, \"&vangrt;\"], [0, \"&angrtvbd;\"], [6, \"&ange;\"], [0, \"&range;\"], [0, \"&dwangle;\"], [0, \"&uwangle;\"], [0, \"&angmsdaa;\"], [0, \"&angmsdab;\"], [0, \"&angmsdac;\"], [0, \"&angmsdad;\"], [0, \"&angmsdae;\"], [0, \"&angmsdaf;\"], [0, \"&angmsdag;\"], [0, \"&angmsdah;\"], [0, \"&bemptyv;\"], [0, \"&demptyv;\"], [0, \"&cemptyv;\"], [0, \"&raemptyv;\"], [0, \"&laemptyv;\"], [0, \"&ohbar;\"], [0, \"&omid;\"], [0, \"&opar;\"], [1, \"&operp;\"], [1, \"&olcross;\"], [0, \"&odsold;\"], [1, \"&olcir;\"], [0, \"&ofcir;\"], [0, \"&olt;\"], [0, \"&ogt;\"], [0, \"&cirscir;\"], [0, \"&cirE;\"], [0, \"&solb;\"], [0, \"&bsolb;\"], [3, \"&boxbox;\"], [3, \"&trisb;\"], [0, \"&rtriltri;\"], [0, { v: \"&LeftTriangleBar;\", n: 824, o: \"&NotLeftTriangleBar;\" }], [0, { v: \"&RightTriangleBar;\", n: 824, o: \"&NotRightTriangleBar;\" }], [11, \"&iinfin;\"], [0, \"&infintie;\"], [0, \"&nvinfin;\"], [4, \"&eparsl;\"], [0, \"&smeparsl;\"], [0, \"&eqvparsl;\"], [5, \"&blacklozenge;\"], [8, \"&RuleDelayed;\"], [1, \"&dsol;\"], [9, \"&bigodot;\"], [0, \"&bigoplus;\"], [0, \"&bigotimes;\"], [1, \"&biguplus;\"], [1, \"&bigsqcup;\"], [5, \"&iiiint;\"], [0, \"&fpartint;\"], [2, \"&cirfnint;\"], [0, \"&awint;\"], [0, \"&rppolint;\"], [0, \"&scpolint;\"], [0, \"&npolint;\"], [0, \"&pointint;\"], [0, \"&quatint;\"], [0, \"&intlarhk;\"], [10, \"&pluscir;\"], [0, \"&plusacir;\"], [0, \"&simplus;\"], [0, \"&plusdu;\"], [0, \"&plussim;\"], [0, \"&plustwo;\"], [1, \"&mcomma;\"], [0, \"&minusdu;\"], [2, \"&loplus;\"], [0, \"&roplus;\"], [0, \"&Cross;\"], [0, \"&timesd;\"], [0, \"&timesbar;\"], [1, \"&smashp;\"], [0, \"&lotimes;\"], [0, \"&rotimes;\"], [0, \"&otimesas;\"], [0, \"&Otimes;\"], [0, \"&odiv;\"], [0, \"&triplus;\"], [0, \"&triminus;\"], [0, \"&tritime;\"], [0, \"&intprod;\"], [2, \"&amalg;\"], [0, \"&capdot;\"], [1, \"&ncup;\"], [0, \"&ncap;\"], [0, \"&capand;\"], [0, \"&cupor;\"], [0, \"&cupcap;\"], [0, \"&capcup;\"], [0, \"&cupbrcap;\"], [0, \"&capbrcup;\"], [0, \"&cupcup;\"], [0, \"&capcap;\"], [0, \"&ccups;\"], [0, \"&ccaps;\"], [2, \"&ccupssm;\"], [2, \"&And;\"], [0, \"&Or;\"], [0, \"&andand;\"], [0, \"&oror;\"], [0, \"&orslope;\"], [0, \"&andslope;\"], [1, \"&andv;\"], [0, \"&orv;\"], [0, \"&andd;\"], [0, \"&ord;\"], [1, \"&wedbar;\"], [6, \"&sdote;\"], [3, \"&simdot;\"], [2, { v: \"&congdot;\", n: 824, o: \"&ncongdot;\" }], [0, \"&easter;\"], [0, \"&apacir;\"], [0, { v: \"&apE;\", n: 824, o: \"&napE;\" }], [0, \"&eplus;\"], [0, \"&pluse;\"], [0, \"&Esim;\"], [0, \"&Colone;\"], [0, \"&Equal;\"], [1, \"&ddotseq;\"], [0, \"&equivDD;\"], [0, \"&ltcir;\"], [0, \"&gtcir;\"], [0, \"&ltquest;\"], [0, \"&gtquest;\"], [0, { v: \"&leqslant;\", n: 824, o: \"&nleqslant;\" }], [0, { v: \"&geqslant;\", n: 824, o: \"&ngeqslant;\" }], [0, \"&lesdot;\"], [0, \"&gesdot;\"], [0, \"&lesdoto;\"], [0, \"&gesdoto;\"], [0, \"&lesdotor;\"], [0, \"&gesdotol;\"], [0, \"&lap;\"], [0, \"&gap;\"], [0, \"&lne;\"], [0, \"&gne;\"], [0, \"&lnap;\"], [0, \"&gnap;\"], [0, \"&lEg;\"], [0, \"&gEl;\"], [0, \"&lsime;\"], [0, \"&gsime;\"], [0, \"&lsimg;\"], [0, \"&gsiml;\"], [0, \"&lgE;\"], [0, \"&glE;\"], [0, \"&lesges;\"], [0, \"&gesles;\"], [0, \"&els;\"], [0, \"&egs;\"], [0, \"&elsdot;\"], [0, \"&egsdot;\"], [0, \"&el;\"], [0, \"&eg;\"], [2, \"&siml;\"], [0, \"&simg;\"], [0, \"&simlE;\"], [0, \"&simgE;\"], [0, { v: \"&LessLess;\", n: 824, o: \"&NotNestedLessLess;\" }], [0, { v: \"&GreaterGreater;\", n: 824, o: \"&NotNestedGreaterGreater;\" }], [1, \"&glj;\"], [0, \"&gla;\"], [0, \"&ltcc;\"], [0, \"&gtcc;\"], [0, \"&lescc;\"], [0, \"&gescc;\"], [0, \"&smt;\"], [0, \"&lat;\"], [0, { v: \"&smte;\", n: 65024, o: \"&smtes;\" }], [0, { v: \"&late;\", n: 65024, o: \"&lates;\" }], [0, \"&bumpE;\"], [0, { v: \"&PrecedesEqual;\", n: 824, o: \"&NotPrecedesEqual;\" }], [0, { v: \"&sce;\", n: 824, o: \"&NotSucceedsEqual;\" }], [2, \"&prE;\"], [0, \"&scE;\"], [0, \"&precneqq;\"], [0, \"&scnE;\"], [0, \"&prap;\"], [0, \"&scap;\"], [0, \"&precnapprox;\"], [0, \"&scnap;\"], [0, \"&Pr;\"], [0, \"&Sc;\"], [0, \"&subdot;\"], [0, \"&supdot;\"], [0, \"&subplus;\"], [0, \"&supplus;\"], [0, \"&submult;\"], [0, \"&supmult;\"], [0, \"&subedot;\"], [0, \"&supedot;\"], [0, { v: \"&subE;\", n: 824, o: \"&nsubE;\" }], [0, { v: \"&supE;\", n: 824, o: \"&nsupE;\" }], [0, \"&subsim;\"], [0, \"&supsim;\"], [2, { v: \"&subnE;\", n: 65024, o: \"&varsubsetneqq;\" }], [0, { v: \"&supnE;\", n: 65024, o: \"&varsupsetneqq;\" }], [2, \"&csub;\"], [0, \"&csup;\"], [0, \"&csube;\"], [0, \"&csupe;\"], [0, \"&subsup;\"], [0, \"&supsub;\"], [0, \"&subsub;\"], [0, \"&supsup;\"], [0, \"&suphsub;\"], [0, \"&supdsub;\"], [0, \"&forkv;\"], [0, \"&topfork;\"], [0, \"&mlcp;\"], [8, \"&Dashv;\"], [1, \"&Vdashl;\"], [0, \"&Barv;\"], [0, \"&vBar;\"], [0, \"&vBarv;\"], [1, \"&Vbar;\"], [0, \"&Not;\"], [0, \"&bNot;\"], [0, \"&rnmid;\"], [0, \"&cirmid;\"], [0, \"&midcir;\"], [0, \"&topcir;\"], [0, \"&nhpar;\"], [0, \"&parsim;\"], [9, { v: \"&parsl;\", n: 8421, o: \"&nparsl;\" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, \"&Ascr;\"], [1, \"&Cscr;\"], [0, \"&Dscr;\"], [2, \"&Gscr;\"], [2, \"&Jscr;\"], [0, \"&Kscr;\"], [2, \"&Nscr;\"], [0, \"&Oscr;\"], [0, \"&Pscr;\"], [0, \"&Qscr;\"], [1, \"&Sscr;\"], [0, \"&Tscr;\"], [0, \"&Uscr;\"], [0, \"&Vscr;\"], [0, \"&Wscr;\"], [0, \"&Xscr;\"], [0, \"&Yscr;\"], [0, \"&Zscr;\"], [0, \"&ascr;\"], [0, \"&bscr;\"], [0, \"&cscr;\"], [0, \"&dscr;\"], [1, \"&fscr;\"], [1, \"&hscr;\"], [0, \"&iscr;\"], [0, \"&jscr;\"], [0, \"&kscr;\"], [0, \"&lscr;\"], [0, \"&mscr;\"], [0, \"&nscr;\"], [1, \"&pscr;\"], [0, \"&qscr;\"], [0, \"&rscr;\"], [0, \"&sscr;\"], [0, \"&tscr;\"], [0, \"&uscr;\"], [0, \"&vscr;\"], [0, \"&wscr;\"], [0, \"&xscr;\"], [0, \"&yscr;\"], [0, \"&zscr;\"], [52, \"&Afr;\"], [0, \"&Bfr;\"], [1, \"&Dfr;\"], [0, \"&Efr;\"], [0, \"&Ffr;\"], [0, \"&Gfr;\"], [2, \"&Jfr;\"], [0, \"&Kfr;\"], [0, \"&Lfr;\"], [0, \"&Mfr;\"], [0, \"&Nfr;\"], [0, \"&Ofr;\"], [0, \"&Pfr;\"], [0, \"&Qfr;\"], [1, \"&Sfr;\"], [0, \"&Tfr;\"], [0, \"&Ufr;\"], [0, \"&Vfr;\"], [0, \"&Wfr;\"], [0, \"&Xfr;\"], [0, \"&Yfr;\"], [1, \"&afr;\"], [0, \"&bfr;\"], [0, \"&cfr;\"], [0, \"&dfr;\"], [0, \"&efr;\"], [0, \"&ffr;\"], [0, \"&gfr;\"], [0, \"&hfr;\"], [0, \"&ifr;\"], [0, \"&jfr;\"], [0, \"&kfr;\"], [0, \"&lfr;\"], [0, \"&mfr;\"], [0, \"&nfr;\"], [0, \"&ofr;\"], [0, \"&pfr;\"], [0, \"&qfr;\"], [0, \"&rfr;\"], [0, \"&sfr;\"], [0, \"&tfr;\"], [0, \"&ufr;\"], [0, \"&vfr;\"], [0, \"&wfr;\"], [0, \"&xfr;\"], [0, \"&yfr;\"], [0, \"&zfr;\"], [0, \"&Aopf;\"], [0, \"&Bopf;\"], [1, \"&Dopf;\"], [0, \"&Eopf;\"], [0, \"&Fopf;\"], [0, \"&Gopf;\"], [1, \"&Iopf;\"], [0, \"&Jopf;\"], [0, \"&Kopf;\"], [0, \"&Lopf;\"], [0, \"&Mopf;\"], [1, \"&Oopf;\"], [3, \"&Sopf;\"], [0, \"&Topf;\"], [0, \"&Uopf;\"], [0, \"&Vopf;\"], [0, \"&Wopf;\"], [0, \"&Xopf;\"], [0, \"&Yopf;\"], [1, \"&aopf;\"], [0, \"&bopf;\"], [0, \"&copf;\"], [0, \"&dopf;\"], [0, \"&eopf;\"], [0, \"&fopf;\"], [0, \"&gopf;\"], [0, \"&hopf;\"], [0, \"&iopf;\"], [0, \"&jopf;\"], [0, \"&kopf;\"], [0, \"&lopf;\"], [0, \"&mopf;\"], [0, \"&nopf;\"], [0, \"&oopf;\"], [0, \"&popf;\"], [0, \"&qopf;\"], [0, \"&ropf;\"], [0, \"&sopf;\"], [0, \"&topf;\"], [0, \"&uopf;\"], [0, \"&vopf;\"], [0, \"&wopf;\"], [0, \"&xopf;\"], [0, \"&yopf;\"], [0, \"&zopf;\"]])) }], [8906, \"&fflig;\"], [0, \"&filig;\"], [0, \"&fllig;\"], [0, \"&ffilig;\"], [0, \"&ffllig;\"]])));\n//# sourceMappingURL=encode-html.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2dlbmVyYXRlZC9lbmNvZGUtaHRtbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLCtDQUErQyxrQkFBa0IsZ0JBQWdCLGVBQWUsY0FBYyxpQkFBaUIsaUJBQWlCLGNBQWMsZUFBZSxlQUFlLGVBQWUsY0FBYyxlQUFlLGdCQUFnQixpQkFBaUIsY0FBYyxpQkFBaUIsZUFBZSxVQUFVLFFBQVEsc0JBQXNCLEdBQUcsU0FBUyxZQUFZLHFCQUFxQixHQUFHLFNBQVMsUUFBUSxzQkFBc0IsR0FBRyxlQUFlLGlCQUFpQixrQkFBa0IsZUFBZSxpQkFBaUIsY0FBYyxpQkFBaUIsMkJBQTJCLFVBQVUsbUJBQW1CLEdBQUcsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixlQUFlLGdCQUFnQixpQkFBaUIsY0FBYyxpQkFBaUIsZUFBZSxjQUFjLGVBQWUsZUFBZSxnQkFBZ0IsY0FBYyxjQUFjLG1CQUFtQixlQUFlLGNBQWMsb0JBQW9CLGVBQWUsZUFBZSxnQkFBZ0IsZ0JBQWdCLGVBQWUsb0JBQW9CLGdCQUFnQixlQUFlLGVBQWUsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsZUFBZSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGVBQWUsY0FBYyxpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGVBQWUsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGlCQUFpQixlQUFlLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGVBQWUsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZUFBZSxjQUFjLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsZUFBZSxjQUFjLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZUFBZSxlQUFlLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZUFBZSxlQUFlLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZUFBZSxlQUFlLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsaUJBQWlCLGlCQUFpQixlQUFlLGVBQWUsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGtCQUFrQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIseUJBQXlCLGVBQWUsZUFBZSwyQkFBMkIsZ0JBQWdCLHFCQUFxQixrQkFBa0IsZUFBZSxnQkFBZ0IsZ0JBQWdCLGtCQUFrQixlQUFlLGNBQWMsZ0JBQWdCLGVBQWUsZ0JBQWdCLGlCQUFpQixhQUFhLGFBQWEsYUFBYSxrQkFBa0IsYUFBYSxjQUFjLGdCQUFnQixjQUFjLGtCQUFrQixjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGdCQUFnQixnQkFBZ0IsZUFBZSxlQUFlLGNBQWMsZ0JBQWdCLGVBQWUsZ0JBQWdCLGlCQUFpQixhQUFhLGFBQWEsYUFBYSxrQkFBa0IsYUFBYSxjQUFjLGlCQUFpQixnQkFBZ0IsY0FBYyxlQUFlLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixtQkFBbUIsZUFBZSxlQUFlLGNBQWMsaUJBQWlCLGtCQUFrQixrQkFBa0IsZUFBZSxnQkFBZ0Isc0JBQXNCLGdCQUFnQixlQUFlLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLGVBQWUsaUJBQWlCLGVBQWUsZUFBZSxnQkFBZ0IsZUFBZSxnQkFBZ0IsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxlQUFlLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGVBQWUsZUFBZSxlQUFlLGlCQUFpQixpQkFBaUIsY0FBYyxpQkFBaUIsY0FBYyxlQUFlLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxlQUFlLGVBQWUsZUFBZSxpQkFBaUIsaUJBQWlCLGNBQWMsaUJBQWlCLGNBQWMsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGdCQUFnQixlQUFlLGdCQUFnQixlQUFlLGlCQUFpQixlQUFlLGVBQWUsZ0JBQWdCLGVBQWUsZ0JBQWdCLGVBQWUsa0JBQWtCLGVBQWUsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLG9CQUFvQixpQkFBaUIsOEJBQThCLGVBQWUsY0FBYyxjQUFjLGNBQWMsZUFBZSxnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLDBCQUEwQixpQkFBaUIsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixlQUFlLGVBQWUsaUJBQWlCLGlCQUFpQixrQkFBa0IsZ0JBQWdCLGdCQUFnQixpQkFBaUIsb0JBQW9CLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQixpQkFBaUIsZ0JBQWdCLGlCQUFpQixpQkFBaUIsVUFBVSxpQkFBaUIsNEJBQTRCLEdBQUcsaUJBQWlCLGFBQWEseUJBQXlCLGFBQWEsZ0JBQWdCLGdCQUFnQixpQkFBaUIscUJBQXFCLGlCQUFpQixlQUFlLGlCQUFpQixjQUFjLGVBQWUsa0JBQWtCLGVBQWUsbUJBQW1CLGNBQWMsaUJBQWlCLGNBQWMsbUJBQW1CLGlCQUFpQixpQkFBaUIsaUJBQWlCLGVBQWUsZUFBZSxrQkFBa0IsZUFBZSxnQkFBZ0IsYUFBYSxnQkFBZ0IsbUJBQW1CLGNBQWMsaUJBQWlCLGdCQUFnQixpQkFBaUIsa0JBQWtCLGVBQWUsZUFBZSxxQkFBcUIsb0JBQW9CLGdCQUFnQixrQkFBa0IsZUFBZSxnQkFBZ0IsaUJBQWlCLGdDQUFnQyxhQUFhLGFBQWEsYUFBYSxrQkFBa0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsdUJBQXVCLGVBQWUsZUFBZSxlQUFlLHNCQUFzQixnQkFBZ0IsZ0JBQWdCLDBCQUEwQix5QkFBeUIsZ0JBQWdCLGdCQUFnQixVQUFVLFdBQVcsdUJBQXVCLEdBQUcsY0FBYyxlQUFlLGVBQWUsZUFBZSxpQkFBaUIsaUJBQWlCLHVCQUF1QixtQkFBbUIsY0FBYyx1QkFBdUIsd0JBQXdCLHlCQUF5QixpQkFBaUIseUJBQXlCLGdCQUFnQixnQkFBZ0IsY0FBYyxjQUFjLGVBQWUsZUFBZSxnQkFBZ0IsaUJBQWlCLGlCQUFpQiwwQkFBMEIsMkJBQTJCLHdCQUF3Qix5QkFBeUIsd0JBQXdCLHVCQUF1QixnQkFBZ0IsMEJBQTBCLGdCQUFnQixnQkFBZ0IsOEJBQThCLGdCQUFnQiw4QkFBOEIseUJBQXlCLHFCQUFxQiwyQkFBMkIsZ0JBQWdCLDRCQUE0QixzQkFBc0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsMEJBQTBCLHdCQUF3QiwyQkFBMkIsZUFBZSwrQkFBK0IsNEJBQTRCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixpQkFBaUIsZUFBZSxVQUFVLFVBQVUsc0JBQXNCLEdBQUcsZUFBZSxpQkFBaUIsZ0JBQWdCLGNBQWMsa0JBQWtCLHFCQUFxQixhQUFhLGdCQUFnQixlQUFlLGlCQUFpQixjQUFjLGdCQUFnQixvQkFBb0Isa0JBQWtCLG9CQUFvQixpQkFBaUIsaUJBQWlCLGdCQUFnQixlQUFlLGdCQUFnQixnQkFBZ0IsVUFBVSxTQUFTLHNCQUFzQixHQUFHLGdCQUFnQixpQkFBaUIsY0FBYyxlQUFlLDRCQUE0QiwrQkFBK0IsY0FBYyxhQUFhLFVBQVUsU0FBUyx1QkFBdUIsR0FBRyxTQUFTLFNBQVMsdUJBQXVCLEdBQUcsYUFBYSxjQUFjLGdCQUFnQixpQkFBaUIsaUJBQWlCLGtCQUFrQixnQkFBZ0IsbUNBQW1DLG1CQUFtQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsbUJBQW1CLGdCQUFnQixpQkFBaUIsVUFBVSxTQUFTLHVCQUF1QixHQUFHLFNBQVMsYUFBYSxxQkFBcUIsR0FBRyxTQUFTLFFBQVEsb0JBQW9CLEdBQUcsYUFBYSx3QkFBd0IsbUJBQW1CLFVBQVUsV0FBVyxzQkFBc0IsR0FBRyxjQUFjLHdCQUF3QixlQUFlLGdCQUFnQixnQkFBZ0IsYUFBYSxjQUFjLGNBQWMsVUFBVSxVQUFVLHNCQUFzQixHQUFHLGtCQUFrQixVQUFVLGFBQWEsc0JBQXNCLEdBQUcsU0FBUyxVQUFVLHNCQUFzQixHQUFHLFNBQVMsV0FBVyx1QkFBdUIsR0FBRyxTQUFTLFdBQVcsc0JBQXNCLEdBQUcsa0JBQWtCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixlQUFlLGlCQUFpQixpQkFBaUIsZ0JBQWdCLG9CQUFvQixpQkFBaUIsYUFBYSxVQUFVLGVBQWUseUJBQXlCLEdBQUcsZ0JBQWdCLFVBQVUsUUFBUSxzQkFBc0IsR0FBRyxTQUFTLFFBQVEsc0JBQXNCLEdBQUcsU0FBUyxRQUFRLG9CQUFvQixHQUFHLFNBQVMsUUFBUSxvQkFBb0IsR0FBRyxTQUFTLFNBQVMsNEJBQTRCLEdBQUcsU0FBUyxTQUFTLDRCQUE0QixHQUFHLFNBQVMsUUFBUSx3REFBd0QsaUJBQWlCLE9BQU8sU0FBUyxRQUFRLHdEQUF3RCxpQkFBaUIsT0FBTyxpQkFBaUIsb0JBQW9CLGdCQUFnQixjQUFjLGNBQWMsY0FBYyxrQkFBa0IsdUJBQXVCLGdCQUFnQixnQkFBZ0Isc0JBQXNCLGFBQWEseUJBQXlCLHlCQUF5QixhQUFhLGFBQWEsZ0JBQWdCLGdCQUFnQix3QkFBd0IsVUFBVSxXQUFXLGlDQUFpQyxHQUFHLHFCQUFxQixzQkFBc0IsVUFBVSxTQUFTLDJCQUEyQixHQUFHLFNBQVMsU0FBUyw2QkFBNkIsR0FBRyxjQUFjLGVBQWUsZUFBZSxlQUFlLHlCQUF5QiwyQkFBMkIsVUFBVSxXQUFXLCtCQUErQixHQUFHLFNBQVMsV0FBVywrQkFBK0IsR0FBRyxnQkFBZ0Isb0JBQW9CLFVBQVUsV0FBVyxnQ0FBZ0MsR0FBRyxTQUFTLFdBQVcsa0NBQWtDLEdBQUcsZ0JBQWdCLGlCQUFpQixVQUFVLFdBQVcseUJBQXlCLEdBQUcsU0FBUyxXQUFXLHlCQUF5QixHQUFHLG9CQUFvQixzQkFBc0Isc0JBQXNCLGVBQWUsb0JBQW9CLHNCQUFzQixxQkFBcUIsc0JBQXNCLGtCQUFrQixtQkFBbUIsbUJBQW1CLG9CQUFvQixtQkFBbUIsZ0JBQWdCLGtCQUFrQixjQUFjLGlCQUFpQix5QkFBeUIsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQix1QkFBdUIsd0JBQXdCLFVBQVUsdUJBQXVCLHlCQUF5QixHQUFHLFNBQVMsd0JBQXdCLHlCQUF5QixHQUFHLGdCQUFnQixlQUFlLG1CQUFtQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsa0JBQWtCLGdCQUFnQixtQkFBbUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZUFBZSxlQUFlLGlCQUFpQix3QkFBd0IsaUJBQWlCLGlCQUFpQixpQkFBaUIseUJBQXlCLDBCQUEwQixvQkFBb0IsbUJBQW1CLHFCQUFxQixjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsZUFBZSxrQkFBa0IsZ0JBQWdCLFVBQVUsUUFBUSxvQkFBb0IsR0FBRyxTQUFTLFFBQVEsb0JBQW9CLEdBQUcsU0FBUyxTQUFTLHVCQUF1QixHQUFHLFNBQVMsU0FBUyx1QkFBdUIsR0FBRyxlQUFlLGdCQUFnQixnQ0FBZ0MsZ0NBQWdDLCtCQUErQixpQ0FBaUMsZ0JBQWdCLGdCQUFnQixtQkFBbUIsaUJBQWlCLGdCQUFnQiwyQkFBMkIsaUJBQWlCLGdDQUFnQyxpQkFBaUIsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixnQkFBZ0IsVUFBVSxhQUFhLHlCQUF5QixHQUFHLGlCQUFpQixrQkFBa0IsVUFBVSxXQUFXLHVCQUF1QixHQUFHLGNBQWMsZUFBZSxjQUFjLGtCQUFrQixrQkFBa0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLG9CQUFvQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGVBQWUsbUJBQW1CLG1CQUFtQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixtQkFBbUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsbUJBQW1CLHNCQUFzQixxQkFBcUIsc0JBQXNCLGVBQWUsbUJBQW1CLDJCQUEyQiwyQkFBMkIsb0JBQW9CLHFCQUFxQixtQkFBbUIsbUJBQW1CLGlCQUFpQixxQkFBcUIsZ0JBQWdCLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0Isa0JBQWtCLHNCQUFzQiwrQkFBK0IsZUFBZSxpQkFBaUIsZ0JBQWdCLHdCQUF3Qix3QkFBd0IsbUJBQW1CLDZCQUE2QixlQUFlLDBCQUEwQiw0QkFBNEIsZUFBZSw0QkFBNEIsZUFBZSxjQUFjLGNBQWMsa0JBQWtCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQiwyQkFBMkIsNEJBQTRCLGtCQUFrQixlQUFlLGdCQUFnQixrQkFBa0IsZUFBZSxrQkFBa0IsZ0JBQWdCLGlCQUFpQixzQkFBc0IsZUFBZSxlQUFlLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGdCQUFnQixlQUFlLGdCQUFnQiw2QkFBNkIsaUJBQWlCLGdCQUFnQixvQkFBb0Isa0JBQWtCLDZCQUE2Qiw2QkFBNkIsZUFBZSxlQUFlLGVBQWUsZUFBZSxnQkFBZ0IsZ0JBQWdCLHdCQUF3Qix5QkFBeUIsNkJBQTZCLDhCQUE4QiwrQkFBK0IsbUNBQW1DLHFCQUFxQixtQkFBbUIsbUJBQW1CLGlCQUFpQixpQkFBaUIsY0FBYyxnQkFBZ0IsaUJBQWlCLGdCQUFnQixrQkFBa0IsbUJBQW1CLG1CQUFtQixxQkFBcUIsdUJBQXVCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixrQkFBa0Isa0JBQWtCLGlCQUFpQixpQkFBaUIsbUJBQW1CLG1CQUFtQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsVUFBVSxXQUFXLHVCQUF1QixHQUFHLGlCQUFpQixlQUFlLGVBQWUsa0JBQWtCLGlCQUFpQixrQkFBa0Isa0JBQWtCLGlCQUFpQixrQkFBa0IsbUJBQW1CLG1CQUFtQixtQkFBbUIsMEJBQTBCLDRCQUE0Qiw4QkFBOEIsMkJBQTJCLHdCQUF3Qix5QkFBeUIsMkJBQTJCLDZCQUE2Qiw0QkFBNEIsNkJBQTZCLDBCQUEwQiw0QkFBNEIsd0JBQXdCLHlCQUF5QiwyQkFBMkIsNkJBQTZCLDRCQUE0Qiw2QkFBNkIsMEJBQTBCLDRCQUE0QixlQUFlLGVBQWUsZUFBZSxlQUFlLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtCQUFrQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsZ0JBQWdCLGdCQUFnQix1QkFBdUIsZ0JBQWdCLGtCQUFrQixrQkFBa0Isa0JBQWtCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0IsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsa0JBQWtCLGlCQUFpQixtQkFBbUIsZUFBZSxnQkFBZ0Isa0JBQWtCLGtCQUFrQixtQkFBbUIsbUJBQW1CLG1CQUFtQixtQkFBbUIsbUJBQW1CLG1CQUFtQixtQkFBbUIsbUJBQW1CLGtCQUFrQixrQkFBa0Isa0JBQWtCLG1CQUFtQixtQkFBbUIsZ0JBQWdCLGVBQWUsZUFBZSxnQkFBZ0Isa0JBQWtCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGNBQWMsY0FBYyxrQkFBa0IsZUFBZSxlQUFlLGdCQUFnQixpQkFBaUIsZ0JBQWdCLG1CQUFtQixVQUFVLHFCQUFxQixtQ0FBbUMsR0FBRyxTQUFTLHNCQUFzQixvQ0FBb0MsR0FBRyxpQkFBaUIsbUJBQW1CLGtCQUFrQixpQkFBaUIsbUJBQW1CLG1CQUFtQix1QkFBdUIsc0JBQXNCLGVBQWUsa0JBQWtCLG1CQUFtQixvQkFBb0IsbUJBQW1CLG1CQUFtQixpQkFBaUIsbUJBQW1CLG1CQUFtQixnQkFBZ0IsbUJBQW1CLG1CQUFtQixrQkFBa0IsbUJBQW1CLGtCQUFrQixtQkFBbUIsbUJBQW1CLG1CQUFtQixrQkFBa0IsaUJBQWlCLGtCQUFrQixrQkFBa0IsaUJBQWlCLGtCQUFrQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsbUJBQW1CLGlCQUFpQixrQkFBa0Isa0JBQWtCLG1CQUFtQixpQkFBaUIsZUFBZSxrQkFBa0IsbUJBQW1CLGtCQUFrQixrQkFBa0IsZ0JBQWdCLGlCQUFpQixlQUFlLGVBQWUsaUJBQWlCLGdCQUFnQixpQkFBaUIsaUJBQWlCLG1CQUFtQixtQkFBbUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsZ0JBQWdCLGtCQUFrQixjQUFjLGFBQWEsaUJBQWlCLGVBQWUsa0JBQWtCLG1CQUFtQixlQUFlLGNBQWMsZUFBZSxjQUFjLGlCQUFpQixnQkFBZ0IsaUJBQWlCLFVBQVUsYUFBYSx5QkFBeUIsR0FBRyxnQkFBZ0IsaUJBQWlCLFVBQVUsU0FBUyxxQkFBcUIsR0FBRyxlQUFlLGdCQUFnQixlQUFlLGlCQUFpQixnQkFBZ0Isa0JBQWtCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGtCQUFrQixrQkFBa0IsVUFBVSxjQUFjLDBCQUEwQixHQUFHLFNBQVMsY0FBYywwQkFBMEIsR0FBRyxnQkFBZ0IsaUJBQWlCLGtCQUFrQixrQkFBa0IsbUJBQW1CLG1CQUFtQixjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsZUFBZSxjQUFjLGNBQWMsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGNBQWMsY0FBYyxpQkFBaUIsaUJBQWlCLGNBQWMsY0FBYyxpQkFBaUIsaUJBQWlCLGFBQWEsYUFBYSxlQUFlLGVBQWUsZ0JBQWdCLGdCQUFnQixVQUFVLGNBQWMsa0NBQWtDLEdBQUcsU0FBUyxvQkFBb0Isd0NBQXdDLEdBQUcsYUFBYSxjQUFjLGVBQWUsZUFBZSxnQkFBZ0IsZ0JBQWdCLGNBQWMsY0FBYyxVQUFVLFVBQVUsd0JBQXdCLEdBQUcsU0FBUyxVQUFVLHdCQUF3QixHQUFHLGVBQWUsVUFBVSxtQkFBbUIsaUNBQWlDLEdBQUcsU0FBUyxTQUFTLGlDQUFpQyxHQUFHLGFBQWEsY0FBYyxtQkFBbUIsZUFBZSxlQUFlLGVBQWUsc0JBQXNCLGdCQUFnQixhQUFhLGFBQWEsaUJBQWlCLGlCQUFpQixrQkFBa0Isa0JBQWtCLGtCQUFrQixrQkFBa0Isa0JBQWtCLGtCQUFrQixVQUFVLFVBQVUsc0JBQXNCLEdBQUcsU0FBUyxVQUFVLHNCQUFzQixHQUFHLGdCQUFnQixpQkFBaUIsVUFBVSxXQUFXLGdDQUFnQyxHQUFHLFNBQVMsV0FBVyxnQ0FBZ0MsR0FBRyxjQUFjLGVBQWUsZ0JBQWdCLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsa0JBQWtCLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGVBQWUsZ0JBQWdCLGlCQUFpQixlQUFlLGVBQWUsZ0JBQWdCLGVBQWUsY0FBYyxlQUFlLGdCQUFnQixpQkFBaUIsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLFVBQVUsV0FBVyx3QkFBd0IsR0FBRyxhQUFhLHVEQUF1RCxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxPQUFPLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGlCQUFpQixpQkFBaUIsS0FBSyxFQUFDO0FBQzlxMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2VudGl0aWVzL2xpYi9lc20vZ2VuZXJhdGVkL2VuY29kZS1odG1sLmpzP2YzMjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIHVzaW5nIHNjcmlwdHMvd3JpdGUtZW5jb2RlLW1hcC50c1xuZnVuY3Rpb24gcmVzdG9yZURpZmYoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldWzBdICs9IGFycltpIC0gMV1bMF0gKyAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgZGVmYXVsdCBuZXcgTWFwKC8qICNfX1BVUkVfXyAqLyByZXN0b3JlRGlmZihbWzksIFwiJlRhYjtcIl0sIFswLCBcIiZOZXdMaW5lO1wiXSwgWzIyLCBcIiZleGNsO1wiXSwgWzAsIFwiJnF1b3Q7XCJdLCBbMCwgXCImbnVtO1wiXSwgWzAsIFwiJmRvbGxhcjtcIl0sIFswLCBcIiZwZXJjbnQ7XCJdLCBbMCwgXCImYW1wO1wiXSwgWzAsIFwiJmFwb3M7XCJdLCBbMCwgXCImbHBhcjtcIl0sIFswLCBcIiZycGFyO1wiXSwgWzAsIFwiJmFzdDtcIl0sIFswLCBcIiZwbHVzO1wiXSwgWzAsIFwiJmNvbW1hO1wiXSwgWzEsIFwiJnBlcmlvZDtcIl0sIFswLCBcIiZzb2w7XCJdLCBbMTAsIFwiJmNvbG9uO1wiXSwgWzAsIFwiJnNlbWk7XCJdLCBbMCwgeyB2OiBcIiZsdDtcIiwgbjogODQwMiwgbzogXCImbnZsdDtcIiB9XSwgWzAsIHsgdjogXCImZXF1YWxzO1wiLCBuOiA4NDIxLCBvOiBcIiZibmU7XCIgfV0sIFswLCB7IHY6IFwiJmd0O1wiLCBuOiA4NDAyLCBvOiBcIiZudmd0O1wiIH1dLCBbMCwgXCImcXVlc3Q7XCJdLCBbMCwgXCImY29tbWF0O1wiXSwgWzI2LCBcIiZsYnJhY2s7XCJdLCBbMCwgXCImYnNvbDtcIl0sIFswLCBcIiZyYnJhY2s7XCJdLCBbMCwgXCImSGF0O1wiXSwgWzAsIFwiJmxvd2JhcjtcIl0sIFswLCBcIiZEaWFjcml0aWNhbEdyYXZlO1wiXSwgWzUsIHsgbjogMTA2LCBvOiBcIiZmamxpZztcIiB9XSwgWzIwLCBcIiZsYnJhY2U7XCJdLCBbMCwgXCImdmVyYmFyO1wiXSwgWzAsIFwiJnJicmFjZTtcIl0sIFszNCwgXCImbmJzcDtcIl0sIFswLCBcIiZpZXhjbDtcIl0sIFswLCBcIiZjZW50O1wiXSwgWzAsIFwiJnBvdW5kO1wiXSwgWzAsIFwiJmN1cnJlbjtcIl0sIFswLCBcIiZ5ZW47XCJdLCBbMCwgXCImYnJ2YmFyO1wiXSwgWzAsIFwiJnNlY3Q7XCJdLCBbMCwgXCImZGllO1wiXSwgWzAsIFwiJmNvcHk7XCJdLCBbMCwgXCImb3JkZjtcIl0sIFswLCBcIiZsYXF1bztcIl0sIFswLCBcIiZub3Q7XCJdLCBbMCwgXCImc2h5O1wiXSwgWzAsIFwiJmNpcmNsZWRSO1wiXSwgWzAsIFwiJm1hY3I7XCJdLCBbMCwgXCImZGVnO1wiXSwgWzAsIFwiJlBsdXNNaW51cztcIl0sIFswLCBcIiZzdXAyO1wiXSwgWzAsIFwiJnN1cDM7XCJdLCBbMCwgXCImYWN1dGU7XCJdLCBbMCwgXCImbWljcm87XCJdLCBbMCwgXCImcGFyYTtcIl0sIFswLCBcIiZjZW50ZXJkb3Q7XCJdLCBbMCwgXCImY2VkaWw7XCJdLCBbMCwgXCImc3VwMTtcIl0sIFswLCBcIiZvcmRtO1wiXSwgWzAsIFwiJnJhcXVvO1wiXSwgWzAsIFwiJmZyYWMxNDtcIl0sIFswLCBcIiZmcmFjMTI7XCJdLCBbMCwgXCImZnJhYzM0O1wiXSwgWzAsIFwiJmlxdWVzdDtcIl0sIFswLCBcIiZBZ3JhdmU7XCJdLCBbMCwgXCImQWFjdXRlO1wiXSwgWzAsIFwiJkFjaXJjO1wiXSwgWzAsIFwiJkF0aWxkZTtcIl0sIFswLCBcIiZBdW1sO1wiXSwgWzAsIFwiJmFuZ3N0O1wiXSwgWzAsIFwiJkFFbGlnO1wiXSwgWzAsIFwiJkNjZWRpbDtcIl0sIFswLCBcIiZFZ3JhdmU7XCJdLCBbMCwgXCImRWFjdXRlO1wiXSwgWzAsIFwiJkVjaXJjO1wiXSwgWzAsIFwiJkV1bWw7XCJdLCBbMCwgXCImSWdyYXZlO1wiXSwgWzAsIFwiJklhY3V0ZTtcIl0sIFswLCBcIiZJY2lyYztcIl0sIFswLCBcIiZJdW1sO1wiXSwgWzAsIFwiJkVUSDtcIl0sIFswLCBcIiZOdGlsZGU7XCJdLCBbMCwgXCImT2dyYXZlO1wiXSwgWzAsIFwiJk9hY3V0ZTtcIl0sIFswLCBcIiZPY2lyYztcIl0sIFswLCBcIiZPdGlsZGU7XCJdLCBbMCwgXCImT3VtbDtcIl0sIFswLCBcIiZ0aW1lcztcIl0sIFswLCBcIiZPc2xhc2g7XCJdLCBbMCwgXCImVWdyYXZlO1wiXSwgWzAsIFwiJlVhY3V0ZTtcIl0sIFswLCBcIiZVY2lyYztcIl0sIFswLCBcIiZVdW1sO1wiXSwgWzAsIFwiJllhY3V0ZTtcIl0sIFswLCBcIiZUSE9STjtcIl0sIFswLCBcIiZzemxpZztcIl0sIFswLCBcIiZhZ3JhdmU7XCJdLCBbMCwgXCImYWFjdXRlO1wiXSwgWzAsIFwiJmFjaXJjO1wiXSwgWzAsIFwiJmF0aWxkZTtcIl0sIFswLCBcIiZhdW1sO1wiXSwgWzAsIFwiJmFyaW5nO1wiXSwgWzAsIFwiJmFlbGlnO1wiXSwgWzAsIFwiJmNjZWRpbDtcIl0sIFswLCBcIiZlZ3JhdmU7XCJdLCBbMCwgXCImZWFjdXRlO1wiXSwgWzAsIFwiJmVjaXJjO1wiXSwgWzAsIFwiJmV1bWw7XCJdLCBbMCwgXCImaWdyYXZlO1wiXSwgWzAsIFwiJmlhY3V0ZTtcIl0sIFswLCBcIiZpY2lyYztcIl0sIFswLCBcIiZpdW1sO1wiXSwgWzAsIFwiJmV0aDtcIl0sIFswLCBcIiZudGlsZGU7XCJdLCBbMCwgXCImb2dyYXZlO1wiXSwgWzAsIFwiJm9hY3V0ZTtcIl0sIFswLCBcIiZvY2lyYztcIl0sIFswLCBcIiZvdGlsZGU7XCJdLCBbMCwgXCImb3VtbDtcIl0sIFswLCBcIiZkaXY7XCJdLCBbMCwgXCImb3NsYXNoO1wiXSwgWzAsIFwiJnVncmF2ZTtcIl0sIFswLCBcIiZ1YWN1dGU7XCJdLCBbMCwgXCImdWNpcmM7XCJdLCBbMCwgXCImdXVtbDtcIl0sIFswLCBcIiZ5YWN1dGU7XCJdLCBbMCwgXCImdGhvcm47XCJdLCBbMCwgXCImeXVtbDtcIl0sIFswLCBcIiZBbWFjcjtcIl0sIFswLCBcIiZhbWFjcjtcIl0sIFswLCBcIiZBYnJldmU7XCJdLCBbMCwgXCImYWJyZXZlO1wiXSwgWzAsIFwiJkFvZ29uO1wiXSwgWzAsIFwiJmFvZ29uO1wiXSwgWzAsIFwiJkNhY3V0ZTtcIl0sIFswLCBcIiZjYWN1dGU7XCJdLCBbMCwgXCImQ2NpcmM7XCJdLCBbMCwgXCImY2NpcmM7XCJdLCBbMCwgXCImQ2RvdDtcIl0sIFswLCBcIiZjZG90O1wiXSwgWzAsIFwiJkNjYXJvbjtcIl0sIFswLCBcIiZjY2Fyb247XCJdLCBbMCwgXCImRGNhcm9uO1wiXSwgWzAsIFwiJmRjYXJvbjtcIl0sIFswLCBcIiZEc3Ryb2s7XCJdLCBbMCwgXCImZHN0cm9rO1wiXSwgWzAsIFwiJkVtYWNyO1wiXSwgWzAsIFwiJmVtYWNyO1wiXSwgWzIsIFwiJkVkb3Q7XCJdLCBbMCwgXCImZWRvdDtcIl0sIFswLCBcIiZFb2dvbjtcIl0sIFswLCBcIiZlb2dvbjtcIl0sIFswLCBcIiZFY2Fyb247XCJdLCBbMCwgXCImZWNhcm9uO1wiXSwgWzAsIFwiJkdjaXJjO1wiXSwgWzAsIFwiJmdjaXJjO1wiXSwgWzAsIFwiJkdicmV2ZTtcIl0sIFswLCBcIiZnYnJldmU7XCJdLCBbMCwgXCImR2RvdDtcIl0sIFswLCBcIiZnZG90O1wiXSwgWzAsIFwiJkdjZWRpbDtcIl0sIFsxLCBcIiZIY2lyYztcIl0sIFswLCBcIiZoY2lyYztcIl0sIFswLCBcIiZIc3Ryb2s7XCJdLCBbMCwgXCImaHN0cm9rO1wiXSwgWzAsIFwiJkl0aWxkZTtcIl0sIFswLCBcIiZpdGlsZGU7XCJdLCBbMCwgXCImSW1hY3I7XCJdLCBbMCwgXCImaW1hY3I7XCJdLCBbMiwgXCImSW9nb247XCJdLCBbMCwgXCImaW9nb247XCJdLCBbMCwgXCImSWRvdDtcIl0sIFswLCBcIiZpbWF0aDtcIl0sIFswLCBcIiZJSmxpZztcIl0sIFswLCBcIiZpamxpZztcIl0sIFswLCBcIiZKY2lyYztcIl0sIFswLCBcIiZqY2lyYztcIl0sIFswLCBcIiZLY2VkaWw7XCJdLCBbMCwgXCIma2NlZGlsO1wiXSwgWzAsIFwiJmtncmVlbjtcIl0sIFswLCBcIiZMYWN1dGU7XCJdLCBbMCwgXCImbGFjdXRlO1wiXSwgWzAsIFwiJkxjZWRpbDtcIl0sIFswLCBcIiZsY2VkaWw7XCJdLCBbMCwgXCImTGNhcm9uO1wiXSwgWzAsIFwiJmxjYXJvbjtcIl0sIFswLCBcIiZMbWlkb3Q7XCJdLCBbMCwgXCImbG1pZG90O1wiXSwgWzAsIFwiJkxzdHJvaztcIl0sIFswLCBcIiZsc3Ryb2s7XCJdLCBbMCwgXCImTmFjdXRlO1wiXSwgWzAsIFwiJm5hY3V0ZTtcIl0sIFswLCBcIiZOY2VkaWw7XCJdLCBbMCwgXCImbmNlZGlsO1wiXSwgWzAsIFwiJk5jYXJvbjtcIl0sIFswLCBcIiZuY2Fyb247XCJdLCBbMCwgXCImbmFwb3M7XCJdLCBbMCwgXCImRU5HO1wiXSwgWzAsIFwiJmVuZztcIl0sIFswLCBcIiZPbWFjcjtcIl0sIFswLCBcIiZvbWFjcjtcIl0sIFsyLCBcIiZPZGJsYWM7XCJdLCBbMCwgXCImb2RibGFjO1wiXSwgWzAsIFwiJk9FbGlnO1wiXSwgWzAsIFwiJm9lbGlnO1wiXSwgWzAsIFwiJlJhY3V0ZTtcIl0sIFswLCBcIiZyYWN1dGU7XCJdLCBbMCwgXCImUmNlZGlsO1wiXSwgWzAsIFwiJnJjZWRpbDtcIl0sIFswLCBcIiZSY2Fyb247XCJdLCBbMCwgXCImcmNhcm9uO1wiXSwgWzAsIFwiJlNhY3V0ZTtcIl0sIFswLCBcIiZzYWN1dGU7XCJdLCBbMCwgXCImU2NpcmM7XCJdLCBbMCwgXCImc2NpcmM7XCJdLCBbMCwgXCImU2NlZGlsO1wiXSwgWzAsIFwiJnNjZWRpbDtcIl0sIFswLCBcIiZTY2Fyb247XCJdLCBbMCwgXCImc2Nhcm9uO1wiXSwgWzAsIFwiJlRjZWRpbDtcIl0sIFswLCBcIiZ0Y2VkaWw7XCJdLCBbMCwgXCImVGNhcm9uO1wiXSwgWzAsIFwiJnRjYXJvbjtcIl0sIFswLCBcIiZUc3Ryb2s7XCJdLCBbMCwgXCImdHN0cm9rO1wiXSwgWzAsIFwiJlV0aWxkZTtcIl0sIFswLCBcIiZ1dGlsZGU7XCJdLCBbMCwgXCImVW1hY3I7XCJdLCBbMCwgXCImdW1hY3I7XCJdLCBbMCwgXCImVWJyZXZlO1wiXSwgWzAsIFwiJnVicmV2ZTtcIl0sIFswLCBcIiZVcmluZztcIl0sIFswLCBcIiZ1cmluZztcIl0sIFswLCBcIiZVZGJsYWM7XCJdLCBbMCwgXCImdWRibGFjO1wiXSwgWzAsIFwiJlVvZ29uO1wiXSwgWzAsIFwiJnVvZ29uO1wiXSwgWzAsIFwiJldjaXJjO1wiXSwgWzAsIFwiJndjaXJjO1wiXSwgWzAsIFwiJlljaXJjO1wiXSwgWzAsIFwiJnljaXJjO1wiXSwgWzAsIFwiJll1bWw7XCJdLCBbMCwgXCImWmFjdXRlO1wiXSwgWzAsIFwiJnphY3V0ZTtcIl0sIFswLCBcIiZaZG90O1wiXSwgWzAsIFwiJnpkb3Q7XCJdLCBbMCwgXCImWmNhcm9uO1wiXSwgWzAsIFwiJnpjYXJvbjtcIl0sIFsxOSwgXCImZm5vZjtcIl0sIFszNCwgXCImaW1wZWQ7XCJdLCBbNjMsIFwiJmdhY3V0ZTtcIl0sIFs2NSwgXCImam1hdGg7XCJdLCBbMTQyLCBcIiZjaXJjO1wiXSwgWzAsIFwiJmNhcm9uO1wiXSwgWzE2LCBcIiZicmV2ZTtcIl0sIFswLCBcIiZEaWFjcml0aWNhbERvdDtcIl0sIFswLCBcIiZyaW5nO1wiXSwgWzAsIFwiJm9nb247XCJdLCBbMCwgXCImRGlhY3JpdGljYWxUaWxkZTtcIl0sIFswLCBcIiZkYmxhYztcIl0sIFs1MSwgXCImRG93bkJyZXZlO1wiXSwgWzEyNywgXCImQWxwaGE7XCJdLCBbMCwgXCImQmV0YTtcIl0sIFswLCBcIiZHYW1tYTtcIl0sIFswLCBcIiZEZWx0YTtcIl0sIFswLCBcIiZFcHNpbG9uO1wiXSwgWzAsIFwiJlpldGE7XCJdLCBbMCwgXCImRXRhO1wiXSwgWzAsIFwiJlRoZXRhO1wiXSwgWzAsIFwiJklvdGE7XCJdLCBbMCwgXCImS2FwcGE7XCJdLCBbMCwgXCImTGFtYmRhO1wiXSwgWzAsIFwiJk11O1wiXSwgWzAsIFwiJk51O1wiXSwgWzAsIFwiJlhpO1wiXSwgWzAsIFwiJk9taWNyb247XCJdLCBbMCwgXCImUGk7XCJdLCBbMCwgXCImUmhvO1wiXSwgWzEsIFwiJlNpZ21hO1wiXSwgWzAsIFwiJlRhdTtcIl0sIFswLCBcIiZVcHNpbG9uO1wiXSwgWzAsIFwiJlBoaTtcIl0sIFswLCBcIiZDaGk7XCJdLCBbMCwgXCImUHNpO1wiXSwgWzAsIFwiJm9obTtcIl0sIFs3LCBcIiZhbHBoYTtcIl0sIFswLCBcIiZiZXRhO1wiXSwgWzAsIFwiJmdhbW1hO1wiXSwgWzAsIFwiJmRlbHRhO1wiXSwgWzAsIFwiJmVwc2k7XCJdLCBbMCwgXCImemV0YTtcIl0sIFswLCBcIiZldGE7XCJdLCBbMCwgXCImdGhldGE7XCJdLCBbMCwgXCImaW90YTtcIl0sIFswLCBcIiZrYXBwYTtcIl0sIFswLCBcIiZsYW1iZGE7XCJdLCBbMCwgXCImbXU7XCJdLCBbMCwgXCImbnU7XCJdLCBbMCwgXCImeGk7XCJdLCBbMCwgXCImb21pY3JvbjtcIl0sIFswLCBcIiZwaTtcIl0sIFswLCBcIiZyaG87XCJdLCBbMCwgXCImc2lnbWFmO1wiXSwgWzAsIFwiJnNpZ21hO1wiXSwgWzAsIFwiJnRhdTtcIl0sIFswLCBcIiZ1cHNpO1wiXSwgWzAsIFwiJnBoaTtcIl0sIFswLCBcIiZjaGk7XCJdLCBbMCwgXCImcHNpO1wiXSwgWzAsIFwiJm9tZWdhO1wiXSwgWzcsIFwiJnRoZXRhc3ltO1wiXSwgWzAsIFwiJlVwc2k7XCJdLCBbMiwgXCImcGhpdjtcIl0sIFswLCBcIiZwaXY7XCJdLCBbNSwgXCImR2FtbWFkO1wiXSwgWzAsIFwiJmRpZ2FtbWE7XCJdLCBbMTgsIFwiJmthcHBhdjtcIl0sIFswLCBcIiZyaG92O1wiXSwgWzMsIFwiJmVwc2l2O1wiXSwgWzAsIFwiJmJhY2tlcHNpbG9uO1wiXSwgWzEwLCBcIiZJT2N5O1wiXSwgWzAsIFwiJkRKY3k7XCJdLCBbMCwgXCImR0pjeTtcIl0sIFswLCBcIiZKdWtjeTtcIl0sIFswLCBcIiZEU2N5O1wiXSwgWzAsIFwiJkl1a2N5O1wiXSwgWzAsIFwiJllJY3k7XCJdLCBbMCwgXCImSnNlcmN5O1wiXSwgWzAsIFwiJkxKY3k7XCJdLCBbMCwgXCImTkpjeTtcIl0sIFswLCBcIiZUU0hjeTtcIl0sIFswLCBcIiZLSmN5O1wiXSwgWzEsIFwiJlVicmN5O1wiXSwgWzAsIFwiJkRaY3k7XCJdLCBbMCwgXCImQWN5O1wiXSwgWzAsIFwiJkJjeTtcIl0sIFswLCBcIiZWY3k7XCJdLCBbMCwgXCImR2N5O1wiXSwgWzAsIFwiJkRjeTtcIl0sIFswLCBcIiZJRWN5O1wiXSwgWzAsIFwiJlpIY3k7XCJdLCBbMCwgXCImWmN5O1wiXSwgWzAsIFwiJkljeTtcIl0sIFswLCBcIiZKY3k7XCJdLCBbMCwgXCImS2N5O1wiXSwgWzAsIFwiJkxjeTtcIl0sIFswLCBcIiZNY3k7XCJdLCBbMCwgXCImTmN5O1wiXSwgWzAsIFwiJk9jeTtcIl0sIFswLCBcIiZQY3k7XCJdLCBbMCwgXCImUmN5O1wiXSwgWzAsIFwiJlNjeTtcIl0sIFswLCBcIiZUY3k7XCJdLCBbMCwgXCImVWN5O1wiXSwgWzAsIFwiJkZjeTtcIl0sIFswLCBcIiZLSGN5O1wiXSwgWzAsIFwiJlRTY3k7XCJdLCBbMCwgXCImQ0hjeTtcIl0sIFswLCBcIiZTSGN5O1wiXSwgWzAsIFwiJlNIQ0hjeTtcIl0sIFswLCBcIiZIQVJEY3k7XCJdLCBbMCwgXCImWWN5O1wiXSwgWzAsIFwiJlNPRlRjeTtcIl0sIFswLCBcIiZFY3k7XCJdLCBbMCwgXCImWVVjeTtcIl0sIFswLCBcIiZZQWN5O1wiXSwgWzAsIFwiJmFjeTtcIl0sIFswLCBcIiZiY3k7XCJdLCBbMCwgXCImdmN5O1wiXSwgWzAsIFwiJmdjeTtcIl0sIFswLCBcIiZkY3k7XCJdLCBbMCwgXCImaWVjeTtcIl0sIFswLCBcIiZ6aGN5O1wiXSwgWzAsIFwiJnpjeTtcIl0sIFswLCBcIiZpY3k7XCJdLCBbMCwgXCImamN5O1wiXSwgWzAsIFwiJmtjeTtcIl0sIFswLCBcIiZsY3k7XCJdLCBbMCwgXCImbWN5O1wiXSwgWzAsIFwiJm5jeTtcIl0sIFswLCBcIiZvY3k7XCJdLCBbMCwgXCImcGN5O1wiXSwgWzAsIFwiJnJjeTtcIl0sIFswLCBcIiZzY3k7XCJdLCBbMCwgXCImdGN5O1wiXSwgWzAsIFwiJnVjeTtcIl0sIFswLCBcIiZmY3k7XCJdLCBbMCwgXCIma2hjeTtcIl0sIFswLCBcIiZ0c2N5O1wiXSwgWzAsIFwiJmNoY3k7XCJdLCBbMCwgXCImc2hjeTtcIl0sIFswLCBcIiZzaGNoY3k7XCJdLCBbMCwgXCImaGFyZGN5O1wiXSwgWzAsIFwiJnljeTtcIl0sIFswLCBcIiZzb2Z0Y3k7XCJdLCBbMCwgXCImZWN5O1wiXSwgWzAsIFwiJnl1Y3k7XCJdLCBbMCwgXCImeWFjeTtcIl0sIFsxLCBcIiZpb2N5O1wiXSwgWzAsIFwiJmRqY3k7XCJdLCBbMCwgXCImZ2pjeTtcIl0sIFswLCBcIiZqdWtjeTtcIl0sIFswLCBcIiZkc2N5O1wiXSwgWzAsIFwiJml1a2N5O1wiXSwgWzAsIFwiJnlpY3k7XCJdLCBbMCwgXCImanNlcmN5O1wiXSwgWzAsIFwiJmxqY3k7XCJdLCBbMCwgXCImbmpjeTtcIl0sIFswLCBcIiZ0c2hjeTtcIl0sIFswLCBcIiZramN5O1wiXSwgWzEsIFwiJnVicmN5O1wiXSwgWzAsIFwiJmR6Y3k7XCJdLCBbNzA3NCwgXCImZW5zcDtcIl0sIFswLCBcIiZlbXNwO1wiXSwgWzAsIFwiJmVtc3AxMztcIl0sIFswLCBcIiZlbXNwMTQ7XCJdLCBbMSwgXCImbnVtc3A7XCJdLCBbMCwgXCImcHVuY3NwO1wiXSwgWzAsIFwiJlRoaW5TcGFjZTtcIl0sIFswLCBcIiZoYWlyc3A7XCJdLCBbMCwgXCImTmVnYXRpdmVNZWRpdW1TcGFjZTtcIl0sIFswLCBcIiZ6d25qO1wiXSwgWzAsIFwiJnp3ajtcIl0sIFswLCBcIiZscm07XCJdLCBbMCwgXCImcmxtO1wiXSwgWzAsIFwiJmRhc2g7XCJdLCBbMiwgXCImbmRhc2g7XCJdLCBbMCwgXCImbWRhc2g7XCJdLCBbMCwgXCImaG9yYmFyO1wiXSwgWzAsIFwiJlZlcmJhcjtcIl0sIFsxLCBcIiZsc3F1bztcIl0sIFswLCBcIiZDbG9zZUN1cmx5UXVvdGU7XCJdLCBbMCwgXCImbHNxdW9yO1wiXSwgWzEsIFwiJmxkcXVvO1wiXSwgWzAsIFwiJkNsb3NlQ3VybHlEb3VibGVRdW90ZTtcIl0sIFswLCBcIiZiZHF1bztcIl0sIFsxLCBcIiZkYWdnZXI7XCJdLCBbMCwgXCImRGFnZ2VyO1wiXSwgWzAsIFwiJmJ1bGw7XCJdLCBbMiwgXCImbmxkcjtcIl0sIFswLCBcIiZoZWxsaXA7XCJdLCBbOSwgXCImcGVybWlsO1wiXSwgWzAsIFwiJnBlcnRlbms7XCJdLCBbMCwgXCImcHJpbWU7XCJdLCBbMCwgXCImUHJpbWU7XCJdLCBbMCwgXCImdHByaW1lO1wiXSwgWzAsIFwiJmJhY2twcmltZTtcIl0sIFszLCBcIiZsc2FxdW87XCJdLCBbMCwgXCImcnNhcXVvO1wiXSwgWzMsIFwiJm9saW5lO1wiXSwgWzIsIFwiJmNhcmV0O1wiXSwgWzEsIFwiJmh5YnVsbDtcIl0sIFswLCBcIiZmcmFzbDtcIl0sIFsxMCwgXCImYnNlbWk7XCJdLCBbNywgXCImcXByaW1lO1wiXSwgWzcsIHsgdjogXCImTWVkaXVtU3BhY2U7XCIsIG46IDgyMDIsIG86IFwiJlRoaWNrU3BhY2U7XCIgfV0sIFswLCBcIiZOb0JyZWFrO1wiXSwgWzAsIFwiJmFmO1wiXSwgWzAsIFwiJkludmlzaWJsZVRpbWVzO1wiXSwgWzAsIFwiJmljO1wiXSwgWzcyLCBcIiZldXJvO1wiXSwgWzQ2LCBcIiZ0ZG90O1wiXSwgWzAsIFwiJkRvdERvdDtcIl0sIFszNywgXCImY29tcGxleGVzO1wiXSwgWzIsIFwiJmluY2FyZTtcIl0sIFs0LCBcIiZnc2NyO1wiXSwgWzAsIFwiJmhhbWlsdDtcIl0sIFswLCBcIiZIZnI7XCJdLCBbMCwgXCImSG9wZjtcIl0sIFswLCBcIiZwbGFuY2toO1wiXSwgWzAsIFwiJmhiYXI7XCJdLCBbMCwgXCImaW1hZ2xpbmU7XCJdLCBbMCwgXCImSWZyO1wiXSwgWzAsIFwiJmxhZ3JhbjtcIl0sIFswLCBcIiZlbGw7XCJdLCBbMSwgXCImbmF0dXJhbHM7XCJdLCBbMCwgXCImbnVtZXJvO1wiXSwgWzAsIFwiJmNvcHlzcjtcIl0sIFswLCBcIiZ3ZWllcnA7XCJdLCBbMCwgXCImUG9wZjtcIl0sIFswLCBcIiZRb3BmO1wiXSwgWzAsIFwiJnJlYWxpbmU7XCJdLCBbMCwgXCImcmVhbDtcIl0sIFswLCBcIiZyZWFscztcIl0sIFswLCBcIiZyeDtcIl0sIFszLCBcIiZ0cmFkZTtcIl0sIFsxLCBcIiZpbnRlZ2VycztcIl0sIFsyLCBcIiZtaG87XCJdLCBbMCwgXCImemVldHJmO1wiXSwgWzAsIFwiJmlpb3RhO1wiXSwgWzIsIFwiJmJlcm5vdTtcIl0sIFswLCBcIiZDYXlsZXlzO1wiXSwgWzEsIFwiJmVzY3I7XCJdLCBbMCwgXCImRXNjcjtcIl0sIFswLCBcIiZGb3VyaWVydHJmO1wiXSwgWzEsIFwiJk1lbGxpbnRyZjtcIl0sIFswLCBcIiZvcmRlcjtcIl0sIFswLCBcIiZhbGVmc3ltO1wiXSwgWzAsIFwiJmJldGg7XCJdLCBbMCwgXCImZ2ltZWw7XCJdLCBbMCwgXCImZGFsZXRoO1wiXSwgWzEyLCBcIiZDYXBpdGFsRGlmZmVyZW50aWFsRDtcIl0sIFswLCBcIiZkZDtcIl0sIFswLCBcIiZlZTtcIl0sIFswLCBcIiZpaTtcIl0sIFsxMCwgXCImZnJhYzEzO1wiXSwgWzAsIFwiJmZyYWMyMztcIl0sIFswLCBcIiZmcmFjMTU7XCJdLCBbMCwgXCImZnJhYzI1O1wiXSwgWzAsIFwiJmZyYWMzNTtcIl0sIFswLCBcIiZmcmFjNDU7XCJdLCBbMCwgXCImZnJhYzE2O1wiXSwgWzAsIFwiJmZyYWM1NjtcIl0sIFswLCBcIiZmcmFjMTg7XCJdLCBbMCwgXCImZnJhYzM4O1wiXSwgWzAsIFwiJmZyYWM1ODtcIl0sIFswLCBcIiZmcmFjNzg7XCJdLCBbNDksIFwiJmxhcnI7XCJdLCBbMCwgXCImU2hvcnRVcEFycm93O1wiXSwgWzAsIFwiJnJhcnI7XCJdLCBbMCwgXCImZGFycjtcIl0sIFswLCBcIiZoYXJyO1wiXSwgWzAsIFwiJnVwZG93bmFycm93O1wiXSwgWzAsIFwiJm53YXJyO1wiXSwgWzAsIFwiJm5lYXJyO1wiXSwgWzAsIFwiJkxvd2VyUmlnaHRBcnJvdztcIl0sIFswLCBcIiZMb3dlckxlZnRBcnJvdztcIl0sIFswLCBcIiZubGFycjtcIl0sIFswLCBcIiZucmFycjtcIl0sIFsxLCB7IHY6IFwiJnJhcnJ3O1wiLCBuOiA4MjQsIG86IFwiJm5yYXJydztcIiB9XSwgWzAsIFwiJkxhcnI7XCJdLCBbMCwgXCImVWFycjtcIl0sIFswLCBcIiZSYXJyO1wiXSwgWzAsIFwiJkRhcnI7XCJdLCBbMCwgXCImbGFycnRsO1wiXSwgWzAsIFwiJnJhcnJ0bDtcIl0sIFswLCBcIiZMZWZ0VGVlQXJyb3c7XCJdLCBbMCwgXCImbWFwc3RvdXA7XCJdLCBbMCwgXCImbWFwO1wiXSwgWzAsIFwiJkRvd25UZWVBcnJvdztcIl0sIFsxLCBcIiZob29rbGVmdGFycm93O1wiXSwgWzAsIFwiJmhvb2tyaWdodGFycm93O1wiXSwgWzAsIFwiJmxhcnJscDtcIl0sIFswLCBcIiZsb29wYXJyb3dyaWdodDtcIl0sIFswLCBcIiZoYXJydztcIl0sIFswLCBcIiZuaGFycjtcIl0sIFsxLCBcIiZsc2g7XCJdLCBbMCwgXCImcnNoO1wiXSwgWzAsIFwiJmxkc2g7XCJdLCBbMCwgXCImcmRzaDtcIl0sIFsxLCBcIiZjcmFycjtcIl0sIFswLCBcIiZjdWxhcnI7XCJdLCBbMCwgXCImY3VyYXJyO1wiXSwgWzIsIFwiJmNpcmNsZWFycm93bGVmdDtcIl0sIFswLCBcIiZjaXJjbGVhcnJvd3JpZ2h0O1wiXSwgWzAsIFwiJmxlZnRoYXJwb29udXA7XCJdLCBbMCwgXCImRG93bkxlZnRWZWN0b3I7XCJdLCBbMCwgXCImUmlnaHRVcFZlY3RvcjtcIl0sIFswLCBcIiZMZWZ0VXBWZWN0b3I7XCJdLCBbMCwgXCImcmhhcnU7XCJdLCBbMCwgXCImRG93blJpZ2h0VmVjdG9yO1wiXSwgWzAsIFwiJmRoYXJyO1wiXSwgWzAsIFwiJmRoYXJsO1wiXSwgWzAsIFwiJlJpZ2h0QXJyb3dMZWZ0QXJyb3c7XCJdLCBbMCwgXCImdWRhcnI7XCJdLCBbMCwgXCImTGVmdEFycm93UmlnaHRBcnJvdztcIl0sIFswLCBcIiZsZWZ0bGVmdGFycm93cztcIl0sIFswLCBcIiZ1cHVwYXJyb3dzO1wiXSwgWzAsIFwiJnJpZ2h0cmlnaHRhcnJvd3M7XCJdLCBbMCwgXCImZGRhcnI7XCJdLCBbMCwgXCImbGVmdHJpZ2h0aGFycG9vbnM7XCJdLCBbMCwgXCImRXF1aWxpYnJpdW07XCJdLCBbMCwgXCImbmxBcnI7XCJdLCBbMCwgXCImbmhBcnI7XCJdLCBbMCwgXCImbnJBcnI7XCJdLCBbMCwgXCImRG91YmxlTGVmdEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZVVwQXJyb3c7XCJdLCBbMCwgXCImRG91YmxlUmlnaHRBcnJvdztcIl0sIFswLCBcIiZkQXJyO1wiXSwgWzAsIFwiJkRvdWJsZUxlZnRSaWdodEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZVVwRG93bkFycm93O1wiXSwgWzAsIFwiJm53QXJyO1wiXSwgWzAsIFwiJm5lQXJyO1wiXSwgWzAsIFwiJnNlQXJyO1wiXSwgWzAsIFwiJnN3QXJyO1wiXSwgWzAsIFwiJmxBYXJyO1wiXSwgWzAsIFwiJnJBYXJyO1wiXSwgWzEsIFwiJnppZ3JhcnI7XCJdLCBbNiwgXCImbGFycmI7XCJdLCBbMCwgXCImcmFycmI7XCJdLCBbMTUsIFwiJkRvd25BcnJvd1VwQXJyb3c7XCJdLCBbNywgXCImbG9hcnI7XCJdLCBbMCwgXCImcm9hcnI7XCJdLCBbMCwgXCImaG9hcnI7XCJdLCBbMCwgXCImZm9yYWxsO1wiXSwgWzAsIFwiJmNvbXA7XCJdLCBbMCwgeyB2OiBcIiZwYXJ0O1wiLCBuOiA4MjQsIG86IFwiJm5wYXJ0O1wiIH1dLCBbMCwgXCImZXhpc3Q7XCJdLCBbMCwgXCImbmV4aXN0O1wiXSwgWzAsIFwiJmVtcHR5O1wiXSwgWzEsIFwiJkRlbDtcIl0sIFswLCBcIiZFbGVtZW50O1wiXSwgWzAsIFwiJk5vdEVsZW1lbnQ7XCJdLCBbMSwgXCImbmk7XCJdLCBbMCwgXCImbm90bmk7XCJdLCBbMiwgXCImcHJvZDtcIl0sIFswLCBcIiZjb3Byb2Q7XCJdLCBbMCwgXCImc3VtO1wiXSwgWzAsIFwiJm1pbnVzO1wiXSwgWzAsIFwiJk1pbnVzUGx1cztcIl0sIFswLCBcIiZkb3RwbHVzO1wiXSwgWzEsIFwiJkJhY2tzbGFzaDtcIl0sIFswLCBcIiZsb3dhc3Q7XCJdLCBbMCwgXCImY29tcGZuO1wiXSwgWzEsIFwiJnJhZGljO1wiXSwgWzIsIFwiJnByb3A7XCJdLCBbMCwgXCImaW5maW47XCJdLCBbMCwgXCImYW5ncnQ7XCJdLCBbMCwgeyB2OiBcIiZhbmc7XCIsIG46IDg0MDIsIG86IFwiJm5hbmc7XCIgfV0sIFswLCBcIiZhbmdtc2Q7XCJdLCBbMCwgXCImYW5nc3BoO1wiXSwgWzAsIFwiJm1pZDtcIl0sIFswLCBcIiZubWlkO1wiXSwgWzAsIFwiJkRvdWJsZVZlcnRpY2FsQmFyO1wiXSwgWzAsIFwiJk5vdERvdWJsZVZlcnRpY2FsQmFyO1wiXSwgWzAsIFwiJmFuZDtcIl0sIFswLCBcIiZvcjtcIl0sIFswLCB7IHY6IFwiJmNhcDtcIiwgbjogNjUwMjQsIG86IFwiJmNhcHM7XCIgfV0sIFswLCB7IHY6IFwiJmN1cDtcIiwgbjogNjUwMjQsIG86IFwiJmN1cHM7XCIgfV0sIFswLCBcIiZpbnQ7XCJdLCBbMCwgXCImSW50O1wiXSwgWzAsIFwiJmlpaW50O1wiXSwgWzAsIFwiJmNvbmludDtcIl0sIFswLCBcIiZDb25pbnQ7XCJdLCBbMCwgXCImQ2NvbmludDtcIl0sIFswLCBcIiZjd2ludDtcIl0sIFswLCBcIiZDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7XCJdLCBbMCwgXCImYXdjb25pbnQ7XCJdLCBbMCwgXCImdGhlcmU0O1wiXSwgWzAsIFwiJmJlY2F1cztcIl0sIFswLCBcIiZyYXRpbztcIl0sIFswLCBcIiZDb2xvbjtcIl0sIFswLCBcIiZkb3RtaW51cztcIl0sIFsxLCBcIiZtRERvdDtcIl0sIFswLCBcIiZob210aHQ7XCJdLCBbMCwgeyB2OiBcIiZzaW07XCIsIG46IDg0MDIsIG86IFwiJm52c2ltO1wiIH1dLCBbMCwgeyB2OiBcIiZiYWNrc2ltO1wiLCBuOiA4MTcsIG86IFwiJnJhY2U7XCIgfV0sIFswLCB7IHY6IFwiJmFjO1wiLCBuOiA4MTksIG86IFwiJmFjRTtcIiB9XSwgWzAsIFwiJmFjZDtcIl0sIFswLCBcIiZWZXJ0aWNhbFRpbGRlO1wiXSwgWzAsIFwiJk5vdFRpbGRlO1wiXSwgWzAsIHsgdjogXCImZXFzaW07XCIsIG46IDgyNCwgbzogXCImbmVzaW07XCIgfV0sIFswLCBcIiZzaW1lO1wiXSwgWzAsIFwiJk5vdFRpbGRlRXF1YWw7XCJdLCBbMCwgXCImY29uZztcIl0sIFswLCBcIiZzaW1uZTtcIl0sIFswLCBcIiZuY29uZztcIl0sIFswLCBcIiZhcDtcIl0sIFswLCBcIiZuYXA7XCJdLCBbMCwgXCImYXBlO1wiXSwgWzAsIHsgdjogXCImYXBpZDtcIiwgbjogODI0LCBvOiBcIiZuYXBpZDtcIiB9XSwgWzAsIFwiJmJhY2tjb25nO1wiXSwgWzAsIHsgdjogXCImYXN5bXBlcTtcIiwgbjogODQwMiwgbzogXCImbnZhcDtcIiB9XSwgWzAsIHsgdjogXCImYnVtcDtcIiwgbjogODI0LCBvOiBcIiZuYnVtcDtcIiB9XSwgWzAsIHsgdjogXCImYnVtcGU7XCIsIG46IDgyNCwgbzogXCImbmJ1bXBlO1wiIH1dLCBbMCwgeyB2OiBcIiZkb3RlcTtcIiwgbjogODI0LCBvOiBcIiZuZWRvdDtcIiB9XSwgWzAsIFwiJmRvdGVxZG90O1wiXSwgWzAsIFwiJmVmRG90O1wiXSwgWzAsIFwiJmVyRG90O1wiXSwgWzAsIFwiJkFzc2lnbjtcIl0sIFswLCBcIiZlY29sb247XCJdLCBbMCwgXCImZWNpcjtcIl0sIFswLCBcIiZjaXJjZXE7XCJdLCBbMSwgXCImd2VkZ2VxO1wiXSwgWzAsIFwiJnZlZWVxO1wiXSwgWzEsIFwiJnRyaWFuZ2xlcTtcIl0sIFsyLCBcIiZlcXVlc3Q7XCJdLCBbMCwgXCImbmU7XCJdLCBbMCwgeyB2OiBcIiZDb25ncnVlbnQ7XCIsIG46IDg0MjEsIG86IFwiJmJuZXF1aXY7XCIgfV0sIFswLCBcIiZuZXF1aXY7XCJdLCBbMSwgeyB2OiBcIiZsZTtcIiwgbjogODQwMiwgbzogXCImbnZsZTtcIiB9XSwgWzAsIHsgdjogXCImZ2U7XCIsIG46IDg0MDIsIG86IFwiJm52Z2U7XCIgfV0sIFswLCB7IHY6IFwiJmxFO1wiLCBuOiA4MjQsIG86IFwiJm5sRTtcIiB9XSwgWzAsIHsgdjogXCImZ0U7XCIsIG46IDgyNCwgbzogXCImbmdFO1wiIH1dLCBbMCwgeyB2OiBcIiZsbkU7XCIsIG46IDY1MDI0LCBvOiBcIiZsdmVydG5lcXE7XCIgfV0sIFswLCB7IHY6IFwiJmduRTtcIiwgbjogNjUwMjQsIG86IFwiJmd2ZXJ0bmVxcTtcIiB9XSwgWzAsIHsgdjogXCImbGw7XCIsIG46IG5ldyBNYXAoLyogI19fUFVSRV9fICovIHJlc3RvcmVEaWZmKFtbODI0LCBcIiZuTHR2O1wiXSwgWzc1NzcsIFwiJm5MdDtcIl1dKSkgfV0sIFswLCB7IHY6IFwiJmdnO1wiLCBuOiBuZXcgTWFwKC8qICNfX1BVUkVfXyAqLyByZXN0b3JlRGlmZihbWzgyNCwgXCImbkd0djtcIl0sIFs3NTc3LCBcIiZuR3Q7XCJdXSkpIH1dLCBbMCwgXCImYmV0d2VlbjtcIl0sIFswLCBcIiZOb3RDdXBDYXA7XCJdLCBbMCwgXCImbmxlc3M7XCJdLCBbMCwgXCImbmd0O1wiXSwgWzAsIFwiJm5sZTtcIl0sIFswLCBcIiZuZ2U7XCJdLCBbMCwgXCImbGVzc3NpbTtcIl0sIFswLCBcIiZHcmVhdGVyVGlsZGU7XCJdLCBbMCwgXCImbmxzaW07XCJdLCBbMCwgXCImbmdzaW07XCJdLCBbMCwgXCImTGVzc0dyZWF0ZXI7XCJdLCBbMCwgXCImZ2w7XCJdLCBbMCwgXCImTm90TGVzc0dyZWF0ZXI7XCJdLCBbMCwgXCImTm90R3JlYXRlckxlc3M7XCJdLCBbMCwgXCImcHI7XCJdLCBbMCwgXCImc2M7XCJdLCBbMCwgXCImcHJjdWU7XCJdLCBbMCwgXCImc2NjdWU7XCJdLCBbMCwgXCImUHJlY2VkZXNUaWxkZTtcIl0sIFswLCB7IHY6IFwiJnNjc2ltO1wiLCBuOiA4MjQsIG86IFwiJk5vdFN1Y2NlZWRzVGlsZGU7XCIgfV0sIFswLCBcIiZOb3RQcmVjZWRlcztcIl0sIFswLCBcIiZOb3RTdWNjZWVkcztcIl0sIFswLCB7IHY6IFwiJnN1YjtcIiwgbjogODQwMiwgbzogXCImTm90U3Vic2V0O1wiIH1dLCBbMCwgeyB2OiBcIiZzdXA7XCIsIG46IDg0MDIsIG86IFwiJk5vdFN1cGVyc2V0O1wiIH1dLCBbMCwgXCImbnN1YjtcIl0sIFswLCBcIiZuc3VwO1wiXSwgWzAsIFwiJnN1YmU7XCJdLCBbMCwgXCImc3VwZTtcIl0sIFswLCBcIiZOb3RTdWJzZXRFcXVhbDtcIl0sIFswLCBcIiZOb3RTdXBlcnNldEVxdWFsO1wiXSwgWzAsIHsgdjogXCImc3VibmU7XCIsIG46IDY1MDI0LCBvOiBcIiZ2YXJzdWJzZXRuZXE7XCIgfV0sIFswLCB7IHY6IFwiJnN1cG5lO1wiLCBuOiA2NTAyNCwgbzogXCImdmFyc3Vwc2V0bmVxO1wiIH1dLCBbMSwgXCImY3VwZG90O1wiXSwgWzAsIFwiJlVuaW9uUGx1cztcIl0sIFswLCB7IHY6IFwiJnNxc3ViO1wiLCBuOiA4MjQsIG86IFwiJk5vdFNxdWFyZVN1YnNldDtcIiB9XSwgWzAsIHsgdjogXCImc3FzdXA7XCIsIG46IDgyNCwgbzogXCImTm90U3F1YXJlU3VwZXJzZXQ7XCIgfV0sIFswLCBcIiZzcXN1YmU7XCJdLCBbMCwgXCImc3FzdXBlO1wiXSwgWzAsIHsgdjogXCImc3FjYXA7XCIsIG46IDY1MDI0LCBvOiBcIiZzcWNhcHM7XCIgfV0sIFswLCB7IHY6IFwiJnNxY3VwO1wiLCBuOiA2NTAyNCwgbzogXCImc3FjdXBzO1wiIH1dLCBbMCwgXCImQ2lyY2xlUGx1cztcIl0sIFswLCBcIiZDaXJjbGVNaW51cztcIl0sIFswLCBcIiZDaXJjbGVUaW1lcztcIl0sIFswLCBcIiZvc29sO1wiXSwgWzAsIFwiJkNpcmNsZURvdDtcIl0sIFswLCBcIiZjaXJjbGVkY2lyYztcIl0sIFswLCBcIiZjaXJjbGVkYXN0O1wiXSwgWzEsIFwiJmNpcmNsZWRkYXNoO1wiXSwgWzAsIFwiJmJveHBsdXM7XCJdLCBbMCwgXCImYm94bWludXM7XCJdLCBbMCwgXCImYm94dGltZXM7XCJdLCBbMCwgXCImZG90c3F1YXJlO1wiXSwgWzAsIFwiJlJpZ2h0VGVlO1wiXSwgWzAsIFwiJmRhc2h2O1wiXSwgWzAsIFwiJkRvd25UZWU7XCJdLCBbMCwgXCImYm90O1wiXSwgWzEsIFwiJm1vZGVscztcIl0sIFswLCBcIiZEb3VibGVSaWdodFRlZTtcIl0sIFswLCBcIiZWZGFzaDtcIl0sIFswLCBcIiZWdmRhc2g7XCJdLCBbMCwgXCImVkRhc2g7XCJdLCBbMCwgXCImbnZkYXNoO1wiXSwgWzAsIFwiJm52RGFzaDtcIl0sIFswLCBcIiZuVmRhc2g7XCJdLCBbMCwgXCImblZEYXNoO1wiXSwgWzAsIFwiJnBydXJlbDtcIl0sIFsxLCBcIiZMZWZ0VHJpYW5nbGU7XCJdLCBbMCwgXCImUmlnaHRUcmlhbmdsZTtcIl0sIFswLCB7IHY6IFwiJkxlZnRUcmlhbmdsZUVxdWFsO1wiLCBuOiA4NDAyLCBvOiBcIiZudmx0cmllO1wiIH1dLCBbMCwgeyB2OiBcIiZSaWdodFRyaWFuZ2xlRXF1YWw7XCIsIG46IDg0MDIsIG86IFwiJm52cnRyaWU7XCIgfV0sIFswLCBcIiZvcmlnb2Y7XCJdLCBbMCwgXCImaW1vZjtcIl0sIFswLCBcIiZtdWx0aW1hcDtcIl0sIFswLCBcIiZoZXJjb247XCJdLCBbMCwgXCImaW50Y2FsO1wiXSwgWzAsIFwiJnZlZWJhcjtcIl0sIFsxLCBcIiZiYXJ2ZWU7XCJdLCBbMCwgXCImYW5ncnR2YjtcIl0sIFswLCBcIiZscnRyaTtcIl0sIFswLCBcIiZiaWd3ZWRnZTtcIl0sIFswLCBcIiZiaWd2ZWU7XCJdLCBbMCwgXCImYmlnY2FwO1wiXSwgWzAsIFwiJmJpZ2N1cDtcIl0sIFswLCBcIiZkaWFtO1wiXSwgWzAsIFwiJnNkb3Q7XCJdLCBbMCwgXCImc3N0YXJmO1wiXSwgWzAsIFwiJmRpdmlkZW9udGltZXM7XCJdLCBbMCwgXCImYm93dGllO1wiXSwgWzAsIFwiJmx0aW1lcztcIl0sIFswLCBcIiZydGltZXM7XCJdLCBbMCwgXCImbGVmdHRocmVldGltZXM7XCJdLCBbMCwgXCImcmlnaHR0aHJlZXRpbWVzO1wiXSwgWzAsIFwiJmJhY2tzaW1lcTtcIl0sIFswLCBcIiZjdXJseXZlZTtcIl0sIFswLCBcIiZjdXJseXdlZGdlO1wiXSwgWzAsIFwiJlN1YjtcIl0sIFswLCBcIiZTdXA7XCJdLCBbMCwgXCImQ2FwO1wiXSwgWzAsIFwiJkN1cDtcIl0sIFswLCBcIiZmb3JrO1wiXSwgWzAsIFwiJmVwYXI7XCJdLCBbMCwgXCImbGVzc2RvdDtcIl0sIFswLCBcIiZndGRvdDtcIl0sIFswLCB7IHY6IFwiJkxsO1wiLCBuOiA4MjQsIG86IFwiJm5MbDtcIiB9XSwgWzAsIHsgdjogXCImR2c7XCIsIG46IDgyNCwgbzogXCImbkdnO1wiIH1dLCBbMCwgeyB2OiBcIiZsZWc7XCIsIG46IDY1MDI0LCBvOiBcIiZsZXNnO1wiIH1dLCBbMCwgeyB2OiBcIiZnZWw7XCIsIG46IDY1MDI0LCBvOiBcIiZnZXNsO1wiIH1dLCBbMiwgXCImY3VlcHI7XCJdLCBbMCwgXCImY3Vlc2M7XCJdLCBbMCwgXCImTm90UHJlY2VkZXNTbGFudEVxdWFsO1wiXSwgWzAsIFwiJk5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtcIl0sIFswLCBcIiZOb3RTcXVhcmVTdWJzZXRFcXVhbDtcIl0sIFswLCBcIiZOb3RTcXVhcmVTdXBlcnNldEVxdWFsO1wiXSwgWzIsIFwiJmxuc2ltO1wiXSwgWzAsIFwiJmduc2ltO1wiXSwgWzAsIFwiJnByZWNuc2ltO1wiXSwgWzAsIFwiJnNjbnNpbTtcIl0sIFswLCBcIiZubHRyaTtcIl0sIFswLCBcIiZOb3RSaWdodFRyaWFuZ2xlO1wiXSwgWzAsIFwiJm5sdHJpZTtcIl0sIFswLCBcIiZOb3RSaWdodFRyaWFuZ2xlRXF1YWw7XCJdLCBbMCwgXCImdmVsbGlwO1wiXSwgWzAsIFwiJmN0ZG90O1wiXSwgWzAsIFwiJnV0ZG90O1wiXSwgWzAsIFwiJmR0ZG90O1wiXSwgWzAsIFwiJmRpc2luO1wiXSwgWzAsIFwiJmlzaW5zdjtcIl0sIFswLCBcIiZpc2lucztcIl0sIFswLCB7IHY6IFwiJmlzaW5kb3Q7XCIsIG46IDgyNCwgbzogXCImbm90aW5kb3Q7XCIgfV0sIFswLCBcIiZub3RpbnZjO1wiXSwgWzAsIFwiJm5vdGludmI7XCJdLCBbMSwgeyB2OiBcIiZpc2luRTtcIiwgbjogODI0LCBvOiBcIiZub3RpbkU7XCIgfV0sIFswLCBcIiZuaXNkO1wiXSwgWzAsIFwiJnhuaXM7XCJdLCBbMCwgXCImbmlzO1wiXSwgWzAsIFwiJm5vdG5pdmM7XCJdLCBbMCwgXCImbm90bml2YjtcIl0sIFs2LCBcIiZiYXJ3ZWQ7XCJdLCBbMCwgXCImQmFyd2VkO1wiXSwgWzEsIFwiJmxjZWlsO1wiXSwgWzAsIFwiJnJjZWlsO1wiXSwgWzAsIFwiJkxlZnRGbG9vcjtcIl0sIFswLCBcIiZyZmxvb3I7XCJdLCBbMCwgXCImZHJjcm9wO1wiXSwgWzAsIFwiJmRsY3JvcDtcIl0sIFswLCBcIiZ1cmNyb3A7XCJdLCBbMCwgXCImdWxjcm9wO1wiXSwgWzAsIFwiJmJub3Q7XCJdLCBbMSwgXCImcHJvZmxpbmU7XCJdLCBbMCwgXCImcHJvZnN1cmY7XCJdLCBbMSwgXCImdGVscmVjO1wiXSwgWzAsIFwiJnRhcmdldDtcIl0sIFs1LCBcIiZ1bGNvcm47XCJdLCBbMCwgXCImdXJjb3JuO1wiXSwgWzAsIFwiJmRsY29ybjtcIl0sIFswLCBcIiZkcmNvcm47XCJdLCBbMiwgXCImZnJvd247XCJdLCBbMCwgXCImc21pbGU7XCJdLCBbOSwgXCImY3lsY3R5O1wiXSwgWzAsIFwiJnByb2ZhbGFyO1wiXSwgWzcsIFwiJnRvcGJvdDtcIl0sIFs2LCBcIiZvdmJhcjtcIl0sIFsxLCBcIiZzb2xiYXI7XCJdLCBbNjAsIFwiJmFuZ3phcnI7XCJdLCBbNTEsIFwiJmxtb3VzdGFjaGU7XCJdLCBbMCwgXCImcm1vdXN0YWNoZTtcIl0sIFsyLCBcIiZPdmVyQnJhY2tldDtcIl0sIFswLCBcIiZiYnJrO1wiXSwgWzAsIFwiJmJicmt0YnJrO1wiXSwgWzM3LCBcIiZPdmVyUGFyZW50aGVzaXM7XCJdLCBbMCwgXCImVW5kZXJQYXJlbnRoZXNpcztcIl0sIFswLCBcIiZPdmVyQnJhY2U7XCJdLCBbMCwgXCImVW5kZXJCcmFjZTtcIl0sIFsyLCBcIiZ0cnBleml1bTtcIl0sIFs0LCBcIiZlbGludGVycztcIl0sIFs1OSwgXCImYmxhbms7XCJdLCBbMTY0LCBcIiZjaXJjbGVkUztcIl0sIFs1NSwgXCImYm94aDtcIl0sIFsxLCBcIiZib3h2O1wiXSwgWzksIFwiJmJveGRyO1wiXSwgWzMsIFwiJmJveGRsO1wiXSwgWzMsIFwiJmJveHVyO1wiXSwgWzMsIFwiJmJveHVsO1wiXSwgWzMsIFwiJmJveHZyO1wiXSwgWzcsIFwiJmJveHZsO1wiXSwgWzcsIFwiJmJveGhkO1wiXSwgWzcsIFwiJmJveGh1O1wiXSwgWzcsIFwiJmJveHZoO1wiXSwgWzE5LCBcIiZib3hIO1wiXSwgWzAsIFwiJmJveFY7XCJdLCBbMCwgXCImYm94ZFI7XCJdLCBbMCwgXCImYm94RHI7XCJdLCBbMCwgXCImYm94RFI7XCJdLCBbMCwgXCImYm94ZEw7XCJdLCBbMCwgXCImYm94RGw7XCJdLCBbMCwgXCImYm94REw7XCJdLCBbMCwgXCImYm94dVI7XCJdLCBbMCwgXCImYm94VXI7XCJdLCBbMCwgXCImYm94VVI7XCJdLCBbMCwgXCImYm94dUw7XCJdLCBbMCwgXCImYm94VWw7XCJdLCBbMCwgXCImYm94VUw7XCJdLCBbMCwgXCImYm94dlI7XCJdLCBbMCwgXCImYm94VnI7XCJdLCBbMCwgXCImYm94VlI7XCJdLCBbMCwgXCImYm94dkw7XCJdLCBbMCwgXCImYm94Vmw7XCJdLCBbMCwgXCImYm94Vkw7XCJdLCBbMCwgXCImYm94SGQ7XCJdLCBbMCwgXCImYm94aEQ7XCJdLCBbMCwgXCImYm94SEQ7XCJdLCBbMCwgXCImYm94SHU7XCJdLCBbMCwgXCImYm94aFU7XCJdLCBbMCwgXCImYm94SFU7XCJdLCBbMCwgXCImYm94dkg7XCJdLCBbMCwgXCImYm94Vmg7XCJdLCBbMCwgXCImYm94Vkg7XCJdLCBbMTksIFwiJnVoYmxrO1wiXSwgWzMsIFwiJmxoYmxrO1wiXSwgWzMsIFwiJmJsb2NrO1wiXSwgWzgsIFwiJmJsazE0O1wiXSwgWzAsIFwiJmJsazEyO1wiXSwgWzAsIFwiJmJsazM0O1wiXSwgWzEzLCBcIiZzcXVhcmU7XCJdLCBbOCwgXCImYmxhY2tzcXVhcmU7XCJdLCBbMCwgXCImRW1wdHlWZXJ5U21hbGxTcXVhcmU7XCJdLCBbMSwgXCImcmVjdDtcIl0sIFswLCBcIiZtYXJrZXI7XCJdLCBbMiwgXCImZmx0bnM7XCJdLCBbMSwgXCImYmlndHJpYW5nbGV1cDtcIl0sIFswLCBcIiZibGFja3RyaWFuZ2xlO1wiXSwgWzAsIFwiJnRyaWFuZ2xlO1wiXSwgWzIsIFwiJmJsYWNrdHJpYW5nbGVyaWdodDtcIl0sIFswLCBcIiZydHJpO1wiXSwgWzMsIFwiJmJpZ3RyaWFuZ2xlZG93bjtcIl0sIFswLCBcIiZibGFja3RyaWFuZ2xlZG93bjtcIl0sIFswLCBcIiZkdHJpO1wiXSwgWzIsIFwiJmJsYWNrdHJpYW5nbGVsZWZ0O1wiXSwgWzAsIFwiJmx0cmk7XCJdLCBbNiwgXCImbG96O1wiXSwgWzAsIFwiJmNpcjtcIl0sIFszMiwgXCImdHJpZG90O1wiXSwgWzIsIFwiJmJpZ2NpcmM7XCJdLCBbOCwgXCImdWx0cmk7XCJdLCBbMCwgXCImdXJ0cmk7XCJdLCBbMCwgXCImbGx0cmk7XCJdLCBbMCwgXCImRW1wdHlTbWFsbFNxdWFyZTtcIl0sIFswLCBcIiZGaWxsZWRTbWFsbFNxdWFyZTtcIl0sIFs4LCBcIiZiaWdzdGFyO1wiXSwgWzAsIFwiJnN0YXI7XCJdLCBbNywgXCImcGhvbmU7XCJdLCBbNDksIFwiJmZlbWFsZTtcIl0sIFsxLCBcIiZtYWxlO1wiXSwgWzI5LCBcIiZzcGFkZXM7XCJdLCBbMiwgXCImY2x1YnM7XCJdLCBbMSwgXCImaGVhcnRzO1wiXSwgWzAsIFwiJmRpYW1vbmRzdWl0O1wiXSwgWzMsIFwiJnN1bmc7XCJdLCBbMiwgXCImZmxhdDtcIl0sIFswLCBcIiZuYXR1cmFsO1wiXSwgWzAsIFwiJnNoYXJwO1wiXSwgWzE2MywgXCImY2hlY2s7XCJdLCBbMywgXCImY3Jvc3M7XCJdLCBbOCwgXCImbWFsdDtcIl0sIFsyMSwgXCImc2V4dDtcIl0sIFszMywgXCImVmVydGljYWxTZXBhcmF0b3I7XCJdLCBbMjUsIFwiJmxiYnJrO1wiXSwgWzAsIFwiJnJiYnJrO1wiXSwgWzg0LCBcIiZic29saHN1YjtcIl0sIFswLCBcIiZzdXBoc29sO1wiXSwgWzI4LCBcIiZMZWZ0RG91YmxlQnJhY2tldDtcIl0sIFswLCBcIiZSaWdodERvdWJsZUJyYWNrZXQ7XCJdLCBbMCwgXCImbGFuZztcIl0sIFswLCBcIiZyYW5nO1wiXSwgWzAsIFwiJkxhbmc7XCJdLCBbMCwgXCImUmFuZztcIl0sIFswLCBcIiZsb2FuZztcIl0sIFswLCBcIiZyb2FuZztcIl0sIFs3LCBcIiZsb25nbGVmdGFycm93O1wiXSwgWzAsIFwiJmxvbmdyaWdodGFycm93O1wiXSwgWzAsIFwiJmxvbmdsZWZ0cmlnaHRhcnJvdztcIl0sIFswLCBcIiZEb3VibGVMb25nTGVmdEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZUxvbmdSaWdodEFycm93O1wiXSwgWzAsIFwiJkRvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdztcIl0sIFsxLCBcIiZsb25nbWFwc3RvO1wiXSwgWzIsIFwiJmR6aWdyYXJyO1wiXSwgWzI1OCwgXCImbnZsQXJyO1wiXSwgWzAsIFwiJm52ckFycjtcIl0sIFswLCBcIiZudkhhcnI7XCJdLCBbMCwgXCImTWFwO1wiXSwgWzYsIFwiJmxiYXJyO1wiXSwgWzAsIFwiJmJrYXJvdztcIl0sIFswLCBcIiZsQmFycjtcIl0sIFswLCBcIiZkYmthcm93O1wiXSwgWzAsIFwiJmRyYmthcm93O1wiXSwgWzAsIFwiJkREb3RyYWhkO1wiXSwgWzAsIFwiJlVwQXJyb3dCYXI7XCJdLCBbMCwgXCImRG93bkFycm93QmFyO1wiXSwgWzIsIFwiJlJhcnJ0bDtcIl0sIFsyLCBcIiZsYXRhaWw7XCJdLCBbMCwgXCImcmF0YWlsO1wiXSwgWzAsIFwiJmxBdGFpbDtcIl0sIFswLCBcIiZyQXRhaWw7XCJdLCBbMCwgXCImbGFycmZzO1wiXSwgWzAsIFwiJnJhcnJmcztcIl0sIFswLCBcIiZsYXJyYmZzO1wiXSwgWzAsIFwiJnJhcnJiZnM7XCJdLCBbMiwgXCImbndhcmhrO1wiXSwgWzAsIFwiJm5lYXJoaztcIl0sIFswLCBcIiZoa3NlYXJvdztcIl0sIFswLCBcIiZoa3N3YXJvdztcIl0sIFswLCBcIiZud25lYXI7XCJdLCBbMCwgXCImbmVzZWFyO1wiXSwgWzAsIFwiJnNlc3dhcjtcIl0sIFswLCBcIiZzd253YXI7XCJdLCBbOCwgeyB2OiBcIiZyYXJyYztcIiwgbjogODI0LCBvOiBcIiZucmFycmM7XCIgfV0sIFsxLCBcIiZjdWRhcnJyO1wiXSwgWzAsIFwiJmxkY2E7XCJdLCBbMCwgXCImcmRjYTtcIl0sIFswLCBcIiZjdWRhcnJsO1wiXSwgWzAsIFwiJmxhcnJwbDtcIl0sIFsyLCBcIiZjdXJhcnJtO1wiXSwgWzAsIFwiJmN1bGFycnA7XCJdLCBbNywgXCImcmFycnBsO1wiXSwgWzIsIFwiJmhhcnJjaXI7XCJdLCBbMCwgXCImVWFycm9jaXI7XCJdLCBbMCwgXCImbHVyZHNoYXI7XCJdLCBbMCwgXCImbGRydXNoYXI7XCJdLCBbMiwgXCImTGVmdFJpZ2h0VmVjdG9yO1wiXSwgWzAsIFwiJlJpZ2h0VXBEb3duVmVjdG9yO1wiXSwgWzAsIFwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCJdLCBbMCwgXCImTGVmdFVwRG93blZlY3RvcjtcIl0sIFswLCBcIiZMZWZ0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJlJpZ2h0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJlJpZ2h0VXBWZWN0b3JCYXI7XCJdLCBbMCwgXCImUmlnaHREb3duVmVjdG9yQmFyO1wiXSwgWzAsIFwiJkRvd25MZWZ0VmVjdG9yQmFyO1wiXSwgWzAsIFwiJkRvd25SaWdodFZlY3RvckJhcjtcIl0sIFswLCBcIiZMZWZ0VXBWZWN0b3JCYXI7XCJdLCBbMCwgXCImTGVmdERvd25WZWN0b3JCYXI7XCJdLCBbMCwgXCImTGVmdFRlZVZlY3RvcjtcIl0sIFswLCBcIiZSaWdodFRlZVZlY3RvcjtcIl0sIFswLCBcIiZSaWdodFVwVGVlVmVjdG9yO1wiXSwgWzAsIFwiJlJpZ2h0RG93blRlZVZlY3RvcjtcIl0sIFswLCBcIiZEb3duTGVmdFRlZVZlY3RvcjtcIl0sIFswLCBcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCJdLCBbMCwgXCImTGVmdFVwVGVlVmVjdG9yO1wiXSwgWzAsIFwiJkxlZnREb3duVGVlVmVjdG9yO1wiXSwgWzAsIFwiJmxIYXI7XCJdLCBbMCwgXCImdUhhcjtcIl0sIFswLCBcIiZySGFyO1wiXSwgWzAsIFwiJmRIYXI7XCJdLCBbMCwgXCImbHVydWhhcjtcIl0sIFswLCBcIiZsZHJkaGFyO1wiXSwgWzAsIFwiJnJ1bHVoYXI7XCJdLCBbMCwgXCImcmRsZGhhcjtcIl0sIFswLCBcIiZsaGFydWw7XCJdLCBbMCwgXCImbGxoYXJkO1wiXSwgWzAsIFwiJnJoYXJ1bDtcIl0sIFswLCBcIiZscmhhcmQ7XCJdLCBbMCwgXCImdWRoYXI7XCJdLCBbMCwgXCImZHVoYXI7XCJdLCBbMCwgXCImUm91bmRJbXBsaWVzO1wiXSwgWzAsIFwiJmVyYXJyO1wiXSwgWzAsIFwiJnNpbXJhcnI7XCJdLCBbMCwgXCImbGFycnNpbTtcIl0sIFswLCBcIiZyYXJyc2ltO1wiXSwgWzAsIFwiJnJhcnJhcDtcIl0sIFswLCBcIiZsdGxhcnI7XCJdLCBbMSwgXCImZ3RyYXJyO1wiXSwgWzAsIFwiJnN1YnJhcnI7XCJdLCBbMSwgXCImc3VwbGFycjtcIl0sIFswLCBcIiZsZmlzaHQ7XCJdLCBbMCwgXCImcmZpc2h0O1wiXSwgWzAsIFwiJnVmaXNodDtcIl0sIFswLCBcIiZkZmlzaHQ7XCJdLCBbNSwgXCImbG9wYXI7XCJdLCBbMCwgXCImcm9wYXI7XCJdLCBbNCwgXCImbGJya2U7XCJdLCBbMCwgXCImcmJya2U7XCJdLCBbMCwgXCImbGJya3NsdTtcIl0sIFswLCBcIiZyYnJrc2xkO1wiXSwgWzAsIFwiJmxicmtzbGQ7XCJdLCBbMCwgXCImcmJya3NsdTtcIl0sIFswLCBcIiZsYW5nZDtcIl0sIFswLCBcIiZyYW5nZDtcIl0sIFswLCBcIiZscGFybHQ7XCJdLCBbMCwgXCImcnBhcmd0O1wiXSwgWzAsIFwiJmd0bFBhcjtcIl0sIFswLCBcIiZsdHJQYXI7XCJdLCBbMywgXCImdnppZ3phZztcIl0sIFsxLCBcIiZ2YW5ncnQ7XCJdLCBbMCwgXCImYW5ncnR2YmQ7XCJdLCBbNiwgXCImYW5nZTtcIl0sIFswLCBcIiZyYW5nZTtcIl0sIFswLCBcIiZkd2FuZ2xlO1wiXSwgWzAsIFwiJnV3YW5nbGU7XCJdLCBbMCwgXCImYW5nbXNkYWE7XCJdLCBbMCwgXCImYW5nbXNkYWI7XCJdLCBbMCwgXCImYW5nbXNkYWM7XCJdLCBbMCwgXCImYW5nbXNkYWQ7XCJdLCBbMCwgXCImYW5nbXNkYWU7XCJdLCBbMCwgXCImYW5nbXNkYWY7XCJdLCBbMCwgXCImYW5nbXNkYWc7XCJdLCBbMCwgXCImYW5nbXNkYWg7XCJdLCBbMCwgXCImYmVtcHR5djtcIl0sIFswLCBcIiZkZW1wdHl2O1wiXSwgWzAsIFwiJmNlbXB0eXY7XCJdLCBbMCwgXCImcmFlbXB0eXY7XCJdLCBbMCwgXCImbGFlbXB0eXY7XCJdLCBbMCwgXCImb2hiYXI7XCJdLCBbMCwgXCImb21pZDtcIl0sIFswLCBcIiZvcGFyO1wiXSwgWzEsIFwiJm9wZXJwO1wiXSwgWzEsIFwiJm9sY3Jvc3M7XCJdLCBbMCwgXCImb2Rzb2xkO1wiXSwgWzEsIFwiJm9sY2lyO1wiXSwgWzAsIFwiJm9mY2lyO1wiXSwgWzAsIFwiJm9sdDtcIl0sIFswLCBcIiZvZ3Q7XCJdLCBbMCwgXCImY2lyc2NpcjtcIl0sIFswLCBcIiZjaXJFO1wiXSwgWzAsIFwiJnNvbGI7XCJdLCBbMCwgXCImYnNvbGI7XCJdLCBbMywgXCImYm94Ym94O1wiXSwgWzMsIFwiJnRyaXNiO1wiXSwgWzAsIFwiJnJ0cmlsdHJpO1wiXSwgWzAsIHsgdjogXCImTGVmdFRyaWFuZ2xlQmFyO1wiLCBuOiA4MjQsIG86IFwiJk5vdExlZnRUcmlhbmdsZUJhcjtcIiB9XSwgWzAsIHsgdjogXCImUmlnaHRUcmlhbmdsZUJhcjtcIiwgbjogODI0LCBvOiBcIiZOb3RSaWdodFRyaWFuZ2xlQmFyO1wiIH1dLCBbMTEsIFwiJmlpbmZpbjtcIl0sIFswLCBcIiZpbmZpbnRpZTtcIl0sIFswLCBcIiZudmluZmluO1wiXSwgWzQsIFwiJmVwYXJzbDtcIl0sIFswLCBcIiZzbWVwYXJzbDtcIl0sIFswLCBcIiZlcXZwYXJzbDtcIl0sIFs1LCBcIiZibGFja2xvemVuZ2U7XCJdLCBbOCwgXCImUnVsZURlbGF5ZWQ7XCJdLCBbMSwgXCImZHNvbDtcIl0sIFs5LCBcIiZiaWdvZG90O1wiXSwgWzAsIFwiJmJpZ29wbHVzO1wiXSwgWzAsIFwiJmJpZ290aW1lcztcIl0sIFsxLCBcIiZiaWd1cGx1cztcIl0sIFsxLCBcIiZiaWdzcWN1cDtcIl0sIFs1LCBcIiZpaWlpbnQ7XCJdLCBbMCwgXCImZnBhcnRpbnQ7XCJdLCBbMiwgXCImY2lyZm5pbnQ7XCJdLCBbMCwgXCImYXdpbnQ7XCJdLCBbMCwgXCImcnBwb2xpbnQ7XCJdLCBbMCwgXCImc2Nwb2xpbnQ7XCJdLCBbMCwgXCImbnBvbGludDtcIl0sIFswLCBcIiZwb2ludGludDtcIl0sIFswLCBcIiZxdWF0aW50O1wiXSwgWzAsIFwiJmludGxhcmhrO1wiXSwgWzEwLCBcIiZwbHVzY2lyO1wiXSwgWzAsIFwiJnBsdXNhY2lyO1wiXSwgWzAsIFwiJnNpbXBsdXM7XCJdLCBbMCwgXCImcGx1c2R1O1wiXSwgWzAsIFwiJnBsdXNzaW07XCJdLCBbMCwgXCImcGx1c3R3bztcIl0sIFsxLCBcIiZtY29tbWE7XCJdLCBbMCwgXCImbWludXNkdTtcIl0sIFsyLCBcIiZsb3BsdXM7XCJdLCBbMCwgXCImcm9wbHVzO1wiXSwgWzAsIFwiJkNyb3NzO1wiXSwgWzAsIFwiJnRpbWVzZDtcIl0sIFswLCBcIiZ0aW1lc2JhcjtcIl0sIFsxLCBcIiZzbWFzaHA7XCJdLCBbMCwgXCImbG90aW1lcztcIl0sIFswLCBcIiZyb3RpbWVzO1wiXSwgWzAsIFwiJm90aW1lc2FzO1wiXSwgWzAsIFwiJk90aW1lcztcIl0sIFswLCBcIiZvZGl2O1wiXSwgWzAsIFwiJnRyaXBsdXM7XCJdLCBbMCwgXCImdHJpbWludXM7XCJdLCBbMCwgXCImdHJpdGltZTtcIl0sIFswLCBcIiZpbnRwcm9kO1wiXSwgWzIsIFwiJmFtYWxnO1wiXSwgWzAsIFwiJmNhcGRvdDtcIl0sIFsxLCBcIiZuY3VwO1wiXSwgWzAsIFwiJm5jYXA7XCJdLCBbMCwgXCImY2FwYW5kO1wiXSwgWzAsIFwiJmN1cG9yO1wiXSwgWzAsIFwiJmN1cGNhcDtcIl0sIFswLCBcIiZjYXBjdXA7XCJdLCBbMCwgXCImY3VwYnJjYXA7XCJdLCBbMCwgXCImY2FwYnJjdXA7XCJdLCBbMCwgXCImY3VwY3VwO1wiXSwgWzAsIFwiJmNhcGNhcDtcIl0sIFswLCBcIiZjY3VwcztcIl0sIFswLCBcIiZjY2FwcztcIl0sIFsyLCBcIiZjY3Vwc3NtO1wiXSwgWzIsIFwiJkFuZDtcIl0sIFswLCBcIiZPcjtcIl0sIFswLCBcIiZhbmRhbmQ7XCJdLCBbMCwgXCImb3JvcjtcIl0sIFswLCBcIiZvcnNsb3BlO1wiXSwgWzAsIFwiJmFuZHNsb3BlO1wiXSwgWzEsIFwiJmFuZHY7XCJdLCBbMCwgXCImb3J2O1wiXSwgWzAsIFwiJmFuZGQ7XCJdLCBbMCwgXCImb3JkO1wiXSwgWzEsIFwiJndlZGJhcjtcIl0sIFs2LCBcIiZzZG90ZTtcIl0sIFszLCBcIiZzaW1kb3Q7XCJdLCBbMiwgeyB2OiBcIiZjb25nZG90O1wiLCBuOiA4MjQsIG86IFwiJm5jb25nZG90O1wiIH1dLCBbMCwgXCImZWFzdGVyO1wiXSwgWzAsIFwiJmFwYWNpcjtcIl0sIFswLCB7IHY6IFwiJmFwRTtcIiwgbjogODI0LCBvOiBcIiZuYXBFO1wiIH1dLCBbMCwgXCImZXBsdXM7XCJdLCBbMCwgXCImcGx1c2U7XCJdLCBbMCwgXCImRXNpbTtcIl0sIFswLCBcIiZDb2xvbmU7XCJdLCBbMCwgXCImRXF1YWw7XCJdLCBbMSwgXCImZGRvdHNlcTtcIl0sIFswLCBcIiZlcXVpdkREO1wiXSwgWzAsIFwiJmx0Y2lyO1wiXSwgWzAsIFwiJmd0Y2lyO1wiXSwgWzAsIFwiJmx0cXVlc3Q7XCJdLCBbMCwgXCImZ3RxdWVzdDtcIl0sIFswLCB7IHY6IFwiJmxlcXNsYW50O1wiLCBuOiA4MjQsIG86IFwiJm5sZXFzbGFudDtcIiB9XSwgWzAsIHsgdjogXCImZ2Vxc2xhbnQ7XCIsIG46IDgyNCwgbzogXCImbmdlcXNsYW50O1wiIH1dLCBbMCwgXCImbGVzZG90O1wiXSwgWzAsIFwiJmdlc2RvdDtcIl0sIFswLCBcIiZsZXNkb3RvO1wiXSwgWzAsIFwiJmdlc2RvdG87XCJdLCBbMCwgXCImbGVzZG90b3I7XCJdLCBbMCwgXCImZ2VzZG90b2w7XCJdLCBbMCwgXCImbGFwO1wiXSwgWzAsIFwiJmdhcDtcIl0sIFswLCBcIiZsbmU7XCJdLCBbMCwgXCImZ25lO1wiXSwgWzAsIFwiJmxuYXA7XCJdLCBbMCwgXCImZ25hcDtcIl0sIFswLCBcIiZsRWc7XCJdLCBbMCwgXCImZ0VsO1wiXSwgWzAsIFwiJmxzaW1lO1wiXSwgWzAsIFwiJmdzaW1lO1wiXSwgWzAsIFwiJmxzaW1nO1wiXSwgWzAsIFwiJmdzaW1sO1wiXSwgWzAsIFwiJmxnRTtcIl0sIFswLCBcIiZnbEU7XCJdLCBbMCwgXCImbGVzZ2VzO1wiXSwgWzAsIFwiJmdlc2xlcztcIl0sIFswLCBcIiZlbHM7XCJdLCBbMCwgXCImZWdzO1wiXSwgWzAsIFwiJmVsc2RvdDtcIl0sIFswLCBcIiZlZ3Nkb3Q7XCJdLCBbMCwgXCImZWw7XCJdLCBbMCwgXCImZWc7XCJdLCBbMiwgXCImc2ltbDtcIl0sIFswLCBcIiZzaW1nO1wiXSwgWzAsIFwiJnNpbWxFO1wiXSwgWzAsIFwiJnNpbWdFO1wiXSwgWzAsIHsgdjogXCImTGVzc0xlc3M7XCIsIG46IDgyNCwgbzogXCImTm90TmVzdGVkTGVzc0xlc3M7XCIgfV0sIFswLCB7IHY6IFwiJkdyZWF0ZXJHcmVhdGVyO1wiLCBuOiA4MjQsIG86IFwiJk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiIH1dLCBbMSwgXCImZ2xqO1wiXSwgWzAsIFwiJmdsYTtcIl0sIFswLCBcIiZsdGNjO1wiXSwgWzAsIFwiJmd0Y2M7XCJdLCBbMCwgXCImbGVzY2M7XCJdLCBbMCwgXCImZ2VzY2M7XCJdLCBbMCwgXCImc210O1wiXSwgWzAsIFwiJmxhdDtcIl0sIFswLCB7IHY6IFwiJnNtdGU7XCIsIG46IDY1MDI0LCBvOiBcIiZzbXRlcztcIiB9XSwgWzAsIHsgdjogXCImbGF0ZTtcIiwgbjogNjUwMjQsIG86IFwiJmxhdGVzO1wiIH1dLCBbMCwgXCImYnVtcEU7XCJdLCBbMCwgeyB2OiBcIiZQcmVjZWRlc0VxdWFsO1wiLCBuOiA4MjQsIG86IFwiJk5vdFByZWNlZGVzRXF1YWw7XCIgfV0sIFswLCB7IHY6IFwiJnNjZTtcIiwgbjogODI0LCBvOiBcIiZOb3RTdWNjZWVkc0VxdWFsO1wiIH1dLCBbMiwgXCImcHJFO1wiXSwgWzAsIFwiJnNjRTtcIl0sIFswLCBcIiZwcmVjbmVxcTtcIl0sIFswLCBcIiZzY25FO1wiXSwgWzAsIFwiJnByYXA7XCJdLCBbMCwgXCImc2NhcDtcIl0sIFswLCBcIiZwcmVjbmFwcHJveDtcIl0sIFswLCBcIiZzY25hcDtcIl0sIFswLCBcIiZQcjtcIl0sIFswLCBcIiZTYztcIl0sIFswLCBcIiZzdWJkb3Q7XCJdLCBbMCwgXCImc3VwZG90O1wiXSwgWzAsIFwiJnN1YnBsdXM7XCJdLCBbMCwgXCImc3VwcGx1cztcIl0sIFswLCBcIiZzdWJtdWx0O1wiXSwgWzAsIFwiJnN1cG11bHQ7XCJdLCBbMCwgXCImc3ViZWRvdDtcIl0sIFswLCBcIiZzdXBlZG90O1wiXSwgWzAsIHsgdjogXCImc3ViRTtcIiwgbjogODI0LCBvOiBcIiZuc3ViRTtcIiB9XSwgWzAsIHsgdjogXCImc3VwRTtcIiwgbjogODI0LCBvOiBcIiZuc3VwRTtcIiB9XSwgWzAsIFwiJnN1YnNpbTtcIl0sIFswLCBcIiZzdXBzaW07XCJdLCBbMiwgeyB2OiBcIiZzdWJuRTtcIiwgbjogNjUwMjQsIG86IFwiJnZhcnN1YnNldG5lcXE7XCIgfV0sIFswLCB7IHY6IFwiJnN1cG5FO1wiLCBuOiA2NTAyNCwgbzogXCImdmFyc3Vwc2V0bmVxcTtcIiB9XSwgWzIsIFwiJmNzdWI7XCJdLCBbMCwgXCImY3N1cDtcIl0sIFswLCBcIiZjc3ViZTtcIl0sIFswLCBcIiZjc3VwZTtcIl0sIFswLCBcIiZzdWJzdXA7XCJdLCBbMCwgXCImc3Vwc3ViO1wiXSwgWzAsIFwiJnN1YnN1YjtcIl0sIFswLCBcIiZzdXBzdXA7XCJdLCBbMCwgXCImc3VwaHN1YjtcIl0sIFswLCBcIiZzdXBkc3ViO1wiXSwgWzAsIFwiJmZvcmt2O1wiXSwgWzAsIFwiJnRvcGZvcms7XCJdLCBbMCwgXCImbWxjcDtcIl0sIFs4LCBcIiZEYXNodjtcIl0sIFsxLCBcIiZWZGFzaGw7XCJdLCBbMCwgXCImQmFydjtcIl0sIFswLCBcIiZ2QmFyO1wiXSwgWzAsIFwiJnZCYXJ2O1wiXSwgWzEsIFwiJlZiYXI7XCJdLCBbMCwgXCImTm90O1wiXSwgWzAsIFwiJmJOb3Q7XCJdLCBbMCwgXCImcm5taWQ7XCJdLCBbMCwgXCImY2lybWlkO1wiXSwgWzAsIFwiJm1pZGNpcjtcIl0sIFswLCBcIiZ0b3BjaXI7XCJdLCBbMCwgXCImbmhwYXI7XCJdLCBbMCwgXCImcGFyc2ltO1wiXSwgWzksIHsgdjogXCImcGFyc2w7XCIsIG46IDg0MjEsIG86IFwiJm5wYXJzbDtcIiB9XSwgWzQ0MzQzLCB7IG46IG5ldyBNYXAoLyogI19fUFVSRV9fICovIHJlc3RvcmVEaWZmKFtbNTY0NzYsIFwiJkFzY3I7XCJdLCBbMSwgXCImQ3NjcjtcIl0sIFswLCBcIiZEc2NyO1wiXSwgWzIsIFwiJkdzY3I7XCJdLCBbMiwgXCImSnNjcjtcIl0sIFswLCBcIiZLc2NyO1wiXSwgWzIsIFwiJk5zY3I7XCJdLCBbMCwgXCImT3NjcjtcIl0sIFswLCBcIiZQc2NyO1wiXSwgWzAsIFwiJlFzY3I7XCJdLCBbMSwgXCImU3NjcjtcIl0sIFswLCBcIiZUc2NyO1wiXSwgWzAsIFwiJlVzY3I7XCJdLCBbMCwgXCImVnNjcjtcIl0sIFswLCBcIiZXc2NyO1wiXSwgWzAsIFwiJlhzY3I7XCJdLCBbMCwgXCImWXNjcjtcIl0sIFswLCBcIiZac2NyO1wiXSwgWzAsIFwiJmFzY3I7XCJdLCBbMCwgXCImYnNjcjtcIl0sIFswLCBcIiZjc2NyO1wiXSwgWzAsIFwiJmRzY3I7XCJdLCBbMSwgXCImZnNjcjtcIl0sIFsxLCBcIiZoc2NyO1wiXSwgWzAsIFwiJmlzY3I7XCJdLCBbMCwgXCImanNjcjtcIl0sIFswLCBcIiZrc2NyO1wiXSwgWzAsIFwiJmxzY3I7XCJdLCBbMCwgXCImbXNjcjtcIl0sIFswLCBcIiZuc2NyO1wiXSwgWzEsIFwiJnBzY3I7XCJdLCBbMCwgXCImcXNjcjtcIl0sIFswLCBcIiZyc2NyO1wiXSwgWzAsIFwiJnNzY3I7XCJdLCBbMCwgXCImdHNjcjtcIl0sIFswLCBcIiZ1c2NyO1wiXSwgWzAsIFwiJnZzY3I7XCJdLCBbMCwgXCImd3NjcjtcIl0sIFswLCBcIiZ4c2NyO1wiXSwgWzAsIFwiJnlzY3I7XCJdLCBbMCwgXCImenNjcjtcIl0sIFs1MiwgXCImQWZyO1wiXSwgWzAsIFwiJkJmcjtcIl0sIFsxLCBcIiZEZnI7XCJdLCBbMCwgXCImRWZyO1wiXSwgWzAsIFwiJkZmcjtcIl0sIFswLCBcIiZHZnI7XCJdLCBbMiwgXCImSmZyO1wiXSwgWzAsIFwiJktmcjtcIl0sIFswLCBcIiZMZnI7XCJdLCBbMCwgXCImTWZyO1wiXSwgWzAsIFwiJk5mcjtcIl0sIFswLCBcIiZPZnI7XCJdLCBbMCwgXCImUGZyO1wiXSwgWzAsIFwiJlFmcjtcIl0sIFsxLCBcIiZTZnI7XCJdLCBbMCwgXCImVGZyO1wiXSwgWzAsIFwiJlVmcjtcIl0sIFswLCBcIiZWZnI7XCJdLCBbMCwgXCImV2ZyO1wiXSwgWzAsIFwiJlhmcjtcIl0sIFswLCBcIiZZZnI7XCJdLCBbMSwgXCImYWZyO1wiXSwgWzAsIFwiJmJmcjtcIl0sIFswLCBcIiZjZnI7XCJdLCBbMCwgXCImZGZyO1wiXSwgWzAsIFwiJmVmcjtcIl0sIFswLCBcIiZmZnI7XCJdLCBbMCwgXCImZ2ZyO1wiXSwgWzAsIFwiJmhmcjtcIl0sIFswLCBcIiZpZnI7XCJdLCBbMCwgXCImamZyO1wiXSwgWzAsIFwiJmtmcjtcIl0sIFswLCBcIiZsZnI7XCJdLCBbMCwgXCImbWZyO1wiXSwgWzAsIFwiJm5mcjtcIl0sIFswLCBcIiZvZnI7XCJdLCBbMCwgXCImcGZyO1wiXSwgWzAsIFwiJnFmcjtcIl0sIFswLCBcIiZyZnI7XCJdLCBbMCwgXCImc2ZyO1wiXSwgWzAsIFwiJnRmcjtcIl0sIFswLCBcIiZ1ZnI7XCJdLCBbMCwgXCImdmZyO1wiXSwgWzAsIFwiJndmcjtcIl0sIFswLCBcIiZ4ZnI7XCJdLCBbMCwgXCImeWZyO1wiXSwgWzAsIFwiJnpmcjtcIl0sIFswLCBcIiZBb3BmO1wiXSwgWzAsIFwiJkJvcGY7XCJdLCBbMSwgXCImRG9wZjtcIl0sIFswLCBcIiZFb3BmO1wiXSwgWzAsIFwiJkZvcGY7XCJdLCBbMCwgXCImR29wZjtcIl0sIFsxLCBcIiZJb3BmO1wiXSwgWzAsIFwiJkpvcGY7XCJdLCBbMCwgXCImS29wZjtcIl0sIFswLCBcIiZMb3BmO1wiXSwgWzAsIFwiJk1vcGY7XCJdLCBbMSwgXCImT29wZjtcIl0sIFszLCBcIiZTb3BmO1wiXSwgWzAsIFwiJlRvcGY7XCJdLCBbMCwgXCImVW9wZjtcIl0sIFswLCBcIiZWb3BmO1wiXSwgWzAsIFwiJldvcGY7XCJdLCBbMCwgXCImWG9wZjtcIl0sIFswLCBcIiZZb3BmO1wiXSwgWzEsIFwiJmFvcGY7XCJdLCBbMCwgXCImYm9wZjtcIl0sIFswLCBcIiZjb3BmO1wiXSwgWzAsIFwiJmRvcGY7XCJdLCBbMCwgXCImZW9wZjtcIl0sIFswLCBcIiZmb3BmO1wiXSwgWzAsIFwiJmdvcGY7XCJdLCBbMCwgXCImaG9wZjtcIl0sIFswLCBcIiZpb3BmO1wiXSwgWzAsIFwiJmpvcGY7XCJdLCBbMCwgXCIma29wZjtcIl0sIFswLCBcIiZsb3BmO1wiXSwgWzAsIFwiJm1vcGY7XCJdLCBbMCwgXCImbm9wZjtcIl0sIFswLCBcIiZvb3BmO1wiXSwgWzAsIFwiJnBvcGY7XCJdLCBbMCwgXCImcW9wZjtcIl0sIFswLCBcIiZyb3BmO1wiXSwgWzAsIFwiJnNvcGY7XCJdLCBbMCwgXCImdG9wZjtcIl0sIFswLCBcIiZ1b3BmO1wiXSwgWzAsIFwiJnZvcGY7XCJdLCBbMCwgXCImd29wZjtcIl0sIFswLCBcIiZ4b3BmO1wiXSwgWzAsIFwiJnlvcGY7XCJdLCBbMCwgXCImem9wZjtcIl1dKSkgfV0sIFs4OTA2LCBcIiZmZmxpZztcIl0sIFswLCBcIiZmaWxpZztcIl0sIFswLCBcIiZmbGxpZztcIl0sIFswLCBcIiZmZmlsaWc7XCJdLCBbMCwgXCImZmZsbGlnO1wiXV0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kZS1odG1sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/generated/encode-html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/entities/lib/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/entities/lib/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DecodingMode: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode; },\n/* harmony export */   EncodingMode: function() { return /* binding */ EncodingMode; },\n/* harmony export */   EntityDecoder: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.EntityDecoder; },\n/* harmony export */   EntityLevel: function() { return /* binding */ EntityLevel; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   decodeHTML: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },\n/* harmony export */   decodeHTML4: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },\n/* harmony export */   decodeHTML4Strict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },\n/* harmony export */   decodeHTML5: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML; },\n/* harmony export */   decodeHTML5Strict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },\n/* harmony export */   decodeHTMLAttribute: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLAttribute; },\n/* harmony export */   decodeHTMLStrict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTMLStrict; },\n/* harmony export */   decodeStrict: function() { return /* binding */ decodeStrict; },\n/* harmony export */   decodeXML: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML; },\n/* harmony export */   decodeXMLStrict: function() { return /* reexport safe */ _decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML; },\n/* harmony export */   encode: function() { return /* binding */ encode; },\n/* harmony export */   encodeHTML: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },\n/* harmony export */   encodeHTML4: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },\n/* harmony export */   encodeHTML5: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML; },\n/* harmony export */   encodeNonAsciiHTML: function() { return /* reexport safe */ _encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeNonAsciiHTML; },\n/* harmony export */   encodeXML: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.encodeXML; },\n/* harmony export */   escape: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escape; },\n/* harmony export */   escapeAttribute: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeAttribute; },\n/* harmony export */   escapeText: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeText; },\n/* harmony export */   escapeUTF8: function() { return /* reexport safe */ _escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeUTF8; }\n/* harmony export */ });\n/* harmony import */ var _decode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decode.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/decode.js\");\n/* harmony import */ var _encode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./encode.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/encode.js\");\n/* harmony import */ var _escape_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./escape.js */ \"(app-pages-browser)/./node_modules/entities/lib/esm/escape.js\");\n\n\n\n/** The level of entities to support. */\nvar EntityLevel;\n(function (EntityLevel) {\n    /** Support only XML entities. */\n    EntityLevel[EntityLevel[\"XML\"] = 0] = \"XML\";\n    /** Support HTML entities, which are a superset of XML entities. */\n    EntityLevel[EntityLevel[\"HTML\"] = 1] = \"HTML\";\n})(EntityLevel || (EntityLevel = {}));\nvar EncodingMode;\n(function (EncodingMode) {\n    /**\n     * The output is UTF-8 encoded. Only characters that need escaping within\n     * XML will be escaped.\n     */\n    EncodingMode[EncodingMode[\"UTF8\"] = 0] = \"UTF8\";\n    /**\n     * The output consists only of ASCII characters. Characters that need\n     * escaping within HTML, and characters that aren't ASCII characters will\n     * be escaped.\n     */\n    EncodingMode[EncodingMode[\"ASCII\"] = 1] = \"ASCII\";\n    /**\n     * Encode all characters that have an equivalent entity, as well as all\n     * characters that are not ASCII characters.\n     */\n    EncodingMode[EncodingMode[\"Extensive\"] = 2] = \"Extensive\";\n    /**\n     * Encode all characters that have to be escaped in HTML attributes,\n     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n     */\n    EncodingMode[EncodingMode[\"Attribute\"] = 3] = \"Attribute\";\n    /**\n     * Encode all characters that have to be escaped in HTML text,\n     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n     */\n    EncodingMode[EncodingMode[\"Text\"] = 4] = \"Text\";\n})(EncodingMode || (EncodingMode = {}));\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param options Decoding options.\n */\nfunction decode(data, options = EntityLevel.XML) {\n    const level = typeof options === \"number\" ? options : options.level;\n    if (level === EntityLevel.HTML) {\n        const mode = typeof options === \"object\" ? options.mode : undefined;\n        return (0,_decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeHTML)(data, mode);\n    }\n    return (0,_decode_js__WEBPACK_IMPORTED_MODULE_0__.decodeXML)(data);\n}\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param options Decoding options.\n * @deprecated Use `decode` with the `mode` set to `Strict`.\n */\nfunction decodeStrict(data, options = EntityLevel.XML) {\n    var _a;\n    const opts = typeof options === \"number\" ? { level: options } : options;\n    (_a = opts.mode) !== null && _a !== void 0 ? _a : (opts.mode = _decode_js__WEBPACK_IMPORTED_MODULE_0__.DecodingMode.Strict);\n    return decode(data, opts);\n}\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param options Encoding options.\n */\nfunction encode(data, options = EntityLevel.XML) {\n    const opts = typeof options === \"number\" ? { level: options } : options;\n    // Mode `UTF8` just escapes XML entities\n    if (opts.mode === EncodingMode.UTF8)\n        return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeUTF8)(data);\n    if (opts.mode === EncodingMode.Attribute)\n        return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeAttribute)(data);\n    if (opts.mode === EncodingMode.Text)\n        return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.escapeText)(data);\n    if (opts.level === EntityLevel.HTML) {\n        if (opts.mode === EncodingMode.ASCII) {\n            return (0,_encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeNonAsciiHTML)(data);\n        }\n        return (0,_encode_js__WEBPACK_IMPORTED_MODULE_1__.encodeHTML)(data);\n    }\n    // ASCII and Extensive are equivalent\n    return (0,_escape_js__WEBPACK_IMPORTED_MODULE_2__.encodeXML)(data);\n}\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0U7QUFDTDtBQUNxQjtBQUNsRjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQzVCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUVBQXlFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFVO0FBQ3pCO0FBQ0EsV0FBVyxxREFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEUsbUVBQW1FLG9EQUFZO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBLGVBQWUsc0RBQVU7QUFDekI7QUFDQSxlQUFlLDJEQUFlO0FBQzlCO0FBQ0EsZUFBZSxzREFBVTtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFrQjtBQUNyQztBQUNBLGVBQWUsc0RBQVU7QUFDekI7QUFDQTtBQUNBLFdBQVcscURBQVM7QUFDcEI7QUFDMEY7QUFHZjtBQUc0RztBQUN2TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZW50aXRpZXMvbGliL2VzbS9pbmRleC5qcz8xZDU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZVhNTCwgZGVjb2RlSFRNTCwgRGVjb2RpbmdNb2RlIH0gZnJvbSBcIi4vZGVjb2RlLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVIVE1MLCBlbmNvZGVOb25Bc2NpaUhUTUwgfSBmcm9tIFwiLi9lbmNvZGUuanNcIjtcbmltcG9ydCB7IGVuY29kZVhNTCwgZXNjYXBlVVRGOCwgZXNjYXBlQXR0cmlidXRlLCBlc2NhcGVUZXh0LCB9IGZyb20gXCIuL2VzY2FwZS5qc1wiO1xuLyoqIFRoZSBsZXZlbCBvZiBlbnRpdGllcyB0byBzdXBwb3J0LiAqL1xuZXhwb3J0IHZhciBFbnRpdHlMZXZlbDtcbihmdW5jdGlvbiAoRW50aXR5TGV2ZWwpIHtcbiAgICAvKiogU3VwcG9ydCBvbmx5IFhNTCBlbnRpdGllcy4gKi9cbiAgICBFbnRpdHlMZXZlbFtFbnRpdHlMZXZlbFtcIlhNTFwiXSA9IDBdID0gXCJYTUxcIjtcbiAgICAvKiogU3VwcG9ydCBIVE1MIGVudGl0aWVzLCB3aGljaCBhcmUgYSBzdXBlcnNldCBvZiBYTUwgZW50aXRpZXMuICovXG4gICAgRW50aXR5TGV2ZWxbRW50aXR5TGV2ZWxbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbn0pKEVudGl0eUxldmVsIHx8IChFbnRpdHlMZXZlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEVuY29kaW5nTW9kZTtcbihmdW5jdGlvbiAoRW5jb2RpbmdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBpcyBVVEYtOCBlbmNvZGVkLiBPbmx5IGNoYXJhY3RlcnMgdGhhdCBuZWVkIGVzY2FwaW5nIHdpdGhpblxuICAgICAqIFhNTCB3aWxsIGJlIGVzY2FwZWQuXG4gICAgICovXG4gICAgRW5jb2RpbmdNb2RlW0VuY29kaW5nTW9kZVtcIlVURjhcIl0gPSAwXSA9IFwiVVRGOFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgY29uc2lzdHMgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzLiBDaGFyYWN0ZXJzIHRoYXQgbmVlZFxuICAgICAqIGVzY2FwaW5nIHdpdGhpbiBIVE1MLCBhbmQgY2hhcmFjdGVycyB0aGF0IGFyZW4ndCBBU0NJSSBjaGFyYWN0ZXJzIHdpbGxcbiAgICAgKiBiZSBlc2NhcGVkLlxuICAgICAqL1xuICAgIEVuY29kaW5nTW9kZVtFbmNvZGluZ01vZGVbXCJBU0NJSVwiXSA9IDFdID0gXCJBU0NJSVwiO1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgYW4gZXF1aXZhbGVudCBlbnRpdHksIGFzIHdlbGwgYXMgYWxsXG4gICAgICogY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgQVNDSUkgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBFbmNvZGluZ01vZGVbRW5jb2RpbmdNb2RlW1wiRXh0ZW5zaXZlXCJdID0gMl0gPSBcIkV4dGVuc2l2ZVwiO1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBhbGwgY2hhcmFjdGVycyB0aGF0IGhhdmUgdG8gYmUgZXNjYXBlZCBpbiBIVE1MIGF0dHJpYnV0ZXMsXG4gICAgICogZm9sbG93aW5nIHtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9wYXJzaW5nLmh0bWwjZXNjYXBpbmdTdHJpbmd9LlxuICAgICAqL1xuICAgIEVuY29kaW5nTW9kZVtFbmNvZGluZ01vZGVbXCJBdHRyaWJ1dGVcIl0gPSAzXSA9IFwiQXR0cmlidXRlXCI7XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSB0byBiZSBlc2NhcGVkIGluIEhUTUwgdGV4dCxcbiAgICAgKiBmb2xsb3dpbmcge0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3BhcnNpbmcuaHRtbCNlc2NhcGluZ1N0cmluZ30uXG4gICAgICovXG4gICAgRW5jb2RpbmdNb2RlW0VuY29kaW5nTW9kZVtcIlRleHRcIl0gPSA0XSA9IFwiVGV4dFwiO1xufSkoRW5jb2RpbmdNb2RlIHx8IChFbmNvZGluZ01vZGUgPSB7fSkpO1xuLyoqXG4gKiBEZWNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIERlY29kaW5nIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoZGF0YSwgb3B0aW9ucyA9IEVudGl0eUxldmVsLlhNTCkge1xuICAgIGNvbnN0IGxldmVsID0gdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgPyBvcHRpb25zIDogb3B0aW9ucy5sZXZlbDtcbiAgICBpZiAobGV2ZWwgPT09IEVudGl0eUxldmVsLkhUTUwpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5tb2RlIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGVjb2RlSFRNTChkYXRhLCBtb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVhNTChkYXRhKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLiBEb2VzIG5vdCBhbGxvdyBtaXNzaW5nIHRyYWlsaW5nIHNlbWljb2xvbnMgZm9yIGVudGl0aWVzLlxuICpcbiAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyBEZWNvZGluZyBvcHRpb25zLlxuICogQGRlcHJlY2F0ZWQgVXNlIGBkZWNvZGVgIHdpdGggdGhlIGBtb2RlYCBzZXQgdG8gYFN0cmljdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpY3QoZGF0YSwgb3B0aW9ucyA9IEVudGl0eUxldmVsLlhNTCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvcHRzID0gdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgPyB7IGxldmVsOiBvcHRpb25zIH0gOiBvcHRpb25zO1xuICAgIChfYSA9IG9wdHMubW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKG9wdHMubW9kZSA9IERlY29kaW5nTW9kZS5TdHJpY3QpO1xuICAgIHJldHVybiBkZWNvZGUoZGF0YSwgb3B0cyk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgRW5jb2Rpbmcgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBvcHRpb25zID0gRW50aXR5TGV2ZWwuWE1MKSB7XG4gICAgY29uc3Qgb3B0cyA9IHR5cGVvZiBvcHRpb25zID09PSBcIm51bWJlclwiID8geyBsZXZlbDogb3B0aW9ucyB9IDogb3B0aW9ucztcbiAgICAvLyBNb2RlIGBVVEY4YCBqdXN0IGVzY2FwZXMgWE1MIGVudGl0aWVzXG4gICAgaWYgKG9wdHMubW9kZSA9PT0gRW5jb2RpbmdNb2RlLlVURjgpXG4gICAgICAgIHJldHVybiBlc2NhcGVVVEY4KGRhdGEpO1xuICAgIGlmIChvcHRzLm1vZGUgPT09IEVuY29kaW5nTW9kZS5BdHRyaWJ1dGUpXG4gICAgICAgIHJldHVybiBlc2NhcGVBdHRyaWJ1dGUoZGF0YSk7XG4gICAgaWYgKG9wdHMubW9kZSA9PT0gRW5jb2RpbmdNb2RlLlRleHQpXG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0KGRhdGEpO1xuICAgIGlmIChvcHRzLmxldmVsID09PSBFbnRpdHlMZXZlbC5IVE1MKSB7XG4gICAgICAgIGlmIChvcHRzLm1vZGUgPT09IEVuY29kaW5nTW9kZS5BU0NJSSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZU5vbkFzY2lpSFRNTChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlSFRNTChkYXRhKTtcbiAgICB9XG4gICAgLy8gQVNDSUkgYW5kIEV4dGVuc2l2ZSBhcmUgZXF1aXZhbGVudFxuICAgIHJldHVybiBlbmNvZGVYTUwoZGF0YSk7XG59XG5leHBvcnQgeyBlbmNvZGVYTUwsIGVzY2FwZSwgZXNjYXBlVVRGOCwgZXNjYXBlQXR0cmlidXRlLCBlc2NhcGVUZXh0LCB9IGZyb20gXCIuL2VzY2FwZS5qc1wiO1xuZXhwb3J0IHsgZW5jb2RlSFRNTCwgZW5jb2RlTm9uQXNjaWlIVE1MLCBcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuZW5jb2RlSFRNTCBhcyBlbmNvZGVIVE1MNCwgZW5jb2RlSFRNTCBhcyBlbmNvZGVIVE1MNSwgfSBmcm9tIFwiLi9lbmNvZGUuanNcIjtcbmV4cG9ydCB7IEVudGl0eURlY29kZXIsIERlY29kaW5nTW9kZSwgZGVjb2RlWE1MLCBkZWNvZGVIVE1MLCBkZWNvZGVIVE1MU3RyaWN0LCBkZWNvZGVIVE1MQXR0cmlidXRlLCBcbi8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuZGVjb2RlSFRNTCBhcyBkZWNvZGVIVE1MNCwgZGVjb2RlSFRNTCBhcyBkZWNvZGVIVE1MNSwgZGVjb2RlSFRNTFN0cmljdCBhcyBkZWNvZGVIVE1MNFN0cmljdCwgZGVjb2RlSFRNTFN0cmljdCBhcyBkZWNvZGVIVE1MNVN0cmljdCwgZGVjb2RlWE1MIGFzIGRlY29kZVhNTFN0cmljdCwgfSBmcm9tIFwiLi9kZWNvZGUuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/entities/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/linkify-it/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/linkify-it/index.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_re_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/re.mjs */ \"(app-pages-browser)/./node_modules/linkify-it/lib/re.mjs\");\n\n\n//\n// Helpers\n//\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\nfunction isString (obj) { return _class(obj) === '[object String]' }\nfunction isObject (obj) { return _class(obj) === '[object Object]' }\nfunction isRegExp (obj) { return _class(obj) === '[object RegExp]' }\nfunction isFunction (obj) { return _class(obj) === '[object Function]' }\n\nfunction escapeRE (str) { return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&') }\n\n//\n\nconst defaultOptions = {\n  fuzzyLink: true,\n  fuzzyEmail: true,\n  fuzzyIP: false\n}\n\nfunction isOptionsObj (obj) {\n  return Object.keys(obj || {}).reduce(function (acc, k) {\n    /* eslint-disable-next-line no-prototype-builtins */\n    return acc || defaultOptions.hasOwnProperty(k)\n  }, false)\n}\n\nconst defaultSchemas = {\n  'http:': {\n    validate: function (text, pos, self) {\n      const tail = text.slice(pos)\n\n      if (!self.re.http) {\n        // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.http = new RegExp(\n          '^\\\\/\\\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'\n        )\n      }\n      if (self.re.http.test(tail)) {\n        return tail.match(self.re.http)[0].length\n      }\n      return 0\n    }\n  },\n  'https:': 'http:',\n  'ftp:': 'http:',\n  '//': {\n    validate: function (text, pos, self) {\n      const tail = text.slice(pos)\n\n      if (!self.re.no_http) {\n      // compile lazily, because \"host\"-containing variables can change on tlds update.\n        self.re.no_http = new RegExp(\n          '^' +\n          self.re.src_auth +\n          // Don't allow single-level domains, because of false positives like '//test'\n          // with code comments\n          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\\\.)+' + self.re.src_domain_root + ')' +\n          self.re.src_port +\n          self.re.src_host_terminator +\n          self.re.src_path,\n\n          'i'\n        )\n      }\n\n      if (self.re.no_http.test(tail)) {\n        // should not be `://` & `///`, that protects from errors in protocol name\n        if (pos >= 3 && text[pos - 3] === ':') { return 0 }\n        if (pos >= 3 && text[pos - 3] === '/') { return 0 }\n        return tail.match(self.re.no_http)[0].length\n      }\n      return 0\n    }\n  },\n  'mailto:': {\n    validate: function (text, pos, self) {\n      const tail = text.slice(pos)\n\n      if (!self.re.mailto) {\n        self.re.mailto = new RegExp(\n          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'\n        )\n      }\n      if (self.re.mailto.test(tail)) {\n        return tail.match(self.re.mailto)[0].length\n      }\n      return 0\n    }\n  }\n}\n\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\n/* eslint-disable-next-line max-len */\nconst tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]'\n\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nconst tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|'.split('|')\n\nfunction resetScanCache (self) {\n  self.__index__ = -1\n  self.__text_cache__ = ''\n}\n\nfunction createValidator (re) {\n  return function (text, pos) {\n    const tail = text.slice(pos)\n\n    if (re.test(tail)) {\n      return tail.match(re)[0].length\n    }\n    return 0\n  }\n}\n\nfunction createNormalizer () {\n  return function (match, self) {\n    self.normalize(match)\n  }\n}\n\n// Schemas compiler. Build regexps.\n//\nfunction compile (self) {\n  // Load & clone RE patterns.\n  const re = self.re = (0,_lib_re_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(self.__opts__)\n\n  // Define dynamic patterns\n  const tlds = self.__tlds__.slice()\n\n  self.onCompile()\n\n  if (!self.__tlds_replaced__) {\n    tlds.push(tlds_2ch_src_re)\n  }\n  tlds.push(re.src_xn)\n\n  re.src_tlds = tlds.join('|')\n\n  function untpl (tpl) { return tpl.replace('%TLDS%', re.src_tlds) }\n\n  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i')\n  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i')\n  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i')\n  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i')\n\n  //\n  // Compile each schema\n  //\n\n  const aliases = []\n\n  self.__compiled__ = {} // Reset compiled data\n\n  function schemaError (name, val) {\n    throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val)\n  }\n\n  Object.keys(self.__schemas__).forEach(function (name) {\n    const val = self.__schemas__[name]\n\n    // skip disabled methods\n    if (val === null) { return }\n\n    const compiled = { validate: null, link: null }\n\n    self.__compiled__[name] = compiled\n\n    if (isObject(val)) {\n      if (isRegExp(val.validate)) {\n        compiled.validate = createValidator(val.validate)\n      } else if (isFunction(val.validate)) {\n        compiled.validate = val.validate\n      } else {\n        schemaError(name, val)\n      }\n\n      if (isFunction(val.normalize)) {\n        compiled.normalize = val.normalize\n      } else if (!val.normalize) {\n        compiled.normalize = createNormalizer()\n      } else {\n        schemaError(name, val)\n      }\n\n      return\n    }\n\n    if (isString(val)) {\n      aliases.push(name)\n      return\n    }\n\n    schemaError(name, val)\n  })\n\n  //\n  // Compile postponed aliases\n  //\n\n  aliases.forEach(function (alias) {\n    if (!self.__compiled__[self.__schemas__[alias]]) {\n      // Silently fail on missed schemas to avoid errons on disable.\n      // schemaError(alias, self.__schemas__[alias]);\n      return\n    }\n\n    self.__compiled__[alias].validate =\n      self.__compiled__[self.__schemas__[alias]].validate\n    self.__compiled__[alias].normalize =\n      self.__compiled__[self.__schemas__[alias]].normalize\n  })\n\n  //\n  // Fake record for guessed links\n  //\n  self.__compiled__[''] = { validate: null, normalize: createNormalizer() }\n\n  //\n  // Build schema condition\n  //\n  const slist = Object.keys(self.__compiled__)\n    .filter(function (name) {\n      // Filter disabled & fake schemas\n      return name.length > 0 && self.__compiled__[name]\n    })\n    .map(escapeRE)\n    .join('|')\n  // (?!_) cause 1.5x slowdown\n  self.re.schema_test = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i')\n  self.re.schema_search = RegExp('(^|(?!_)(?:[><\\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig')\n  self.re.schema_at_start = RegExp('^' + self.re.schema_search.source, 'i')\n\n  self.re.pretest = RegExp(\n    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',\n    'i'\n  )\n\n  //\n  // Cleanup\n  //\n\n  resetScanCache(self)\n}\n\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/\nfunction Match (self, shift) {\n  const start = self.__index__\n  const end = self.__last_index__\n  const text = self.__text_cache__.slice(start, end)\n\n  /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/\n  this.schema = self.__schema__.toLowerCase()\n  /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/\n  this.index = start + shift\n  /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/\n  this.lastIndex = end + shift\n  /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/\n  this.raw = text\n  /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/\n  this.text = text\n  /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/\n  this.url = text\n}\n\nfunction createMatch (self, shift) {\n  const match = new Match(self, shift)\n\n  self.__compiled__[match.schema].normalize(match, self)\n\n  return match\n}\n\n/**\n * class LinkifyIt\n **/\n\n/**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/\nfunction LinkifyIt (schemas, options) {\n  if (!(this instanceof LinkifyIt)) {\n    return new LinkifyIt(schemas, options)\n  }\n\n  if (!options) {\n    if (isOptionsObj(schemas)) {\n      options = schemas\n      schemas = {}\n    }\n  }\n\n  this.__opts__ = assign({}, defaultOptions, options)\n\n  // Cache last tested result. Used to skip repeating steps on next `match` call.\n  this.__index__ = -1\n  this.__last_index__ = -1 // Next scan position\n  this.__schema__ = ''\n  this.__text_cache__ = ''\n\n  this.__schemas__ = assign({}, defaultSchemas, schemas)\n  this.__compiled__ = {}\n\n  this.__tlds__ = tlds_default\n  this.__tlds_replaced__ = false\n\n  this.re = {}\n\n  compile(this)\n}\n\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/\nLinkifyIt.prototype.add = function add (schema, definition) {\n  this.__schemas__[schema] = definition\n  compile(this)\n  return this\n}\n\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/\nLinkifyIt.prototype.set = function set (options) {\n  this.__opts__ = assign(this.__opts__, options)\n  return this\n}\n\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/\nLinkifyIt.prototype.test = function test (text) {\n  // Reset scan cache\n  this.__text_cache__ = text\n  this.__index__ = -1\n\n  if (!text.length) { return false }\n\n  let m, ml, me, len, shift, next, re, tld_pos, at_pos\n\n  // try to scan for link with schema - that's the most simple rule\n  if (this.re.schema_test.test(text)) {\n    re = this.re.schema_search\n    re.lastIndex = 0\n    while ((m = re.exec(text)) !== null) {\n      len = this.testSchemaAt(text, m[2], re.lastIndex)\n      if (len) {\n        this.__schema__ = m[2]\n        this.__index__ = m.index + m[1].length\n        this.__last_index__ = m.index + m[0].length + len\n        break\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {\n    // guess schemaless links\n    tld_pos = text.search(this.re.host_fuzzy_test)\n    if (tld_pos >= 0) {\n      // if tld is located after found link - no need to check fuzzy pattern\n      if (this.__index__ < 0 || tld_pos < this.__index__) {\n        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n          shift = ml.index + ml[1].length\n\n          if (this.__index__ < 0 || shift < this.__index__) {\n            this.__schema__ = ''\n            this.__index__ = shift\n            this.__last_index__ = ml.index + ml[0].length\n          }\n        }\n      }\n    }\n  }\n\n  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {\n    // guess schemaless emails\n    at_pos = text.indexOf('@')\n    if (at_pos >= 0) {\n      // We can't skip this check, because this cases are possible:\n      // 192.168.1.1@gmail.com, my.in@example.com\n      if ((me = text.match(this.re.email_fuzzy)) !== null) {\n        shift = me.index + me[1].length\n        next = me.index + me[0].length\n\n        if (this.__index__ < 0 || shift < this.__index__ ||\n            (shift === this.__index__ && next > this.__last_index__)) {\n          this.__schema__ = 'mailto:'\n          this.__index__ = shift\n          this.__last_index__ = next\n        }\n      }\n    }\n  }\n\n  return this.__index__ >= 0\n}\n\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/\nLinkifyIt.prototype.pretest = function pretest (text) {\n  return this.re.pretest.test(text)\n}\n\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/\nLinkifyIt.prototype.testSchemaAt = function testSchemaAt (text, schema, pos) {\n  // If not supported schema check requested - terminate\n  if (!this.__compiled__[schema.toLowerCase()]) {\n    return 0\n  }\n  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this)\n}\n\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/\nLinkifyIt.prototype.match = function match (text) {\n  const result = []\n  let shift = 0\n\n  // Try to take previous element from cache, if .test() called before\n  if (this.__index__ >= 0 && this.__text_cache__ === text) {\n    result.push(createMatch(this, shift))\n    shift = this.__last_index__\n  }\n\n  // Cut head if cache was used\n  let tail = shift ? text.slice(shift) : text\n\n  // Scan string until end reached\n  while (this.test(tail)) {\n    result.push(createMatch(this, shift))\n\n    tail = tail.slice(this.__last_index__)\n    shift += this.__last_index__\n  }\n\n  if (result.length) {\n    return result\n  }\n\n  return null\n}\n\n/**\n * LinkifyIt#matchAtStart(text) -> Match|null\n *\n * Returns fully-formed (not fuzzy) link if it starts at the beginning\n * of the string, and null otherwise.\n **/\nLinkifyIt.prototype.matchAtStart = function matchAtStart (text) {\n  // Reset scan cache\n  this.__text_cache__ = text\n  this.__index__ = -1\n\n  if (!text.length) return null\n\n  const m = this.re.schema_at_start.exec(text)\n  if (!m) return null\n\n  const len = this.testSchemaAt(text, m[2], m[0].length)\n  if (!len) return null\n\n  this.__schema__ = m[2]\n  this.__index__ = m.index + m[1].length\n  this.__last_index__ = m.index + m[0].length + len\n\n  return createMatch(this, 0)\n}\n\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/\nLinkifyIt.prototype.tlds = function tlds (list, keepOld) {\n  list = Array.isArray(list) ? list : [list]\n\n  if (!keepOld) {\n    this.__tlds__ = list.slice()\n    this.__tlds_replaced__ = true\n    compile(this)\n    return this\n  }\n\n  this.__tlds__ = this.__tlds__.concat(list)\n    .sort()\n    .filter(function (el, idx, arr) {\n      return el !== arr[idx - 1]\n    })\n    .reverse()\n\n  compile(this)\n  return this\n}\n\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/\nLinkifyIt.prototype.normalize = function normalize (match) {\n  // Do minimal possible changes by default. Need to collect feedback prior\n  // to move forward https://github.com/markdown-it/linkify-it/issues/1\n\n  if (!match.schema) { match.url = 'http://' + match.url }\n\n  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {\n    match.url = 'mailto:' + match.url\n  }\n}\n\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/\nLinkifyIt.prototype.onCompile = function onCompile () {\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinkifyIt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsNEJBQTRCOztBQUU1QiwwQkFBMEIsb0NBQW9DOztBQUU5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFTOztBQUVoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9pbmRleC5tanM/MTMwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVGYWN0b3J5IGZyb20gJy4vbGliL3JlLm1qcydcblxuLy9cbi8vIEhlbHBlcnNcbi8vXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24gKG9iaiAvKiBmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4gKi8pIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybiB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBfY2xhc3MgKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgfVxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nIH1cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJFIChzdHIpIHsgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csICdcXFxcJCYnKSB9XG5cbi8vXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmogfHwge30pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoaylcbiAgfSwgZmFsc2UpXG59XG5cbmNvbnN0IGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIGNvbnN0IHRhaWwgPSB0ZXh0LnNsaWNlKHBvcylcblxuICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5odHRwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICdodHRwOicsXG4gICdmdHA6JzogJ2h0dHA6JyxcbiAgJy8vJzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICBjb25zdCB0YWlsID0gdGV4dC5zbGljZShwb3MpXG5cbiAgICAgIGlmICghc2VsZi5yZS5ub19odHRwKSB7XG4gICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLm5vX2h0dHAgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwIH1cbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICcvJykgeyByZXR1cm4gMCB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfSxcbiAgJ21haWx0bzonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIGNvbnN0IHRhaWwgPSB0ZXh0LnNsaWNlKHBvcylcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICsgc2VsZi5yZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHNlbGYucmUuc3JjX2hvc3Rfc3RyaWN0LCAnaSdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aFxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cbn1cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuY29uc3QgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nXG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG5jb25zdCB0bGRzX2RlZmF1bHQgPSAnYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YQnLnNwbGl0KCd8JylcblxuZnVuY3Rpb24gcmVzZXRTY2FuQ2FjaGUgKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMVxuICBzZWxmLl9fdGV4dF9jYWNoZV9fID0gJydcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yIChyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIGNvbnN0IHRhaWwgPSB0ZXh0LnNsaWNlKHBvcylcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplciAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWF0Y2gsIHNlbGYpIHtcbiAgICBzZWxmLm5vcm1hbGl6ZShtYXRjaClcbiAgfVxufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUgKHNlbGYpIHtcbiAgLy8gTG9hZCAmIGNsb25lIFJFIHBhdHRlcm5zLlxuICBjb25zdCByZSA9IHNlbGYucmUgPSByZUZhY3Rvcnkoc2VsZi5fX29wdHNfXylcblxuICAvLyBEZWZpbmUgZHluYW1pYyBwYXR0ZXJuc1xuICBjb25zdCB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpXG5cbiAgc2VsZi5vbkNvbXBpbGUoKVxuXG4gIGlmICghc2VsZi5fX3RsZHNfcmVwbGFjZWRfXykge1xuICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpXG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bilcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpXG5cbiAgZnVuY3Rpb24gdW50cGwgKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKSB9XG5cbiAgcmUuZW1haWxfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKVxuICByZS5saW5rX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX2Z1enp5KSwgJ2knKVxuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKVxuICByZS5ob3N0X2Z1enp5X3Rlc3QgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJylcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgY29uc3QgYWxpYXNlcyA9IFtdXG5cbiAgc2VsZi5fX2NvbXBpbGVkX18gPSB7fSAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IgKG5hbWUsIHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignKExpbmtpZnlJdCkgSW52YWxpZCBzY2hlbWEgXCInICsgbmFtZSArICdcIjogJyArIHZhbClcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBjb25zdCB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdXG5cbiAgICAvLyBza2lwIGRpc2FibGVkIG1ldGhvZHNcbiAgICBpZiAodmFsID09PSBudWxsKSB7IHJldHVybiB9XG5cbiAgICBjb25zdCBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV0gPSBjb21waWxlZFxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSlcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemVcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbClcbiAgfSlcblxuICAvL1xuICAvLyBDb21waWxlIHBvc3Rwb25lZCBhbGlhc2VzXG4gIC8vXG5cbiAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIG9uIG1pc3NlZCBzY2hlbWFzIHRvIGF2b2lkIGVycm9ucyBvbiBkaXNhYmxlLlxuICAgICAgLy8gc2NoZW1hRXJyb3IoYWxpYXMsIHNlbGYuX19zY2hlbWFzX19bYWxpYXNdKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGVcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemVcbiAgfSlcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICBjb25zdCBzbGlzdCA9IE9iamVjdC5rZXlzKHNlbGYuX19jb21waWxlZF9fKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIC8vIEZpbHRlciBkaXNhYmxlZCAmIGZha2Ugc2NoZW1hc1xuICAgICAgcmV0dXJuIG5hbWUubGVuZ3RoID4gMCAmJiBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXVxuICAgIH0pXG4gICAgLm1hcChlc2NhcGVSRSlcbiAgICAuam9pbignfCcpXG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpXG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKVxuICBzZWxmLnJlLnNjaGVtYV9hdF9zdGFydCA9IFJlZ0V4cCgnXicgKyBzZWxmLnJlLnNjaGVtYV9zZWFyY2guc291cmNlLCAnaScpXG5cbiAgc2VsZi5yZS5wcmV0ZXN0ID0gUmVnRXhwKFxuICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8KCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXxAJyxcbiAgICAnaSdcbiAgKVxuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKVxufVxuXG4vKipcbiAqIGNsYXNzIE1hdGNoXG4gKlxuICogTWF0Y2ggcmVzdWx0LiBTaW5nbGUgZWxlbWVudCBvZiBhcnJheSwgcmV0dXJuZWQgYnkgW1tMaW5raWZ5SXQjbWF0Y2hdXVxuICoqL1xuZnVuY3Rpb24gTWF0Y2ggKHNlbGYsIHNoaWZ0KSB7XG4gIGNvbnN0IHN0YXJ0ID0gc2VsZi5fX2luZGV4X19cbiAgY29uc3QgZW5kID0gc2VsZi5fX2xhc3RfaW5kZXhfX1xuICBjb25zdCB0ZXh0ID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKVxuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpXG4gIC8qKlxuICAgKiBNYXRjaCNpbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogRmlyc3QgcG9zaXRpb24gb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5pbmRleCA9IHN0YXJ0ICsgc2hpZnRcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0XG4gIC8qKlxuICAgKiBNYXRjaCNyYXcgLT4gU3RyaW5nXG4gICAqXG4gICAqIE1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMucmF3ID0gdGV4dFxuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCA9IHRleHRcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgPSB0ZXh0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoIChzZWxmLCBzaGlmdCkge1xuICBjb25zdCBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdClcblxuICBzZWxmLl9fY29tcGlsZWRfX1ttYXRjaC5zY2hlbWFdLm5vcm1hbGl6ZShtYXRjaCwgc2VsZilcblxuICByZXR1cm4gbWF0Y2hcbn1cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdCAoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hc1xuICAgICAgc2NoZW1hcyA9IHt9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyA9IC0xXG4gIHRoaXMuX19sYXN0X2luZGV4X18gPSAtMSAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fID0gJydcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9ICcnXG5cbiAgdGhpcy5fX3NjaGVtYXNfXyA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpXG4gIHRoaXMuX19jb21waWxlZF9fID0ge31cblxuICB0aGlzLl9fdGxkc19fID0gdGxkc19kZWZhdWx0XG4gIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSBmYWxzZVxuXG4gIHRoaXMucmUgPSB7fVxuXG4gIGNvbXBpbGUodGhpcylcbn1cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I2FkZChzY2hlbWEsIGRlZmluaXRpb24pXG4gKiAtIHNjaGVtYSAoU3RyaW5nKTogcnVsZSBuYW1lIChmaXhlZCBwYXR0ZXJuIHByZWZpeClcbiAqIC0gZGVmaW5pdGlvbiAoU3RyaW5nfFJlZ0V4cHxPYmplY3QpOiBzY2hlbWEgZGVmaW5pdGlvblxuICpcbiAqIEFkZCBuZXcgcnVsZSBkZWZpbml0aW9uLiBTZWUgY29uc3RydWN0b3IgZGVzY3JpcHRpb24gZm9yIGRldGFpbHMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb25cbiAgY29tcGlsZSh0aGlzKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QgKHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dFxuICB0aGlzLl9faW5kZXhfXyA9IC0xXG5cbiAgaWYgKCF0ZXh0Lmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGxldCBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3NcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2hcbiAgICByZS5sYXN0SW5kZXggPSAwXG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleClcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fID0gbVsyXVxuICAgICAgICB0aGlzLl9faW5kZXhfXyA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aFxuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdClcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNoaWZ0ID0gbWwuaW5kZXggKyBtbFsxXS5sZW5ndGhcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fID0gJydcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fID0gc2hpZnRcbiAgICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtbC5pbmRleCArIG1sWzBdLmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJylcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoXG4gICAgICAgIG5leHQgPSBtZS5pbmRleCArIG1lWzBdLmxlbmd0aFxuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gPSAnbWFpbHRvOidcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyA9IHNoaWZ0XG4gICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG5leHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwXG59XG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCAodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dClcbn1cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQgKHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpXG59XG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoKHRleHQpIC0+IEFycmF5fG51bGxcbiAqXG4gKiBSZXR1cm5zIGFycmF5IG9mIGZvdW5kIGxpbmsgZGVzY3JpcHRpb25zIG9yIGBudWxsYCBvbiBmYWlsLiBXZSBzdHJvbmdseVxuICogcmVjb21tZW5kIHRvIHVzZSBbW0xpbmtpZnlJdCN0ZXN0XV0gZmlyc3QsIGZvciBiZXN0IHNwZWVkLlxuICpcbiAqICMjIyMjIFJlc3VsdCBtYXRjaCBkZXNjcmlwdGlvblxuICpcbiAqIC0gX19zY2hlbWFfXyAtIGxpbmsgc2NoZW1hLCBjYW4gYmUgZW1wdHkgZm9yIGZ1enp5IGxpbmtzLCBvciBgLy9gIGZvclxuICogICBwcm90b2NvbC1uZXV0cmFsICBsaW5rcy5cbiAqIC0gX19pbmRleF9fIC0gb2Zmc2V0IG9mIG1hdGNoZWQgdGV4dFxuICogLSBfX2xhc3RJbmRleF9fIC0gaW5kZXggb2YgbmV4dCBjaGFyIGFmdGVyIG1hdGhjaCBlbmRcbiAqIC0gX19yYXdfXyAtIG1hdGNoZWQgdGV4dFxuICogLSBfX3RleHRfXyAtIG5vcm1hbGl6ZWQgdGV4dFxuICogLSBfX3VybF9fIC0gbGluaywgZ2VuZXJhdGVkIGZyb20gbWF0Y2hlZCB0ZXh0XG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKHRleHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgbGV0IHNoaWZ0ID0gMFxuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpXG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fXG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICBsZXQgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSlcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pXG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfX1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaEF0U3RhcnQodGV4dCkgLT4gTWF0Y2h8bnVsbFxuICpcbiAqIFJldHVybnMgZnVsbHktZm9ybWVkIChub3QgZnV6enkpIGxpbmsgaWYgaXQgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmdcbiAqIG9mIHRoZSBzdHJpbmcsIGFuZCBudWxsIG90aGVyd2lzZS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2hBdFN0YXJ0ID0gZnVuY3Rpb24gbWF0Y2hBdFN0YXJ0ICh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHRcbiAgdGhpcy5fX2luZGV4X18gPSAtMVxuXG4gIGlmICghdGV4dC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgY29uc3QgbSA9IHRoaXMucmUuc2NoZW1hX2F0X3N0YXJ0LmV4ZWModGV4dClcbiAgaWYgKCFtKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIG1bMF0ubGVuZ3RoKVxuICBpZiAoIWxlbikgcmV0dXJuIG51bGxcblxuICB0aGlzLl9fc2NoZW1hX18gPSBtWzJdXG4gIHRoaXMuX19pbmRleF9fID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoXG4gIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW5cblxuICByZXR1cm4gY3JlYXRlTWF0Y2godGhpcywgMClcbn1cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMgKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogW2xpc3RdXG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKVxuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlXG4gICAgY29tcGlsZSh0aGlzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAuc29ydCgpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXVxuICAgIH0pXG4gICAgLnJldmVyc2UoKVxuXG4gIGNvbXBpbGUodGhpcylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAobWF0Y2gpIHtcbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmwgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsXG4gIH1cbn1cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSAoKSB7XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtpZnlJdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/linkify-it/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/linkify-it/lib/re.mjs":
/*!********************************************!*\
  !*** ./node_modules/linkify-it/lib/re.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony import */ var uc_micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uc.micro */ \"(app-pages-browser)/./node_modules/uc.micro/index.mjs\");\n\n\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(opts) {\n  const re = {}\n  opts = opts || {}\n\n  re.src_Any = uc_micro__WEBPACK_IMPORTED_MODULE_0__.Any.source\n  re.src_Cc = uc_micro__WEBPACK_IMPORTED_MODULE_0__.Cc.source\n  re.src_Z = uc_micro__WEBPACK_IMPORTED_MODULE_0__.Z.source\n  re.src_P = uc_micro__WEBPACK_IMPORTED_MODULE_0__.P.source\n\n  // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|')\n\n  // \\p{\\Z\\Cc} (white spaces + control)\n  re.src_ZCc = [re.src_Z, re.src_Cc].join('|')\n\n  // Experimental. List of chars, completely prohibited in links\n  // because can separate it from other part of text\n  const text_separators = '[><\\uff5c]'\n\n  // All possible word characters (everything without punctuation, spaces & controls)\n  // Defined via punctuation & spaces to save space\n  // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')'\n  // The same as abothe but without [0-9]\n  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n\n  re.src_ip4 =\n\n    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'\n\n  // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\\\[\\\\]()]).)+@)?'\n\n  re.src_port =\n\n    '(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?'\n\n  re.src_host_terminator =\n\n    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')' +\n    '(?!' + (opts['---'] ? '-(?!--)|' : '-|') + '_|:\\\\d|\\\\.-|\\\\.(?!$|' + re.src_ZPCc + '))'\n\n  re.src_path =\n\n    '(?:' +\n      '[/?#]' +\n        '(?:' +\n          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\\\]{}.,\"\\'?!\\\\-;]).|' +\n          '\\\\[(?:(?!' + re.src_ZCc + '|\\\\]).)*\\\\]|' +\n          '\\\\((?:(?!' + re.src_ZCc + '|[)]).)*\\\\)|' +\n          '\\\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\\\}|' +\n          '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' +\n          \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" +\n\n          // allow `I'm_king` if no pair found\n          \"\\\\'(?=\" + re.src_pseudo_letter + '|[-])|' +\n\n          // google has many dots in \"google search\" links (#66, #81).\n          // github has ... in commit range links,\n          // Restrict to\n          // - english\n          // - percent-encoded\n          // - parts of file path\n          // - params separator\n          // until more examples found.\n          '\\\\.{2,}[a-zA-Z0-9%/&]|' +\n\n          '\\\\.(?!' + re.src_ZCc + '|[.]|$)|' +\n          (opts['---']\n            ? '\\\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate\n            : '\\\\-+|'\n          ) +\n          // allow `,,,` in paths\n          ',(?!' + re.src_ZCc + '|$)|' +\n\n          // allow `;` if not followed by space-like char\n          ';(?!' + re.src_ZCc + '|$)|' +\n\n          // allow `!!!` in paths, but not at the end\n          '\\\\!+(?!' + re.src_ZCc + '|[!]|$)|' +\n\n          '\\\\?(?!' + re.src_ZCc + '|[?]|$)' +\n        ')+' +\n      '|\\\\/' +\n    ')?'\n\n  // Allow anything in markdown spec, forbid quote (\") at the first position\n  // because emails enclosed in quotes are far more common\n  re.src_email_name =\n\n    '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*'\n\n  re.src_xn =\n\n    'xn--[a-z0-9\\\\-]{1,59}'\n\n  // More to read about domain names\n  // http://serverfault.com/questions/638260/\n\n  re.src_domain_root =\n\n    // Allow letters & digits (http://test1)\n    '(?:' +\n      re.src_xn +\n      '|' +\n      re.src_pseudo_letter + '{1,63}' +\n    ')'\n\n  re.src_domain =\n\n    '(?:' +\n      re.src_xn +\n      '|' +\n      '(?:' + re.src_pseudo_letter + ')' +\n      '|' +\n      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +\n    ')'\n\n  re.src_host =\n\n    '(?:' +\n    // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)*' + re.src_domain/* _root */ + ')' +\n    ')'\n\n  re.tpl_host_fuzzy =\n\n    '(?:' +\n      re.src_ip4 +\n    '|' +\n      '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))' +\n    ')'\n\n  re.tpl_host_no_ip_fuzzy =\n\n    '(?:(?:(?:' + re.src_domain + ')\\\\.)+(?:%TLDS%))'\n\n  re.src_host_strict =\n\n    re.src_host + re.src_host_terminator\n\n  re.tpl_host_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_host_terminator\n\n  re.src_host_port_strict =\n\n    re.src_host + re.src_port + re.src_host_terminator\n\n  re.tpl_host_port_fuzzy_strict =\n\n    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator\n\n  re.tpl_host_port_no_ip_fuzzy_strict =\n\n    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator\n\n  //\n  // Main rules\n  //\n\n  // Rude test fuzzy links by host, for quick deny\n  re.tpl_host_fuzzy_test =\n\n    'localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))'\n\n  re.tpl_email_fuzzy =\n\n      '(^|' + text_separators + '|\"|\\\\(|' + re.src_ZCc + ')' +\n      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')'\n\n  re.tpl_link_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')'\n\n  re.tpl_link_no_ip_fuzzy =\n      // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n      // but can start with > (markdown blockquote)\n      '(^|(?![.:/\\\\-_@])(?:[$+<=>^`|\\uff5c]|' + re.src_ZPCc + '))' +\n      '((?![$+<=>^`|\\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')'\n\n  return re\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saW5raWZ5LWl0L2xpYi9yZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7O0FBRXhDLDZCQUFlLG9DQUFVO0FBQ3pCO0FBQ0E7O0FBRUEsZUFBZSx5Q0FBRztBQUNsQixjQUFjLHdDQUFFO0FBQ2hCLGFBQWEsdUNBQUM7QUFDZCxhQUFhLHVDQUFDOztBQUVkLFFBQVEsWUFBWTtBQUNwQjs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtREFBbUQsRUFBRTs7QUFFckQ7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsRUFBRSxjQUFjLEVBQUUsa0NBQWtDLElBQUk7O0FBRWpGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFdBQVc7QUFDN0U7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQixZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsNkJBQTZCOztBQUV2Qzs7QUFFQSxxQkFBcUIsS0FBSzs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsS0FBSztBQUM5RTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsSUFBSTs7QUFFakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9saWIvcmUubWpzP2Q5ZTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW55LCBDYywgWiwgUCB9IGZyb20gJ3VjLm1pY3JvJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAob3B0cykge1xuICBjb25zdCByZSA9IHt9XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgcmUuc3JjX0FueSA9IEFueS5zb3VyY2VcbiAgcmUuc3JjX0NjID0gQ2Muc291cmNlXG4gIHJlLnNyY19aID0gWi5zb3VyY2VcbiAgcmUuc3JjX1AgPSBQLnNvdXJjZVxuXG4gIC8vIFxccHtcXFpcXFBcXENjXFxDRn0gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wgKyBmb3JtYXQgKyBwdW5jdHVhdGlvbilcbiAgcmUuc3JjX1pQQ2MgPSBbcmUuc3JjX1osIHJlLnNyY19QLCByZS5zcmNfQ2NdLmpvaW4oJ3wnKVxuXG4gIC8vIFxccHtcXFpcXENjfSAod2hpdGUgc3BhY2VzICsgY29udHJvbClcbiAgcmUuc3JjX1pDYyA9IFtyZS5zcmNfWiwgcmUuc3JjX0NjXS5qb2luKCd8JylcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICBjb25zdCB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nXG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSdcbiAgLy8gVGhlIHNhbWUgYXMgYWJvdGhlIGJ1dCB3aXRob3V0IFswLTldXG4gIC8vIHZhciBzcmNfcHNldWRvX2xldHRlcl9ub25fZCA9ICcoPzooPyFbMC05XXwnICsgc3JjX1pQQ2MgKyAnKScgKyBzcmNfQW55ICsgJyknO1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknXG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/J1xuXG4gIHJlLnNyY19wb3J0ID1cblxuICAgICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nXG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgK1xuICAgICcoPyEnICsgKG9wdHNbJy0tLSddID8gJy0oPyEtLSl8JyA6ICctfCcpICsgJ198OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8JyArIHJlLnNyY19aUENjICsgJykpJ1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtO10pLnwnICtcbiAgICAgICAgICAnXFxcXFsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8XFxcXF0pLikqXFxcXF18JyArXG4gICAgICAgICAgJ1xcXFwoKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFspXSkuKSpcXFxcKXwnICtcbiAgICAgICAgICAnXFxcXHsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W31dKS4pKlxcXFx9fCcgK1xuICAgICAgICAgICdcXFxcXCIoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W1wiXSkuKStcXFxcXCJ8JyArXG4gICAgICAgICAgXCJcXFxcJyg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFsnXSkuKStcXFxcJ3xcIiArXG5cbiAgICAgICAgICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKXwnICtcblxuICAgICAgICAgIC8vIGdvb2dsZSBoYXMgbWFueSBkb3RzIGluIFwiZ29vZ2xlIHNlYXJjaFwiIGxpbmtzICgjNjYsICM4MSkuXG4gICAgICAgICAgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLFxuICAgICAgICAgIC8vIFJlc3RyaWN0IHRvXG4gICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgIC8vIC0gcGFyYW1zIHNlcGFyYXRvclxuICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuezIsfVthLXpBLVowLTklLyZdfCcgK1xuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXXwkKXwnICtcbiAgICAgICAgICAob3B0c1snLS0tJ11cbiAgICAgICAgICAgID8gJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgICA6ICdcXFxcLSt8J1xuICAgICAgICAgICkgK1xuICAgICAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJywoPyEnICsgcmUuc3JjX1pDYyArICd8JCl8JyArXG5cbiAgICAgICAgICAvLyBhbGxvdyBgO2AgaWYgbm90IGZvbGxvd2VkIGJ5IHNwYWNlLWxpa2UgY2hhclxuICAgICAgICAgICc7KD8hJyArIHJlLnNyY19aQ2MgKyAnfCQpfCcgK1xuXG4gICAgICAgICAgLy8gYWxsb3cgYCEhIWAgaW4gcGF0aHMsIGJ1dCBub3QgYXQgdGhlIGVuZFxuICAgICAgICAgICdcXFxcISsoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdfCQpfCcgK1xuXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XXwkKScgK1xuICAgICAgICAnKSsnICtcbiAgICAgICd8XFxcXC8nICtcbiAgICAnKT8nXG5cbiAgLy8gQWxsb3cgYW55dGhpbmcgaW4gbWFya2Rvd24gc3BlYywgZm9yYmlkIHF1b3RlIChcIikgYXQgdGhlIGZpcnN0IHBvc2l0aW9uXG4gIC8vIGJlY2F1c2UgZW1haWxzIGVuY2xvc2VkIGluIHF1b3RlcyBhcmUgZmFyIG1vcmUgY29tbW9uXG4gIHJlLnNyY19lbWFpbF9uYW1lID1cblxuICAgICdbXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcLmEtekEtWjAtOV9dW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSonXG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSdcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknXG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKD86LXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknXG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLyogX3Jvb3QgKi8gKyAnKScgK1xuICAgICcpJ1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJ1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJ1xuXG4gIHJlLnNyY19ob3N0X3N0cmljdCA9XG5cbiAgICByZS5zcmNfaG9zdCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3JcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yXG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3JcblxuICByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19wb3J0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvclxuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yXG5cbiAgLy9cbiAgLy8gTWFpbiBydWxlc1xuICAvL1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSdcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XCJ8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKScgK1xuICAgICAgJygnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSdcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJ1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknXG5cbiAgcmV0dXJuIHJlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/linkify-it/lib/re.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/index.mjs":
/*!********************************************!*\
  !*** ./node_modules/markdown-it/index.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _lib_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _lib_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/index.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/index.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2luZGV4Lm1qcz9kYmI0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2xpYi9pbmRleC5tanMnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/common/html_blocks.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_blocks.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// List of valid html blocks names, according to commonmark spec\n// https://spec.commonmark.org/0.30/#html-blocks\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ([\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'search',\n  'section',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQSwrREFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLm1qcz8wODNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIExpc3Qgb2YgdmFsaWQgaHRtbCBibG9ja3MgbmFtZXMsIGFjY29yZGluZyB0byBjb21tb25tYXJrIHNwZWNcbi8vIGh0dHBzOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjMwLyNodG1sLWJsb2Nrc1xuXG5leHBvcnQgZGVmYXVsdCBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdzZWFyY2gnLFxuICAnc2VjdGlvbicsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/common/html_blocks.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/common/html_re.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_re.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTML_OPEN_CLOSE_TAG_RE: function() { return /* binding */ HTML_OPEN_CLOSE_TAG_RE; },\n/* harmony export */   HTML_TAG_RE: function() { return /* binding */ HTML_TAG_RE; }\n/* harmony export */ });\n// Regexps to match html elements\n\nconst attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*'\n\nconst unquoted      = '[^\"\\'=<>`\\\\x00-\\\\x20]+'\nconst single_quoted = \"'[^']*'\"\nconst double_quoted = '\"[^\"]*\"'\n\nconst attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')'\n\nconst attribute   = '(?:\\\\s+' + attr_name + '(?:\\\\s*=\\\\s*' + attr_value + ')?)'\n\nconst open_tag    = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>'\n\nconst close_tag   = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>'\nconst comment     = '<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->'\nconst processing  = '<[?][\\\\s\\\\S]*?[?]>'\nconst declaration = '<![A-Za-z][^>]*>'\nconst cdata       = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>'\n\nconst HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +\n                        '|' + processing + '|' + declaration + '|' + cdata + ')')\nconst HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')')\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfcmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLm1qcz82ZTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG5jb25zdCBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJ1xuXG5jb25zdCB1bnF1b3RlZCAgICAgID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnXG5jb25zdCBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCJcbmNvbnN0IGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIidcblxuY29uc3QgYXR0cl92YWx1ZSAgPSAnKD86JyArIHVucXVvdGVkICsgJ3wnICsgc2luZ2xlX3F1b3RlZCArICd8JyArIGRvdWJsZV9xdW90ZWQgKyAnKSdcblxuY29uc3QgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJ1xuXG5jb25zdCBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nXG5cbmNvbnN0IGNsb3NlX3RhZyAgID0gJzxcXFxcL1tBLVphLXpdW0EtWmEtejAtOVxcXFwtXSpcXFxccyo+J1xuY29uc3QgY29tbWVudCAgICAgPSAnPCEtLS0/Pnw8IS0tKD86W14tXXwtW14tXXwtLVtePl0pKi0tPidcbmNvbnN0IHByb2Nlc3NpbmcgID0gJzxbP11bXFxcXHNcXFxcU10qP1s/XT4nXG5jb25zdCBkZWNsYXJhdGlvbiA9ICc8IVtBLVphLXpdW14+XSo+J1xuY29uc3QgY2RhdGEgICAgICAgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+J1xuXG5jb25zdCBIVE1MX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnfCcgKyBjb21tZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHByb2Nlc3NpbmcgKyAnfCcgKyBkZWNsYXJhdGlvbiArICd8JyArIGNkYXRhICsgJyknKVxuY29uc3QgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpXG5cbmV4cG9ydCB7IEhUTUxfVEFHX1JFLCBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/common/html_re.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/utils.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayReplaceAt: function() { return /* binding */ arrayReplaceAt; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   escapeHtml: function() { return /* binding */ escapeHtml; },\n/* harmony export */   escapeRE: function() { return /* binding */ escapeRE; },\n/* harmony export */   fromCodePoint: function() { return /* binding */ fromCodePoint; },\n/* harmony export */   has: function() { return /* binding */ has; },\n/* harmony export */   isMdAsciiPunct: function() { return /* binding */ isMdAsciiPunct; },\n/* harmony export */   isPunctChar: function() { return /* binding */ isPunctChar; },\n/* harmony export */   isSpace: function() { return /* binding */ isSpace; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isValidEntityCode: function() { return /* binding */ isValidEntityCode; },\n/* harmony export */   isWhiteSpace: function() { return /* binding */ isWhiteSpace; },\n/* harmony export */   lib: function() { return /* binding */ lib; },\n/* harmony export */   normalizeReference: function() { return /* binding */ normalizeReference; },\n/* harmony export */   unescapeAll: function() { return /* binding */ unescapeAll; },\n/* harmony export */   unescapeMd: function() { return /* binding */ unescapeMd; }\n/* harmony export */ });\n/* harmony import */ var mdurl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdurl */ \"(app-pages-browser)/./node_modules/mdurl/index.mjs\");\n/* harmony import */ var uc_micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uc.micro */ \"(app-pages-browser)/./node_modules/uc.micro/index.mjs\");\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! entities */ \"(app-pages-browser)/./node_modules/entities/lib/esm/index.js\");\n// Utilities\n//\n\n\n\n\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = (0,entities__WEBPACK_IMPORTED_MODULE_2__.decodeHTML)(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return uc_micro__WEBPACK_IMPORTED_MODULE_1__.P.test(ch) || uc_micro__WEBPACK_IMPORTED_MODULE_1__.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 ''.toLowerCase() === '', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if (''.toLowerCase() === '') {\n    str = str.replace(//g, '')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // , , , , ,  - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (), U+03f4 () and lowercase U+03b8 (), U+03d1 ()\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change  (it's already lowercase),\n  // and .toUpperCase() doesn't change  (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl: mdurl__WEBPACK_IMPORTED_MODULE_0__, ucmicro: uc_micro__WEBPACK_IMPORTED_MODULE_1__ }\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFOEI7QUFDSztBQUNFOztBQUVyQyx3QkFBd0I7O0FBRXhCLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEMsNERBQTREO0FBQzVEO0FBQ0EsZ0NBQWdDO0FBQ2hDLG9CQUFvQjtBQUNwQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLEVBQUU7QUFDL0QsMENBQTBDLEtBQUssRUFBRTtBQUNqRDs7QUFFQSxnREFBZ0QsSUFBSSxPQUFPLElBQUk7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLG9EQUFVO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLEVBQUU7O0FBRUY7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHVDQUFTLGFBQWEsdUNBQVM7QUFDeEM7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxvQ0FBb0MsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCLEdBQUcsRUFBRSxNQUFNLEtBQUs7QUFDckQsVUFBVSx5QkFBeUIsR0FBRyxFQUFFLE1BQU0sSUFBSSxNQUFNO0FBQ3hELFVBQVUsbUJBQW1CLEdBQUcsRUFBRSxFQUFFLGlCQUFpQixFQUFFLGlDQUFpQyxNQUFNO0FBQzlGLFVBQVUsMkJBQTJCLEdBQUcsRUFBRSxFQUFFLGlCQUFpQixLQUFLO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLDZDQUFTOztBQW1CM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vdXRpbHMubWpzPzVjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXRpbGl0aWVzXG4vL1xuXG5pbXBvcnQgKiBhcyBtZHVybCBmcm9tICdtZHVybCdcbmltcG9ydCAqIGFzIHVjbWljcm8gZnJvbSAndWMubWljcm8nXG5pbXBvcnQgeyBkZWNvZGVIVE1MIH0gZnJvbSAnZW50aXRpZXMnXG5cbmZ1bmN0aW9uIF9jbGFzcyAob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSB9XG5cbmZ1bmN0aW9uIGlzU3RyaW5nIChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJyB9XG5cbmNvbnN0IF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gaGFzIChvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpXG59XG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24gKG9iaiAvKiBmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4gKi8pIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybiB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgb2JqZWN0JylcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIG9ialxufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdCAoc3JjLCBwb3MsIG5ld0VsZW1lbnRzKSB7XG4gIHJldHVybiBbXS5jb25jYXQoc3JjLnNsaWNlKDAsIHBvcyksIG5ld0VsZW1lbnRzLCBzcmMuc2xpY2UocG9zICsgMSkpXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlIChjKSB7XG4gIC8qIGVzbGludCBuby1iaXR3aXNlOjAgKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2UgfVxuICAvLyBuZXZlciB1c2VkXG4gIGlmIChjID49IDB4RkREMCAmJiBjIDw9IDB4RkRFRikgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoKGMgJiAweEZGRkYpID09PSAweEZGRkYgfHwgKGMgJiAweEZGRkYpID09PSAweEZGRkUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoYyA9PT0gMHgwQikgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoYyA+PSAweDBFICYmIGMgPD0gMHgxRikgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2UgfVxuICAvLyBvdXQgb2YgcmFuZ2VcbiAgaWYgKGMgPiAweDEwRkZGRikgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50IChjKSB7XG4gIC8qIGVzbGludCBuby1iaXR3aXNlOjAgKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDBcbiAgICBjb25zdCBzdXJyb2dhdGUxID0gMHhkODAwICsgKGMgPj4gMTApXG4gICAgY29uc3Qgc3Vycm9nYXRlMiA9IDB4ZGMwMCArIChjICYgMHgzZmYpXG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKVxuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpXG59XG5cbmNvbnN0IFVORVNDQVBFX01EX1JFICA9IC9cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZ1xuY29uc3QgRU5USVRZX1JFICAgICAgID0gLyYoW2EteiNdW2EtejAtOV17MSwzMX0pOy9naVxuY29uc3QgVU5FU0NBUEVfQUxMX1JFID0gbmV3IFJlZ0V4cChVTkVTQ0FQRV9NRF9SRS5zb3VyY2UgKyAnfCcgKyBFTlRJVFlfUkUuc291cmNlLCAnZ2knKVxuXG5jb25zdCBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKSQvaVxuXG5mdW5jdGlvbiByZXBsYWNlRW50aXR5UGF0dGVybiAobWF0Y2gsIG5hbWUpIHtcbiAgaWYgKG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyMy8qICMgKi8gJiYgRElHSVRBTF9FTlRJVFlfVEVTVF9SRS50ZXN0KG5hbWUpKSB7XG4gICAgY29uc3QgY29kZSA9IG5hbWVbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnXG4gICAgICA/IHBhcnNlSW50KG5hbWUuc2xpY2UoMiksIDE2KVxuICAgICAgOiBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMClcblxuICAgIGlmIChpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hcbiAgfVxuXG4gIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVIVE1MKG1hdGNoKVxuICBpZiAoZGVjb2RlZCAhPT0gbWF0Y2gpIHtcbiAgICByZXR1cm4gZGVjb2RlZFxuICB9XG5cbiAgcmV0dXJuIG1hdGNoXG59XG5cbi8qIGZ1bmN0aW9uIHJlcGxhY2VFbnRpdGllcyhzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoRU5USVRZX1JFLCByZXBsYWNlRW50aXR5UGF0dGVybik7XG59ICovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQgKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0ciB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJylcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVBbGwgKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0ciB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFVORVNDQVBFX0FMTF9SRSwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBlbnRpdHkpIHtcbiAgICBpZiAoZXNjYXBlZCkgeyByZXR1cm4gZXNjYXBlZCB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpXG4gIH0pXG59XG5cbmNvbnN0IEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS9cbmNvbnN0IEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUgPSAvWyY8PlwiXS9nXG5jb25zdCBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyIChjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdXG59XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5jb25zdCBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZ1xuXG5mdW5jdGlvbiBlc2NhcGVSRSAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gaXNTcGFjZSAoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UgKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj0gMHgyMDAwICYmIGNvZGUgPD0gMHgyMDBBKSB7IHJldHVybiB0cnVlIH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhciAoY2gpIHtcbiAgcmV0dXJuIHVjbWljcm8uUC50ZXN0KGNoKSB8fCB1Y21pY3JvLlMudGVzdChjaClcbn1cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0IChjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDIxLyogISAqLzpcbiAgICBjYXNlIDB4MjIvKiBcIiAqLzpcbiAgICBjYXNlIDB4MjMvKiAjICovOlxuICAgIGNhc2UgMHgyNC8qICQgKi86XG4gICAgY2FzZSAweDI1LyogJSAqLzpcbiAgICBjYXNlIDB4MjYvKiAmICovOlxuICAgIGNhc2UgMHgyNy8qICcgKi86XG4gICAgY2FzZSAweDI4LyogKCAqLzpcbiAgICBjYXNlIDB4MjkvKiApICovOlxuICAgIGNhc2UgMHgyQS8qICogKi86XG4gICAgY2FzZSAweDJCLyogKyAqLzpcbiAgICBjYXNlIDB4MkMvKiAsICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDJFLyogLiAqLzpcbiAgICBjYXNlIDB4MkYvKiAvICovOlxuICAgIGNhc2UgMHgzQS8qIDogKi86XG4gICAgY2FzZSAweDNCLyogOyAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4M0YvKiA/ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdDLyogfCAqLzpcbiAgICBjYXNlIDB4N0QvKiB9ICovOlxuICAgIGNhc2UgMHg3RS8qIH4gKi86XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZSAoc3RyKSB7XG4gIC8vIFRyaW0gYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2VcbiAgLy9cbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJylcblxuICAvLyBJbiBub2RlIHYxMCAn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jywgd2hpY2ggaXMgcHJlc3VtZWQgdG8gYmUgYSBidWdcbiAgLy8gZml4ZWQgaW4gdjEyIChjb3VsZG4ndCBmaW5kIGFueSBkZXRhaWxzKS5cbiAgLy9cbiAgLy8gU28gdHJlYXQgdGhpcyBvbmUgYXMgYSBzcGVjaWFsIGNhc2VcbiAgLy8gKHJlbW92ZSB0aGlzIHdoZW4gbm9kZSB2MTAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCkuXG4gIC8vXG4gIGlmICgn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/hup4vZywgJ8OfJylcbiAgfVxuXG4gIC8vIC50b0xvd2VyQ2FzZSgpLnRvVXBwZXJDYXNlKCkgc2hvdWxkIGdldCByaWQgb2YgYWxsIGRpZmZlcmVuY2VzXG4gIC8vIGJldHdlZW4gbGV0dGVyIHZhcmlhbnRzLlxuICAvL1xuICAvLyBTaW1wbGUgLnRvTG93ZXJDYXNlKCkgZG9lc24ndCBub3JtYWxpemUgMTI1IGNvZGUgcG9pbnRzIGNvcnJlY3RseSxcbiAgLy8gYW5kIC50b1VwcGVyQ2FzZSBkb2Vzbid0IG5vcm1hbGl6ZSA2IG9mIHRoZW0gKGxpc3Qgb2YgZXhjZXB0aW9uczpcbiAgLy8gxLAsIM+0LCDhup4sIOKEpiwg4oSqLCDihKsgLSB0aG9zZSBhcmUgYWxyZWFkeSB1cHBlcmNhc2VkLCBidXQgaGF2ZSBkaWZmZXJlbnRseVxuICAvLyB1cHBlcmNhc2VkIHZlcnNpb25zKS5cbiAgLy9cbiAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgc2hvd2luZyBob3cgaXQgaGFwcGVucy4gTGV0cyB0YWtlIGdyZWVrIGxldHRlciBvbWVnYTpcbiAgLy8gdXBwZXJjYXNlIFUrMDM5OCAozpgpLCBVKzAzZjQgKM+0KSBhbmQgbG93ZXJjYXNlIFUrMDNiOCAozrgpLCBVKzAzZDEgKM+RKVxuICAvL1xuICAvLyBVbmljb2RlIGVudHJpZXM6XG4gIC8vIDAzOTg7R1JFRUsgQ0FQSVRBTCBMRVRURVIgVEhFVEE7THU7MDtMOzs7OztOOzs7OzAzQjg7XG4gIC8vIDAzQjg7R1JFRUsgU01BTEwgTEVUVEVSIFRIRVRBO0xsOzA7TDs7Ozs7Tjs7OzAzOTg7OzAzOThcbiAgLy8gMDNEMTtHUkVFSyBUSEVUQSBTWU1CT0w7TGw7MDtMOzxjb21wYXQ+IDAzQjg7Ozs7TjtHUkVFSyBTTUFMTCBMRVRURVIgU0NSSVBUIFRIRVRBOzswMzk4OzswMzk4XG4gIC8vIDAzRjQ7R1JFRUsgQ0FQSVRBTCBUSEVUQSBTWU1CT0w7THU7MDtMOzxjb21wYXQ+IDAzOTg7Ozs7Tjs7OzswM0I4O1xuICAvL1xuICAvLyBDYXNlLWluc2Vuc2l0aXZlIGNvbXBhcmlzb24gc2hvdWxkIHRyZWF0IGFsbCBvZiB0aGVtIGFzIGVxdWl2YWxlbnQuXG4gIC8vXG4gIC8vIEJ1dCAudG9Mb3dlckNhc2UoKSBkb2Vzbid0IGNoYW5nZSDPkSAoaXQncyBhbHJlYWR5IGxvd2VyY2FzZSksXG4gIC8vIGFuZCAudG9VcHBlckNhc2UoKSBkb2Vzbid0IGNoYW5nZSDPtCAoYWxyZWFkeSB1cHBlcmNhc2UpLlxuICAvL1xuICAvLyBBcHBseWluZyBmaXJzdCBsb3dlciB0aGVuIHVwcGVyIGNhc2Ugbm9ybWFsaXplcyBhbnkgY2hhcmFjdGVyOlxuICAvLyAnXFx1MDM5OFxcdTAzZjRcXHUwM2I4XFx1MDNkMScudG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpID09PSAnXFx1MDM5OFxcdTAzOThcXHUwMzk4XFx1MDM5OCdcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBpcyBlcXVpdmFsZW50IHRvIHVuaWNvZGUgY2FzZSBmb2xkaW5nOyB1bmljb2RlIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgYSBkaWZmZXJlbnQgc3RlcCB0aGF0IGlzIG5vdCByZXF1aXJlZCBoZXJlLlxuICAvL1xuICAvLyBGaW5hbCByZXN1bHQgc2hvdWxkIGJlIHVwcGVyY2FzZWQsIGJlY2F1c2UgaXQncyBsYXRlciBzdG9yZWQgaW4gYW4gb2JqZWN0XG4gIC8vICh0aGlzIGF2b2lkIGEgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIG1lbWJlcnMsXG4gIC8vIG1vc3Qgbm90YWJseSwgYF9fcHJvdG9fX2ApXG4gIC8vXG4gIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpXG59XG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5jb25zdCBsaWIgPSB7IG1kdXJsLCB1Y21pY3JvIH1cblxuZXhwb3J0IHtcbiAgbGliLFxuICBhc3NpZ24sXG4gIGlzU3RyaW5nLFxuICBoYXMsXG4gIHVuZXNjYXBlTWQsXG4gIHVuZXNjYXBlQWxsLFxuICBpc1ZhbGlkRW50aXR5Q29kZSxcbiAgZnJvbUNvZGVQb2ludCxcbiAgZXNjYXBlSHRtbCxcbiAgYXJyYXlSZXBsYWNlQXQsXG4gIGlzU3BhY2UsXG4gIGlzV2hpdGVTcGFjZSxcbiAgaXNNZEFzY2lpUHVuY3QsXG4gIGlzUHVuY3RDaGFyLFxuICBlc2NhcGVSRSxcbiAgbm9ybWFsaXplUmVmZXJlbmNlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/helpers/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseLinkDestination: function() { return /* reexport safe */ _parse_link_destination_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   parseLinkLabel: function() { return /* reexport safe */ _parse_link_label_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   parseLinkTitle: function() { return /* reexport safe */ _parse_link_title_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _parse_link_label_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse_link_label.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_label.mjs\");\n/* harmony import */ var _parse_link_destination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse_link_destination.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_destination.mjs\");\n/* harmony import */ var _parse_link_title_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse_link_title.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_title.mjs\");\n// Just a shortcut for bulk export\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRW1EO0FBQ1k7QUFDWjs7QUFNbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4Lm1qcz8zOTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcblxuaW1wb3J0IHBhcnNlTGlua0xhYmVsIGZyb20gJy4vcGFyc2VfbGlua19sYWJlbC5tanMnXG5pbXBvcnQgcGFyc2VMaW5rRGVzdGluYXRpb24gZnJvbSAnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLm1qcydcbmltcG9ydCBwYXJzZUxpbmtUaXRsZSBmcm9tICcuL3BhcnNlX2xpbmtfdGl0bGUubWpzJ1xuXG5leHBvcnQge1xuICBwYXJzZUxpbmtMYWJlbCxcbiAgcGFyc2VMaW5rRGVzdGluYXRpb24sXG4gIHBhcnNlTGlua1RpdGxlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/helpers/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_destination.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_destination.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ parseLinkDestination; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Parse link destination\n//\n\n\n\nfunction parseLinkDestination (str, start, max) {\n  let code\n  let pos = start\n\n  const result = {\n    ok: false,\n    pos: 0,\n    str: ''\n  }\n\n  if (str.charCodeAt(pos) === 0x3C /* < */) {\n    pos++\n    while (pos < max) {\n      code = str.charCodeAt(pos)\n      if (code === 0x0A /* \\n */) { return result }\n      if (code === 0x3C /* < */) { return result }\n      if (code === 0x3E /* > */) {\n        result.pos = pos + 1\n        result.str = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapeAll)(str.slice(start + 1, pos))\n        result.ok = true\n        return result\n      }\n      if (code === 0x5C /* \\ */ && pos + 1 < max) {\n        pos += 2\n        continue\n      }\n\n      pos++\n    }\n\n    // no closing '>'\n    return result\n  }\n\n  // this should be ... } else { ... branch\n\n  let level = 0\n  while (pos < max) {\n    code = str.charCodeAt(pos)\n\n    if (code === 0x20) { break }\n\n    // ascii control characters\n    if (code < 0x20 || code === 0x7F) { break }\n\n    if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      if (str.charCodeAt(pos + 1) === 0x20) { break }\n      pos += 2\n      continue\n    }\n\n    if (code === 0x28 /* ( */) {\n      level++\n      if (level > 32) { return result }\n    }\n\n    if (code === 0x29 /* ) */) {\n      if (level === 0) { break }\n      level--\n    }\n\n    pos++\n  }\n\n  if (start === pos) { return result }\n  if (level !== 0) { return result }\n\n  result.str = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapeAll)(str.slice(start, pos))\n  result.pos = pos\n  result.ok = true\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRWlEOztBQUVsQztBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHFCQUFxQiw4REFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsT0FBTzs7QUFFakM7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIscUJBQXFCOztBQUVyQixlQUFlLDhEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uLm1qcz81NDA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhcnNlIGxpbmsgZGVzdGluYXRpb25cbi8vXG5cbmltcG9ydCB7IHVuZXNjYXBlQWxsIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24gKHN0ciwgc3RhcnQsIG1heCkge1xuICBsZXQgY29kZVxuICBsZXQgcG9zID0gc3RhcnRcblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgb2s6IGZhbHNlLFxuICAgIHBvczogMCxcbiAgICBzdHI6ICcnXG4gIH1cblxuICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgzQyAvKiA8ICovKSB7XG4gICAgcG9zKytcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovKSB7IHJldHVybiByZXN1bHQgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0MgLyogPCAqLykgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDFcbiAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpXG4gICAgICAgIHJlc3VsdC5vayA9IHRydWVcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMlxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBwb3MrK1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gdGhpcyBzaG91bGQgYmUgLi4uIH0gZWxzZSB7IC4uLiBicmFuY2hcblxuICBsZXQgbGV2ZWwgPSAwXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWsgfVxuXG4gICAgLy8gYXNjaWkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWsgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAweDIwKSB7IGJyZWFrIH1cbiAgICAgIHBvcyArPSAyXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI4IC8qICggKi8pIHtcbiAgICAgIGxldmVsKytcbiAgICAgIGlmIChsZXZlbCA+IDMyKSB7IHJldHVybiByZXN1bHQgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSAweDI5IC8qICkgKi8pIHtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkgeyBicmVhayB9XG4gICAgICBsZXZlbC0tXG4gICAgfVxuXG4gICAgcG9zKytcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gcG9zKSB7IHJldHVybiByZXN1bHQgfVxuICBpZiAobGV2ZWwgIT09IDApIHsgcmV0dXJuIHJlc3VsdCB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSlcbiAgcmVzdWx0LnBvcyA9IHBvc1xuICByZXN1bHQub2sgPSB0cnVlXG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_destination.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_label.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_label.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ parseLinkLabel; }\n/* harmony export */ });\n// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\nfunction parseLinkLabel (state, start, disableNested) {\n  let level, found, marker, prevPos\n\n  const max = state.posMax\n  const oldPos = state.pos\n\n  state.pos = start + 1\n  level = 1\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos)\n    if (marker === 0x5D /* ] */) {\n      level--\n      if (level === 0) {\n        found = true\n        break\n      }\n    }\n\n    prevPos = state.pos\n    state.md.inline.skipToken(state)\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++\n      } else if (disableNested) {\n        state.pos = oldPos\n        return -1\n      }\n    }\n  }\n\n  let labelEnd = -1\n\n  if (found) {\n    labelEnd = state.pos\n  }\n\n  // restore old state\n  state.pos = oldPos\n\n  return labelEnd\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX2xhYmVsLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5tanM/ZTA5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYXJzZSBsaW5rIGxhYmVsXG4vL1xuLy8gdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3QgY2hhcmFjdGVyIChcIltcIikgYWxyZWFkeSBtYXRjaGVzO1xuLy8gcmV0dXJucyB0aGUgZW5kIG9mIHRoZSBsYWJlbFxuLy9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VMaW5rTGFiZWwgKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICBsZXQgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3NcblxuICBjb25zdCBtYXggPSBzdGF0ZS5wb3NNYXhcbiAgY29uc3Qgb2xkUG9zID0gc3RhdGUucG9zXG5cbiAgc3RhdGUucG9zID0gc3RhcnQgKyAxXG4gIGxldmVsID0gMVxuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpXG4gICAgaWYgKG1hcmtlciA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsZXZlbC0tXG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgZm91bmQgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldlBvcyA9IHN0YXRlLnBvc1xuICAgIHN0YXRlLm1kLmlubGluZS5za2lwVG9rZW4oc3RhdGUpXG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrXG4gICAgICB9IGVsc2UgaWYgKGRpc2FibGVOZXN0ZWQpIHtcbiAgICAgICAgc3RhdGUucG9zID0gb2xkUG9zXG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBsYWJlbEVuZCA9IC0xXG5cbiAgaWYgKGZvdW5kKSB7XG4gICAgbGFiZWxFbmQgPSBzdGF0ZS5wb3NcbiAgfVxuXG4gIC8vIHJlc3RvcmUgb2xkIHN0YXRlXG4gIHN0YXRlLnBvcyA9IG9sZFBvc1xuXG4gIHJldHVybiBsYWJlbEVuZFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_label.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_title.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_title.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ parseLinkTitle; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Parse link title\n//\n\n\n\n// Parse link title within `str` in [start, max] range,\n// or continue previous parsing if `prev_state` is defined (equal to result of last execution).\n//\nfunction parseLinkTitle (str, start, max, prev_state) {\n  let code\n  let pos = start\n\n  const state = {\n    // if `true`, this is a valid link title\n    ok: false,\n    // if `true`, this link can be continued on the next line\n    can_continue: false,\n    // if `ok`, it's the position of the first character after the closing marker\n    pos: 0,\n    // if `ok`, it's the unescaped title\n    str: '',\n    // expected closing marker character code\n    marker: 0\n  }\n\n  if (prev_state) {\n    // this is a continuation of a previous parseLinkTitle call on the next line,\n    // used in reference links only\n    state.str = prev_state.str\n    state.marker = prev_state.marker\n  } else {\n    if (pos >= max) { return state }\n\n    let marker = str.charCodeAt(pos)\n    if (marker !== 0x22 /* \" */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return state }\n\n    start++\n    pos++\n\n    // if opening marker is \"(\", switch it to closing marker \")\"\n    if (marker === 0x28) { marker = 0x29 }\n\n    state.marker = marker\n  }\n\n  while (pos < max) {\n    code = str.charCodeAt(pos)\n    if (code === state.marker) {\n      state.pos = pos + 1\n      state.str += (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapeAll)(str.slice(start, pos))\n      state.ok = true\n      return state\n    } else if (code === 0x28 /* ( */ && state.marker === 0x29 /* ) */) {\n      return state\n    } else if (code === 0x5C /* \\ */ && pos + 1 < max) {\n      pos++\n    }\n\n    pos++\n  }\n\n  // no closing marker found, but this link title may continue on the next line (for references)\n  state.can_continue = true\n  state.str += (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapeAll)(str.slice(start, pos))\n  return state\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0JBQXNCOztBQUV0QjtBQUNBLHlGQUF5Rjs7QUFFekY7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBVztBQUM5QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSw4REFBVztBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLm1qcz9hNzE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhcnNlIGxpbmsgdGl0bGVcbi8vXG5cbmltcG9ydCB7IHVuZXNjYXBlQWxsIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuLy8gUGFyc2UgbGluayB0aXRsZSB3aXRoaW4gYHN0cmAgaW4gW3N0YXJ0LCBtYXhdIHJhbmdlLFxuLy8gb3IgY29udGludWUgcHJldmlvdXMgcGFyc2luZyBpZiBgcHJldl9zdGF0ZWAgaXMgZGVmaW5lZCAoZXF1YWwgdG8gcmVzdWx0IG9mIGxhc3QgZXhlY3V0aW9uKS5cbi8vXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZUxpbmtUaXRsZSAoc3RyLCBzdGFydCwgbWF4LCBwcmV2X3N0YXRlKSB7XG4gIGxldCBjb2RlXG4gIGxldCBwb3MgPSBzdGFydFxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIC8vIGlmIGB0cnVlYCwgdGhpcyBpcyBhIHZhbGlkIGxpbmsgdGl0bGVcbiAgICBvazogZmFsc2UsXG4gICAgLy8gaWYgYHRydWVgLCB0aGlzIGxpbmsgY2FuIGJlIGNvbnRpbnVlZCBvbiB0aGUgbmV4dCBsaW5lXG4gICAgY2FuX2NvbnRpbnVlOiBmYWxzZSxcbiAgICAvLyBpZiBgb2tgLCBpdCdzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGFmdGVyIHRoZSBjbG9zaW5nIG1hcmtlclxuICAgIHBvczogMCxcbiAgICAvLyBpZiBgb2tgLCBpdCdzIHRoZSB1bmVzY2FwZWQgdGl0bGVcbiAgICBzdHI6ICcnLFxuICAgIC8vIGV4cGVjdGVkIGNsb3NpbmcgbWFya2VyIGNoYXJhY3RlciBjb2RlXG4gICAgbWFya2VyOiAwXG4gIH1cblxuICBpZiAocHJldl9zdGF0ZSkge1xuICAgIC8vIHRoaXMgaXMgYSBjb250aW51YXRpb24gb2YgYSBwcmV2aW91cyBwYXJzZUxpbmtUaXRsZSBjYWxsIG9uIHRoZSBuZXh0IGxpbmUsXG4gICAgLy8gdXNlZCBpbiByZWZlcmVuY2UgbGlua3Mgb25seVxuICAgIHN0YXRlLnN0ciA9IHByZXZfc3RhdGUuc3RyXG4gICAgc3RhdGUubWFya2VyID0gcHJldl9zdGF0ZS5tYXJrZXJcbiAgfSBlbHNlIHtcbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gc3RhdGUgfVxuXG4gICAgbGV0IG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICBpZiAobWFya2VyICE9PSAweDIyIC8qIFwiICovICYmIG1hcmtlciAhPT0gMHgyNyAvKiAnICovICYmIG1hcmtlciAhPT0gMHgyOCAvKiAoICovKSB7IHJldHVybiBzdGF0ZSB9XG5cbiAgICBzdGFydCsrXG4gICAgcG9zKytcblxuICAgIC8vIGlmIG9wZW5pbmcgbWFya2VyIGlzIFwiKFwiLCBzd2l0Y2ggaXQgdG8gY2xvc2luZyBtYXJrZXIgXCIpXCJcbiAgICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4MjkgfVxuXG4gICAgc3RhdGUubWFya2VyID0gbWFya2VyXG4gIH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICBpZiAoY29kZSA9PT0gc3RhdGUubWFya2VyKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBwb3MgKyAxXG4gICAgICBzdGF0ZS5zdHIgKz0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0LCBwb3MpKVxuICAgICAgc3RhdGUub2sgPSB0cnVlXG4gICAgICByZXR1cm4gc3RhdGVcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLyAmJiBzdGF0ZS5tYXJrZXIgPT09IDB4MjkgLyogKSAqLykge1xuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcysrXG4gICAgfVxuXG4gICAgcG9zKytcbiAgfVxuXG4gIC8vIG5vIGNsb3NpbmcgbWFya2VyIGZvdW5kLCBidXQgdGhpcyBsaW5rIHRpdGxlIG1heSBjb250aW51ZSBvbiB0aGUgbmV4dCBsaW5lIChmb3IgcmVmZXJlbmNlcylcbiAgc3RhdGUuY2FuX2NvbnRpbnVlID0gdHJ1ZVxuICBzdGF0ZS5zdHIgKz0gdW5lc2NhcGVBbGwoc3RyLnNsaWNlKHN0YXJ0LCBwb3MpKVxuICByZXR1cm4gc3RhdGVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/helpers/parse_link_title.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/markdown-it/lib/index.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n/* harmony import */ var _helpers_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/index.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/helpers/index.mjs\");\n/* harmony import */ var _renderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/renderer.mjs\");\n/* harmony import */ var _parser_core_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser_core.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/parser_core.mjs\");\n/* harmony import */ var _parser_block_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser_block.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/parser_block.mjs\");\n/* harmony import */ var _parser_inline_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser_inline.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/parser_inline.mjs\");\n/* harmony import */ var linkify_it__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! linkify-it */ \"(app-pages-browser)/./node_modules/linkify-it/index.mjs\");\n/* harmony import */ var mdurl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! mdurl */ \"(app-pages-browser)/./node_modules/mdurl/index.mjs\");\n/* harmony import */ var punycode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! punycode.js */ \"(app-pages-browser)/./node_modules/punycode.js/punycode.es6.js\");\n/* harmony import */ var _presets_default_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./presets/default.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/presets/default.mjs\");\n/* harmony import */ var _presets_zero_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./presets/zero.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/presets/zero.mjs\");\n/* harmony import */ var _presets_commonmark_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./presets/commonmark.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/presets/commonmark.mjs\");\n// Main parser class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst config = {\n  default: _presets_default_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n  zero: _presets_zero_mjs__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n  commonmark: _presets_commonmark_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"]\n}\n\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nconst BAD_PROTO_RE = /^(vbscript|javascript|file|data):/\nconst GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/\n\nfunction validateLink (url) {\n  // url should be normalized at this point, and existing entities are decoded\n  const str = url.trim().toLowerCase()\n\n  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true\n}\n\nconst RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:']\n\nfunction normalizeLink (url) {\n  const parsed = mdurl__WEBPACK_IMPORTED_MODULE_7__.parse(url, true)\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].toASCII(parsed.hostname)\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl__WEBPACK_IMPORTED_MODULE_7__.encode(mdurl__WEBPACK_IMPORTED_MODULE_7__.format(parsed))\n}\n\nfunction normalizeLinkText (url) {\n  const parsed = mdurl__WEBPACK_IMPORTED_MODULE_7__.parse(url, true)\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].toUnicode(parsed.hostname)\n      } catch (er) { /**/ }\n    }\n  }\n\n  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720\n  return mdurl__WEBPACK_IMPORTED_MODULE_7__.decode(mdurl__WEBPACK_IMPORTED_MODULE_7__.format(parsed), mdurl__WEBPACK_IMPORTED_MODULE_7__.decode.defaultChars + '%')\n}\n\n/**\n * class MarkdownIt\n *\n * Main parser/renderer class.\n *\n * ##### Usage\n *\n * ```javascript\n * // node.js, \"classic\" way:\n * var MarkdownIt = require('markdown-it'),\n *     md = new MarkdownIt();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // node.js, the same, but with sugar:\n * var md = require('markdown-it')();\n * var result = md.render('# markdown-it rulezz!');\n *\n * // browser without AMD, added to \"window\" on script load\n * // Note, there are no dash.\n * var md = window.markdownit();\n * var result = md.render('# markdown-it rulezz!');\n * ```\n *\n * Single line rendering, without paragraph wrap:\n *\n * ```javascript\n * var md = require('markdown-it')();\n * var result = md.renderInline('__markdown-it__ rulezz!');\n * ```\n **/\n\n/**\n * new MarkdownIt([presetName, options])\n * - presetName (String): optional, `commonmark` / `zero`\n * - options (Object)\n *\n * Creates parser instanse with given config. Can be called without `new`.\n *\n * ##### presetName\n *\n * MarkdownIt provides named presets as a convenience to quickly\n * enable/disable active syntax rules and options for common use cases.\n *\n * - [\"commonmark\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.mjs) -\n *   configures parser to strict [CommonMark](http://commonmark.org/) mode.\n * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.mjs) -\n *   similar to GFM, used when no preset name given. Enables all available rules,\n *   but still without html, typographer & autolinker.\n * - [\"zero\"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.mjs) -\n *   all rules disabled. Useful to quickly setup your config via `.enable()`.\n *   For example, when you need only `bold` and `italic` markup and nothing else.\n *\n * ##### options:\n *\n * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!\n *   That's not safe! You may need external sanitizer to protect output from XSS.\n *   It's better to extend features via plugins, instead of enabling HTML.\n * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags\n *   (`<br />`). This is needed only for full CommonMark compatibility. In real\n *   world you will need HTML output.\n * - __breaks__ - `false`. Set `true` to convert `\\n` in paragraphs into `<br>`.\n * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.\n *   Can be useful for external highlighters.\n * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.\n * - __typographer__  - `false`. Set `true` to enable [some language-neutral\n *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.mjs) +\n *   quotes beautification (smartquotes).\n * - __quotes__ - ``, String or Array. Double + single quotes replacement\n *   pairs, when typographer enabled and smartquotes on. For example, you can\n *   use `''` for Russian, `''` for German, and\n *   `['\\xA0', '\\xA0', '\\xA0', '\\xA0']` for French (including nbsp).\n * - __highlight__ - `null`. Highlighter function for fenced code blocks.\n *   Highlighter `function (str, lang)` should return escaped HTML. It can also\n *   return empty string if the source was not changed and should be escaped\n *   externaly. If result starts with <pre... internal wrapper is skipped.\n *\n * ##### Example\n *\n * ```javascript\n * // commonmark mode\n * var md = require('markdown-it')('commonmark');\n *\n * // default mode\n * var md = require('markdown-it')();\n *\n * // enable everything\n * var md = require('markdown-it')({\n *   html: true,\n *   linkify: true,\n *   typographer: true\n * });\n * ```\n *\n * ##### Syntax highlighting\n *\n * ```js\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;\n *       } catch (__) {}\n *     }\n *\n *     return ''; // use external default escaping\n *   }\n * });\n * ```\n *\n * Or with full wrapper override (if you need assign class to `<pre>` or `<code>`):\n *\n * ```javascript\n * var hljs = require('highlight.js') // https://highlightjs.org/\n *\n * // Actual default values\n * var md = require('markdown-it')({\n *   highlight: function (str, lang) {\n *     if (lang && hljs.getLanguage(lang)) {\n *       try {\n *         return '<pre><code class=\"hljs\">' +\n *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +\n *                '</code></pre>';\n *       } catch (__) {}\n *     }\n *\n *     return '<pre><code class=\"hljs\">' + md.utils.escapeHtml(str) + '</code></pre>';\n *   }\n * });\n * ```\n *\n **/\nfunction MarkdownIt (presetName, options) {\n  if (!(this instanceof MarkdownIt)) {\n    return new MarkdownIt(presetName, options)\n  }\n\n  if (!options) {\n    if (!_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(presetName)) {\n      options = presetName || {}\n      presetName = 'default'\n    }\n  }\n\n  /**\n   * MarkdownIt#inline -> ParserInline\n   *\n   * Instance of [[ParserInline]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.inline = new _parser_inline_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()\n\n  /**\n   * MarkdownIt#block -> ParserBlock\n   *\n   * Instance of [[ParserBlock]]. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.block = new _parser_block_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]()\n\n  /**\n   * MarkdownIt#core -> Core\n   *\n   * Instance of [[Core]] chain executor. You may need it to add new rules when\n   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and\n   * [[MarkdownIt.enable]].\n   **/\n  this.core = new _parser_core_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]()\n\n  /**\n   * MarkdownIt#renderer -> Renderer\n   *\n   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering\n   * rules for new token types, generated by plugins.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * function myToken(tokens, idx, options, env, self) {\n   *   //...\n   *   return result;\n   * };\n   *\n   * md.renderer.rules['my_token'] = myToken\n   * ```\n   *\n   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs).\n   **/\n  this.renderer = new _renderer_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()\n\n  /**\n   * MarkdownIt#linkify -> LinkifyIt\n   *\n   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.\n   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.mjs)\n   * rule.\n   **/\n  this.linkify = new linkify_it__WEBPACK_IMPORTED_MODULE_6__[\"default\"]()\n\n  /**\n   * MarkdownIt#validateLink(url) -> Boolean\n   *\n   * Link validation function. CommonMark allows too much in links. By default\n   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas\n   * except some embedded image types.\n   *\n   * You can change this behaviour:\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   * // enable everything\n   * md.validateLink = function () { return true; }\n   * ```\n   **/\n  this.validateLink = validateLink\n\n  /**\n   * MarkdownIt#normalizeLink(url) -> String\n   *\n   * Function used to encode link url to a machine-readable format,\n   * which includes url-encoding, punycode, etc.\n   **/\n  this.normalizeLink = normalizeLink\n\n  /**\n   * MarkdownIt#normalizeLinkText(url) -> String\n   *\n   * Function used to decode link url to a human-readable format`\n   **/\n  this.normalizeLinkText = normalizeLinkText\n\n  // Expose utils & helpers for easy acces from plugins\n\n  /**\n   * MarkdownIt#utils -> utils\n   *\n   * Assorted utility functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.mjs).\n   **/\n  this.utils = _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__\n\n  /**\n   * MarkdownIt#helpers -> helpers\n   *\n   * Link components parser functions, useful to write plugins. See details\n   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).\n   **/\n  this.helpers = _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, _helpers_index_mjs__WEBPACK_IMPORTED_MODULE_1__)\n\n  this.options = {}\n  this.configure(presetName)\n\n  if (options) { this.set(options) }\n}\n\n/** chainable\n * MarkdownIt.set(options)\n *\n * Set parser options (in the same format as in constructor). Probably, you\n * will never need it, but you can change options after constructor call.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .set({ html: true, breaks: true })\n *             .set({ typographer, true });\n * ```\n *\n * __Note:__ To achieve the best possible performance, don't modify a\n * `markdown-it` instance options on the fly. If you need multiple configurations\n * it's best to create multiple instances and initialize each with separate\n * config.\n **/\nMarkdownIt.prototype.set = function (options) {\n  _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.assign(this.options, options)\n  return this\n}\n\n/** chainable, internal\n * MarkdownIt.configure(presets)\n *\n * Batch load of all options and compenent settings. This is internal method,\n * and you probably will not need it. But if you will - see available presets\n * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)\n *\n * We strongly recommend to use presets instead of direct config loads. That\n * will give better compatibility with next versions.\n **/\nMarkdownIt.prototype.configure = function (presets) {\n  const self = this\n\n  if (_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(presets)) {\n    const presetName = presets\n    presets = config[presetName]\n    if (!presets) { throw new Error('Wrong `markdown-it` preset \"' + presetName + '\", check name') }\n  }\n\n  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\\'t be empty') }\n\n  if (presets.options) { self.set(presets.options) }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enableOnly(presets.components[name].rules)\n      }\n      if (presets.components[name].rules2) {\n        self[name].ruler2.enableOnly(presets.components[name].rules2)\n      }\n    })\n  }\n  return this\n}\n\n/** chainable\n * MarkdownIt.enable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to enable\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable list or rules. It will automatically find appropriate components,\n * containing rules with given names. If rule not found, and `ignoreInvalid`\n * not set - throws exception.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')()\n *             .enable(['sub', 'sup'])\n *             .disable('smartquotes');\n * ```\n **/\nMarkdownIt.prototype.enable = function (list, ignoreInvalid) {\n  let result = []\n\n  if (!Array.isArray(list)) { list = [list] }\n\n  ['core', 'block', 'inline'].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.enable(list, true))\n  }, this)\n\n  result = result.concat(this.inline.ruler2.enable(list, true))\n\n  const missed = list.filter(function (name) { return result.indexOf(name) < 0 })\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed)\n  }\n\n  return this\n}\n\n/** chainable\n * MarkdownIt.disable(list, ignoreInvalid)\n * - list (String|Array): rule name or list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * The same as [[MarkdownIt.enable]], but turn specified rules off.\n **/\nMarkdownIt.prototype.disable = function (list, ignoreInvalid) {\n  let result = []\n\n  if (!Array.isArray(list)) { list = [list] }\n\n  ['core', 'block', 'inline'].forEach(function (chain) {\n    result = result.concat(this[chain].ruler.disable(list, true))\n  }, this)\n\n  result = result.concat(this.inline.ruler2.disable(list, true))\n\n  const missed = list.filter(function (name) { return result.indexOf(name) < 0 })\n\n  if (missed.length && !ignoreInvalid) {\n    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed)\n  }\n  return this\n}\n\n/** chainable\n * MarkdownIt.use(plugin, params)\n *\n * Load specified plugin with given params into current parser instance.\n * It's just a sugar to call `plugin(md, params)` with curring.\n *\n * ##### Example\n *\n * ```javascript\n * var iterator = require('markdown-it-for-inline');\n * var md = require('markdown-it')()\n *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {\n *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');\n *             });\n * ```\n **/\nMarkdownIt.prototype.use = function (plugin /*, params, ... */) {\n  const args = [this].concat(Array.prototype.slice.call(arguments, 1))\n  plugin.apply(plugin, args)\n  return this\n}\n\n/** internal\n * MarkdownIt.parse(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Parse input string and return list of block tokens (special token type\n * \"inline\" will contain list of inline tokens). You should not call this\n * method directly, until you write custom renderer (for example, to produce\n * AST).\n *\n * `env` is used to pass data between \"distributed\" rules and return additional\n * metadata like reference info, needed for the renderer. It also can be used to\n * inject data in specific cases. Usually, you will be ok to pass `{}`,\n * and then pass updated object to renderer.\n **/\nMarkdownIt.prototype.parse = function (src, env) {\n  if (typeof src !== 'string') {\n    throw new Error('Input data should be a String')\n  }\n\n  const state = new this.core.State(src, this, env)\n\n  this.core.process(state)\n\n  return state.tokens\n}\n\n/**\n * MarkdownIt.render(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Render markdown string into html. It does all magic for you :).\n *\n * `env` can be used to inject additional metadata (`{}` by default).\n * But you will not need it with high probability. See also comment\n * in [[MarkdownIt.parse]].\n **/\nMarkdownIt.prototype.render = function (src, env) {\n  env = env || {}\n\n  return this.renderer.render(this.parse(src, env), this.options, env)\n}\n\n/** internal\n * MarkdownIt.parseInline(src, env) -> Array\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the\n * block tokens list with the single `inline` element, containing parsed inline\n * tokens in `children` property. Also updates `env` object.\n **/\nMarkdownIt.prototype.parseInline = function (src, env) {\n  const state = new this.core.State(src, this, env)\n\n  state.inlineMode = true\n  this.core.process(state)\n\n  return state.tokens\n}\n\n/**\n * MarkdownIt.renderInline(src [, env]) -> String\n * - src (String): source string\n * - env (Object): environment sandbox\n *\n * Similar to [[MarkdownIt.render]] but for single paragraph content. Result\n * will NOT be wrapped into `<p>` tags.\n **/\nMarkdownIt.prototype.renderInline = function (src, env) {\n  env = env || {}\n\n  return this.renderer.render(this.parseInline(src, env), this.options, env)\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MarkdownIt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFMkM7QUFDRztBQUNUO0FBQ0s7QUFDRTtBQUNFO0FBQ1o7QUFDSjtBQUNJOztBQUVhO0FBQ047QUFDWTs7QUFFckQ7QUFDQSxXQUFXLDREQUFXO0FBQ3RCLFFBQVEsMERBQVE7QUFDaEIsY0FBYyxnRUFBYztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIsd0NBQVc7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyREFBZ0I7QUFDMUMsUUFBUSxhQUFhO0FBQ3JCO0FBQ0E7O0FBRUEsU0FBUyx5Q0FBWSxDQUFDLHlDQUFZO0FBQ2xDOztBQUVBO0FBQ0EsaUJBQWlCLHdDQUFXOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkRBQWtCO0FBQzVDLFFBQVEsYUFBYTtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5Q0FBWSxDQUFDLHlDQUFZLFVBQVUseUNBQVk7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsV0FBVztBQUNYO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0NBQXNDO0FBQzlFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVc7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFVOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFTOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFLOztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVksR0FBRyxFQUFFLCtDQUFPOztBQUV6QztBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxREFBWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sdURBQWM7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQSxrQkFBa0I7O0FBRWxCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSwrQ0FBK0MsaUNBQWlDOztBQUVoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQSwrQ0FBK0MsaUNBQWlDOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaW5kZXgubWpzPzJkOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFpbiBwYXJzZXIgY2xhc3NcblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi9jb21tb24vdXRpbHMubWpzJ1xuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tICcuL2hlbHBlcnMvaW5kZXgubWpzJ1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIubWpzJ1xuaW1wb3J0IFBhcnNlckNvcmUgZnJvbSAnLi9wYXJzZXJfY29yZS5tanMnXG5pbXBvcnQgUGFyc2VyQmxvY2sgZnJvbSAnLi9wYXJzZXJfYmxvY2subWpzJ1xuaW1wb3J0IFBhcnNlcklubGluZSBmcm9tICcuL3BhcnNlcl9pbmxpbmUubWpzJ1xuaW1wb3J0IExpbmtpZnlJdCBmcm9tICdsaW5raWZ5LWl0J1xuaW1wb3J0ICogYXMgbWR1cmwgZnJvbSAnbWR1cmwnXG5pbXBvcnQgcHVueWNvZGUgZnJvbSAncHVueWNvZGUuanMnXG5cbmltcG9ydCBjZmdfZGVmYXVsdCBmcm9tICcuL3ByZXNldHMvZGVmYXVsdC5tanMnXG5pbXBvcnQgY2ZnX3plcm8gZnJvbSAnLi9wcmVzZXRzL3plcm8ubWpzJ1xuaW1wb3J0IGNmZ19jb21tb25tYXJrIGZyb20gJy4vcHJlc2V0cy9jb21tb25tYXJrLm1qcydcblxuY29uc3QgY29uZmlnID0ge1xuICBkZWZhdWx0OiBjZmdfZGVmYXVsdCxcbiAgemVybzogY2ZnX3plcm8sXG4gIGNvbW1vbm1hcms6IGNmZ19jb21tb25tYXJrXG59XG5cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbmNvbnN0IEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovXG5jb25zdCBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy9cblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rICh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICBjb25zdCBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKClcblxuICByZXR1cm4gQkFEX1BST1RPX1JFLnRlc3Qoc3RyKSA/IEdPT0RfREFUQV9SRS50ZXN0KHN0cikgOiB0cnVlXG59XG5cbmNvbnN0IFJFQ09ERV9IT1NUTkFNRV9GT1IgPSBbJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86J11cblxuZnVuY3Rpb24gbm9ybWFsaXplTGluayAodXJsKSB7XG4gIGNvbnN0IHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSlcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKVxuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTGlua1RleHQgKHVybCkge1xuICBjb25zdCBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpXG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKVxuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkICclJyB0byBleGNsdWRlIGxpc3QgYmVjYXVzZSBvZiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzcyMFxuICByZXR1cm4gbWR1cmwuZGVjb2RlKG1kdXJsLmZvcm1hdChwYXJzZWQpLCBtZHVybC5kZWNvZGUuZGVmYXVsdENoYXJzICsgJyUnKVxufVxuXG4vKipcbiAqIGNsYXNzIE1hcmtkb3duSXRcbiAqXG4gKiBNYWluIHBhcnNlci9yZW5kZXJlciBjbGFzcy5cbiAqXG4gKiAjIyMjIyBVc2FnZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIG5vZGUuanMsIFwiY2xhc3NpY1wiIHdheTpcbiAqIHZhciBNYXJrZG93bkl0ID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSxcbiAqICAgICBtZCA9IG5ldyBNYXJrZG93bkl0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBub2RlLmpzLCB0aGUgc2FtZSwgYnV0IHdpdGggc3VnYXI6XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqXG4gKiAvLyBicm93c2VyIHdpdGhvdXQgQU1ELCBhZGRlZCB0byBcIndpbmRvd1wiIG9uIHNjcmlwdCBsb2FkXG4gKiAvLyBOb3RlLCB0aGVyZSBhcmUgbm8gZGFzaC5cbiAqIHZhciBtZCA9IHdpbmRvdy5tYXJrZG93bml0KCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVyKCcjIG1hcmtkb3duLWl0IHJ1bGV6eiEnKTtcbiAqIGBgYFxuICpcbiAqIFNpbmdsZSBsaW5lIHJlbmRlcmluZywgd2l0aG91dCBwYXJhZ3JhcGggd3JhcDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKCdfX21hcmtkb3duLWl0X18gcnVsZXp6IScpO1xuICogYGBgXG4gKiovXG5cbi8qKlxuICogbmV3IE1hcmtkb3duSXQoW3ByZXNldE5hbWUsIG9wdGlvbnNdKVxuICogLSBwcmVzZXROYW1lIChTdHJpbmcpOiBvcHRpb25hbCwgYGNvbW1vbm1hcmtgIC8gYHplcm9gXG4gKiAtIG9wdGlvbnMgKE9iamVjdClcbiAqXG4gKiBDcmVhdGVzIHBhcnNlciBpbnN0YW5zZSB3aXRoIGdpdmVuIGNvbmZpZy4gQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgLlxuICpcbiAqICMjIyMjIHByZXNldE5hbWVcbiAqXG4gKiBNYXJrZG93bkl0IHByb3ZpZGVzIG5hbWVkIHByZXNldHMgYXMgYSBjb252ZW5pZW5jZSB0byBxdWlja2x5XG4gKiBlbmFibGUvZGlzYWJsZSBhY3RpdmUgc3ludGF4IHJ1bGVzIGFuZCBvcHRpb25zIGZvciBjb21tb24gdXNlIGNhc2VzLlxuICpcbiAqIC0gW1wiY29tbW9ubWFya1wiXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3ByZXNldHMvY29tbW9ubWFyay5tanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQubWpzKSAtXG4gKiAgIHNpbWlsYXIgdG8gR0ZNLCB1c2VkIHdoZW4gbm8gcHJlc2V0IG5hbWUgZ2l2ZW4uIEVuYWJsZXMgYWxsIGF2YWlsYWJsZSBydWxlcyxcbiAqICAgYnV0IHN0aWxsIHdpdGhvdXQgaHRtbCwgdHlwb2dyYXBoZXIgJiBhdXRvbGlua2VyLlxuICogLSBbXCJ6ZXJvXCJdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcHJlc2V0cy96ZXJvLm1qcykgLVxuICogICBhbGwgcnVsZXMgZGlzYWJsZWQuIFVzZWZ1bCB0byBxdWlja2x5IHNldHVwIHlvdXIgY29uZmlnIHZpYSBgLmVuYWJsZSgpYC5cbiAqICAgRm9yIGV4YW1wbGUsIHdoZW4geW91IG5lZWQgb25seSBgYm9sZGAgYW5kIGBpdGFsaWNgIG1hcmt1cCBhbmQgbm90aGluZyBlbHNlLlxuICpcbiAqICMjIyMjIG9wdGlvbnM6XG4gKlxuICogLSBfX2h0bWxfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2UuIEJlIGNhcmVmdWwhXG4gKiAgIFRoYXQncyBub3Qgc2FmZSEgWW91IG1heSBuZWVkIGV4dGVybmFsIHNhbml0aXplciB0byBwcm90ZWN0IG91dHB1dCBmcm9tIFhTUy5cbiAqICAgSXQncyBiZXR0ZXIgdG8gZXh0ZW5kIGZlYXR1cmVzIHZpYSBwbHVnaW5zLCBpbnN0ZWFkIG9mIGVuYWJsaW5nIEhUTUwuXG4gKiAtIF9feGh0bWxPdXRfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYWRkICcvJyB3aGVuIGNsb3Npbmcgc2luZ2xlIHRhZ3NcbiAqICAgKGA8YnIgLz5gKS4gVGhpcyBpcyBuZWVkZWQgb25seSBmb3IgZnVsbCBDb21tb25NYXJrIGNvbXBhdGliaWxpdHkuIEluIHJlYWxcbiAqICAgd29ybGQgeW91IHdpbGwgbmVlZCBIVE1MIG91dHB1dC5cbiAqIC0gX19icmVha3NfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gY29udmVydCBgXFxuYCBpbiBwYXJhZ3JhcGhzIGludG8gYDxicj5gLlxuICogLSBfX2xhbmdQcmVmaXhfXyAtIGBsYW5ndWFnZS1gLiBDU1MgbGFuZ3VhZ2UgY2xhc3MgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzLlxuICogICBDYW4gYmUgdXNlZnVsIGZvciBleHRlcm5hbCBoaWdobGlnaHRlcnMuXG4gKiAtIF9fbGlua2lmeV9fIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0IHRvIGxpbmtzLlxuICogLSBfX3R5cG9ncmFwaGVyX18gIC0gYGZhbHNlYC4gU2V0IGB0cnVlYCB0byBlbmFibGUgW3NvbWUgbGFuZ3VhZ2UtbmV1dHJhbFxuICogICByZXBsYWNlbWVudF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cy5tanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KHN0ciwgeyBsYW5ndWFnZTogbGFuZywgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmAgb3IgYDxjb2RlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiaGxqc1wiPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQoc3RyLCB7IGxhbmd1YWdlOiBsYW5nLCBpZ25vcmVJbGxlZ2FsczogdHJ1ZSB9KS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImhsanNcIj4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQgKHByZXNldE5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hcmtkb3duSXQpKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrZG93bkl0KHByZXNldE5hbWUsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fVxuICAgICAgcHJlc2V0TmFtZSA9ICdkZWZhdWx0J1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2lubGluZSAtPiBQYXJzZXJJbmxpbmVcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJJbmxpbmVdXS4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuaW5saW5lID0gbmV3IFBhcnNlcklubGluZSgpXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjY29yZSAtPiBDb3JlXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbQ29yZV1dIGNoYWluIGV4ZWN1dG9yLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5jb3JlID0gbmV3IFBhcnNlckNvcmUoKVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3JlbmRlcmVyIC0+IFJlbmRlcmVyXG4gICAqXG4gICAqIEluc3RhbmNlIG9mIFtbUmVuZGVyZXJdXS4gVXNlIGl0IHRvIG1vZGlmeSBvdXRwdXQgbG9vay4gT3IgdG8gYWRkIHJlbmRlcmluZ1xuICAgKiBydWxlcyBmb3IgbmV3IHRva2VuIHR5cGVzLCBnZW5lcmF0ZWQgYnkgcGx1Z2lucy5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogZnVuY3Rpb24gbXlUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzZWxmKSB7XG4gICAqICAgLy8uLi5cbiAgICogICByZXR1cm4gcmVzdWx0O1xuICAgKiB9O1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlc1snbXlfdG9rZW4nXSA9IG15VG9rZW5cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbW1JlbmRlcmVyXV0gZG9jcyBhbmQgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLm1qcykuXG4gICAqKi9cbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcigpXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbGlua2lmeSAtPiBMaW5raWZ5SXRcbiAgICpcbiAgICogW2xpbmtpZnktaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0KSBpbnN0YW5jZS5cbiAgICogVXNlZCBieSBbbGlua2lmeV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9ydWxlc19jb3JlL2xpbmtpZnkubWpzKVxuICAgKiBydWxlLlxuICAgKiovXG4gIHRoaXMubGlua2lmeSA9IG5ldyBMaW5raWZ5SXQoKVxuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3ZhbGlkYXRlTGluayh1cmwpIC0+IEJvb2xlYW5cbiAgICpcbiAgICogTGluayB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBDb21tb25NYXJrIGFsbG93cyB0b28gbXVjaCBpbiBsaW5rcy4gQnkgZGVmYXVsdFxuICAgKiB3ZSBkaXNhYmxlIGBqYXZhc2NyaXB0OmAsIGB2YnNjcmlwdDpgLCBgZmlsZTpgIHNjaGVtYXMsIGFuZCBhbG1vc3QgYWxsIGBkYXRhOi4uLmAgc2NoZW1hc1xuICAgKiBleGNlcHQgc29tZSBlbWJlZGRlZCBpbWFnZSB0eXBlcy5cbiAgICpcbiAgICogWW91IGNhbiBjaGFuZ2UgdGhpcyBiZWhhdmlvdXI6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICAgKiBtZC52YWxpZGF0ZUxpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9XG4gICAqIGBgYFxuICAgKiovXG4gIHRoaXMudmFsaWRhdGVMaW5rID0gdmFsaWRhdGVMaW5rXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGlua1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I25vcm1hbGl6ZUxpbmtUZXh0KHVybCkgLT4gU3RyaW5nXG4gICAqXG4gICAqIEZ1bmN0aW9uIHVzZWQgdG8gZGVjb2RlIGxpbmsgdXJsIHRvIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0YFxuICAgKiovXG4gIHRoaXMubm9ybWFsaXplTGlua1RleHQgPSBub3JtYWxpemVMaW5rVGV4dFxuXG4gIC8vIEV4cG9zZSB1dGlscyAmIGhlbHBlcnMgZm9yIGVhc3kgYWNjZXMgZnJvbSBwbHVnaW5zXG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdXRpbHMgLT4gdXRpbHNcbiAgICpcbiAgICogQXNzb3J0ZWQgdXRpbGl0eSBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9jb21tb24vdXRpbHMubWpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHNcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNoZWxwZXJzIC0+IGhlbHBlcnNcbiAgICpcbiAgICogTGluayBjb21wb25lbnRzIHBhcnNlciBmdW5jdGlvbnMsIHVzZWZ1bCB0byB3cml0ZSBwbHVnaW5zLiBTZWUgZGV0YWlsc1xuICAgKiBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9oZWxwZXJzKS5cbiAgICoqL1xuICB0aGlzLmhlbHBlcnMgPSB1dGlscy5hc3NpZ24oe30sIGhlbHBlcnMpXG5cbiAgdGhpcy5vcHRpb25zID0ge31cbiAgdGhpcy5jb25maWd1cmUocHJlc2V0TmFtZSlcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKSB9XG59XG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqIGNoYWluYWJsZSwgaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQuY29uZmlndXJlKHByZXNldHMpXG4gKlxuICogQmF0Y2ggbG9hZCBvZiBhbGwgb3B0aW9ucyBhbmQgY29tcGVuZW50IHNldHRpbmdzLiBUaGlzIGlzIGludGVybmFsIG1ldGhvZCxcbiAqIGFuZCB5b3UgcHJvYmFibHkgd2lsbCBub3QgbmVlZCBpdC4gQnV0IGlmIHlvdSB3aWxsIC0gc2VlIGF2YWlsYWJsZSBwcmVzZXRzXG4gKiBhbmQgZGF0YSBzdHJ1Y3R1cmUgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC90cmVlL21hc3Rlci9saWIvcHJlc2V0cylcbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIHByZXNldHMgaW5zdGVhZCBvZiBkaXJlY3QgY29uZmlnIGxvYWRzLiBUaGF0XG4gKiB3aWxsIGdpdmUgYmV0dGVyIGNvbXBhdGliaWxpdHkgd2l0aCBuZXh0IHZlcnNpb25zLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHByZXNldHMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBpZiAodXRpbHMuaXNTdHJpbmcocHJlc2V0cykpIHtcbiAgICBjb25zdCBwcmVzZXROYW1lID0gcHJlc2V0c1xuICAgIHByZXNldHMgPSBjb25maWdbcHJlc2V0TmFtZV1cbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJykgfVxuICB9XG5cbiAgaWYgKCFwcmVzZXRzKSB7IHRocm93IG5ldyBFcnJvcignV3JvbmcgYG1hcmtkb3duLWl0YCBwcmVzZXQsIGNhblxcJ3QgYmUgZW1wdHknKSB9XG5cbiAgaWYgKHByZXNldHMub3B0aW9ucykgeyBzZWxmLnNldChwcmVzZXRzLm9wdGlvbnMpIH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpXG4gICAgICB9XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzMikge1xuICAgICAgICBzZWxmW25hbWVdLnJ1bGVyMi5lbmFibGVPbmx5KHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKiogY2hhaW5hYmxlXG4gKiBNYXJrZG93bkl0LmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZVxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIGxpc3Qgb3IgcnVsZXMuIEl0IHdpbGwgYXV0b21hdGljYWxseSBmaW5kIGFwcHJvcHJpYXRlIGNvbXBvbmVudHMsXG4gKiBjb250YWluaW5nIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIHJ1bGUgbm90IGZvdW5kLCBhbmQgYGlnbm9yZUludmFsaWRgXG4gKiBub3Qgc2V0IC0gdGhyb3dzIGV4Y2VwdGlvbi5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAuZW5hYmxlKFsnc3ViJywgJ3N1cCddKVxuICogICAgICAgICAgICAgLmRpc2FibGUoJ3NtYXJ0cXVvdGVzJyk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGxldCByZXN1bHQgPSBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gW2xpc3RdIH1cblxuICBbJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXNbY2hhaW5dLnJ1bGVyLmVuYWJsZShsaXN0LCB0cnVlKSlcbiAgfSwgdGhpcylcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpXG5cbiAgY29uc3QgbWlzc2VkID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHJlc3VsdC5pbmRleE9mKG5hbWUpIDwgMCB9KVxuXG4gIGlmIChtaXNzZWQubGVuZ3RoICYmICFpZ25vcmVJbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZG93bkl0LiBGYWlsZWQgdG8gZW5hYmxlIHVua25vd24gcnVsZShzKTogJyArIG1pc3NlZClcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgbGV0IHJlc3VsdCA9IFtdXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbbGlzdF0gfVxuXG4gIFsnY29yZScsICdibG9jaycsICdpbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSlcbiAgfSwgdGhpcylcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5kaXNhYmxlKGxpc3QsIHRydWUpKVxuXG4gIGNvbnN0IG1pc3NlZCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiByZXN1bHQuaW5kZXhPZihuYW1lKSA8IDAgfSlcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQudXNlKHBsdWdpbiwgcGFyYW1zKVxuICpcbiAqIExvYWQgc3BlY2lmaWVkIHBsdWdpbiB3aXRoIGdpdmVuIHBhcmFtcyBpbnRvIGN1cnJlbnQgcGFyc2VyIGluc3RhbmNlLlxuICogSXQncyBqdXN0IGEgc3VnYXIgdG8gY2FsbCBgcGx1Z2luKG1kLCBwYXJhbXMpYCB3aXRoIGN1cnJpbmcuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBpdGVyYXRvciA9IHJlcXVpcmUoJ21hcmtkb3duLWl0LWZvci1pbmxpbmUnKTtcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnVzZShpdGVyYXRvciwgJ2Zvb19yZXBsYWNlJywgJ3RleHQnLCBmdW5jdGlvbiAodG9rZW5zLCBpZHgpIHtcbiAqICAgICAgICAgICAgICAgdG9rZW5zW2lkeF0uY29udGVudCA9IHRva2Vuc1tpZHhdLmNvbnRlbnQucmVwbGFjZSgvZm9vL2csICdiYXInKTtcbiAqICAgICAgICAgICAgIH0pO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luIC8qLCBwYXJhbXMsIC4uLiAqLykge1xuICBjb25zdCBhcmdzID0gW3RoaXNdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2Uoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBQYXJzZSBpbnB1dCBzdHJpbmcgYW5kIHJldHVybiBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJylcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudilcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSlcblxuICByZXR1cm4gc3RhdGUudG9rZW5zXG59XG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXIoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogUmVuZGVyIG1hcmtkb3duIHN0cmluZyBpbnRvIGh0bWwuIEl0IGRvZXMgYWxsIG1hZ2ljIGZvciB5b3UgOikuXG4gKlxuICogYGVudmAgY2FuIGJlIHVzZWQgdG8gaW5qZWN0IGFkZGl0aW9uYWwgbWV0YWRhdGEgKGB7fWAgYnkgZGVmYXVsdCkuXG4gKiBCdXQgeW91IHdpbGwgbm90IG5lZWQgaXQgd2l0aCBoaWdoIHByb2JhYmlsaXR5LiBTZWUgYWxzbyBjb21tZW50XG4gKiBpbiBbW01hcmtkb3duSXQucGFyc2VdXS5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge31cblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KVxufVxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGNvbnN0IHN0YXRlID0gbmV3IHRoaXMuY29yZS5TdGF0ZShzcmMsIHRoaXMsIGVudilcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZVxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSlcblxuICByZXR1cm4gc3RhdGUudG9rZW5zXG59XG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudilcbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFya2Rvd25JdFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/parser_block.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_block.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ruler.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/ruler.mjs\");\n/* harmony import */ var _rules_block_state_block_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rules_block/state_block.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/state_block.mjs\");\n/* harmony import */ var _rules_block_table_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rules_block/table.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/table.mjs\");\n/* harmony import */ var _rules_block_code_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rules_block/code.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/code.mjs\");\n/* harmony import */ var _rules_block_fence_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules_block/fence.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/fence.mjs\");\n/* harmony import */ var _rules_block_blockquote_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rules_block/blockquote.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/blockquote.mjs\");\n/* harmony import */ var _rules_block_hr_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rules_block/hr.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/hr.mjs\");\n/* harmony import */ var _rules_block_list_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rules_block/list.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/list.mjs\");\n/* harmony import */ var _rules_block_reference_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rules_block/reference.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/reference.mjs\");\n/* harmony import */ var _rules_block_html_block_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rules_block/html_block.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/html_block.mjs\");\n/* harmony import */ var _rules_block_heading_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rules_block/heading.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/heading.mjs\");\n/* harmony import */ var _rules_block_lheading_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rules_block/lheading.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/lheading.mjs\");\n/* harmony import */ var _rules_block_paragraph_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./rules_block/paragraph.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/paragraph.mjs\");\n/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  ['table',      _rules_block_table_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"],      ['paragraph', 'reference']],\n  ['code',       _rules_block_code_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]],\n  ['fence',      _rules_block_fence_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"],      ['paragraph', 'reference', 'blockquote', 'list']],\n  ['blockquote', _rules_block_blockquote_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"], ['paragraph', 'reference', 'blockquote', 'list']],\n  ['hr',         _rules_block_hr_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"],         ['paragraph', 'reference', 'blockquote', 'list']],\n  ['list',       _rules_block_list_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"],       ['paragraph', 'reference', 'blockquote']],\n  ['reference',  _rules_block_reference_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"]],\n  ['html_block', _rules_block_html_block_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"], ['paragraph', 'reference', 'blockquote']],\n  ['heading',    _rules_block_heading_mjs__WEBPACK_IMPORTED_MODULE_10__[\"default\"],    ['paragraph', 'reference', 'blockquote']],\n  ['lheading',   _rules_block_lheading_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"]],\n  ['paragraph',  _rules_block_paragraph_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"]]\n]\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock () {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() })\n  }\n}\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  let line = startLine\n  let hasEmptyLines = false\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line)\n    if (line >= endLine) { break }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine\n      break\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n    const prevLine = state.line\n    let ok = false\n\n    for (let i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false)\n      if (ok) {\n        if (prevLine >= state.line) {\n          throw new Error(\"block rule didn't increment state.line\")\n        }\n        break\n      }\n    }\n\n    // this can only happen if user disables paragraph rule\n    if (!ok) throw new Error('none of the block rules matched')\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true\n    }\n\n    line = state.line\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true\n      line++\n      state.line = line\n    }\n  }\n}\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  if (!src) { return }\n\n  const state = new this.State(src, md, env, outTokens)\n\n  this.tokenize(state, state.line, state.lineMax)\n}\n\nParserBlock.prototype.State = _rules_block_state_block_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParserBlock);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ3VCOztBQUVUO0FBQ0Y7QUFDRTtBQUNVO0FBQ2hCO0FBQ0k7QUFDVTtBQUNFO0FBQ047QUFDRTtBQUNFOztBQUVyRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQU87QUFDeEIsaUJBQWlCLDZEQUFNO0FBQ3ZCLGlCQUFpQiw4REFBTztBQUN4QixpQkFBaUIsbUVBQVk7QUFDN0IsaUJBQWlCLDJEQUFJO0FBQ3JCLGlCQUFpQiw2REFBTTtBQUN2QixpQkFBaUIsa0VBQVc7QUFDNUIsaUJBQWlCLG1FQUFZO0FBQzdCLGlCQUFpQixpRUFBUztBQUMxQixpQkFBaUIsa0VBQVU7QUFDM0IsaUJBQWlCLG1FQUFXO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBSzs7QUFFeEIsa0JBQWtCLG1CQUFtQjtBQUNyQyxrREFBa0QsbUNBQW1DO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsb0VBQVU7O0FBRXhDLCtEQUFlLFdBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfYmxvY2subWpzPzZjODkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJCbG9ja1xuICpcbiAqIEJsb2NrLWxldmVsIHRva2VuaXplci5cbiAqKi9cblxuaW1wb3J0IFJ1bGVyIGZyb20gJy4vcnVsZXIubWpzJ1xuaW1wb3J0IFN0YXRlQmxvY2sgZnJvbSAnLi9ydWxlc19ibG9jay9zdGF0ZV9ibG9jay5tanMnXG5cbmltcG9ydCByX3RhYmxlIGZyb20gJy4vcnVsZXNfYmxvY2svdGFibGUubWpzJ1xuaW1wb3J0IHJfY29kZSBmcm9tICcuL3J1bGVzX2Jsb2NrL2NvZGUubWpzJ1xuaW1wb3J0IHJfZmVuY2UgZnJvbSAnLi9ydWxlc19ibG9jay9mZW5jZS5tanMnXG5pbXBvcnQgcl9ibG9ja3F1b3RlIGZyb20gJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZS5tanMnXG5pbXBvcnQgcl9ociBmcm9tICcuL3J1bGVzX2Jsb2NrL2hyLm1qcydcbmltcG9ydCByX2xpc3QgZnJvbSAnLi9ydWxlc19ibG9jay9saXN0Lm1qcydcbmltcG9ydCByX3JlZmVyZW5jZSBmcm9tICcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5tanMnXG5pbXBvcnQgcl9odG1sX2Jsb2NrIGZyb20gJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jay5tanMnXG5pbXBvcnQgcl9oZWFkaW5nIGZyb20gJy4vcnVsZXNfYmxvY2svaGVhZGluZy5tanMnXG5pbXBvcnQgcl9saGVhZGluZyBmcm9tICcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLm1qcydcbmltcG9ydCByX3BhcmFncmFwaCBmcm9tICcuL3J1bGVzX2Jsb2NrL3BhcmFncmFwaC5tanMnXG5cbmNvbnN0IF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbJ3RhYmxlJywgICAgICByX3RhYmxlLCAgICAgIFsncGFyYWdyYXBoJywgJ3JlZmVyZW5jZSddXSxcbiAgWydjb2RlJywgICAgICAgcl9jb2RlXSxcbiAgWydmZW5jZScsICAgICAgcl9mZW5jZSwgICAgICBbJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0J11dLFxuICBbJ2Jsb2NrcXVvdGUnLCByX2Jsb2NrcXVvdGUsIFsncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnXV0sXG4gIFsnaHInLCAgICAgICAgIHJfaHIsICAgICAgICAgWydwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCddXSxcbiAgWydsaXN0JywgICAgICAgcl9saXN0LCAgICAgICBbJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZSddXSxcbiAgWydyZWZlcmVuY2UnLCAgcl9yZWZlcmVuY2VdLFxuICBbJ2h0bWxfYmxvY2snLCByX2h0bWxfYmxvY2ssIFsncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJ11dLFxuICBbJ2hlYWRpbmcnLCAgICByX2hlYWRpbmcsICAgIFsncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJ11dLFxuICBbJ2xoZWFkaW5nJywgICByX2xoZWFkaW5nXSxcbiAgWydwYXJhZ3JhcGgnLCAgcl9wYXJhZ3JhcGhdXG5dXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrICgpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KVxuICB9XG59XG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICBjb25zdCBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpXG4gIGNvbnN0IGxlbiA9IHJ1bGVzLmxlbmd0aFxuICBjb25zdCBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nXG4gIGxldCBsaW5lID0gc3RhcnRMaW5lXG4gIGxldCBoYXNFbXB0eUxpbmVzID0gZmFsc2VcblxuICB3aGlsZSAobGluZSA8IGVuZExpbmUpIHtcbiAgICBzdGF0ZS5saW5lID0gbGluZSA9IHN0YXRlLnNraXBFbXB0eUxpbmVzKGxpbmUpXG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhayB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrIH1cblxuICAgIC8vIElmIG5lc3RpbmcgbGV2ZWwgZXhjZWVkZWQgLSBza2lwIHRhaWwgdG8gdGhlIGVuZC4gVGhhdCdzIG5vdCBvcmRpbmFyeVxuICAgIC8vIHNpdHVhdGlvbiBhbmQgd2Ugc2hvdWxkIG5vdCBjYXJlIGFib3V0IGNvbnRlbnQuXG4gICAgaWYgKHN0YXRlLmxldmVsID49IG1heE5lc3RpbmcpIHtcbiAgICAgIHN0YXRlLmxpbmUgPSBlbmRMaW5lXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcbiAgICBjb25zdCBwcmV2TGluZSA9IHN0YXRlLmxpbmVcbiAgICBsZXQgb2sgPSBmYWxzZVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgaWYgKHByZXZMaW5lID49IHN0YXRlLmxpbmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBydWxlIGRpZG4ndCBpbmNyZW1lbnQgc3RhdGUubGluZVwiKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdXNlciBkaXNhYmxlcyBwYXJhZ3JhcGggcnVsZVxuICAgIGlmICghb2spIHRocm93IG5ldyBFcnJvcignbm9uZSBvZiB0aGUgYmxvY2sgcnVsZXMgbWF0Y2hlZCcpXG5cbiAgICAvLyBzZXQgc3RhdGUudGlnaHQgaWYgd2UgaGFkIGFuIGVtcHR5IGxpbmUgYmVmb3JlIGN1cnJlbnQgdGFnXG4gICAgLy8gaS5lLiBsYXRlc3QgZW1wdHkgbGluZSBzaG91bGQgbm90IGNvdW50XG4gICAgc3RhdGUudGlnaHQgPSAhaGFzRW1wdHlMaW5lc1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZVxuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lXG5cbiAgICBpZiAobGluZSA8IGVuZExpbmUgJiYgc3RhdGUuaXNFbXB0eShsaW5lKSkge1xuICAgICAgaGFzRW1wdHlMaW5lcyA9IHRydWVcbiAgICAgIGxpbmUrK1xuICAgICAgc3RhdGUubGluZSA9IGxpbmVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXJCbG9jay5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBibG9jayB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgbWQsIGVudiwgb3V0VG9rZW5zKSB7XG4gIGlmICghc3JjKSB7IHJldHVybiB9XG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2VucylcblxuICB0aGlzLnRva2VuaXplKHN0YXRlLCBzdGF0ZS5saW5lLCBzdGF0ZS5saW5lTWF4KVxufVxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSBTdGF0ZUJsb2NrXG5cbmV4cG9ydCBkZWZhdWx0IFBhcnNlckJsb2NrXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/parser_block.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/parser_core.mjs":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_core.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ruler.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/ruler.mjs\");\n/* harmony import */ var _rules_core_state_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rules_core/state_core.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/state_core.mjs\");\n/* harmony import */ var _rules_core_normalize_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rules_core/normalize.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/normalize.mjs\");\n/* harmony import */ var _rules_core_block_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rules_core/block.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/block.mjs\");\n/* harmony import */ var _rules_core_inline_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules_core/inline.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/inline.mjs\");\n/* harmony import */ var _rules_core_linkify_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rules_core/linkify.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/linkify.mjs\");\n/* harmony import */ var _rules_core_replacements_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rules_core/replacements.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/replacements.mjs\");\n/* harmony import */ var _rules_core_smartquotes_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rules_core/smartquotes.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/smartquotes.mjs\");\n/* harmony import */ var _rules_core_text_join_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rules_core/text_join.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/text_join.mjs\");\n/** internal\n * class Core\n *\n * Top-level rules executor. Glues block/inline parsers and does intermediate\n * transformations.\n **/\n\n\n\n\n\n\n\n\n\n\n\n\nconst _rules = [\n  ['normalize',      _rules_core_normalize_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]],\n  ['block',          _rules_core_block_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]],\n  ['inline',         _rules_core_inline_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]],\n  ['linkify',        _rules_core_linkify_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]],\n  ['replacements',   _rules_core_replacements_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]],\n  ['smartquotes',    _rules_core_smartquotes_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"]],\n  // `text_join` finds `text_special` tokens (for escape sequences)\n  // and joins them with the rest of the text\n  ['text_join',      _rules_core_text_join_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"]]\n]\n\n/**\n * new Core()\n **/\nfunction Core () {\n  /**\n   * Core#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of core rules.\n   **/\n  this.ruler = new _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1])\n  }\n}\n\n/**\n * Core.process(state)\n *\n * Executes core chain rules.\n **/\nCore.prototype.process = function (state) {\n  const rules = this.ruler.getRules('')\n\n  for (let i = 0, l = rules.length; i < l; i++) {\n    rules[i](state)\n  }\n}\n\nCore.prototype.State = _rules_core_state_core_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Core);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStCO0FBQ29COztBQUVDO0FBQ1I7QUFDRTtBQUNFO0FBQ1U7QUFDRjtBQUNKOztBQUVwRDtBQUNBLHFCQUFxQixpRUFBVztBQUNoQyxxQkFBcUIsNkRBQU87QUFDNUIscUJBQXFCLDhEQUFRO0FBQzdCLHFCQUFxQiwrREFBUztBQUM5QixxQkFBcUIsb0VBQWM7QUFDbkMscUJBQXFCLG1FQUFhO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUIsaUVBQVc7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFLOztBQUV4QixrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGtFQUFTOztBQUVoQywrREFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUubWpzPzA2ODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cblxuaW1wb3J0IFJ1bGVyIGZyb20gJy4vcnVsZXIubWpzJ1xuaW1wb3J0IFN0YXRlQ29yZSBmcm9tICcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5tanMnXG5cbmltcG9ydCByX25vcm1hbGl6ZSBmcm9tICcuL3J1bGVzX2NvcmUvbm9ybWFsaXplLm1qcydcbmltcG9ydCByX2Jsb2NrIGZyb20gJy4vcnVsZXNfY29yZS9ibG9jay5tanMnXG5pbXBvcnQgcl9pbmxpbmUgZnJvbSAnLi9ydWxlc19jb3JlL2lubGluZS5tanMnXG5pbXBvcnQgcl9saW5raWZ5IGZyb20gJy4vcnVsZXNfY29yZS9saW5raWZ5Lm1qcydcbmltcG9ydCByX3JlcGxhY2VtZW50cyBmcm9tICcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzLm1qcydcbmltcG9ydCByX3NtYXJ0cXVvdGVzIGZyb20gJy4vcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5tanMnXG5pbXBvcnQgcl90ZXh0X2pvaW4gZnJvbSAnLi9ydWxlc19jb3JlL3RleHRfam9pbi5tanMnXG5cbmNvbnN0IF9ydWxlcyA9IFtcbiAgWydub3JtYWxpemUnLCAgICAgIHJfbm9ybWFsaXplXSxcbiAgWydibG9jaycsICAgICAgICAgIHJfYmxvY2tdLFxuICBbJ2lubGluZScsICAgICAgICAgcl9pbmxpbmVdLFxuICBbJ2xpbmtpZnknLCAgICAgICAgcl9saW5raWZ5XSxcbiAgWydyZXBsYWNlbWVudHMnLCAgIHJfcmVwbGFjZW1lbnRzXSxcbiAgWydzbWFydHF1b3RlcycsICAgIHJfc21hcnRxdW90ZXNdLFxuICAvLyBgdGV4dF9qb2luYCBmaW5kcyBgdGV4dF9zcGVjaWFsYCB0b2tlbnMgKGZvciBlc2NhcGUgc2VxdWVuY2VzKVxuICAvLyBhbmQgam9pbnMgdGhlbSB3aXRoIHRoZSByZXN0IG9mIHRoZSB0ZXh0XG4gIFsndGV4dF9qb2luJywgICAgICByX3RleHRfam9pbl1cbl1cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlICgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSlcbiAgfVxufVxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjb25zdCBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpXG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSlcbiAgfVxufVxuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IFN0YXRlQ29yZVxuXG5leHBvcnQgZGVmYXVsdCBDb3JlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/parser_core.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/parser_inline.mjs":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_inline.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ruler.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/ruler.mjs\");\n/* harmony import */ var _rules_inline_state_inline_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rules_inline/state_inline.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/state_inline.mjs\");\n/* harmony import */ var _rules_inline_text_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rules_inline/text.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/text.mjs\");\n/* harmony import */ var _rules_inline_linkify_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rules_inline/linkify.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/linkify.mjs\");\n/* harmony import */ var _rules_inline_newline_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rules_inline/newline.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/newline.mjs\");\n/* harmony import */ var _rules_inline_escape_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rules_inline/escape.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/escape.mjs\");\n/* harmony import */ var _rules_inline_backticks_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rules_inline/backticks.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/backticks.mjs\");\n/* harmony import */ var _rules_inline_strikethrough_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./rules_inline/strikethrough.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/strikethrough.mjs\");\n/* harmony import */ var _rules_inline_emphasis_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rules_inline/emphasis.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/emphasis.mjs\");\n/* harmony import */ var _rules_inline_link_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rules_inline/link.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/link.mjs\");\n/* harmony import */ var _rules_inline_image_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rules_inline/image.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/image.mjs\");\n/* harmony import */ var _rules_inline_autolink_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./rules_inline/autolink.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/autolink.mjs\");\n/* harmony import */ var _rules_inline_html_inline_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./rules_inline/html_inline.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/html_inline.mjs\");\n/* harmony import */ var _rules_inline_entity_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./rules_inline/entity.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/entity.mjs\");\n/* harmony import */ var _rules_inline_balance_pairs_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rules_inline/balance_pairs.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs\");\n/* harmony import */ var _rules_inline_fragments_join_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./rules_inline/fragments_join.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/fragments_join.mjs\");\n/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Parser rules\n\nconst _rules = [\n  ['text',            _rules_inline_text_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]],\n  ['linkify',         _rules_inline_linkify_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]],\n  ['newline',         _rules_inline_newline_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]],\n  ['escape',          _rules_inline_escape_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]],\n  ['backticks',       _rules_inline_backticks_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]],\n  ['strikethrough',   _rules_inline_strikethrough_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"].tokenize],\n  ['emphasis',        _rules_inline_emphasis_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"].tokenize],\n  ['link',            _rules_inline_link_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"]],\n  ['image',           _rules_inline_image_mjs__WEBPACK_IMPORTED_MODULE_10__[\"default\"]],\n  ['autolink',        _rules_inline_autolink_mjs__WEBPACK_IMPORTED_MODULE_11__[\"default\"]],\n  ['html_inline',     _rules_inline_html_inline_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"]],\n  ['entity',          _rules_inline_entity_mjs__WEBPACK_IMPORTED_MODULE_13__[\"default\"]]\n]\n\n// `rule2` ruleset was created specifically for emphasis/strikethrough\n// post-processing and may be changed in the future.\n//\n// Don't use this for anything except pairs (plugins working with `balance_pairs`).\n//\nconst _rules2 = [\n  ['balance_pairs',   _rules_inline_balance_pairs_mjs__WEBPACK_IMPORTED_MODULE_14__[\"default\"]],\n  ['strikethrough',   _rules_inline_strikethrough_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"].postProcess],\n  ['emphasis',        _rules_inline_emphasis_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"].postProcess],\n  // rules for pairs separate '**' into its own text tokens, which may be left unused,\n  // rule below merges unused segments back with the rest of the text\n  ['fragments_join',  _rules_inline_fragments_join_mjs__WEBPACK_IMPORTED_MODULE_15__[\"default\"]]\n]\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline () {\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n\n  for (let i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1])\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new _ruler_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]()\n\n  for (let i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1])\n  }\n}\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  const pos = state.pos\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const maxNesting = state.md.options.maxNesting\n  const cache = state.cache\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos]\n    return\n  }\n\n  let ok = false\n\n  if (state.level < maxNesting) {\n    for (let i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++\n      ok = rules[i](state, true)\n      state.level--\n\n      if (ok) {\n        if (pos >= state.pos) { throw new Error(\"inline rule didn't increment state.pos\") }\n        break\n      }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax\n  }\n\n  if (!ok) { state.pos++ }\n  cache[pos] = state.pos\n}\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  const rules = this.ruler.getRules('')\n  const len = rules.length\n  const end = state.posMax\n  const maxNesting = state.md.options.maxNesting\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    const prevPos = state.pos\n    let ok = false\n\n    if (state.level < maxNesting) {\n      for (let i = 0; i < len; i++) {\n        ok = rules[i](state, false)\n        if (ok) {\n          if (prevPos >= state.pos) { throw new Error(\"inline rule didn't increment state.pos\") }\n          break\n        }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break }\n      continue\n    }\n\n    state.pending += state.src[state.pos++]\n  }\n\n  if (state.pending) {\n    state.pushPending()\n  }\n}\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  const state = new this.State(str, md, env, outTokens)\n\n  this.tokenize(state)\n\n  const rules = this.ruler2.getRules('')\n  const len = rules.length\n\n  for (let i = 0; i < len; i++) {\n    rules[i](state)\n  }\n}\n\nParserInline.prototype.State = _rules_inline_state_inline_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParserInline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjtBQUMwQjs7QUFFYjtBQUNNO0FBQ0E7QUFDRjtBQUNNO0FBQ1E7QUFDVjtBQUNSO0FBQ0U7QUFDTTtBQUNNO0FBQ1Y7O0FBRWM7QUFDRTs7QUFFaEU7O0FBRUE7QUFDQSxzQkFBc0IsOERBQU07QUFDNUIsc0JBQXNCLGlFQUFTO0FBQy9CLHNCQUFzQixpRUFBUztBQUMvQixzQkFBc0IsZ0VBQVE7QUFDOUIsc0JBQXNCLG1FQUFXO0FBQ2pDLHNCQUFzQix1RUFBZTtBQUNyQyxzQkFBc0Isa0VBQVU7QUFDaEMsc0JBQXNCLDhEQUFNO0FBQzVCLHNCQUFzQixnRUFBTztBQUM3QixzQkFBc0IsbUVBQVU7QUFDaEMsc0JBQXNCLHNFQUFhO0FBQ25DLHNCQUFzQixpRUFBUTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0VBQWU7QUFDckMsc0JBQXNCLHVFQUFlO0FBQ3JDLHNCQUFzQixrRUFBVTtBQUNoQztBQUNBO0FBQ0Esc0JBQXNCLHlFQUFnQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQUs7O0FBRXhCLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQUs7O0FBRXpCLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0Isc0VBQVc7O0FBRTFDLCtEQUFlLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLm1qcz85ZWEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuXG5pbXBvcnQgUnVsZXIgZnJvbSAnLi9ydWxlci5tanMnXG5pbXBvcnQgU3RhdGVJbmxpbmUgZnJvbSAnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLm1qcydcblxuaW1wb3J0IHJfdGV4dCBmcm9tICcuL3J1bGVzX2lubGluZS90ZXh0Lm1qcydcbmltcG9ydCByX2xpbmtpZnkgZnJvbSAnLi9ydWxlc19pbmxpbmUvbGlua2lmeS5tanMnXG5pbXBvcnQgcl9uZXdsaW5lIGZyb20gJy4vcnVsZXNfaW5saW5lL25ld2xpbmUubWpzJ1xuaW1wb3J0IHJfZXNjYXBlIGZyb20gJy4vcnVsZXNfaW5saW5lL2VzY2FwZS5tanMnXG5pbXBvcnQgcl9iYWNrdGlja3MgZnJvbSAnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLm1qcydcbmltcG9ydCByX3N0cmlrZXRocm91Z2ggZnJvbSAnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5tanMnXG5pbXBvcnQgcl9lbXBoYXNpcyBmcm9tICcuL3J1bGVzX2lubGluZS9lbXBoYXNpcy5tanMnXG5pbXBvcnQgcl9saW5rIGZyb20gJy4vcnVsZXNfaW5saW5lL2xpbmsubWpzJ1xuaW1wb3J0IHJfaW1hZ2UgZnJvbSAnLi9ydWxlc19pbmxpbmUvaW1hZ2UubWpzJ1xuaW1wb3J0IHJfYXV0b2xpbmsgZnJvbSAnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsubWpzJ1xuaW1wb3J0IHJfaHRtbF9pbmxpbmUgZnJvbSAnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUubWpzJ1xuaW1wb3J0IHJfZW50aXR5IGZyb20gJy4vcnVsZXNfaW5saW5lL2VudGl0eS5tanMnXG5cbmltcG9ydCByX2JhbGFuY2VfcGFpcnMgZnJvbSAnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5tanMnXG5pbXBvcnQgcl9mcmFnbWVudHNfam9pbiBmcm9tICcuL3J1bGVzX2lubGluZS9mcmFnbWVudHNfam9pbi5tanMnXG5cbi8vIFBhcnNlciBydWxlc1xuXG5jb25zdCBfcnVsZXMgPSBbXG4gIFsndGV4dCcsICAgICAgICAgICAgcl90ZXh0XSxcbiAgWydsaW5raWZ5JywgICAgICAgICByX2xpbmtpZnldLFxuICBbJ25ld2xpbmUnLCAgICAgICAgIHJfbmV3bGluZV0sXG4gIFsnZXNjYXBlJywgICAgICAgICAgcl9lc2NhcGVdLFxuICBbJ2JhY2t0aWNrcycsICAgICAgIHJfYmFja3RpY2tzXSxcbiAgWydzdHJpa2V0aHJvdWdoJywgICByX3N0cmlrZXRocm91Z2gudG9rZW5pemVdLFxuICBbJ2VtcGhhc2lzJywgICAgICAgIHJfZW1waGFzaXMudG9rZW5pemVdLFxuICBbJ2xpbmsnLCAgICAgICAgICAgIHJfbGlua10sXG4gIFsnaW1hZ2UnLCAgICAgICAgICAgcl9pbWFnZV0sXG4gIFsnYXV0b2xpbmsnLCAgICAgICAgcl9hdXRvbGlua10sXG4gIFsnaHRtbF9pbmxpbmUnLCAgICAgcl9odG1sX2lubGluZV0sXG4gIFsnZW50aXR5JywgICAgICAgICAgcl9lbnRpdHldXG5dXG5cbi8vIGBydWxlMmAgcnVsZXNldCB3YXMgY3JlYXRlZCBzcGVjaWZpY2FsbHkgZm9yIGVtcGhhc2lzL3N0cmlrZXRocm91Z2hcbi8vIHBvc3QtcHJvY2Vzc2luZyBhbmQgbWF5IGJlIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBEb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcgZXhjZXB0IHBhaXJzIChwbHVnaW5zIHdvcmtpbmcgd2l0aCBgYmFsYW5jZV9wYWlyc2ApLlxuLy9cbmNvbnN0IF9ydWxlczIgPSBbXG4gIFsnYmFsYW5jZV9wYWlycycsICAgcl9iYWxhbmNlX3BhaXJzXSxcbiAgWydzdHJpa2V0aHJvdWdoJywgICByX3N0cmlrZXRocm91Z2gucG9zdFByb2Nlc3NdLFxuICBbJ2VtcGhhc2lzJywgICAgICAgIHJfZW1waGFzaXMucG9zdFByb2Nlc3NdLFxuICAvLyBydWxlcyBmb3IgcGFpcnMgc2VwYXJhdGUgJyoqJyBpbnRvIGl0cyBvd24gdGV4dCB0b2tlbnMsIHdoaWNoIG1heSBiZSBsZWZ0IHVudXNlZCxcbiAgLy8gcnVsZSBiZWxvdyBtZXJnZXMgdW51c2VkIHNlZ21lbnRzIGJhY2sgd2l0aCB0aGUgcmVzdCBvZiB0aGUgdGV4dFxuICBbJ2ZyYWdtZW50c19qb2luJywgIHJfZnJhZ21lbnRzX2pvaW5dXG5dXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUgKCkge1xuICAvKipcbiAgICogUGFyc2VySW5saW5lI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGlubGluZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKVxuICB9XG59XG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICBjb25zdCBwb3MgPSBzdGF0ZS5wb3NcbiAgY29uc3QgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKVxuICBjb25zdCBsZW4gPSBydWxlcy5sZW5ndGhcbiAgY29uc3QgbWF4TmVzdGluZyA9IHN0YXRlLm1kLm9wdGlvbnMubWF4TmVzdGluZ1xuICBjb25zdCBjYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc11cbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBvayA9IGZhbHNlXG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKytcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpXG4gICAgICBzdGF0ZS5sZXZlbC0tXG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICBpZiAocG9zID49IHN0YXRlLnBvcykgeyB0aHJvdyBuZXcgRXJyb3IoXCJpbmxpbmUgcnVsZSBkaWRuJ3QgaW5jcmVtZW50IHN0YXRlLnBvc1wiKSB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heFxuICB9XG5cbiAgaWYgKCFvaykgeyBzdGF0ZS5wb3MrKyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3Ncbn1cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY29uc3QgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKVxuICBjb25zdCBsZW4gPSBydWxlcy5sZW5ndGhcbiAgY29uc3QgZW5kID0gc3RhdGUucG9zTWF4XG4gIGNvbnN0IG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmdcblxuICB3aGlsZSAoc3RhdGUucG9zIDwgZW5kKSB7XG4gICAgLy8gVHJ5IGFsbCBwb3NzaWJsZSBydWxlcy5cbiAgICAvLyBPbiBzdWNjZXNzLCBydWxlIHNob3VsZDpcbiAgICAvL1xuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS5wb3NgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG4gICAgY29uc3QgcHJldlBvcyA9IHN0YXRlLnBvc1xuICAgIGxldCBvayA9IGZhbHNlXG5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPCBtYXhOZXN0aW5nKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKVxuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBpZiAocHJldlBvcyA+PSBzdGF0ZS5wb3MpIHsgdGhyb3cgbmV3IEVycm9yKFwiaW5saW5lIHJ1bGUgZGlkbid0IGluY3JlbWVudCBzdGF0ZS5wb3NcIikgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2spIHtcbiAgICAgIGlmIChzdGF0ZS5wb3MgPj0gZW5kKSB7IGJyZWFrIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdXG4gIH1cblxuICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgIHN0YXRlLnB1c2hQZW5kaW5nKClcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgY29uc3Qgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKVxuXG4gIGNvbnN0IHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpXG4gIGNvbnN0IGxlbiA9IHJ1bGVzLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBydWxlc1tpXShzdGF0ZSlcbiAgfVxufVxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gU3RhdGVJbmxpbmVcblxuZXhwb3J0IGRlZmF1bHQgUGFyc2VySW5saW5lXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/parser_inline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/presets/commonmark.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/commonmark.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Commonmark default options\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  options: {\n    // Enable HTML tags in source\n    html: true,\n\n    // Use '/' to close single tags (<br />)\n    xhtmlOut: true,\n\n    // Convert '\\n' in paragraphs into <br>\n    breaks: false,\n\n    // CSS language prefix for fenced blocks\n    langPrefix: 'language-',\n\n    // autoconvert URL-like texts to links\n    linkify: false,\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    // Internal protection, recursion limit\n    maxNesting: 20\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline',\n        'text_join'\n      ]\n    },\n\n    block: {\n      rules: [\n        'blockquote',\n        'code',\n        'fence',\n        'heading',\n        'hr',\n        'html_block',\n        'lheading',\n        'list',\n        'reference',\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'autolink',\n        'backticks',\n        'emphasis',\n        'entity',\n        'escape',\n        'html_inline',\n        'image',\n        'link',\n        'newline',\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'emphasis',\n        'fragments_join'\n      ]\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUEsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsubWpzP2Q0NjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29tbW9ubWFyayBkZWZhdWx0IG9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcHRpb25zOiB7XG4gICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICBodG1sOiB0cnVlLFxuXG4gICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIHhodG1sT3V0OiB0cnVlLFxuXG4gICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGJyZWFrczogZmFsc2UsXG5cbiAgICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG5cbiAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuICAgIGxpbmtpZnk6IGZhbHNlLFxuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICAgIG1heE5lc3Rpbmc6IDIwXG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnLFxuICAgICAgICAndGV4dF9qb2luJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZnJhZ21lbnRzX2pvaW4nXG4gICAgICBdXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/presets/commonmark.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/presets/default.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/default.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// markdown-it default options\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  options: {\n    // Enable HTML tags in source\n    html: false,\n\n    // Use '/' to close single tags (<br />)\n    xhtmlOut: false,\n\n    // Convert '\\n' in paragraphs into <br>\n    breaks: false,\n\n    // CSS language prefix for fenced blocks\n    langPrefix: 'language-',\n\n    // autoconvert URL-like texts to links\n    linkify: false,\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    // Internal protection, recursion limit\n    maxNesting: 100\n  },\n\n  components: {\n    core: {},\n    block: {},\n    inline: {}\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0Lm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUEsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsWUFBWTtBQUNaLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvZGVmYXVsdC5tanM/Y2Q0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQge1xuICBvcHRpb25zOiB7XG4gICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICBodG1sOiBmYWxzZSxcblxuICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICB4aHRtbE91dDogZmFsc2UsXG5cbiAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgYnJlYWtzOiBmYWxzZSxcblxuICAgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcblxuICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG4gICAgbGlua2lmeTogZmFsc2UsXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gICAgbWF4TmVzdGluZzogMTAwXG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIGNvcmU6IHt9LFxuICAgIGJsb2NrOiB7fSxcbiAgICBpbmxpbmU6IHt9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/presets/default.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/presets/zero.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/zero.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// \"Zero\" preset, with nothing enabled. Useful for manual configuring of simple\n// modes. For example, to parse bold/italic only.\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  options: {\n    // Enable HTML tags in source\n    html: false,\n\n    // Use '/' to close single tags (<br />)\n    xhtmlOut: false,\n\n    // Convert '\\n' in paragraphs into <br>\n    breaks: false,\n\n    // CSS language prefix for fenced blocks\n    langPrefix: 'language-',\n\n    // autoconvert URL-like texts to links\n    linkify: false,\n\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Could be either a String or an Array.\n    //\n    // For example, you can use '' for Russian, '' for German,\n    // and ['\\xA0', '\\xA0', '\\xA0', '\\xA0'] for French (including nbsp).\n    quotes: '\\u201c\\u201d\\u2018\\u2019', /*  */\n\n    // Highlighter function. Should return escaped HTML,\n    // or '' if the source string is not changed and should be escaped externaly.\n    // If result starts with <pre... internal wrapper is skipped.\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n\n    // Internal protection, recursion limit\n    maxNesting: 20\n  },\n\n  components: {\n\n    core: {\n      rules: [\n        'normalize',\n        'block',\n        'inline',\n        'text_join'\n      ]\n    },\n\n    block: {\n      rules: [\n        'paragraph'\n      ]\n    },\n\n    inline: {\n      rules: [\n        'text'\n      ],\n      rules2: [\n        'balance_pairs',\n        'fragments_join'\n      ]\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQSwrREFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL3plcm8ubWpzPzRiNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgb3B0aW9uczoge1xuICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgaHRtbDogZmFsc2UsXG5cbiAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgeGh0bWxPdXQ6IGZhbHNlLFxuXG4gICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGJyZWFrczogZmFsc2UsXG5cbiAgICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGFuZ1ByZWZpeDogJ2xhbmd1YWdlLScsXG5cbiAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuICAgIGxpbmtpZnk6IGZhbHNlLFxuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICAgIG1heE5lc3Rpbmc6IDIwXG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnLFxuICAgICAgICAndGV4dF9qb2luJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZnJhZ21lbnRzX2pvaW4nXG4gICAgICBdXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/presets/zero.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/renderer.mjs":
/*!***************************************************!*\
  !*** ./node_modules/markdown-it/lib/renderer.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\n\n\nconst default_rules = {}\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(token.content) +\n          '</code>'\n}\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(tokens[idx].content) +\n          '</code></pre>\\n'\n}\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n  const info = token.info ? (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.unescapeAll)(token.info).trim() : ''\n  let langName = ''\n  let langAttrs = ''\n\n  if (info) {\n    const arr = info.split(/(\\s+)/g)\n    langName = arr[0]\n    langAttrs = arr.slice(2).join('')\n  }\n\n  let highlighted\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(token.content)\n  } else {\n    highlighted = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(token.content)\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n'\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    const i = token.attrIndex('class')\n    const tmpAttrs = token.attrs ? token.attrs.slice() : []\n\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName])\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice()\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName\n    }\n\n    // Fake token just to render attributes\n    const tmpToken = {\n      attrs: tmpAttrs\n    }\n\n    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>\\n`\n  }\n\n  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>\\n`\n}\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env)\n\n  return slf.renderToken(tokens, idx, options)\n}\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n'\n}\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n'\n}\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(tokens[idx].content)\n}\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer () {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs)\n   * for more details and examples.\n   **/\n  this.rules = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, default_rules)\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs (token) {\n  let i, l, result\n\n  if (!token.attrs) { return '' }\n\n  result = ''\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(token.attrs[i][0]) + '=\"' + (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.escapeHtml)(token.attrs[i][1]) + '\"'\n  }\n\n  return result\n}\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken (tokens, idx, options) {\n  const token = tokens[idx]\n  let result = ''\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return ''\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n'\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token)\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /'\n  }\n\n  // Check if we need to add a newline after this tag\n  let needLf = false\n  if (token.block) {\n    needLf = true\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        const nextToken = tokens[idx + 1]\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>'\n\n  return result\n}\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options)\n    }\n  }\n\n  return result\n}\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  let result = ''\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    switch (tokens[i].type) {\n      case 'text':\n        result += tokens[i].content\n        break\n      case 'image':\n        result += this.renderInlineAsText(tokens[i].children, options, env)\n        break\n      case 'html_inline':\n      case 'html_block':\n        result += tokens[i].content\n        break\n      case 'softbreak':\n      case 'hardbreak':\n        result += '\\n'\n        break\n      default:\n        // all other tokens are skipped\n    }\n  }\n\n  return result\n}\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env)\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options, env)\n    }\n  }\n\n  return result\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Renderer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIubWpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9FOztBQUVwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSw2REFBVTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDZEQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qiw4REFBVztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRSw2REFBVTtBQUNyRixJQUFJO0FBQ0osa0JBQWtCLDZEQUFVO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDBCQUEwQixHQUFHLFlBQVk7QUFDakU7O0FBRUEsc0JBQXNCLHVCQUF1QixHQUFHLFlBQVk7QUFDNUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyw2REFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBTSxHQUFHO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0Msb0JBQW9CLDZEQUFVLDZCQUE2Qiw2REFBVTtBQUNyRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9yZW5kZXJlci5tanM/MzYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuXG5pbXBvcnQgeyBhc3NpZ24sIHVuZXNjYXBlQWxsLCBlc2NhcGVIdG1sIH0gZnJvbSAnLi9jb21tb24vdXRpbHMubWpzJ1xuXG5jb25zdCBkZWZhdWx0X3J1bGVzID0ge31cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaWR4XVxuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW4uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+J1xufVxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIGNvbnN0IHRva2VuID0gdG9rZW5zW2lkeF1cblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJ1xufVxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpZHhdXG4gIGNvbnN0IGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJydcbiAgbGV0IGxhbmdOYW1lID0gJydcbiAgbGV0IGxhbmdBdHRycyA9ICcnXG5cbiAgaWYgKGluZm8pIHtcbiAgICBjb25zdCBhcnIgPSBpbmZvLnNwbGl0KC8oXFxzKykvZylcbiAgICBsYW5nTmFtZSA9IGFyclswXVxuICAgIGxhbmdBdHRycyA9IGFyci5zbGljZSgyKS5qb2luKCcnKVxuICB9XG5cbiAgbGV0IGhpZ2hsaWdodGVkXG4gIGlmIChvcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIGhpZ2hsaWdodGVkID0gb3B0aW9ucy5oaWdobGlnaHQodG9rZW4uY29udGVudCwgbGFuZ05hbWUsIGxhbmdBdHRycykgfHwgZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KVxuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KVxuICB9XG5cbiAgaWYgKGhpZ2hsaWdodGVkLmluZGV4T2YoJzxwcmUnKSA9PT0gMCkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZCArICdcXG4nXG4gIH1cblxuICAvLyBJZiBsYW5ndWFnZSBleGlzdHMsIGluamVjdCBjbGFzcyBnZW50bHksIHdpdGhvdXQgbW9kaWZ5aW5nIG9yaWdpbmFsIHRva2VuLlxuICAvLyBNYXkgYmUsIG9uZSBkYXkgd2Ugd2lsbCBhZGQgLmRlZXBDbG9uZSgpIGZvciB0b2tlbiBhbmQgc2ltcGxpZnkgdGhpcyBwYXJ0LCBidXRcbiAgLy8gbm93IHdlIHByZWZlciB0byBrZWVwIHRoaW5ncyBsb2NhbC5cbiAgaWYgKGluZm8pIHtcbiAgICBjb25zdCBpID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpXG4gICAgY29uc3QgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXVxuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0bXBBdHRycy5wdXNoKFsnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcEF0dHJzW2ldID0gdG1wQXR0cnNbaV0uc2xpY2UoKVxuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWVcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICBjb25zdCB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH1cblxuICAgIHJldHVybiBgPHByZT48Y29kZSR7c2xmLnJlbmRlckF0dHJzKHRtcFRva2VuKX0+JHtoaWdobGlnaHRlZH08L2NvZGU+PC9wcmU+XFxuYFxuICB9XG5cbiAgcmV0dXJuIGA8cHJlPjxjb2RlJHtzbGYucmVuZGVyQXR0cnModG9rZW4pfT4ke2hpZ2hsaWdodGVkfTwvY29kZT48L3ByZT5cXG5gXG59XG5cbmRlZmF1bHRfcnVsZXMuaW1hZ2UgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIGNvbnN0IHRva2VuID0gdG9rZW5zW2lkeF1cblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudilcblxuICByZXR1cm4gc2xmLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKVxufVxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbidcbn1cbmRlZmF1bHRfcnVsZXMuc29mdGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMuYnJlYWtzID8gKG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJykgOiAnXFxuJ1xufVxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KVxufVxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudFxufVxuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50XG59XG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlciAoKSB7XG4gIC8qKlxuICAgKiBSZW5kZXJlciNydWxlcyAtPiBPYmplY3RcbiAgICpcbiAgICogQ29udGFpbnMgcmVuZGVyIHJ1bGVzIGZvciB0b2tlbnMuIENhbiBiZSB1cGRhdGVkIGFuZCBleHRlbmRlZC5cbiAgICpcbiAgICogIyMjIyMgRXhhbXBsZVxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAgICpcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX29wZW4gID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzxiPic7IH07XG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19jbG9zZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8L2I+JzsgfTtcbiAgICpcbiAgICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSguLi4pO1xuICAgKiBgYGBcbiAgICpcbiAgICogRWFjaCBydWxlIGlzIGNhbGxlZCBhcyBpbmRlcGVuZGVudCBzdGF0aWMgZnVuY3Rpb24gd2l0aCBmaXhlZCBzaWduYXR1cmU6XG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogZnVuY3Rpb24gbXlfdG9rZW5fcmVuZGVyKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHJlbmRlcmVyKSB7XG4gICAqICAgLy8gLi4uXG4gICAqICAgcmV0dXJuIHJlbmRlcmVkSFRNTDtcbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtzb3VyY2UgY29kZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9yZW5kZXJlci5tanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpXG59XG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzICh0b2tlbikge1xuICBsZXQgaSwgbCwgcmVzdWx0XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJycgfVxuXG4gIHJlc3VsdCA9ICcnXG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvZiB0b2tlbnNcbiAqIC0gaWR4IChOdW1iZWQpOiB0b2tlbiBpbmRleCB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICpcbiAqIERlZmF1bHQgdG9rZW4gcmVuZGVyZXIuIENhbiBiZSBvdmVycmlkZW4gYnkgY3VzdG9tIGZ1bmN0aW9uXG4gKiBpbiBbW1JlbmRlcmVyI3J1bGVzXV0uXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9rZW4gPSBmdW5jdGlvbiByZW5kZXJUb2tlbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaWR4XVxuICBsZXQgcmVzdWx0ID0gJydcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nXG4gIH1cblxuICAvLyBBZGQgdG9rZW4gbmFtZSwgZS5nLiBgPGltZ2BcbiAgcmVzdWx0ICs9ICh0b2tlbi5uZXN0aW5nID09PSAtMSA/ICc8LycgOiAnPCcpICsgdG9rZW4udGFnXG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKVxuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLydcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgbmV3bGluZSBhZnRlciB0aGlzIHRhZ1xuICBsZXQgbmVlZExmID0gZmFsc2VcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZVxuXG4gICAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDEpIHtcbiAgICAgIGlmIChpZHggKyAxIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0b2tlbnNbaWR4ICsgMV1cblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPidcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICBsZXQgcmVzdWx0ID0gJydcbiAgY29uc3QgcnVsZXMgPSB0aGlzLnJ1bGVzXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHR5cGUgPSB0b2tlbnNbaV0udHlwZVxuXG4gICAgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0eXBlXSh0b2tlbnMsIGksIG9wdGlvbnMsIGVudiwgdGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqIGludGVybmFsXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFNwZWNpYWwga2x1ZGdlIGZvciBpbWFnZSBgYWx0YCBhdHRyaWJ1dGVzIHRvIGNvbmZvcm0gQ29tbW9uTWFyayBzcGVjLlxuICogRG9uJ3QgdHJ5IHRvIHVzZSBpdCEgU3BlYyByZXF1aXJlcyB0byBzaG93IGBhbHRgIGNvbnRlbnQgd2l0aCBzdHJpcHBlZCBtYXJrdXAsXG4gKiBpbnN0ZWFkIG9mIHNpbXBsZSBlc2NhcGluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJJbmxpbmVBc1RleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgbGV0IHJlc3VsdCA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN3aXRjaCAodG9rZW5zW2ldLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnaHRtbF9pbmxpbmUnOlxuICAgICAgY2FzZSAnaHRtbF9ibG9jayc6XG4gICAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc29mdGJyZWFrJzpcbiAgICAgIGNhc2UgJ2hhcmRicmVhayc6XG4gICAgICAgIHJlc3VsdCArPSAnXFxuJ1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gYWxsIG90aGVyIHRva2VucyBhcmUgc2tpcHBlZFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXIodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRha2VzIHRva2VuIHN0cmVhbSBhbmQgZ2VuZXJhdGVzIEhUTUwuIFByb2JhYmx5LCB5b3Ugd2lsbCBuZXZlciBuZWVkIHRvIGNhbGxcbiAqIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICBsZXQgcmVzdWx0ID0gJydcbiAgY29uc3QgcnVsZXMgPSB0aGlzLnJ1bGVzXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHR5cGUgPSB0b2tlbnNbaV0udHlwZVxuXG4gICAgaWYgKHR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmUodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCArPSB0aGlzLnJlbmRlclRva2VuKHRva2VucywgaSwgb3B0aW9ucywgZW52KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/renderer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/ruler.mjs":
/*!************************************************!*\
  !*** ./node_modules/markdown-it/lib/ruler.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * class Ruler\n *\n * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and\n * [[MarkdownIt#inline]] to manage sequences of functions (rules):\n *\n * - keep rules in defined order\n * - assign the name to each rule\n * - enable/disable rules\n * - add/replace rules\n * - allow assign rules to additional named chains (in the same)\n * - cacheing lists of active rules\n *\n * You will not need use this class directly until write plugins. For simple\n * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and\n * [[MarkdownIt.use]].\n **/\n\n/**\n * new Ruler()\n **/\nfunction Ruler () {\n  // List of added rules. Each element is:\n  //\n  // {\n  //   name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ]\n  // }\n  //\n  this.__rules__ = []\n\n  // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - diginal anchor for fast filtering by charcodes.\n  //\n  this.__cache__ = null\n}\n\n// Helper methods, should not be used directly\n\n// Find rule index by name\n//\nRuler.prototype.__find__ = function (name) {\n  for (let i = 0; i < this.__rules__.length; i++) {\n    if (this.__rules__[i].name === name) {\n      return i\n    }\n  }\n  return -1\n}\n\n// Build rules lookup cache\n//\nRuler.prototype.__compile__ = function () {\n  const self = this\n  const chains = ['']\n\n  // collect unique names\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) { return }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName)\n      }\n    })\n  })\n\n  self.__cache__ = {}\n\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = []\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) { return }\n\n      if (chain && rule.alt.indexOf(chain) < 0) { return }\n\n      self.__cache__[chain].push(rule.fn)\n    })\n  })\n}\n\n/**\n * Ruler.at(name, fn [, options])\n * - name (String): rule name to replace.\n * - fn (Function): new rule function.\n * - options (Object): new rule options (not mandatory).\n *\n * Replace rule by name with new function & options. Throws error if name not\n * found.\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * Replace existing typographer replacement rule with new one:\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.at('replacements', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.at = function (name, fn, options) {\n  const index = this.__find__(name)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + name) }\n\n  this.__rules__[index].fn = fn\n  this.__rules__[index].alt = opt.alt || []\n  this.__cache__ = null\n}\n\n/**\n * Ruler.before(beforeName, ruleName, fn [, options])\n * - beforeName (String): new rule will be added before this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain before one with given name. See also\n * [[Ruler.after]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  const index = this.__find__(beforeName)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName) }\n\n  this.__rules__.splice(index, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n\n/**\n * Ruler.after(afterName, ruleName, fn [, options])\n * - afterName (String): new rule will be added after this one.\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Add new rule to chain after one with given name. See also\n * [[Ruler.before]], [[Ruler.push]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.inline.ruler.after('text', 'my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  const index = this.__find__(afterName)\n  const opt = options || {}\n\n  if (index === -1) { throw new Error('Parser rule not found: ' + afterName) }\n\n  this.__rules__.splice(index + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n\n/**\n * Ruler.push(ruleName, fn [, options])\n * - ruleName (String): name of added rule.\n * - fn (Function): rule function.\n * - options (Object): rule options (not mandatory).\n *\n * Push new rule to the end of chain. See also\n * [[Ruler.before]], [[Ruler.after]].\n *\n * ##### Options:\n *\n * - __alt__ - array with names of \"alternate\" chains.\n *\n * ##### Example\n *\n * ```javascript\n * var md = require('markdown-it')();\n *\n * md.core.ruler.push('my_rule', function replace(state) {\n *   //...\n * });\n * ```\n **/\nRuler.prototype.push = function (ruleName, fn, options) {\n  const opt = options || {}\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn,\n    alt: opt.alt || []\n  })\n\n  this.__cache__ = null\n}\n\n/**\n * Ruler.enable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to enable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.disable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.enable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  const result = []\n\n  // Search by name and enable\n  list.forEach(function (name) {\n    const idx = this.__find__(name)\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return }\n      throw new Error('Rules manager: invalid rule name ' + name)\n    }\n    this.__rules__[idx].enabled = true\n    result.push(name)\n  }, this)\n\n  this.__cache__ = null\n  return result\n}\n\n/**\n * Ruler.enableOnly(list [, ignoreInvalid])\n * - list (String|Array): list of rule names to enable (whitelist).\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Enable rules with given names, and disable everything else. If any rule name\n * not found - throw Error. Errors can be disabled by second param.\n *\n * See also [[Ruler.disable]], [[Ruler.enable]].\n **/\nRuler.prototype.enableOnly = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  this.__rules__.forEach(function (rule) { rule.enabled = false })\n\n  this.enable(list, ignoreInvalid)\n}\n\n/**\n * Ruler.disable(list [, ignoreInvalid]) -> Array\n * - list (String|Array): list of rule names to disable.\n * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.\n *\n * Disable rules with given names. If any rule name not found - throw Error.\n * Errors can be disabled by second param.\n *\n * Returns list of found rule names (if no exception happened).\n *\n * See also [[Ruler.enable]], [[Ruler.enableOnly]].\n **/\nRuler.prototype.disable = function (list, ignoreInvalid) {\n  if (!Array.isArray(list)) { list = [list] }\n\n  const result = []\n\n  // Search by name and disable\n  list.forEach(function (name) {\n    const idx = this.__find__(name)\n\n    if (idx < 0) {\n      if (ignoreInvalid) { return }\n      throw new Error('Rules manager: invalid rule name ' + name)\n    }\n    this.__rules__[idx].enabled = false\n    result.push(name)\n  }, this)\n\n  this.__cache__ = null\n  return result\n}\n\n/**\n * Ruler.getRules(chainName) -> Array\n *\n * Return array of active functions (rules) for given chain name. It analyzes\n * rules configuration, compiles caches if not exists and returns result.\n *\n * Default chain name is `''` (empty string). It can't be skipped. That's\n * done intentionally, to keep signature monomorphic for high speed.\n **/\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__()\n  }\n\n  // Chain can be empty, if rules disabled. But we still have to return Array.\n  return this.__cache__[chainName] || []\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Ruler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXIubWpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0Isa0RBQWtEOztBQUVsRDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QiwyQ0FBMkMsc0JBQXNCOztBQUVqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLm1qcz9iNWIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY2xhc3MgUnVsZXJcbiAqXG4gKiBIZWxwZXIgY2xhc3MsIHVzZWQgYnkgW1tNYXJrZG93bkl0I2NvcmVdXSwgW1tNYXJrZG93bkl0I2Jsb2NrXV0gYW5kXG4gKiBbW01hcmtkb3duSXQjaW5saW5lXV0gdG8gbWFuYWdlIHNlcXVlbmNlcyBvZiBmdW5jdGlvbnMgKHJ1bGVzKTpcbiAqXG4gKiAtIGtlZXAgcnVsZXMgaW4gZGVmaW5lZCBvcmRlclxuICogLSBhc3NpZ24gdGhlIG5hbWUgdG8gZWFjaCBydWxlXG4gKiAtIGVuYWJsZS9kaXNhYmxlIHJ1bGVzXG4gKiAtIGFkZC9yZXBsYWNlIHJ1bGVzXG4gKiAtIGFsbG93IGFzc2lnbiBydWxlcyB0byBhZGRpdGlvbmFsIG5hbWVkIGNoYWlucyAoaW4gdGhlIHNhbWUpXG4gKiAtIGNhY2hlaW5nIGxpc3RzIG9mIGFjdGl2ZSBydWxlc1xuICpcbiAqIFlvdSB3aWxsIG5vdCBuZWVkIHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5IHVudGlsIHdyaXRlIHBsdWdpbnMuIEZvciBzaW1wbGVcbiAqIHJ1bGVzIGNvbnRyb2wgdXNlIFtbTWFya2Rvd25JdC5kaXNhYmxlXV0sIFtbTWFya2Rvd25JdC5lbmFibGVdXSBhbmRcbiAqIFtbTWFya2Rvd25JdC51c2VdXS5cbiAqKi9cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIgKCkge1xuICAvLyBMaXN0IG9mIGFkZGVkIHJ1bGVzLiBFYWNoIGVsZW1lbnQgaXM6XG4gIC8vXG4gIC8vIHtcbiAgLy8gICBuYW1lOiBYWFgsXG4gIC8vICAgZW5hYmxlZDogQm9vbGVhbixcbiAgLy8gICBmbjogRnVuY3Rpb24oKSxcbiAgLy8gICBhbHQ6IFsgbmFtZTIsIG5hbWUzIF1cbiAgLy8gfVxuICAvL1xuICB0aGlzLl9fcnVsZXNfXyA9IFtdXG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGxcbn1cblxuLy8gSGVscGVyIG1ldGhvZHMsIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseVxuXG4vLyBGaW5kIHJ1bGUgaW5kZXggYnkgbmFtZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2ZpbmRfXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fX3J1bGVzX18ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5fX3J1bGVzX19baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgY2hhaW5zID0gWycnXVxuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm4gfVxuXG4gICAgcnVsZS5hbHQuZm9yRWFjaChmdW5jdGlvbiAoYWx0TmFtZSkge1xuICAgICAgaWYgKGNoYWlucy5pbmRleE9mKGFsdE5hbWUpIDwgMCkge1xuICAgICAgICBjaGFpbnMucHVzaChhbHROYW1lKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgc2VsZi5fX2NhY2hlX18gPSB7fVxuXG4gIGNoYWlucy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXSA9IFtdXG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuIH1cblxuICAgICAgaWYgKGNoYWluICYmIHJ1bGUuYWx0LmluZGV4T2YoY2hhaW4pIDwgMCkgeyByZXR1cm4gfVxuXG4gICAgICBzZWxmLl9fY2FjaGVfX1tjaGFpbl0ucHVzaChydWxlLmZuKVxuICAgIH0pXG4gIH0pXG59XG5cbi8qKlxuICogUnVsZXIuYXQobmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgbmFtZSB0byByZXBsYWNlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBuZXcgcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogbmV3IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogUmVwbGFjZSBydWxlIGJ5IG5hbWUgd2l0aCBuZXcgZnVuY3Rpb24gJiBvcHRpb25zLiBUaHJvd3MgZXJyb3IgaWYgbmFtZSBub3RcbiAqIGZvdW5kLlxuICpcbiAqICMjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBfX2FsdF9fIC0gYXJyYXkgd2l0aCBuYW1lcyBvZiBcImFsdGVybmF0ZVwiIGNoYWlucy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogUmVwbGFjZSBleGlzdGluZyB0eXBvZ3JhcGhlciByZXBsYWNlbWVudCBydWxlIHdpdGggbmV3IG9uZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5hdCgncmVwbGFjZW1lbnRzJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgb3B0aW9ucykge1xuICBjb25zdCBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSlcbiAgY29uc3Qgb3B0ID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKSB9XG5cbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmZuID0gZm5cbiAgdGhpcy5fX3J1bGVzX19baW5kZXhdLmFsdCA9IG9wdC5hbHQgfHwgW11cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsXG59XG5cbi8qKlxuICogUnVsZXIuYmVmb3JlKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gYmVmb3JlTmFtZSAoU3RyaW5nKTogbmV3IHJ1bGUgd2lsbCBiZSBhZGRlZCBiZWZvcmUgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGJlZm9yZSBvbmUgd2l0aCBnaXZlbiBuYW1lLiBTZWUgYWxzb1xuICogW1tSdWxlci5hZnRlcl1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5ibG9jay5ydWxlci5iZWZvcmUoJ3BhcmFncmFwaCcsICdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbiAoYmVmb3JlTmFtZSwgcnVsZU5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhiZWZvcmVOYW1lKVxuICBjb25zdCBvcHQgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKGluZGV4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBydWxlIG5vdCBmb3VuZDogJyArIGJlZm9yZU5hbWUpIH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuLFxuICAgIGFsdDogb3B0LmFsdCB8fCBbXVxuICB9KVxuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbFxufVxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgaW5kZXggPSB0aGlzLl9fZmluZF9fKGFmdGVyTmFtZSlcbiAgY29uc3Qgb3B0ID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBhZnRlck5hbWUpIH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSlcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGxcbn1cblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBvcHRpb25zIHx8IHt9XG5cbiAgdGhpcy5fX3J1bGVzX18ucHVzaCh7XG4gICAgbmFtZTogcnVsZU5hbWUsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSlcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGxcbn1cblxuLyoqXG4gKiBSdWxlci5lbmFibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlT25seV1dLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gW2xpc3RdIH1cblxuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIFNlYXJjaCBieSBuYW1lIGFuZCBlbmFibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKVxuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybiB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKVxuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSB0cnVlXG4gICAgcmVzdWx0LnB1c2gobmFtZSlcbiAgfSwgdGhpcylcblxuICB0aGlzLl9fY2FjaGVfXyA9IG51bGxcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZU9ubHkobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGVuYWJsZSAod2hpdGVsaXN0KS5cbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLCBhbmQgZGlzYWJsZSBldmVyeXRoaW5nIGVsc2UuIElmIGFueSBydWxlIG5hbWVcbiAqIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVdXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5lbmFibGVPbmx5ID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbbGlzdF0gfVxuXG4gIHRoaXMuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHsgcnVsZS5lbmFibGVkID0gZmFsc2UgfSlcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxufVxuXG4vKipcbiAqIFJ1bGVyLmRpc2FibGUobGlzdCBbLCBpZ25vcmVJbnZhbGlkXSkgLT4gQXJyYXlcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBEaXNhYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmVuYWJsZV1dLCBbW1J1bGVyLmVuYWJsZU9ubHldXS5cbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbbGlzdF0gfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5fX2ZpbmRfXyhuYW1lKVxuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybiB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKVxuICAgIH1cbiAgICB0aGlzLl9fcnVsZXNfX1tpZHhdLmVuYWJsZWQgPSBmYWxzZVxuICAgIHJlc3VsdC5wdXNoKG5hbWUpXG4gIH0sIHRoaXMpXG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKClcbiAgfVxuXG4gIC8vIENoYWluIGNhbiBiZSBlbXB0eSwgaWYgcnVsZXMgZGlzYWJsZWQuIEJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHJldHVybiBBcnJheS5cbiAgcmV0dXJuIHRoaXMuX19jYWNoZV9fW2NoYWluTmFtZV0gfHwgW11cbn1cblxuZXhwb3J0IGRlZmF1bHQgUnVsZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/ruler.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/blockquote.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/blockquote.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ blockquote; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Block quotes\n\n\n\nfunction blockquote (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  const oldLineMax = state.lineMax\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos) !== 0x3E/* > */) { return false }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true }\n\n  const oldBMarks  = []\n  const oldBSCount = []\n  const oldSCount  = []\n  const oldTShift  = []\n\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const oldParentType = state.parentType\n  state.parentType = 'blockquote'\n  let lastLineEmpty = false\n  let nextLine\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    const isOutdented = state.sCount[nextLine] < state.blkIndent\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      let initial = state.sCount[nextLine] + 1\n      let spaceAfterMarker\n      let adjustTab\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++\n        initial++\n        adjustTab = false\n        spaceAfterMarker = true\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true\n\n        if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++\n          initial++\n          adjustTab = false\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true\n        }\n      } else {\n        spaceAfterMarker = false\n      }\n\n      let offset = initial\n      oldBMarks.push(state.bMarks[nextLine])\n      state.bMarks[nextLine] = pos\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos)\n\n        if ((0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4\n          } else {\n            offset++\n          }\n        } else {\n          break\n        }\n\n        pos++\n      }\n\n      lastLineEmpty = pos >= max\n\n      oldBSCount.push(state.bsCount[nextLine])\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)\n\n      oldSCount.push(state.sCount[nextLine])\n      state.sCount[nextLine] = offset - initial\n\n      oldTShift.push(state.tShift[nextLine])\n      state.tShift[nextLine] = pos - state.bMarks[nextLine]\n      continue\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break }\n\n    // Case 3: another tag found.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine])\n        oldBSCount.push(state.bsCount[nextLine])\n        oldTShift.push(state.tShift[nextLine])\n        oldSCount.push(state.sCount[nextLine])\n        state.sCount[nextLine] -= state.blkIndent\n      }\n\n      break\n    }\n\n    oldBMarks.push(state.bMarks[nextLine])\n    oldBSCount.push(state.bsCount[nextLine])\n    oldTShift.push(state.tShift[nextLine])\n    oldSCount.push(state.sCount[nextLine])\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1\n  }\n\n  const oldIndent = state.blkIndent\n  state.blkIndent = 0\n\n  const token_o  = state.push('blockquote_open', 'blockquote', 1)\n  token_o.markup = '>'\n  const lines = [startLine, 0]\n  token_o.map    = lines\n\n  state.md.block.tokenize(state, startLine, nextLine)\n\n  const token_c  = state.push('blockquote_close', 'blockquote', -1)\n  token_c.markup = '>'\n\n  state.lineMax = oldLineMax\n  state.parentType = oldParentType\n  lines[1] = state.line\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (let i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i]\n    state.tShift[i + startLine] = oldTShift[i]\n    state.sCount[i + startLine] = oldSCount[i]\n    state.bsCount[i + startLine] = oldBSCount[i]\n  }\n  state.blkIndent = oldIndent\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFNkM7O0FBRTlCO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSwwREFBTztBQUNuQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svYmxvY2txdW90ZS5tanM/MjMxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCbG9jayBxdW90ZXNcblxuaW1wb3J0IHsgaXNTcGFjZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJsb2NrcXVvdGUgKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuICBsZXQgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV1cblxuICBjb25zdCBvbGRMaW5lTWF4ID0gc3RhdGUubGluZU1heFxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgLy8gY2hlY2sgdGhlIGJsb2NrIHF1b3RlIG1hcmtlclxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlIH1cblxuICAvLyB3ZSBrbm93IHRoYXQgaXQncyBnb2luZyB0byBiZSBhIHZhbGlkIGJsb2NrcXVvdGUsXG4gIC8vIHNvIG5vIHBvaW50IHRyeWluZyB0byBmaW5kIHRoZSBlbmQgb2YgaXQgaW4gc2lsZW50IG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgY29uc3Qgb2xkQk1hcmtzICA9IFtdXG4gIGNvbnN0IG9sZEJTQ291bnQgPSBbXVxuICBjb25zdCBvbGRTQ291bnQgID0gW11cbiAgY29uc3Qgb2xkVFNoaWZ0ICA9IFtdXG5cbiAgY29uc3QgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2Jsb2NrcXVvdGUnKVxuXG4gIGNvbnN0IG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlXG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSdcbiAgbGV0IGxhc3RMaW5lRW1wdHkgPSBmYWxzZVxuICBsZXQgbmV4dExpbmVcblxuICAvLyBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgYmxvY2tcbiAgLy9cbiAgLy8gQmxvY2sgZW5kcyB3aXRoIGVpdGhlcjpcbiAgLy8gIDEuIGFuIGVtcHR5IGxpbmUgb3V0c2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vXG4gIC8vICAgICBgYGBcbiAgLy8gIDIuIGFuIGVtcHR5IGxpbmUgaW5zaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+XG4gIC8vICAgICB0ZXN0XG4gIC8vICAgICBgYGBcbiAgLy8gIDMuIGFub3RoZXIgdGFnOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy8gICAgICAtIC0gLVxuICAvLyAgICAgYGBgXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmU7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgY29uc3QgaXNPdXRkZW50ZWQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXVxuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV1cblxuICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAvLyBDYXNlIDE6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoaXMgbGluZSBpcyBlbXB0eS5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIWlzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBzZXQgb2Zmc2V0IHBhc3Qgc3BhY2VzIGFuZCBcIj5cIlxuICAgICAgbGV0IGluaXRpYWwgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgMVxuICAgICAgbGV0IHNwYWNlQWZ0ZXJNYXJrZXJcbiAgICAgIGxldCBhZGp1c3RUYWJcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrK1xuICAgICAgICBpbml0aWFsKytcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2VcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWVcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgaW5pdGlhbCkgJSA0ID09PSAzKSB7XG4gICAgICAgICAgLy8gJyAgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgICAgIHBvcysrXG4gICAgICAgICAgaW5pdGlhbCsrXG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICsgc2hpZnQgYnNDb3VudCBzbGlnaHRseVxuICAgICAgICAgIC8vICAgICAgICAgdG8gbWFrZSBleHRyYSBzcGFjZSBhcHBlYXJcbiAgICAgICAgICBhZGp1c3RUYWIgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBsZXQgb2Zmc2V0ID0gaW5pdGlhbFxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSlcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3NcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjb25zdCBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBwb3MrK1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heFxuXG4gICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pXG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMClcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSlcbiAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSBvZmZzZXQgLSBpbml0aWFsXG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pXG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrIH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgIC8vIFF1aXJrIHRvIGVuZm9yY2UgXCJoYXJkIHRlcm1pbmF0aW9uIG1vZGVcIiBmb3IgcGFyYWdyYXBocztcbiAgICAgIC8vIG5vcm1hbGx5IGlmIHlvdSBjYWxsIGB0b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSlgLFxuICAgICAgLy8gcGFyYWdyYXBocyB3aWxsIGxvb2sgYmVsb3cgbmV4dExpbmUgZm9yIHBhcmFncmFwaCBjb250aW51YXRpb24sXG4gICAgICAvLyBidXQgaWYgYmxvY2txdW90ZSBpcyB0ZXJtaW5hdGVkIGJ5IGFub3RoZXIgdGFnLCB0aGV5IHNob3VsZG4ndFxuICAgICAgc3RhdGUubGluZU1heCA9IG5leHRMaW5lXG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pXG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSlcbiAgICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSlcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSlcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnRcbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKVxuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSlcbiAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKVxuICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pXG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMVxuICB9XG5cbiAgY29uc3Qgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50XG4gIHN0YXRlLmJsa0luZGVudCA9IDBcblxuICBjb25zdCB0b2tlbl9vICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfb3BlbicsICdibG9ja3F1b3RlJywgMSlcbiAgdG9rZW5fby5tYXJrdXAgPSAnPidcbiAgY29uc3QgbGluZXMgPSBbc3RhcnRMaW5lLCAwXVxuICB0b2tlbl9vLm1hcCAgICA9IGxpbmVzXG5cbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpXG5cbiAgY29uc3QgdG9rZW5fYyAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX2Nsb3NlJywgJ2Jsb2NrcXVvdGUnLCAtMSlcbiAgdG9rZW5fYy5tYXJrdXAgPSAnPidcblxuICBzdGF0ZS5saW5lTWF4ID0gb2xkTGluZU1heFxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZVxuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmVcblxuICAvLyBSZXN0b3JlIG9yaWdpbmFsIHRTaGlmdDsgdGhpcyBtaWdodCBub3QgYmUgbmVjZXNzYXJ5IHNpbmNlIHRoZSBwYXJzZXJcbiAgLy8gaGFzIGFscmVhZHkgYmVlbiBoZXJlLCBidXQganVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIGRvIHRoYXQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldXG4gICAgc3RhdGUudFNoaWZ0W2kgKyBzdGFydExpbmVdID0gb2xkVFNoaWZ0W2ldXG4gICAgc3RhdGUuc0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkU0NvdW50W2ldXG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV1cbiAgfVxuICBzdGF0ZS5ibGtJbmRlbnQgPSBvbGRJbmRlbnRcblxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/blockquote.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/code.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/code.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ code; }\n/* harmony export */ });\n// Code block (4 spaces padded)\n\nfunction code (state, startLine, endLine/*, silent */) {\n  if (state.sCount[startLine] - state.blkIndent < 4) { return false }\n\n  let nextLine = startLine + 1\n  let last = nextLine\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++\n      continue\n    }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      nextLine++\n      last = nextLine\n      continue\n    }\n    break\n  }\n\n  state.line = last\n\n  const token   = state.push('code_block', 'code', 0)\n  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\\n'\n  token.map     = [startLine, state.line]\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svY29kZS5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVlO0FBQ2YsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLm1qcz80NzlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29kZSAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQgKi8pIHtcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGxldCBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDFcbiAgbGV0IGxhc3QgPSBuZXh0TGluZVxuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKytcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrK1xuICAgICAgbGFzdCA9IG5leHRMaW5lXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBicmVha1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3RcblxuICBjb25zdCB0b2tlbiAgID0gc3RhdGUucHVzaCgnY29kZV9ibG9jaycsICdjb2RlJywgMClcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpICsgJ1xcbidcbiAgdG9rZW4ubWFwICAgICA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdXG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/code.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/fence.mjs":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/fence.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ fence; }\n/* harmony export */ });\n// fences (``` lang, ~~~ lang)\n\nfunction fence (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (pos + 3 > max) { return false }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) { return false }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true }\n\n  // search end of block\n  let nextLine = startLine\n  let haveEndMarker = false\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) { continue }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token   = state.push('fence', 'code', 0)\n  token.info    = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup  = markup\n  token.map     = [startLine, state.line]\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7O0FBRXhELHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UubWpzPzFhYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZlbmNlIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgbGV0IHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV1cbiAgbGV0IG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdXG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGNvbnN0IG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIGxldCBtZW0gPSBwb3NcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKVxuXG4gIGxldCBsZW4gPSBwb3MgLSBtZW1cblxuICBpZiAobGVuIDwgMykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGNvbnN0IG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcylcbiAgY29uc3QgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KVxuXG4gIGlmIChtYXJrZXIgPT09IDB4NjAgLyogYCAqLykge1xuICAgIGlmIChwYXJhbXMuaW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpID49IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFNpbmNlIHN0YXJ0IGlzIGZvdW5kLCB3ZSBjYW4gcmVwb3J0IHN1Y2Nlc3MgaGVyZSBpbiB2YWxpZGF0aW9uIG1vZGVcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBsZXQgbmV4dExpbmUgPSBzdGFydExpbmVcbiAgbGV0IGhhdmVFbmRNYXJrZXIgPSBmYWxzZVxuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHtcbiAgICAgIC8vIHVuY2xvc2VkIGJsb2NrIHNob3VsZCBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBkb2N1bWVudC5cbiAgICAgIC8vIGFsc28gYmxvY2sgc2VlbXMgdG8gYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgcGFyZW50XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdXG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICAvLyBub24tZW1wdHkgbGluZSB3aXRoIG5lZ2F0aXZlIGluZGVudCBzaG91bGQgc3RvcCB0aGUgbGlzdDpcbiAgICAgIC8vIC0gYGBgXG4gICAgICAvLyAgdGVzdFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlIH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBwb3MgPSBzdGF0ZS5za2lwQ2hhcnMocG9zLCBtYXJrZXIpXG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWUgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpXG5cbiAgICBpZiAocG9zIDwgbWF4KSB7IGNvbnRpbnVlIH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlXG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWtcbiAgfVxuXG4gIC8vIElmIGEgZmVuY2UgaGFzIGhlYWRpbmcgc3BhY2VzLCB0aGV5IHNob3VsZCBiZSByZW1vdmVkIGZyb20gaXRzIGlubmVyIGJsb2NrXG4gIGxlbiA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdXG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMClcblxuICBjb25zdCB0b2tlbiAgID0gc3RhdGUucHVzaCgnZmVuY2UnLCAnY29kZScsIDApXG4gIHRva2VuLmluZm8gICAgPSBwYXJhbXNcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpXG4gIHRva2VuLm1hcmt1cCAgPSBtYXJrdXBcbiAgdG9rZW4ubWFwICAgICA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdXG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/fence.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/heading.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/heading.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ heading; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// heading (#, ##, ...)\n\n\n\nfunction heading (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  let ch  = state.src.charCodeAt(pos)\n\n  if (ch !== 0x23/* # */ || pos >= max) { return false }\n\n  // count heading level\n  let level = 1\n  ch = state.src.charCodeAt(++pos)\n  while (ch === 0x23/* # */ && pos < max && level <= 6) {\n    level++\n    ch = state.src.charCodeAt(++pos)\n  }\n\n  if (level > 6 || (pos < max && !(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch))) { return false }\n\n  if (silent) { return true }\n\n  // Let's cut tails like '    ###  ' from the end of string\n\n  max = state.skipSpacesBack(max, pos)\n  const tmp = state.skipCharsBack(max, 0x23, pos) // #\n  if (tmp > pos && (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(state.src.charCodeAt(tmp - 1))) {\n    max = tmp\n  }\n\n  state.line = startLine + 1\n\n  const token_o  = state.push('heading_open', 'h' + String(level), 1)\n  token_o.markup = '########'.slice(0, level)\n  token_o.map    = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = state.src.slice(pos, max).trim()\n  token_i.map      = [startLine, state.line]\n  token_i.children = []\n\n  const token_c  = state.push('heading_close', 'h' + String(level), -1)\n  token_c.markup = '########'.slice(0, level)\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaGVhZGluZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFNkM7O0FBRTlCO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDs7QUFFeEQ7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsMERBQU8sU0FBUzs7QUFFbEQsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2hlYWRpbmcubWpzPzY3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGVhZGluZyAoIywgIyMsIC4uLilcblxuaW1wb3J0IHsgaXNTcGFjZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhlYWRpbmcgKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuICBsZXQgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGxldCBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpXG5cbiAgaWYgKGNoICE9PSAweDIzLyogIyAqLyB8fCBwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXQgbGV2ZWwgPSAxXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpXG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3BvcylcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgLy8gTGV0J3MgY3V0IHRhaWxzIGxpa2UgJyAgICAjIyMgICcgZnJvbSB0aGUgZW5kIG9mIHN0cmluZ1xuXG4gIG1heCA9IHN0YXRlLnNraXBTcGFjZXNCYWNrKG1heCwgcG9zKVxuICBjb25zdCB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKSAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXBcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyAxXG5cbiAgY29uc3QgdG9rZW5fbyAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKVxuICB0b2tlbl9vLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpXG4gIHRva2VuX28ubWFwICAgID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV1cblxuICBjb25zdCB0b2tlbl9pICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApXG4gIHRva2VuX2kuY29udGVudCAgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpLnRyaW0oKVxuICB0b2tlbl9pLm1hcCAgICAgID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV1cbiAgdG9rZW5faS5jaGlsZHJlbiA9IFtdXG5cbiAgY29uc3QgdG9rZW5fYyAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpXG4gIHRva2VuX2MubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbClcblxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/heading.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/hr.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/hr.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ hr; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Horizontal rule\n\n\n\nfunction hr (state, startLine, endLine, silent) {\n  const max = state.eMarks[startLine]\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const marker = state.src.charCodeAt(pos++)\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < max) {\n    const ch = state.src.charCodeAt(pos++)\n    if (ch !== marker && !(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) { return false }\n    if (ch === marker) { cnt++ }\n  }\n\n  if (cnt < 3) { return false }\n\n  if (silent) { return true }\n\n  state.line = startLine + 1\n\n  const token  = state.push('hr', 'hr', 0)\n  token.map    = [startLine, state.line]\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker))\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRTZDOztBQUU5QjtBQUNmO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBTyxRQUFRO0FBQ3pDLHlCQUF5QjtBQUN6Qjs7QUFFQSxpQkFBaUI7O0FBRWpCLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oci5tanM/ODBlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIb3Jpem9udGFsIHJ1bGVcblxuaW1wb3J0IHsgaXNTcGFjZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhyIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgY29uc3QgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV1cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuICBjb25zdCBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKylcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGxldCBjbnQgPSAxXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjb25zdCBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKVxuICAgIGlmIChjaCAhPT0gbWFya2VyICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrIH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDFcblxuICBjb25zdCB0b2tlbiAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApXG4gIHRva2VuLm1hcCAgICA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdXG4gIHRva2VuLm1hcmt1cCA9IEFycmF5KGNudCArIDEpLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKVxuXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/hr.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/html_block.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/html_block.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ html_block; }\n/* harmony export */ });\n/* harmony import */ var _common_html_blocks_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/html_blocks.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/html_blocks.mjs\");\n/* harmony import */ var _common_html_re_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/html_re.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/html_re.mjs\");\n// HTML block\n\n\n\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nconst HTML_SEQUENCES = [\n  [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n  [/^<!--/,        /-->/,   true],\n  [/^<\\?/,         /\\?>/,   true],\n  [/^<![A-Z]/,     />/,     true],\n  [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n  [new RegExp('^</?(' + _common_html_blocks_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n  [new RegExp(_common_html_re_mjs__WEBPACK_IMPORTED_MODULE_1__.HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false]\n]\n\nfunction html_block (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (!state.md.options.html) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false }\n\n  let lineText = state.src.slice(pos, max)\n\n  let i = 0\n  for (; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break }\n  }\n  if (i === HTML_SEQUENCES.length) { return false }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2]\n  }\n\n  let nextLine = startLine + 1\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n      lineText = state.src.slice(pos, max)\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++ }\n        break\n      }\n    }\n  }\n\n  state.line = nextLine\n\n  const token   = state.push('html_block', '', 0)\n  token.map     = [startLine, nextLine]\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true)\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHRtbF9ibG9jay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRW1EO0FBQ1c7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBVztBQUNuQyxjQUFjLHVFQUFzQjtBQUNwQzs7QUFFZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7O0FBRXhELGdDQUFnQzs7QUFFaEMsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDLCtDQUErQztBQUMvQztBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0Isc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLm1qcz82ZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhUTUwgYmxvY2tcblxuaW1wb3J0IGJsb2NrX25hbWVzIGZyb20gJy4uL2NvbW1vbi9odG1sX2Jsb2Nrcy5tanMnXG5pbXBvcnQgeyBIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIH0gZnJvbSAnLi4vY29tbW9uL2h0bWxfcmUubWpzJ1xuXG4vLyBBbiBhcnJheSBvZiBvcGVuaW5nIGFuZCBjb3JyZXNwb25kaW5nIGNsb3Npbmcgc2VxdWVuY2VzIGZvciBodG1sIHRhZ3MsXG4vLyBsYXN0IGFyZ3VtZW50IGRlZmluZXMgd2hldGhlciBpdCBjYW4gdGVybWluYXRlIGEgcGFyYWdyYXBoIG9yIG5vdFxuLy9cbmNvbnN0IEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbL148KHNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKT4vaSwgdHJ1ZV0sXG4gIFsvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZV0sXG4gIFsvXjxcXD8vLCAgICAgICAgIC9cXD8+LywgICB0cnVlXSxcbiAgWy9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlXSxcbiAgWy9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZV0sXG4gIFtuZXcgUmVnRXhwKCdePC8/KCcgKyBibG9ja19uYW1lcy5qb2luKCd8JykgKyAnKSg/PShcXFxcc3wvPz58JCkpJywgJ2knKSwgL14kLywgdHJ1ZV0sXG4gIFtuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlXVxuXVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBodG1sX2Jsb2NrIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgbGV0IHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV1cbiAgbGV0IG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdXG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGxldCBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heClcblxuICBsZXQgaSA9IDBcbiAgZm9yICg7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhayB9XG4gIH1cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGlmIChzaWxlbnQpIHtcbiAgICAvLyB0cnVlIGlmIHRoaXMgc2VxdWVuY2UgY2FuIGJlIGEgdGVybWluYXRvciwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgcmV0dXJuIEhUTUxfU0VRVUVOQ0VTW2ldWzJdXG4gIH1cblxuICBsZXQgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxXG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhayB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdXG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heClcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKyB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lXG5cbiAgY29uc3QgdG9rZW4gICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMClcbiAgdG9rZW4ubWFwICAgICA9IFtzdGFydExpbmUsIG5leHRMaW5lXVxuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCB0cnVlKVxuXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/html_block.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/lheading.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/lheading.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ lheading; }\n/* harmony export */ });\n// lheading (---, ===)\n\nfunction lheading (state, startLine, endLine/*, silent */) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph')\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  const oldParentType = state.parentType\n  state.parentType = 'paragraph' // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  let level = 0\n  let marker\n  let nextLine = startLine + 1\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      const max = state.eMarks[nextLine]\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos)\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker)\n          pos = state.skipSpaces(pos)\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2)\n            break\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n\n  state.line = nextLine + 1\n\n  const token_o    = state.push('heading_open', 'h' + String(level), 1)\n  token_o.markup   = String.fromCharCode(marker)\n  token_o.map      = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = content\n  token_i.map      = [startLine, state.line - 1]\n  token_i.children = []\n\n  const token_c    = state.push('heading_close', 'h' + String(level), -1)\n  token_c.markup   = String.fromCharCode(marker)\n\n  state.parentType = oldParentType\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFZTtBQUNmOztBQUVBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsZ0RBQWdEO0FBQ3pEO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLm1qcz9mODk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGhlYWRpbmcgKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUvKiwgc2lsZW50ICovKSB7XG4gIGNvbnN0IHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgY29uc3Qgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGVcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnIC8vIHVzZSBwYXJhZ3JhcGggdG8gbWF0Y2ggdGVybWluYXRvclJ1bGVzXG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBsZXQgbGV2ZWwgPSAwXG4gIGxldCBtYXJrZXJcbiAgbGV0IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMVxuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZSB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV1cbiAgICAgIGNvbnN0IG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV1cblxuICAgICAgaWYgKHBvcyA8IG1heCkge1xuICAgICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpXG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcilcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcylcblxuICAgICAgICAgIGlmIChwb3MgPj0gbWF4KSB7XG4gICAgICAgICAgICBsZXZlbCA9IChtYXJrZXIgPT09IDB4M0QvKiA9ICovID8gMSA6IDIpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlIH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrIH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKClcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxXG5cbiAgY29uc3QgdG9rZW5fbyAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfb3BlbicsICdoJyArIFN0cmluZyhsZXZlbCksIDEpXG4gIHRva2VuX28ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcilcbiAgdG9rZW5fby5tYXAgICAgICA9IFtzdGFydExpbmUsIHN0YXRlLmxpbmVdXG5cbiAgY29uc3QgdG9rZW5faSAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKVxuICB0b2tlbl9pLmNvbnRlbnQgID0gY29udGVudFxuICB0b2tlbl9pLm1hcCAgICAgID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZSAtIDFdXG4gIHRva2VuX2kuY2hpbGRyZW4gPSBbXVxuXG4gIGNvbnN0IHRva2VuX2MgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpXG4gIHRva2VuX2MubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcilcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZVxuXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/lheading.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/list.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/list.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ list; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Lists\n\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker (state, startLine) {\n  const max = state.eMarks[startLine]\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n\n  const marker = state.src.charCodeAt(pos++)\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1\n  }\n\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) {\n      // \" -test \" - is not a list item\n      return -1\n    }\n  }\n\n  return pos\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker (state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine]\n  const max = state.eMarks[startLine]\n  let pos = start\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1 }\n\n  let ch = state.src.charCodeAt(pos++)\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1 }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1 }\n\n    ch = state.src.charCodeAt(pos++)\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1 }\n\n      continue\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break\n    }\n\n    return -1\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos)\n\n    if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1\n    }\n  }\n  return pos\n}\n\nfunction markTightParagraphs (state, idx) {\n  const level = state.level + 2\n\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true\n      state.tokens[i].hidden = true\n      i += 2\n    }\n  }\n}\n\nfunction list (state, startLine, endLine, silent) {\n  let max, pos, start, token\n  let nextLine = startLine\n  let tight = true\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[nextLine] - state.listIndent >= 4 &&\n      state.sCount[nextLine] < state.blkIndent) {\n    return false\n  }\n\n  let isTerminatingParagraph = false\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true\n    }\n  }\n\n  // Detect list type and position after marker\n  let isOrdered\n  let markerValue\n  let posAfterMarker\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true\n    start = state.bMarks[nextLine] + state.tShift[nextLine]\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1))\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false\n  } else {\n    return false\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false\n  }\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true }\n\n  // We should terminate list on style change. Remember first one to compare.\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1)\n\n  // Start list\n  const listTokIdx = state.tokens.length\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1)\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]]\n    }\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1)\n  }\n\n  const listLines = [nextLine, 0]\n  token.map    = listLines\n  token.markup = String.fromCharCode(markerCharCode)\n\n  //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false\n  const terminatorRules = state.md.block.ruler.getRules('list')\n\n  const oldParentType = state.parentType\n  state.parentType = 'list'\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker\n    max = state.eMarks[nextLine]\n\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine])\n    let offset = initial\n\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos)\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4\n      } else if (ch === 0x20) {\n        offset++\n      } else {\n        break\n      }\n\n      pos++\n    }\n\n    const contentStart = pos\n    let indentAfterMarker\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1\n    } else {\n      indentAfterMarker = offset - initial\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1 }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    const indent = initial + indentAfterMarker\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1)\n    token.markup = String.fromCharCode(markerCharCode)\n    const itemLines = [nextLine, 0]\n    token.map    = itemLines\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1)\n    }\n\n    // change current state, then restore it after parser subcall\n    const oldTight = state.tight\n    const oldTShift = state.tShift[nextLine]\n    const oldSCount = state.sCount[nextLine]\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    const oldListIndent = state.listIndent\n    state.listIndent = state.blkIndent\n    state.blkIndent = indent\n\n    state.tight = true\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine]\n    state.sCount[nextLine] = offset\n\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine)\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true)\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - nextLine) > 1 && state.isEmpty(state.line - 1)\n\n    state.blkIndent = state.listIndent\n    state.listIndent = oldListIndent\n    state.tShift[nextLine] = oldTShift\n    state.sCount[nextLine] = oldSCount\n    state.tight = oldTight\n\n    token        = state.push('list_item_close', 'li', -1)\n    token.markup = String.fromCharCode(markerCharCode)\n\n    nextLine = state.line\n    itemLines[1] = nextLine\n\n    if (nextLine >= endLine) { break }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n\n    // fail if terminating block found\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1)\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1)\n  }\n  token.markup = String.fromCharCode(markerCharCode)\n\n  listLines[1] = nextLine\n  state.line = nextLine\n\n  state.parentType = oldParentType\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx)\n  }\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDBEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQSw4Q0FBOEM7O0FBRTlDLFNBQVM7QUFDVDtBQUNBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDBEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUEsdUVBQXVFO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGlzdC5tanM/N2UxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMaXN0c1xuXG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlciAoc3RhdGUsIHN0YXJ0TGluZSkge1xuICBjb25zdCBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXVxuICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuXG4gIGNvbnN0IG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKVxuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjb25zdCBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIC10ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zXG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyIChzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIGNvbnN0IHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuICBjb25zdCBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXVxuICBsZXQgcG9zID0gc3RhcnRcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMSB9XG5cbiAgbGV0IGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspXG5cbiAgaWYgKGNoIDwgMHgzMC8qIDAgKi8gfHwgY2ggPiAweDM5LyogOSAqLykgeyByZXR1cm4gLTEgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMSB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKVxuXG4gICAgaWYgKGNoID49IDB4MzAvKiAwICovICYmIGNoIDw9IDB4MzkvKiA5ICovKSB7XG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMSB9XG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpXG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAxLnRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zXG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMgKHN0YXRlLCBpZHgpIHtcbiAgY29uc3QgbGV2ZWwgPSBzdGF0ZS5sZXZlbCArIDJcblxuICBmb3IgKGxldCBpID0gaWR4ICsgMiwgbCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHN0YXRlLnRva2Vuc1tpXS5sZXZlbCA9PT0gbGV2ZWwgJiYgc3RhdGUudG9rZW5zW2ldLnR5cGUgPT09ICdwYXJhZ3JhcGhfb3BlbicpIHtcbiAgICAgIHN0YXRlLnRva2Vuc1tpICsgMl0uaGlkZGVuID0gdHJ1ZVxuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWVcbiAgICAgIGkgKz0gMlxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0IChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgbGV0IG1heCwgcG9zLCBzdGFydCwgdG9rZW5cbiAgbGV0IG5leHRMaW5lID0gc3RhcnRMaW5lXG4gIGxldCB0aWdodCA9IHRydWVcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlOlxuICAvLyAgLSBpdGVtIDFcbiAgLy8gICAtIGl0ZW0gMlxuICAvLyAgICAtIGl0ZW0gM1xuICAvLyAgICAgLSBpdGVtIDRcbiAgLy8gICAgICAtIHRoaXMgb25lIGlzIGEgcGFyYWdyYXBoIGNvbnRpbnVhdGlvblxuICBpZiAoc3RhdGUubGlzdEluZGVudCA+PSAwICYmXG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUubGlzdEluZGVudCA+PSA0ICYmXG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlXG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIERldGVjdCBsaXN0IHR5cGUgYW5kIHBvc2l0aW9uIGFmdGVyIG1hcmtlclxuICBsZXQgaXNPcmRlcmVkXG4gIGxldCBtYXJrZXJWYWx1ZVxuICBsZXQgcG9zQWZ0ZXJNYXJrZXJcbiAgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gdHJ1ZVxuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV1cbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSkpXG5cbiAgICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyBvcmRlcmVkIGxpc3QgcmlnaHQgYWZ0ZXJcbiAgICAvLyBhIHBhcmFncmFwaCwgaXQgc2hvdWxkIHN0YXJ0IHdpdGggMS5cbiAgICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCAmJiBtYXJrZXJWYWx1ZSAhPT0gMSkgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoKHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKSkgPj0gMCkge1xuICAgIGlzT3JkZXJlZCA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEZvciB2YWxpZGF0aW9uIG1vZGUgd2UgY2FuIHRlcm1pbmF0ZSBpbW1lZGlhdGVseVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlIH1cblxuICAvLyBXZSBzaG91bGQgdGVybWluYXRlIGxpc3Qgb24gc3R5bGUgY2hhbmdlLiBSZW1lbWJlciBmaXJzdCBvbmUgdG8gY29tcGFyZS5cbiAgY29uc3QgbWFya2VyQ2hhckNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpXG5cbiAgLy8gU3RhcnQgbGlzdFxuICBjb25zdCBsaXN0VG9rSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aFxuXG4gIGlmIChpc09yZGVyZWQpIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ29yZGVyZWRfbGlzdF9vcGVuJywgJ29sJywgMSlcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gW1snc3RhcnQnLCBtYXJrZXJWYWx1ZV1dXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3Rfb3BlbicsICd1bCcsIDEpXG4gIH1cblxuICBjb25zdCBsaXN0TGluZXMgPSBbbmV4dExpbmUsIDBdXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lc1xuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKVxuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIGxldCBwcmV2RW1wdHlFbmQgPSBmYWxzZVxuICBjb25zdCB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnbGlzdCcpXG5cbiAgY29uc3Qgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGVcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0J1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBwb3MgPSBwb3NBZnRlck1hcmtlclxuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pXG4gICAgbGV0IG9mZnNldCA9IGluaXRpYWxcblxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvbnN0IGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuXG4gICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pICUgNFxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgcG9zKytcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50U3RhcnQgPSBwb3NcbiAgICBsZXQgaW5kZW50QWZ0ZXJNYXJrZXJcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4KSB7XG4gICAgICAvLyB0cmltbWluZyBzcGFjZSBpbiBcIi0gICAgXFxuICAzXCIgY2FzZSwgaW5kZW50IGlzIDEgaGVyZVxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gb2Zmc2V0IC0gaW5pdGlhbFxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxIH1cblxuICAgIC8vIFwiICAtICB0ZXN0XCJcbiAgICAvLyAgXl5eXl4gLSBjYWxjdWxhdGluZyB0b3RhbCBsZW5ndGggb2YgdGhpcyB0aGluZ1xuICAgIGNvbnN0IGluZGVudCA9IGluaXRpYWwgKyBpbmRlbnRBZnRlck1hcmtlclxuXG4gICAgLy8gUnVuIHN1YnBhcnNlciAmIHdyaXRlIHRva2Vuc1xuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9vcGVuJywgJ2xpJywgMSlcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKVxuICAgIGNvbnN0IGl0ZW1MaW5lcyA9IFtuZXh0TGluZSwgMF1cbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXNcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICB0b2tlbi5pbmZvID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIDEpXG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGN1cnJlbnQgc3RhdGUsIHRoZW4gcmVzdG9yZSBpdCBhZnRlciBwYXJzZXIgc3ViY2FsbFxuICAgIGNvbnN0IG9sZFRpZ2h0ID0gc3RhdGUudGlnaHRcbiAgICBjb25zdCBvbGRUU2hpZnQgPSBzdGF0ZS50U2hpZnRbbmV4dExpbmVdXG4gICAgY29uc3Qgb2xkU0NvdW50ID0gc3RhdGUuc0NvdW50W25leHRMaW5lXVxuXG4gICAgLy8gIC0gZXhhbXBsZSBsaXN0XG4gICAgLy8gXiBsaXN0SW5kZW50IHBvc2l0aW9uIHdpbGwgYmUgaGVyZVxuICAgIC8vICAgXiBibGtJbmRlbnQgcG9zaXRpb24gd2lsbCBiZSBoZXJlXG4gICAgLy9cbiAgICBjb25zdCBvbGRMaXN0SW5kZW50ID0gc3RhdGUubGlzdEluZGVudFxuICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnRcbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBpbmRlbnRcblxuICAgIHN0YXRlLnRpZ2h0ID0gdHJ1ZVxuICAgIHN0YXRlLnRTaGlmdFtuZXh0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdXG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldFxuXG4gICAgaWYgKGNvbnRlbnRTdGFydCA+PSBtYXggJiYgc3RhdGUuaXNFbXB0eShuZXh0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKVxuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlXG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBuZXh0TGluZSkgPiAxICYmIHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpXG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50XG4gICAgc3RhdGUubGlzdEluZGVudCA9IG9sZExpc3RJbmRlbnRcbiAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gb2xkVFNoaWZ0XG4gICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9sZFNDb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHRcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKVxuICAgIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpXG5cbiAgICBuZXh0TGluZSA9IHN0YXRlLmxpbmVcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZVxuXG4gICAgaWYgKG5leHRMaW5lID49IGVuZExpbmUpIHsgYnJlYWsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrIH1cblxuICAgIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhayB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrIH1cblxuICAgIC8vIGZhaWwgaWYgbGlzdCBoYXMgYW5vdGhlciB0eXBlXG4gICAgaWYgKGlzT3JkZXJlZCkge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKVxuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhayB9XG4gICAgICBzdGFydCA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKVxuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhayB9XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlckNoYXJDb2RlICE9PSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3NBZnRlck1hcmtlciAtIDEpKSB7IGJyZWFrIH1cbiAgfVxuXG4gIC8vIEZpbmFsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpXG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9jbG9zZScsICd1bCcsIC0xKVxuICB9XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpXG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmVcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lXG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGVcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/list.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/paragraph.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/paragraph.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ paragraph; }\n/* harmony export */ });\n// Paragraph\n\nfunction paragraph (state, startLine, endLine) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph')\n  const oldParentType = state.parentType\n  let nextLine = startLine + 1\n  state.parentType = 'paragraph'\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n\n  state.line = nextLine\n\n  const token_o    = state.push('paragraph_open', 'p', 1)\n  token_o.map      = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = content\n  token_i.map      = [startLine, state.line]\n  token_i.children = []\n\n  state.push('paragraph_close', 'p', -1)\n\n  state.parentType = oldParentType\n\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0RBQWdEO0FBQ3pEO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGgubWpzPzFhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGFyYWdyYXBoXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBhcmFncmFwaCAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICBjb25zdCB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJylcbiAgY29uc3Qgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGVcbiAgbGV0IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMVxuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCdcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZSB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZSB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIGxldCB0ZXJtaW5hdGUgPSBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhayB9XG4gIH1cblxuICBjb25zdCBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpXG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lXG5cbiAgY29uc3QgdG9rZW5fbyAgICA9IHN0YXRlLnB1c2goJ3BhcmFncmFwaF9vcGVuJywgJ3AnLCAxKVxuICB0b2tlbl9vLm1hcCAgICAgID0gW3N0YXJ0TGluZSwgc3RhdGUubGluZV1cblxuICBjb25zdCB0b2tlbl9pICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApXG4gIHRva2VuX2kuY29udGVudCAgPSBjb250ZW50XG4gIHRva2VuX2kubWFwICAgICAgPSBbc3RhcnRMaW5lLCBzdGF0ZS5saW5lXVxuICB0b2tlbl9pLmNoaWxkcmVuID0gW11cblxuICBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlXG5cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/paragraph.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/reference.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/reference.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ reference; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n\n\nfunction reference (state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  function getNextLine (nextLine) {\n    const endLine = state.lineMax\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null\n    }\n\n    let isContinuation = false\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { isContinuation = true }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { isContinuation = true }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference')\n      const oldParentType = state.parentType\n      state.parentType = 'reference'\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true\n          break\n        }\n      }\n\n      state.parentType = oldParentType\n      if (terminate) {\n        // terminated by another block\n        return null\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    const max = state.eMarks[nextLine]\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1)\n  }\n\n  let str = state.src.slice(pos, max + 1)\n\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine)\n        if (lineContent !== null) {\n          str += lineContent\n          max = str.length\n          nextLine++\n        }\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if ((0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = nextLine\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if ((0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine)\n    if (lineContent === null) break\n    str += lineContent\n    pos = max\n    max = str.length\n    nextLine++\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)\n  }\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n  } else {\n    title = ''\n    pos = destEndPos\n    nextLine = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      nextLine = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeReference)(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.line = nextLine\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRTs7QUFFbEQ7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7O0FBRXhELG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUywwREFBTztBQUN0QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBEQUFPO0FBQ3RCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBTyxRQUFRO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwREFBTyxRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixxRUFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLm1qcz9lODZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU3BhY2UsIG5vcm1hbGl6ZVJlZmVyZW5jZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZmVyZW5jZSAoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXVxuICBsZXQgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV1cbiAgbGV0IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZSB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExpbmUgKG5leHRMaW5lKSB7XG4gICAgY29uc3QgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXhcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lIHx8IHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICAvLyBlbXB0eSBsaW5lIG9yIGVuZCBvZiBpbnB1dFxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBsZXQgaXNDb250aW51YXRpb24gPSBmYWxzZVxuXG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBpc0NvbnRpbnVhdGlvbiA9IHRydWUgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgaXNDb250aW51YXRpb24gPSB0cnVlIH1cblxuICAgIGlmICghaXNDb250aW51YXRpb24pIHtcbiAgICAgIGNvbnN0IHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKVxuICAgICAgY29uc3Qgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGVcbiAgICAgIHN0YXRlLnBhcmVudFR5cGUgPSAncmVmZXJlbmNlJ1xuXG4gICAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgICAgbGV0IHRlcm1pbmF0ZSA9IGZhbHNlXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgICAgdGVybWluYXRlID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGVcbiAgICAgIGlmICh0ZXJtaW5hdGUpIHtcbiAgICAgICAgLy8gdGVybWluYXRlZCBieSBhbm90aGVyIGJsb2NrXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV1cbiAgICBjb25zdCBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdXG5cbiAgICAvLyBtYXggKyAxIGV4cGxpY2l0bHkgaW5jbHVkZXMgdGhlIG5ld2xpbmVcbiAgICByZXR1cm4gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4ICsgMSlcbiAgfVxuXG4gIGxldCBzdHIgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXggKyAxKVxuXG4gIG1heCA9IHN0ci5sZW5ndGhcbiAgbGV0IGxhYmVsRW5kID0gLTFcblxuICBmb3IgKHBvcyA9IDE7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjb25zdCBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvc1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBnZXROZXh0TGluZShuZXh0TGluZSlcbiAgICAgIGlmIChsaW5lQ29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICBzdHIgKz0gbGluZUNvbnRlbnRcbiAgICAgICAgbWF4ID0gc3RyLmxlbmd0aFxuICAgICAgICBuZXh0TGluZSsrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1QyAvKiBcXCAqLykge1xuICAgICAgcG9zKytcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IGdldE5leHRMaW5lKG5leHRMaW5lKVxuICAgICAgICBpZiAobGluZUNvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gbGluZUNvbnRlbnRcbiAgICAgICAgICBtYXggPSBzdHIubGVuZ3RoXG4gICAgICAgICAgbmV4dExpbmUrK1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgXl5eIHNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBoZXJlXG4gIGZvciAocG9zID0gbGFiZWxFbmQgKyAyOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY29uc3QgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpXG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBjb25zdCBsaW5lQ29udGVudCA9IGdldE5leHRMaW5lKG5leHRMaW5lKVxuICAgICAgaWYgKGxpbmVDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN0ciArPSBsaW5lQ29udGVudFxuICAgICAgICBtYXggPSBzdHIubGVuZ3RoXG4gICAgICAgIG5leHRMaW5lKytcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKiBlc2xpbnQgbm8tZW1wdHk6MCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICBjb25zdCBkZXN0UmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KVxuICBpZiAoIWRlc3RSZXMub2spIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhkZXN0UmVzLnN0cilcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBwb3MgPSBkZXN0UmVzLnBvc1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGNvbnN0IGRlc3RFbmRQb3MgPSBwb3NcbiAgY29uc3QgZGVzdEVuZExpbmVObyA9IG5leHRMaW5lXG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgY29uc3Qgc3RhcnQgPSBwb3NcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjb25zdCBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gZ2V0TmV4dExpbmUobmV4dExpbmUpXG4gICAgICBpZiAobGluZUNvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb250ZW50XG4gICAgICAgIG1heCA9IHN0ci5sZW5ndGhcbiAgICAgICAgbmV4dExpbmUrK1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qIGVzbGludCBuby1lbXB0eTowICovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICBsZXQgdGl0bGVSZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpXG4gIHdoaWxlICh0aXRsZVJlcy5jYW5fY29udGludWUpIHtcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGdldE5leHRMaW5lKG5leHRMaW5lKVxuICAgIGlmIChsaW5lQ29udGVudCA9PT0gbnVsbCkgYnJlYWtcbiAgICBzdHIgKz0gbGluZUNvbnRlbnRcbiAgICBwb3MgPSBtYXhcbiAgICBtYXggPSBzdHIubGVuZ3RoXG4gICAgbmV4dExpbmUrK1xuICAgIHRpdGxlUmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdHIsIHBvcywgbWF4LCB0aXRsZVJlcylcbiAgfVxuICBsZXQgdGl0bGVcblxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgdGl0bGVSZXMub2spIHtcbiAgICB0aXRsZSA9IHRpdGxlUmVzLnN0clxuICAgIHBvcyA9IHRpdGxlUmVzLnBvc1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJydcbiAgICBwb3MgPSBkZXN0RW5kUG9zXG4gICAgbmV4dExpbmUgPSBkZXN0RW5kTGluZU5vXG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29uc3QgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhayB9XG4gICAgcG9zKytcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJ1xuICAgICAgcG9zID0gZGVzdEVuZFBvc1xuICAgICAgbmV4dExpbmUgPSBkZXN0RW5kTGluZU5vXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrIH1cbiAgICAgICAgcG9zKytcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpXG4gIGlmICghbGFiZWwpIHtcbiAgICAvLyBDb21tb25NYXJrIDAuMjAgZGlzYWxsb3dzIGVtcHR5IGxhYmVsc1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWUgfVxuXG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXMgPSB7fVxuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGUsIGhyZWYgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/reference.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/state_block.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/state_block.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _token_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../token.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/token.mjs\");\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Parser state class\n\n\n\n\nfunction StateBlock (src, md, env, tokens) {\n  this.src = src\n\n  // link to parser instance\n  this.md     = md\n\n  this.env = env\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens\n\n  this.bMarks = []  // line begin offsets for fast jumps\n  this.eMarks = []  // line end offsets for fast jumps\n  this.tShift = []  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = []\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent  = 0\n  this.line       = 0 // line index in src\n  this.lineMax    = 0 // lines count\n  this.tight      = false  // loose/tight mode for lists\n  this.ddIndent   = -1 // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1 // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root'\n\n  this.level = 0\n\n  // Create caches\n  // Generate markers.\n  const s = this.src\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos)\n\n    if (!indent_found) {\n      if ((0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isSpace)(ch)) {\n        indent++\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4\n        } else {\n          offset++\n        }\n        continue\n      } else {\n        indent_found = true\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++ }\n      this.bMarks.push(start)\n      this.eMarks.push(pos)\n      this.tShift.push(indent)\n      this.sCount.push(offset)\n      this.bsCount.push(0)\n\n      indent_found = false\n      indent = 0\n      offset = 0\n      start = pos + 1\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length)\n  this.eMarks.push(s.length)\n  this.tShift.push(0)\n  this.sCount.push(0)\n  this.bsCount.push(0)\n\n  this.lineMax = this.bMarks.length - 1 // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](type, tag, nesting)\n  token.block = true\n\n  if (nesting < 0) this.level-- // closing tag\n  token.level = this.level\n  if (nesting > 0) this.level++ // opening tag\n\n  this.tokens.push(token)\n  return token\n}\n\nStateBlock.prototype.isEmpty = function isEmpty (line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]\n}\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines (from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break\n    }\n  }\n  return from\n}\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces (pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos)\n    if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isSpace)(ch)) { break }\n  }\n  return pos\n}\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack (pos, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isSpace)(this.src.charCodeAt(--pos))) { return pos + 1 }\n  }\n  return pos\n}\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars (pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break }\n  }\n  return pos\n}\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack (pos, code, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1 }\n  }\n  return pos\n}\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines (begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return ''\n  }\n\n  const queue = new Array(end - begin)\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0\n    const lineStart = this.bMarks[line]\n    let first = lineStart\n    let last\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1\n    } else {\n      last = this.eMarks[line]\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first)\n\n      if ((0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isSpace)(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4\n        } else {\n          lineIndent++\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++\n      } else {\n        break\n      }\n\n      first++\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)\n    } else {\n      queue[i] = this.src.slice(first, last)\n    }\n  }\n\n  return queue.join('')\n}\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StateBlock);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2subWpzIiwibWFwcGluZ3MiOiI7OztBQUFBOztBQUVnQztBQUNhOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZGQUE2RixXQUFXO0FBQ3hHOztBQUVBO0FBQ0EsVUFBVSwwREFBTztBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtEQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBLFNBQVMsMERBQU8sUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSxTQUFTLDBEQUFPLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLDBEQUFPO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixrREFBSzs7QUFFbEMsK0RBQWUsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrLm1qcz9kNmE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG5pbXBvcnQgVG9rZW4gZnJvbSAnLi4vdG9rZW4ubWpzJ1xuaW1wb3J0IHsgaXNTcGFjZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmZ1bmN0aW9uIFN0YXRlQmxvY2sgKHNyYywgbWQsIGVudiwgdG9rZW5zKSB7XG4gIHRoaXMuc3JjID0gc3JjXG5cbiAgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2VcbiAgdGhpcy5tZCAgICAgPSBtZFxuXG4gIHRoaXMuZW52ID0gZW52XG5cbiAgLy9cbiAgLy8gSW50ZXJuYWwgc3RhdGUgdmFydGlhYmxlc1xuICAvL1xuXG4gIHRoaXMudG9rZW5zID0gdG9rZW5zXG5cbiAgdGhpcy5iTWFya3MgPSBbXSAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW10gIC8vIGxpbmUgZW5kIG9mZnNldHMgZm9yIGZhc3QganVtcHNcbiAgdGhpcy50U2hpZnQgPSBbXSAgLy8gb2Zmc2V0cyBvZiB0aGUgZmlyc3Qgbm9uLXNwYWNlIGNoYXJhY3RlcnMgKHRhYnMgbm90IGV4cGFuZGVkKVxuICB0aGlzLnNDb3VudCA9IFtdICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdXG5cbiAgLy8gYmxvY2sgcGFyc2VyIHZhcmlhYmxlc1xuXG4gIC8vIHJlcXVpcmVkIGJsb2NrIGNvbnRlbnQgaW5kZW50IChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlXG4gIC8vIGluc2lkZSBhIGxpc3QsIGl0IHdvdWxkIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgbGlzdCBtYXJrZXIpXG4gIHRoaXMuYmxrSW5kZW50ICA9IDBcbiAgdGhpcy5saW5lICAgICAgID0gMCAvLyBsaW5lIGluZGV4IGluIHNyY1xuICB0aGlzLmxpbmVNYXggICAgPSAwIC8vIGxpbmVzIGNvdW50XG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMSAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgZGQgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcbiAgdGhpcy5saXN0SW5kZW50ID0gLTEgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGxpc3QgYmxvY2sgKC0xIGlmIHRoZXJlIGlzbid0IGFueSlcblxuICAvLyBjYW4gYmUgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdyb290JywgJ3BhcmFncmFwaCcgb3IgJ3JlZmVyZW5jZSdcbiAgLy8gdXNlZCBpbiBsaXN0cyB0byBkZXRlcm1pbmUgaWYgdGhleSBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGhcbiAgdGhpcy5wYXJlbnRUeXBlID0gJ3Jvb3QnXG5cbiAgdGhpcy5sZXZlbCA9IDBcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIGNvbnN0IHMgPSB0aGlzLnNyY1xuXG4gIGZvciAobGV0IHN0YXJ0ID0gMCwgcG9zID0gMCwgaW5kZW50ID0gMCwgb2Zmc2V0ID0gMCwgbGVuID0gcy5sZW5ndGgsIGluZGVudF9mb3VuZCA9IGZhbHNlOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY29uc3QgY2ggPSBzLmNoYXJDb2RlQXQocG9zKVxuXG4gICAgaWYgKCFpbmRlbnRfZm91bmQpIHtcbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpbmRlbnQrK1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIG9mZnNldCArPSA0IC0gb2Zmc2V0ICUgNFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGVudF9mb3VuZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKysgfVxuICAgICAgdGhpcy5iTWFya3MucHVzaChzdGFydClcbiAgICAgIHRoaXMuZU1hcmtzLnB1c2gocG9zKVxuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpXG4gICAgICB0aGlzLnNDb3VudC5wdXNoKG9mZnNldClcbiAgICAgIHRoaXMuYnNDb3VudC5wdXNoKDApXG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlXG4gICAgICBpbmRlbnQgPSAwXG4gICAgICBvZmZzZXQgPSAwXG4gICAgICBzdGFydCA9IHBvcyArIDFcbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGZha2UgZW50cnkgdG8gc2ltcGxpZnkgY2FjaGUgYm91bmRzIGNoZWNrc1xuICB0aGlzLmJNYXJrcy5wdXNoKHMubGVuZ3RoKVxuICB0aGlzLmVNYXJrcy5wdXNoKHMubGVuZ3RoKVxuICB0aGlzLnRTaGlmdC5wdXNoKDApXG4gIHRoaXMuc0NvdW50LnB1c2goMClcbiAgdGhpcy5ic0NvdW50LnB1c2goMClcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxIC8vIGRvbid0IGNvdW50IGxhc3QgZmFrZSBsaW5lXG59XG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vL1xuU3RhdGVCbG9jay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgY29uc3QgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICB0b2tlbi5ibG9jayA9IHRydWVcblxuICBpZiAobmVzdGluZyA8IDApIHRoaXMubGV2ZWwtLSAvLyBjbG9zaW5nIHRhZ1xuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWxcbiAgaWYgKG5lc3RpbmcgPiAwKSB0aGlzLmxldmVsKysgLy8gb3BlbmluZyB0YWdcblxuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKVxuICByZXR1cm4gdG9rZW5cbn1cblxuU3RhdGVCbG9jay5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV1cbn1cblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcEVtcHR5TGluZXMgPSBmdW5jdGlvbiBza2lwRW1wdHlMaW5lcyAoZnJvbSkge1xuICBmb3IgKGxldCBtYXggPSB0aGlzLmxpbmVNYXg7IGZyb20gPCBtYXg7IGZyb20rKykge1xuICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBmcm9tXG59XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyAocG9zKSB7XG4gIGZvciAobGV0IG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNvbnN0IGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIHBvc1xufVxuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uIGluIHJldmVyc2UuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzQmFjayA9IGZ1bmN0aW9uIHNraXBTcGFjZXNCYWNrIChwb3MsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zIH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKCFpc1NwYWNlKHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSkgeyByZXR1cm4gcG9zICsgMSB9XG4gIH1cbiAgcmV0dXJuIHBvc1xufVxuXG4vLyBTa2lwIGNoYXIgY29kZXMgZnJvbSBnaXZlbiBwb3NpdGlvblxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzID0gZnVuY3Rpb24gc2tpcENoYXJzIChwb3MsIGNvZGUpIHtcbiAgZm9yIChsZXQgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIHBvc1xufVxuXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzQmFjayA9IGZ1bmN0aW9uIHNraXBDaGFyc0JhY2sgKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3MgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoY29kZSAhPT0gdGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpIHsgcmV0dXJuIHBvcyArIDEgfVxuICB9XG4gIHJldHVybiBwb3Ncbn1cblxuLy8gY3V0IGxpbmVzIHJhbmdlIGZyb20gc291cmNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyAoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIGlmIChiZWdpbiA+PSBlbmQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGNvbnN0IHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKVxuXG4gIGZvciAobGV0IGkgPSAwLCBsaW5lID0gYmVnaW47IGxpbmUgPCBlbmQ7IGxpbmUrKywgaSsrKSB7XG4gICAgbGV0IGxpbmVJbmRlbnQgPSAwXG4gICAgY29uc3QgbGluZVN0YXJ0ID0gdGhpcy5iTWFya3NbbGluZV1cbiAgICBsZXQgZmlyc3QgPSBsaW5lU3RhcnRcbiAgICBsZXQgbGFzdFxuXG4gICAgaWYgKGxpbmUgKyAxIDwgZW5kIHx8IGtlZXBMYXN0TEYpIHtcbiAgICAgIC8vIE5vIG5lZWQgZm9yIGJvdW5kcyBjaGVjayBiZWNhdXNlIHdlIGhhdmUgZmFrZSBlbnRyeSBvbiB0YWlsLlxuICAgICAgbGFzdCA9IHRoaXMuZU1hcmtzW2xpbmVdICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV1cbiAgICB9XG5cbiAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChmaXJzdClcblxuICAgICAgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgIGxpbmVJbmRlbnQgKz0gNCAtIChsaW5lSW5kZW50ICsgdGhpcy5ic0NvdW50W2xpbmVdKSAlIDRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50KytcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgIC8vIHBhdGNoZWQgdFNoaWZ0IG1hc2tlZCBjaGFyYWN0ZXJzIHRvIGxvb2sgbGlrZSBzcGFjZXMgKGJsb2NrcXVvdGVzLCBsaXN0IG1hcmtlcnMpXG4gICAgICAgIGxpbmVJbmRlbnQrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgZmlyc3QrK1xuICAgIH1cblxuICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAvLyBwYXJ0aWFsbHkgZXhwYW5kaW5nIHRhYnMgaW4gY29kZSBibG9ja3MsIGUuZyAnXFx0XFx0Zm9vYmFyJ1xuICAgICAgLy8gd2l0aCBpbmRlbnQ9MiBiZWNvbWVzICcgIFxcdGZvb2JhcidcbiAgICAgIHF1ZXVlW2ldID0gbmV3IEFycmF5KGxpbmVJbmRlbnQgLSBpbmRlbnQgKyAxKS5qb2luKCcgJykgKyB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdClcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVbaV0gPSB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJylcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBibG9jayBydWxlc1xuU3RhdGVCbG9jay5wcm90b3R5cGUuVG9rZW4gPSBUb2tlblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0ZUJsb2NrXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/state_block.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/table.mjs":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/table.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ table; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// GFM table, https://github.github.com/gfm/#tables-extension-\n\n\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nfunction table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svdGFibGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSxpQ0FBaUM7O0FBRWpDOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQSx1RkFBdUY7O0FBRXZGLHVDQUF1Qzs7QUFFdkM7QUFDQSwyRkFBMkYsMERBQU87QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDBEQUFPLGNBQWM7O0FBRXREO0FBQ0E7O0FBRUEsMkVBQTJFLDBEQUFPLFFBQVE7O0FBRTFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qyx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQyxvQkFBb0I7QUFDckQsb0RBQW9EOztBQUVwRDtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5tanM/OGYzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHRk0gdGFibGUsIGh0dHBzOi8vZ2l0aHViLmdpdGh1Yi5jb20vZ2ZtLyN0YWJsZXMtZXh0ZW5zaW9uLVxuXG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuLy8gTGltaXQgdGhlIGFtb3VudCBvZiBlbXB0eSBhdXRvY29tcGxldGVkIGNlbGxzIGluIGEgdGFibGUsXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy8xMDAwLFxuLy9cbi8vIEJvdGggcHVsbGRvd24tY21hcmsgYW5kIGNvbW1vbm1hcmstaHMgbGltaXQgdGhlIG51bWJlciBvZiBjZWxscyB0aGlzIHdheSB0byB+MjAway5cbi8vIFdlIHNldCBpdCB0byA2NWssIHdoaWNoIGNhbiBleHBhbmQgdXNlciBpbnB1dCBieSBhIGZhY3RvciBvZiB4MzcwXG4vLyAoMjU2eDI1NiBzcXVhcmUgaXMgMS44a0IgZXhwYW5kZWQgaW50byA2NTBrQikuXG5jb25zdCBNQVhfQVVUT0NPTVBMRVRFRF9DRUxMUyA9IDB4MTAwMDBcblxuZnVuY3Rpb24gZ2V0TGluZSAoc3RhdGUsIGxpbmUpIHtcbiAgY29uc3QgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUudFNoaWZ0W2xpbmVdXG4gIGNvbnN0IG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXVxuXG4gIHJldHVybiBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpXG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdCAoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGNvbnN0IG1heCA9IHN0ci5sZW5ndGhcblxuICBsZXQgcG9zID0gMFxuICBsZXQgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpXG4gIGxldCBpc0VzY2FwZWQgPSBmYWxzZVxuICBsZXQgbGFzdFBvcyA9IDBcbiAgbGV0IGN1cnJlbnQgPSAnJ1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBpZiAoY2ggPT09IDB4N2MvKiB8ICovKSB7XG4gICAgICBpZiAoIWlzRXNjYXBlZCkge1xuICAgICAgICAvLyBwaXBlIHNlcGFyYXRpbmcgY2VsbHMsICd8J1xuICAgICAgICByZXN1bHQucHVzaChjdXJyZW50ICsgc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MpKVxuICAgICAgICBjdXJyZW50ID0gJydcbiAgICAgICAgbGFzdFBvcyA9IHBvcyArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzY2FwZWQgcGlwZSwgJ1xcfCdcbiAgICAgICAgY3VycmVudCArPSBzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcyAtIDEpXG4gICAgICAgIGxhc3RQb3MgPSBwb3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VzY2FwZWQgPSAoY2ggPT09IDB4NWMvKiBcXCAqLylcbiAgICBwb3MrK1xuXG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpXG4gIH1cblxuICByZXN1bHQucHVzaChjdXJyZW50ICsgc3RyLnN1YnN0cmluZyhsYXN0UG9zKSlcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRhYmxlIChzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGxldCBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDFcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIGxldCBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXVxuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBmaXJzdENoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspXG4gIGlmIChmaXJzdENoICE9PSAweDdDLyogfCAqLyAmJiBmaXJzdENoICE9PSAweDJELyogLSAqLyAmJiBmaXJzdENoICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGNvbnN0IHNlY29uZENoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspXG4gIGlmIChzZWNvbmRDaCAhPT0gMHg3Qy8qIHwgKi8gJiYgc2Vjb25kQ2ggIT09IDB4MkQvKiAtICovICYmIHNlY29uZENoICE9PSAweDNBLyogOiAqLyAmJiAhaXNTcGFjZShzZWNvbmRDaCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmIGZpcnN0IGNoYXJhY3RlciBpcyAnLScsIHRoZW4gc2Vjb25kIGNoYXJhY3RlciBtdXN0IG5vdCBiZSBhIHNwYWNlXG4gIC8vIChkdWUgdG8gcGFyc2luZyBhbWJpZ3VpdHkgd2l0aCBsaXN0KVxuICBpZiAoZmlyc3RDaCA9PT0gMHgyRC8qIC0gKi8gJiYgaXNTcGFjZShzZWNvbmRDaCkpIHsgcmV0dXJuIGZhbHNlIH1cblxuICB3aGlsZSAocG9zIDwgc3RhdGUuZU1hcmtzW25leHRMaW5lXSkge1xuICAgIGNvbnN0IGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgcG9zKytcbiAgfVxuXG4gIGxldCBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpXG4gIGxldCBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKVxuICBjb25zdCBhbGlnbnMgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0ID0gY29sdW1uc1tpXS50cmltKClcbiAgICBpZiAoIXQpIHtcbiAgICAgIC8vIGFsbG93IGVtcHR5IGNvbHVtbnMgYmVmb3JlIGFuZCBhZnRlciB0YWJsZSwgYnV0IG5vdCBpbiBiZXR3ZWVuIGNvbHVtbnM7XG4gICAgICAvLyBlLmcuIGFsbG93IGAgfC0tLXwgYCwgZGlzYWxsb3cgYCAtLS18fC0tLSBgXG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBjb2x1bW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2godC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLyA/ICdjZW50ZXInIDogJ3JpZ2h0JylcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0JylcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpXG4gICAgfVxuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUpLnRyaW0oKVxuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2UgfVxuICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0KVxuICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1swXSA9PT0gJycpIGNvbHVtbnMuc2hpZnQoKVxuICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdID09PSAnJykgY29sdW1ucy5wb3AoKVxuXG4gIC8vIGhlYWRlciByb3cgd2lsbCBkZWZpbmUgYW4gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGVudGlyZSB0YWJsZSxcbiAgLy8gYW5kIGFsaWduIHJvdyBzaG91bGQgYmUgZXhhY3RseSB0aGUgc2FtZSAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuIGRpZmZlcilcbiAgY29uc3QgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aFxuICBpZiAoY29sdW1uQ291bnQgPT09IDAgfHwgY29sdW1uQ291bnQgIT09IGFsaWducy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlIH1cblxuICBjb25zdCBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZVxuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3RhYmxlJ1xuXG4gIC8vIHVzZSAnYmxvY2txdW90ZScgbGlzdHMgZm9yIHRlcm1pbmF0aW9uIGJlY2F1c2UgaXQnc1xuICAvLyB0aGUgbW9zdCBzaW1pbGFyIHRvIHRhYmxlc1xuICBjb25zdCB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpXG5cbiAgY29uc3QgdG9rZW5fdG8gPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSlcbiAgY29uc3QgdGFibGVMaW5lcyA9IFtzdGFydExpbmUsIDBdXG4gIHRva2VuX3RvLm1hcCA9IHRhYmxlTGluZXNcblxuICBjb25zdCB0b2tlbl90aG8gPSBzdGF0ZS5wdXNoKCd0aGVhZF9vcGVuJywgJ3RoZWFkJywgMSlcbiAgdG9rZW5fdGhvLm1hcCA9IFtzdGFydExpbmUsIHN0YXJ0TGluZSArIDFdXG5cbiAgY29uc3QgdG9rZW5faHRybyA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKVxuICB0b2tlbl9odHJvLm1hcCA9IFtzdGFydExpbmUsIHN0YXJ0TGluZSArIDFdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW5faG8gPSBzdGF0ZS5wdXNoKCd0aF9vcGVuJywgJ3RoJywgMSlcbiAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICB0b2tlbl9oby5hdHRycyAgPSBbWydzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV1dXVxuICAgIH1cblxuICAgIGNvbnN0IHRva2VuX2lsID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApXG4gICAgdG9rZW5faWwuY29udGVudCAgPSBjb2x1bW5zW2ldLnRyaW0oKVxuICAgIHRva2VuX2lsLmNoaWxkcmVuID0gW11cblxuICAgIHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpXG4gIH1cblxuICBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKVxuICBzdGF0ZS5wdXNoKCd0aGVhZF9jbG9zZScsICd0aGVhZCcsIC0xKVxuXG4gIGxldCB0Ym9keUxpbmVzXG4gIGxldCBhdXRvY29tcGxldGVkQ2VsbHMgPSAwXG5cbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDI7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrIH1cblxuICAgIGxldCB0ZXJtaW5hdGUgPSBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrIH1cbiAgICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIG5leHRMaW5lKS50cmltKClcbiAgICBpZiAoIWxpbmVUZXh0KSB7IGJyZWFrIH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrIH1cbiAgICBjb2x1bW5zID0gZXNjYXBlZFNwbGl0KGxpbmVUZXh0KVxuICAgIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zWzBdID09PSAnJykgY29sdW1ucy5zaGlmdCgpXG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSA9PT0gJycpIGNvbHVtbnMucG9wKClcblxuICAgIC8vIG5vdGU6IGF1dG9jb21wbGV0ZSBjb3VudCBjYW4gYmUgbmVnYXRpdmUgaWYgdXNlciBzcGVjaWZpZXMgbW9yZSBjb2x1bW5zIHRoYW4gaGVhZGVyLFxuICAgIC8vIGJ1dCB0aGF0IGRvZXMgbm90IGFmZmVjdCBpbnRlbmRlZCB1c2UgKHdoaWNoIGlzIGxpbWl0aW5nIGV4cGFuc2lvbilcbiAgICBhdXRvY29tcGxldGVkQ2VsbHMgKz0gY29sdW1uQ291bnQgLSBjb2x1bW5zLmxlbmd0aFxuICAgIGlmIChhdXRvY29tcGxldGVkQ2VsbHMgPiBNQVhfQVVUT0NPTVBMRVRFRF9DRUxMUykgeyBicmVhayB9XG5cbiAgICBpZiAobmV4dExpbmUgPT09IHN0YXJ0TGluZSArIDIpIHtcbiAgICAgIGNvbnN0IHRva2VuX3RibyA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKVxuICAgICAgdG9rZW5fdGJvLm1hcCA9IHRib2R5TGluZXMgPSBbc3RhcnRMaW5lICsgMiwgMF1cbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbl90cm8gPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSlcbiAgICB0b2tlbl90cm8ubWFwID0gW25leHRMaW5lLCBuZXh0TGluZSArIDFdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRva2VuX3RkbyA9IHN0YXRlLnB1c2goJ3RkX29wZW4nLCAndGQnLCAxKVxuICAgICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgICB0b2tlbl90ZG8uYXR0cnMgID0gW1snc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldXV1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW5faWwgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMClcbiAgICAgIHRva2VuX2lsLmNvbnRlbnQgID0gY29sdW1uc1tpXSA/IGNvbHVtbnNbaV0udHJpbSgpIDogJydcbiAgICAgIHRva2VuX2lsLmNoaWxkcmVuID0gW11cblxuICAgICAgc3RhdGUucHVzaCgndGRfY2xvc2UnLCAndGQnLCAtMSlcbiAgICB9XG4gICAgc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSlcbiAgfVxuXG4gIGlmICh0Ym9keUxpbmVzKSB7XG4gICAgc3RhdGUucHVzaCgndGJvZHlfY2xvc2UnLCAndGJvZHknLCAtMSlcbiAgICB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmVcbiAgfVxuXG4gIHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpXG4gIHRhYmxlTGluZXNbMV0gPSBuZXh0TGluZVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZVxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_block/table.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/block.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/block.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ block; }\n/* harmony export */ });\nfunction block (state) {\n  let token\n\n  if (state.inlineMode) {\n    token          = new state.Token('inline', '', 0)\n    token.content  = state.src\n    token.map      = [0, 1]\n    token.children = []\n    state.tokens.push(token)\n  } else {\n    state.md.block.parse(state.src, state.md, state.env, state.tokens)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ibG9jay5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2subWpzP2M3MzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmxvY2sgKHN0YXRlKSB7XG4gIGxldCB0b2tlblxuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKVxuICAgIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjXG4gICAgdG9rZW4ubWFwICAgICAgPSBbMCwgMV1cbiAgICB0b2tlbi5jaGlsZHJlbiA9IFtdXG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubWQuYmxvY2sucGFyc2Uoc3RhdGUuc3JjLCBzdGF0ZS5tZCwgc3RhdGUuZW52LCBzdGF0ZS50b2tlbnMpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/block.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/inline.mjs":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/inline.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ inline; }\n/* harmony export */ });\nfunction inline (state) {\n  const tokens = state.tokens\n\n  // Parse inlines\n  for (let i = 0, l = tokens.length; i < l; i++) {\n    const tok = tokens[i]\n    if (tok.type === 'inline') {\n      state.md.inline.parse(tok.content, state.md, state.env, tok.children)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9pbmxpbmUubWpzPzE3ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5saW5lIChzdGF0ZSkge1xuICBjb25zdCB0b2tlbnMgPSBzdGF0ZS50b2tlbnNcblxuICAvLyBQYXJzZSBpbmxpbmVzXG4gIGZvciAobGV0IGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IHRvayA9IHRva2Vuc1tpXVxuICAgIGlmICh0b2sudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIHN0YXRlLm1kLmlubGluZS5wYXJzZSh0b2suY29udGVudCwgc3RhdGUubWQsIHN0YXRlLmVudiwgdG9rLmNoaWxkcmVuKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/inline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/linkify.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/linkify.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ linkify; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\n\n\nfunction isLinkOpen (str) {\n  return /^<a[>\\s]/i.test(str)\n}\nfunction isLinkClose (str) {\n  return /^<\\/a\\s*>/i.test(str)\n}\n\nfunction linkify (state) {\n  const blockTokens = state.tokens\n\n  if (!state.md.options.linkify) { return }\n\n  for (let j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue\n    }\n\n    let tokens = blockTokens[j].children\n\n    let htmlLinkLevel = 0\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const currentToken = tokens[i]\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--\n        }\n        continue\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++\n        }\n      }\n      if (htmlLinkLevel > 0) { continue }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        const text = currentToken.content\n        let links = state.md.linkify.match(text)\n\n        // Now split string to nodes\n        const nodes = []\n        let level = currentToken.level\n        let lastPos = 0\n\n        // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n        if (links.length > 0 &&\n            links[0].index === 0 &&\n            i > 0 &&\n            tokens[i - 1].type === 'text_special') {\n          links = links.slice(1)\n        }\n\n        for (let ln = 0; ln < links.length; ln++) {\n          const url = links[ln].url\n          const fullUrl = state.md.normalizeLink(url)\n          if (!state.md.validateLink(fullUrl)) { continue }\n\n          let urlText = links[ln].text\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '')\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '')\n          } else {\n            urlText = state.md.normalizeLinkText(urlText)\n          }\n\n          const pos = links[ln].index\n\n          if (pos > lastPos) {\n            const token   = new state.Token('text', '', 0)\n            token.content = text.slice(lastPos, pos)\n            token.level   = level\n            nodes.push(token)\n          }\n\n          const token_o   = new state.Token('link_open', 'a', 1)\n          token_o.attrs   = [['href', fullUrl]]\n          token_o.level   = level++\n          token_o.markup  = 'linkify'\n          token_o.info    = 'auto'\n          nodes.push(token_o)\n\n          const token_t   = new state.Token('text', '', 0)\n          token_t.content = urlText\n          token_t.level   = level\n          nodes.push(token_t)\n\n          const token_c   = new state.Token('link_close', 'a', -1)\n          token_c.level   = --level\n          token_c.markup  = 'linkify'\n          token_c.info    = 'auto'\n          nodes.push(token_c)\n\n          lastPos = links[ln].lastIndex\n        }\n        if (lastPos < text.length) {\n          const token   = new state.Token('text', '', 0)\n          token.content = text.slice(lastPos)\n          token.level   = level\n          nodes.push(token)\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.arrayReplaceAt)(tokens, i, nodes)\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUEsbUNBQW1DOztBQUVuQywwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxpRUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5tanM/MjFkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSZXBsYWNlIGxpbmstbGlrZSB0ZXh0cyB3aXRoIGxpbmsgbm9kZXMuXG4vL1xuLy8gQ3VycmVudGx5IHJlc3RyaWN0ZWQgYnkgYG1kLnZhbGlkYXRlTGluaygpYCB0byBodHRwL2h0dHBzL2Z0cFxuLy9cblxuaW1wb3J0IHsgYXJyYXlSZXBsYWNlQXQgfSBmcm9tICcuLi9jb21tb24vdXRpbHMubWpzJ1xuXG5mdW5jdGlvbiBpc0xpbmtPcGVuIChzdHIpIHtcbiAgcmV0dXJuIC9ePGFbPlxcc10vaS50ZXN0KHN0cilcbn1cbmZ1bmN0aW9uIGlzTGlua0Nsb3NlIChzdHIpIHtcbiAgcmV0dXJuIC9ePFxcL2FcXHMqPi9pLnRlc3Qoc3RyKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5raWZ5IChzdGF0ZSkge1xuICBjb25zdCBibG9ja1Rva2VucyA9IHN0YXRlLnRva2Vuc1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSB7IHJldHVybiB9XG5cbiAgZm9yIChsZXQgaiA9IDAsIGwgPSBibG9ja1Rva2Vucy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIXN0YXRlLm1kLmxpbmtpZnkucHJldGVzdChibG9ja1Rva2Vuc1tqXS5jb250ZW50KSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBsZXQgdG9rZW5zID0gYmxvY2tUb2tlbnNbal0uY2hpbGRyZW5cblxuICAgIGxldCBodG1sTGlua0xldmVsID0gMFxuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY3VycmVudFRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tXG4gICAgICAgIHdoaWxlICh0b2tlbnNbaV0ubGV2ZWwgIT09IGN1cnJlbnRUb2tlbi5sZXZlbCAmJiB0b2tlbnNbaV0udHlwZSAhPT0gJ2xpbmtfb3BlbicpIHtcbiAgICAgICAgICBpLS1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaW5rQ2xvc2UoY3VycmVudFRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgICAgaHRtbExpbmtMZXZlbCsrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChodG1sTGlua0xldmVsID4gMCkgeyBjb250aW51ZSB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGN1cnJlbnRUb2tlbi5jb250ZW50XG4gICAgICAgIGxldCBsaW5rcyA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2godGV4dClcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW11cbiAgICAgICAgbGV0IGxldmVsID0gY3VycmVudFRva2VuLmxldmVsXG4gICAgICAgIGxldCBsYXN0UG9zID0gMFxuXG4gICAgICAgIC8vIGZvcmJpZCBlc2NhcGUgc2VxdWVuY2UgYXQgdGhlIHN0YXJ0IG9mIHRoZSBzdHJpbmcsXG4gICAgICAgIC8vIHRoaXMgYXZvaWRzIGh0dHBcXDovL2V4YW1wbGUuY29tLyBmcm9tIGJlaW5nIGxpbmtpZmllZCBhc1xuICAgICAgICAvLyBodHRwOjxhIGhyZWY9XCIvL2V4YW1wbGUuY29tL1wiPi8vZXhhbXBsZS5jb20vPC9hPlxuICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbGlua3NbMF0uaW5kZXggPT09IDAgJiZcbiAgICAgICAgICAgIGkgPiAwICYmXG4gICAgICAgICAgICB0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICd0ZXh0X3NwZWNpYWwnKSB7XG4gICAgICAgICAgbGlua3MgPSBsaW5rcy5zbGljZSgxKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgbG4gPSAwOyBsbiA8IGxpbmtzLmxlbmd0aDsgbG4rKykge1xuICAgICAgICAgIGNvbnN0IHVybCA9IGxpbmtzW2xuXS51cmxcbiAgICAgICAgICBjb25zdCBmdWxsVXJsID0gc3RhdGUubWQubm9ybWFsaXplTGluayh1cmwpXG4gICAgICAgICAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHsgY29udGludWUgfVxuXG4gICAgICAgICAgbGV0IHVybFRleHQgPSBsaW5rc1tsbl0udGV4dFxuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJylcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmtzW2xuXS5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdCh1cmxUZXh0KSkge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KCdtYWlsdG86JyArIHVybFRleHQpLnJlcGxhY2UoL15tYWlsdG86LywgJycpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmxUZXh0KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHBvcyA9IGxpbmtzW2xuXS5pbmRleFxuXG4gICAgICAgICAgaWYgKHBvcyA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMClcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MsIHBvcylcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbFxuICAgICAgICAgICAgbm9kZXMucHVzaCh0b2tlbilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0b2tlbl9vICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSlcbiAgICAgICAgICB0b2tlbl9vLmF0dHJzICAgPSBbWydocmVmJywgZnVsbFVybF1dXG4gICAgICAgICAgdG9rZW5fby5sZXZlbCAgID0gbGV2ZWwrK1xuICAgICAgICAgIHRva2VuX28ubWFya3VwICA9ICdsaW5raWZ5J1xuICAgICAgICAgIHRva2VuX28uaW5mbyAgICA9ICdhdXRvJ1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW5fbylcblxuICAgICAgICAgIGNvbnN0IHRva2VuX3QgICA9IG5ldyBzdGF0ZS5Ub2tlbigndGV4dCcsICcnLCAwKVxuICAgICAgICAgIHRva2VuX3QuY29udGVudCA9IHVybFRleHRcbiAgICAgICAgICB0b2tlbl90LmxldmVsICAgPSBsZXZlbFxuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW5fdClcblxuICAgICAgICAgIGNvbnN0IHRva2VuX2MgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpXG4gICAgICAgICAgdG9rZW5fYy5sZXZlbCAgID0gLS1sZXZlbFxuICAgICAgICAgIHRva2VuX2MubWFya3VwICA9ICdsaW5raWZ5J1xuICAgICAgICAgIHRva2VuX2MuaW5mbyAgICA9ICdhdXRvJ1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW5fYylcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb3MgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRva2VuICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMClcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gdGV4dC5zbGljZShsYXN0UG9zKVxuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbFxuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNlIGN1cnJlbnQgbm9kZVxuICAgICAgICBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbiA9IHRva2VucyA9IGFycmF5UmVwbGFjZUF0KHRva2VucywgaSwgbm9kZXMpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/linkify.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/normalize.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/normalize.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ normalize; }\n/* harmony export */ });\n// Normalize input string\n\n// https://spec.commonmark.org/0.29/#line-ending\nconst NEWLINES_RE  = /\\r\\n?|\\n/g\nconst NULL_RE      = /\\0/g\n\nfunction normalize (state) {\n  let str\n\n  // Normalize newlines\n  str = state.src.replace(NEWLINES_RE, '\\n')\n\n  // Replace NULL characters\n  str = str.replace(NULL_RE, '\\uFFFD')\n\n  state.src = str\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9ub3JtYWxpemUubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLm1qcz84ZWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vcm1hbGl6ZSBpbnB1dCBzdHJpbmdcblxuLy8gaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjkvI2xpbmUtZW5kaW5nXG5jb25zdCBORVdMSU5FU19SRSAgPSAvXFxyXFxuP3xcXG4vZ1xuY29uc3QgTlVMTF9SRSAgICAgID0gL1xcMC9nXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoc3RhdGUpIHtcbiAgbGV0IHN0clxuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpXG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKVxuXG4gIHN0YXRlLnNyYyA9IHN0clxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/normalize.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/replacements.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/replacements.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ replace; }\n/* harmony export */ });\n// Simple typographic replacements\n//\n// (c) (C)  \n// (tm) (TM)  \n// (r) (R)  \n// +-  \n// ...   (also ?....  ?.., !....  !..)\n// ????????  ???, !!!!!  !!!, `,,`  `,`\n// --  &ndash;, ---  &mdash;\n//\n\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> , , \n// - multiplications 2 x 4 -> 2  4\n\nconst RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/\n\n// Workaround for phantomjs - need regex without /g flag,\n// or root check will fail every second time\nconst SCOPED_ABBR_TEST_RE = /\\((c|tm|r)\\)/i\n\nconst SCOPED_ABBR_RE = /\\((c|tm|r)\\)/ig\nconst SCOPED_ABBR = {\n  c: '',\n  r: '',\n  tm: ''\n}\n\nfunction replaceFn (match, name) {\n  return SCOPED_ABBR[name.toLowerCase()]\n}\n\nfunction replace_scoped (inlineTokens) {\n  let inside_autolink = 0\n\n  for (let i = inlineTokens.length - 1; i >= 0; i--) {\n    const token = inlineTokens[i]\n\n    if (token.type === 'text' && !inside_autolink) {\n      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn)\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++\n    }\n  }\n}\n\nfunction replace_rare (inlineTokens) {\n  let inside_autolink = 0\n\n  for (let i = inlineTokens.length - 1; i >= 0; i--) {\n    const token = inlineTokens[i]\n\n    if (token.type === 'text' && !inside_autolink) {\n      if (RARE_RE.test(token.content)) {\n        token.content = token.content\n          .replace(/\\+-/g, '')\n          // .., ..., ....... -> \n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '').replace(/([?!])/g, '$1..')\n          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')\n          // em-dash\n          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\\u2014')\n          // en-dash\n          .replace(/(^|\\s)--(?=\\s|$)/mg, '$1\\u2013')\n          .replace(/(^|[^-\\s])--(?=[^-\\s]|$)/mg, '$1\\u2013')\n      }\n    }\n\n    if (token.type === 'link_open' && token.info === 'auto') {\n      inside_autolink--\n    }\n\n    if (token.type === 'link_close' && token.info === 'auto') {\n      inside_autolink++\n    }\n  }\n}\n\nfunction replace (state) {\n  let blkIdx\n\n  if (!state.md.options.typographer) { return }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') { continue }\n\n    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {\n      replace_scoped(state.tokens[blkIdx].children)\n    }\n\n    if (RARE_RE.test(state.tokens[blkIdx].content)) {\n      replace_rare(state.tokens[blkIdx].children)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixHQUFHO0FBQzFCLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUEsdUNBQXVDOztBQUV2Qyx5Q0FBeUMsYUFBYTtBQUN0RCxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMubWpzP2U3OTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxlIHR5cG9ncmFwaGljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG11bHRpcGxpY2F0aW9ucyAyIHggNCAtPiAyIMOXIDRcblxuY29uc3QgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS9cblxuLy8gV29ya2Fyb3VuZCBmb3IgcGhhbnRvbWpzIC0gbmVlZCByZWdleCB3aXRob3V0IC9nIGZsYWcsXG4vLyBvciByb290IGNoZWNrIHdpbGwgZmFpbCBldmVyeSBzZWNvbmQgdGltZVxuY29uc3QgU0NPUEVEX0FCQlJfVEVTVF9SRSA9IC9cXCgoY3x0bXxyKVxcKS9pXG5cbmNvbnN0IFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHIpXFwpL2lnXG5jb25zdCBTQ09QRURfQUJCUiA9IHtcbiAgYzogJ8KpJyxcbiAgcjogJ8KuJyxcbiAgdG06ICfihKInXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VGbiAobWF0Y2gsIG5hbWUpIHtcbiAgcmV0dXJuIFNDT1BFRF9BQkJSW25hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9zY29wZWQgKGlubGluZVRva2Vucykge1xuICBsZXQgaW5zaWRlX2F1dG9saW5rID0gMFxuXG4gIGZvciAobGV0IGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB0b2tlbiA9IGlubGluZVRva2Vuc1tpXVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pXG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKytcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlIChpbmxpbmVUb2tlbnMpIHtcbiAgbGV0IGluc2lkZV9hdXRvbGluayA9IDBcblxuICBmb3IgKGxldCBpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgaWYgKFJBUkVfUkUudGVzdCh0b2tlbi5jb250ZW50KSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgIC5yZXBsYWNlKC9cXCstL2csICfCsScpXG4gICAgICAgICAgLy8gLi4sIC4uLiwgLi4uLi4uLiAtPiDigKZcbiAgICAgICAgICAvLyBidXQgPy4uLi4uICYgIS4uLi4uIC0+ID8uLiAmICEuLlxuICAgICAgICAgIC5yZXBsYWNlKC9cXC57Mix9L2csICfigKYnKS5yZXBsYWNlKC8oWz8hXSnigKYvZywgJyQxLi4nKVxuICAgICAgICAgIC5yZXBsYWNlKC8oWz8hXSl7NCx9L2csICckMSQxJDEnKS5yZXBsYWNlKC8sezIsfS9nLCAnLCcpXG4gICAgICAgICAgLy8gZW0tZGFzaFxuICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1dKS0tLSg/PVteLV18JCkvbWcsICckMVxcdTIwMTQnKVxuICAgICAgICAgIC8vIGVuLWRhc2hcbiAgICAgICAgICAucmVwbGFjZSgvKF58XFxzKS0tKD89XFxzfCQpL21nLCAnJDFcXHUyMDEzJylcbiAgICAgICAgICAucmVwbGFjZSgvKF58W14tXFxzXSktLSg/PVteLVxcc118JCkvbWcsICckMVxcdTIwMTMnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tXG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcGxhY2UgKHN0YXRlKSB7XG4gIGxldCBibGtJZHhcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuIH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScpIHsgY29udGludWUgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgaWYgKFJBUkVfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/replacements.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/smartquotes.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/smartquotes.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ smartquotes; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Convert straight quotation marks to typographic ones\n//\n\n\n\nconst QUOTE_TEST_RE = /['\"]/\nconst QUOTE_RE = /['\"]/g\nconst APOSTROPHE = '\\u2019' /*  */\n\nfunction replaceAt (str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1)\n}\n\nfunction process_inlines (tokens, state) {\n  let j\n\n  const stack = []\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    const thisLevel = tokens[i].level\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break }\n    }\n    stack.length = j + 1\n\n    if (token.type !== 'text') { continue }\n\n    let text = token.content\n    let pos = 0\n    let max = text.length\n\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos\n      const t = QUOTE_RE.exec(text)\n      if (!t) { break }\n\n      let canOpen = true\n      let canClose = true\n      pos = t.index + 1\n      const isSingle = (t[0] === \"'\")\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      let lastChar = 0x20\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1)\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // lastChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1)\n          break\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      let nextChar = 0x20\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos)\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // nextChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0)\n          break\n        }\n      }\n\n      const isLastPunctChar = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isMdAsciiPunct)(lastChar) || (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isPunctChar)(String.fromCharCode(lastChar))\n      const isNextPunctChar = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isMdAsciiPunct)(nextChar) || (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isPunctChar)(String.fromCharCode(nextChar))\n\n      const isLastWhiteSpace = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(lastChar)\n      const isNextWhiteSpace = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isWhiteSpace)(nextChar)\n\n      if (isNextWhiteSpace) {\n        canOpen = false\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar\n        canClose = isNextPunctChar\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE)\n        }\n        continue\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j]\n          if (stack[j].level < thisLevel) { break }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j]\n\n            let openQuote\n            let closeQuote\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2]\n              closeQuote = state.md.options.quotes[3]\n            } else {\n              openQuote = state.md.options.quotes[0]\n              closeQuote = state.md.options.quotes[1]\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote)\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote)\n\n            pos += closeQuote.length - 1\n            if (item.token === i) { pos += openQuote.length - 1 }\n\n            text = token.content\n            max = text.length\n\n            stack.length = j\n            continue OUTER\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        })\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE)\n      }\n    }\n  }\n}\n\nfunction smartquotes (state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) { return }\n\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zbWFydHF1b3Rlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBOztBQUUrRTs7QUFFL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7O0FBRUEsK0JBQStCLFFBQVE7QUFDdkMseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsUUFBUTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixpRUFBYyxjQUFjLDhEQUFXO0FBQ3JFLDhCQUE4QixpRUFBYyxjQUFjLDhEQUFXOztBQUVyRSwrQkFBK0IsK0RBQVk7QUFDM0MsK0JBQStCLCtEQUFZOztBQUUzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQSx1Q0FBdUM7O0FBRXZDLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMubWpzPzUxYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29udmVydCBzdHJhaWdodCBxdW90YXRpb24gbWFya3MgdG8gdHlwb2dyYXBoaWMgb25lc1xuLy9cblxuaW1wb3J0IHsgaXNXaGl0ZVNwYWNlLCBpc1B1bmN0Q2hhciwgaXNNZEFzY2lpUHVuY3QgfSBmcm9tICcuLi9jb21tb24vdXRpbHMubWpzJ1xuXG5jb25zdCBRVU9URV9URVNUX1JFID0gL1snXCJdL1xuY29uc3QgUVVPVEVfUkUgPSAvWydcIl0vZ1xuY29uc3QgQVBPU1RST1BIRSA9ICdcXHUyMDE5JyAvKiDigJkgKi9cblxuZnVuY3Rpb24gcmVwbGFjZUF0IChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIGluZGV4KSArIGNoICsgc3RyLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzICh0b2tlbnMsIHN0YXRlKSB7XG4gIGxldCBqXG5cbiAgY29uc3Qgc3RhY2sgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGNvbnN0IHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbFxuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWsgfVxuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSBqICsgMVxuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZSB9XG5cbiAgICBsZXQgdGV4dCA9IHRva2VuLmNvbnRlbnRcbiAgICBsZXQgcG9zID0gMFxuICAgIGxldCBtYXggPSB0ZXh0Lmxlbmd0aFxuXG4gICAgLyogZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCAqL1xuICAgIE9VVEVSOlxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIFFVT1RFX1JFLmxhc3RJbmRleCA9IHBvc1xuICAgICAgY29uc3QgdCA9IFFVT1RFX1JFLmV4ZWModGV4dClcbiAgICAgIGlmICghdCkgeyBicmVhayB9XG5cbiAgICAgIGxldCBjYW5PcGVuID0gdHJ1ZVxuICAgICAgbGV0IGNhbkNsb3NlID0gdHJ1ZVxuICAgICAgcG9zID0gdC5pbmRleCArIDFcbiAgICAgIGNvbnN0IGlzU2luZ2xlID0gKHRbMF0gPT09IFwiJ1wiKVxuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGV0IGxhc3RDaGFyID0gMHgyMFxuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSA9PT0gJ3NvZnRicmVhaycgfHwgdG9rZW5zW2pdLnR5cGUgPT09ICdoYXJkYnJlYWsnKSBicmVhayAvLyBsYXN0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKCF0b2tlbnNbal0uY29udGVudCkgY29udGludWUgLy8gc2hvdWxkIHNraXAgYWxsIHRva2VucyBleGNlcHQgJ3RleHQnLCAnaHRtbF9pbmxpbmUnIG9yICdjb2RlX2lubGluZSdcblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGV0IG5leHRDaGFyID0gMHgyMFxuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG5leHRDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrIC8vIG5leHRDaGFyIGRlZmF1bHRzIHRvIDB4MjBcbiAgICAgICAgICBpZiAoIXRva2Vuc1tqXS5jb250ZW50KSBjb250aW51ZSAvLyBzaG91bGQgc2tpcCBhbGwgdG9rZW5zIGV4Y2VwdCAndGV4dCcsICdodG1sX2lubGluZScgb3IgJ2NvZGVfaW5saW5lJ1xuXG4gICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0xhc3RQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChsYXN0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShsYXN0Q2hhcikpXG4gICAgICBjb25zdCBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpXG5cbiAgICAgIGNvbnN0IGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpXG4gICAgICBjb25zdCBpc05leHRXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKG5leHRDaGFyKVxuXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5PcGVuID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xhc3RXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbkNsb3NlID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3BlbiAmJiBjYW5DbG9zZSkge1xuICAgICAgICAvLyBSZXBsYWNlIHF1b3RlcyBpbiB0aGUgbWlkZGxlIG9mIHB1bmN0dWF0aW9uIHNlcXVlbmNlLCBidXQgbm90XG4gICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgdGhlIHdvcmRzLCBpLmUuOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBmb28gXCIgYmFyIFwiIGJheiAtIG5vdCByZXBsYWNlZFxuICAgICAgICAvLyAyLiBmb28tXCItYmFyLVwiLWJheiAtIHJlcGxhY2VkXG4gICAgICAgIC8vIDMuIGZvb1wiYmFyXCJiYXogICAgIC0gbm90IHJlcGxhY2VkXG4gICAgICAgIC8vXG4gICAgICAgIGNhbk9wZW4gPSBpc0xhc3RQdW5jdENoYXJcbiAgICAgICAgY2FuQ2xvc2UgPSBpc05leHRQdW5jdENoYXJcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgYSBjbG9zaW5nIHF1b3RlLCByZXdpbmQgdGhlIHN0YWNrIHRvIGdldCBhIG1hdGNoXG4gICAgICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgbGV0IGl0ZW0gPSBzdGFja1tqXVxuICAgICAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8IHRoaXNMZXZlbCkgeyBicmVhayB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal1cblxuICAgICAgICAgICAgbGV0IG9wZW5RdW90ZVxuICAgICAgICAgICAgbGV0IGNsb3NlUXVvdGVcbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXVxuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM11cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzBdXG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRva2VuLmNvbnRlbnQgKmJlZm9yZSogdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlLCBpZiB0aGV5IGFyZSBwb2ludGluZyBhdCB0aGUgc2FtZSB0b2tlbiwgcmVwbGFjZUF0XG4gICAgICAgICAgICAvLyBjb3VsZCBtZXNzIHVwIGluZGljZXMgd2hlbiBxdW90ZSBsZW5ndGggIT0gMVxuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKVxuICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQgPSByZXBsYWNlQXQoXG4gICAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LCBpdGVtLnBvcywgb3BlblF1b3RlKVxuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxXG4gICAgICAgICAgICBpZiAoaXRlbS50b2tlbiA9PT0gaSkgeyBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDEgfVxuXG4gICAgICAgICAgICB0ZXh0ID0gdG9rZW4uY29udGVudFxuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGhcblxuICAgICAgICAgICAgc3RhY2subGVuZ3RoID0galxuICAgICAgICAgICAgY29udGludWUgT1VURVJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzIChzdGF0ZSkge1xuICAvKiBlc2xpbnQgbWF4LWRlcHRoOjAgKi9cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybiB9XG5cbiAgZm9yIChsZXQgYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHByb2Nlc3NfaW5saW5lcyhzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbiwgc3RhdGUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/smartquotes.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/state_core.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/state_core.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _token_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../token.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/token.mjs\");\n// Core state object\n//\n\n\n\nfunction StateCore (src, md, env) {\n  this.src = src\n  this.env = env\n  this.tokens = []\n  this.inlineMode = false\n  this.md = md // link to parser instance\n}\n\n// re-export Token class to use in core rules\nStateCore.prototype.Token = _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StateCore);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixrREFBSzs7QUFFakMsK0RBQWUsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5tanM/YWIxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cblxuaW1wb3J0IFRva2VuIGZyb20gJy4uL3Rva2VuLm1qcydcblxuZnVuY3Rpb24gU3RhdGVDb3JlIChzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmNcbiAgdGhpcy5lbnYgPSBlbnZcbiAgdGhpcy50b2tlbnMgPSBbXVxuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZVxuICB0aGlzLm1kID0gbWQgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW5cblxuZXhwb3J0IGRlZmF1bHQgU3RhdGVDb3JlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/state_core.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/text_join.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/text_join.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ text_join; }\n/* harmony export */ });\n// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n\nfunction text_join (state) {\n  let curr, last\n  const blockTokens = state.tokens\n  const l = blockTokens.length\n\n  for (let j = 0; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue\n\n    const tokens = blockTokens[j].children\n    const max = tokens.length\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text'\n      }\n    }\n\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' &&\n          curr + 1 < max &&\n          tokens[curr + 1].type === 'text') {\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content\n      } else {\n        if (curr !== last) { tokens[last] = tokens[curr] }\n\n        last++\n      }\n    }\n\n    if (curr !== last) {\n      tokens.length = last\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS90ZXh0X2pvaW4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvdGV4dF9qb2luLm1qcz85M2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEpvaW4gcmF3IHRleHQgdG9rZW5zIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHRleHRcbi8vXG4vLyBUaGlzIGlzIHNldCBhcyBhIHNlcGFyYXRlIHJ1bGUgdG8gcHJvdmlkZSBhbiBvcHBvcnR1bml0eSBmb3IgcGx1Z2luc1xuLy8gdG8gcnVuIHRleHQgcmVwbGFjZW1lbnRzIGFmdGVyIHRleHQgam9pbiwgYnV0IGJlZm9yZSBlc2NhcGUgam9pbi5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgYFxcOilgIHNob3VsZG4ndCBiZSByZXBsYWNlZCB3aXRoIGFuIGVtb2ppLlxuLy9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGV4dF9qb2luIChzdGF0ZSkge1xuICBsZXQgY3VyciwgbGFzdFxuICBjb25zdCBibG9ja1Rva2VucyA9IHN0YXRlLnRva2Vuc1xuICBjb25zdCBsID0gYmxvY2tUb2tlbnMubGVuZ3RoXG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICBpZiAoYmxvY2tUb2tlbnNbal0udHlwZSAhPT0gJ2lubGluZScpIGNvbnRpbnVlXG5cbiAgICBjb25zdCB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlblxuICAgIGNvbnN0IG1heCA9IHRva2Vucy5sZW5ndGhcblxuICAgIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dF9zcGVjaWFsJykge1xuICAgICAgICB0b2tlbnNbY3Vycl0udHlwZSA9ICd0ZXh0J1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAgIGlmICh0b2tlbnNbY3Vycl0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgICB0b2tlbnNbY3VyciArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnQgPSB0b2tlbnNbY3Vycl0uY29udGVudCArIHRva2Vuc1tjdXJyICsgMV0uY29udGVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHsgdG9rZW5zW2xhc3RdID0gdG9rZW5zW2N1cnJdIH1cblxuICAgICAgICBsYXN0KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VyciAhPT0gbGFzdCkge1xuICAgICAgdG9rZW5zLmxlbmd0aCA9IGxhc3RcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_core/text_join.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/autolink.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/autolink.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ autolink; }\n/* harmony export */ });\n// Process autolinks '<protocol:...>'\n\n/* eslint max-len:0 */\nconst EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/\n/* eslint-disable-next-line no-control-regex */\nconst AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\\x00-\\x20]*)$/\n\nfunction autolink (state, silent) {\n  let pos = state.pos\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false }\n\n  const start = state.pos\n  const max = state.posMax\n\n  for (;;) {\n    if (++pos >= max) return false\n\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch === 0x3C /* < */) return false\n    if (ch === 0x3E /* > */) break\n  }\n\n  const url = state.src.slice(start + 1, pos)\n\n  if (AUTOLINK_RE.test(url)) {\n    const fullUrl = state.md.normalizeLink(url)\n    if (!state.md.validateLink(fullUrl)) { return false }\n\n    if (!silent) {\n      const token_o   = state.push('link_open', 'a', 1)\n      token_o.attrs   = [['href', fullUrl]]\n      token_o.markup  = 'autolink'\n      token_o.info    = 'auto'\n\n      const token_t   = state.push('text', '', 0)\n      token_t.content = state.md.normalizeLinkText(url)\n\n      const token_c   = state.push('link_close', 'a', -1)\n      token_c.markup  = 'autolink'\n      token_c.info    = 'auto'\n    }\n\n    state.pos += url.length + 2\n    return true\n  }\n\n  if (EMAIL_RE.test(url)) {\n    const fullUrl = state.md.normalizeLink('mailto:' + url)\n    if (!state.md.validateLink(fullUrl)) { return false }\n\n    if (!silent) {\n      const token_o   = state.push('link_open', 'a', 1)\n      token_o.attrs   = [['href', fullUrl]]\n      token_o.markup  = 'autolink'\n      token_o.info    = 'auto'\n\n      const token_t   = state.push('text', '', 0)\n      token_t.content = state.md.normalizeLinkText(url)\n\n      const token_c   = state.push('link_close', 'a', -1)\n      token_c.markup  = 'autolink'\n      token_c.info    = 'auto'\n    }\n\n    state.pos += url.length + 2\n    return true\n  }\n\n  return false\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQSxpREFBaUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSztBQUMxSTtBQUNBLDhDQUE4QyxLQUFLOztBQUVwQztBQUNmOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLm1qcz81YTNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuLyogZXNsaW50IG1heC1sZW46MCAqL1xuY29uc3QgRU1BSUxfUkUgICAgPSAvXihbYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKikkL1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXggKi9cbmNvbnN0IEFVVE9MSU5LX1JFID0gL14oW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfSk6KFtePD5cXHgwMC1cXHgyMF0qKSQvXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9saW5rIChzdGF0ZSwgc2lsZW50KSB7XG4gIGxldCBwb3MgPSBzdGF0ZS5wb3NcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBzdGFydCA9IHN0YXRlLnBvc1xuICBjb25zdCBtYXggPSBzdGF0ZS5wb3NNYXhcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKCsrcG9zID49IG1heCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcblxuICAgIGlmIChjaCA9PT0gMHgzQyAvKiA8ICovKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoY2ggPT09IDB4M0UgLyogPiAqLykgYnJlYWtcbiAgfVxuXG4gIGNvbnN0IHVybCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCArIDEsIHBvcylcblxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh1cmwpKSB7XG4gICAgY29uc3QgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKVxuICAgIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGZ1bGxVcmwpKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgY29uc3QgdG9rZW5fbyAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKVxuICAgICAgdG9rZW5fby5hdHRycyAgID0gW1snaHJlZicsIGZ1bGxVcmxdXVxuICAgICAgdG9rZW5fby5tYXJrdXAgID0gJ2F1dG9saW5rJ1xuICAgICAgdG9rZW5fby5pbmZvICAgID0gJ2F1dG8nXG5cbiAgICAgIGNvbnN0IHRva2VuX3QgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMClcbiAgICAgIHRva2VuX3QuY29udGVudCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybClcblxuICAgICAgY29uc3QgdG9rZW5fYyAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpXG4gICAgICB0b2tlbl9jLm1hcmt1cCAgPSAnYXV0b2xpbmsnXG4gICAgICB0b2tlbl9jLmluZm8gICAgPSAnYXV0bydcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gdXJsLmxlbmd0aCArIDJcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKEVNQUlMX1JFLnRlc3QodXJsKSkge1xuICAgIGNvbnN0IGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKCdtYWlsdG86JyArIHVybClcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgIGNvbnN0IHRva2VuX28gICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSlcbiAgICAgIHRva2VuX28uYXR0cnMgICA9IFtbJ2hyZWYnLCBmdWxsVXJsXV1cbiAgICAgIHRva2VuX28ubWFya3VwICA9ICdhdXRvbGluaydcbiAgICAgIHRva2VuX28uaW5mbyAgICA9ICdhdXRvJ1xuXG4gICAgICBjb25zdCB0b2tlbl90ICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApXG4gICAgICB0b2tlbl90LmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpXG5cbiAgICAgIGNvbnN0IHRva2VuX2MgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKVxuICAgICAgdG9rZW5fYy5tYXJrdXAgID0gJ2F1dG9saW5rJ1xuICAgICAgdG9rZW5fYy5pbmZvICAgID0gJ2F1dG8nXG4gICAgfVxuXG4gICAgc3RhdGUucG9zICs9IHVybC5sZW5ndGggKyAyXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/autolink.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/backticks.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/backticks.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ backtick; }\n/* harmony export */ });\n// Parse backticks\n\nfunction backtick (state, silent) {\n  let pos = state.pos\n  const ch = state.src.charCodeAt(pos)\n\n  if (ch !== 0x60/* ` */) { return false }\n\n  const start = pos\n  pos++\n  const max = state.posMax\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++ }\n\n  const marker = state.src.slice(start, pos)\n  const openerLength = marker.length\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker\n    state.pos += openerLength\n    return true\n  }\n\n  let matchEnd = pos\n  let matchStart\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++ }\n\n    const closerLength = matchEnd - matchStart\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        const token = state.push('code_inline', 'code', 0)\n        token.markup = marker\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1')\n      }\n      state.pos = matchEnd\n      return true\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true\n\n  if (!silent) state.pending += marker\n  state.pos += openerLength\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLm1qcz9kNmYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhcnNlIGJhY2t0aWNrc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiYWNrdGljayAoc3RhdGUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUucG9zXG4gIGNvbnN0IGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuXG4gIGlmIChjaCAhPT0gMHg2MC8qIGAgKi8pIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBzdGFydCA9IHBvc1xuICBwb3MrK1xuICBjb25zdCBtYXggPSBzdGF0ZS5wb3NNYXhcblxuICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDYwLyogYCAqLykgeyBwb3MrKyB9XG5cbiAgY29uc3QgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpXG4gIGNvbnN0IG9wZW5lckxlbmd0aCA9IG1hcmtlci5sZW5ndGhcblxuICBpZiAoc3RhdGUuYmFja3RpY2tzU2Nhbm5lZCAmJiAoc3RhdGUuYmFja3RpY2tzW29wZW5lckxlbmd0aF0gfHwgMCkgPD0gc3RhcnQpIHtcbiAgICBpZiAoIXNpbGVudCkgc3RhdGUucGVuZGluZyArPSBtYXJrZXJcbiAgICBzdGF0ZS5wb3MgKz0gb3BlbmVyTGVuZ3RoXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBtYXRjaEVuZCA9IHBvc1xuICBsZXQgbWF0Y2hTdGFydFxuXG4gIC8vIE5vdGhpbmcgZm91bmQgaW4gdGhlIGNhY2hlLCBzY2FuIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUgKG9yIHVudGlsIG1hcmtlciBpcyBmb3VuZClcbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDFcblxuICAgIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICAgIHdoaWxlIChtYXRjaEVuZCA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChtYXRjaEVuZCkgPT09IDB4NjAvKiBgICovKSB7IG1hdGNoRW5kKysgfVxuXG4gICAgY29uc3QgY2xvc2VyTGVuZ3RoID0gbWF0Y2hFbmQgLSBtYXRjaFN0YXJ0XG5cbiAgICBpZiAoY2xvc2VyTGVuZ3RoID09PSBvcGVuZXJMZW5ndGgpIHtcbiAgICAgIC8vIEZvdW5kIG1hdGNoaW5nIGNsb3NlciBsZW5ndGguXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKVxuICAgICAgICB0b2tlbi5tYXJrdXAgPSBtYXJrZXJcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnICcpXG4gICAgICAgICAgLnJlcGxhY2UoL14gKC4rKSAkLywgJyQxJylcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBvcyA9IG1hdGNoRW5kXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFNvbWUgZGlmZmVyZW50IGxlbmd0aCBmb3VuZCwgcHV0IGl0IGluIGNhY2hlIGFzIHVwcGVyIGxpbWl0IG9mIHdoZXJlIGNsb3NlciBjYW4gYmUgZm91bmRcbiAgICBzdGF0ZS5iYWNrdGlja3NbY2xvc2VyTGVuZ3RoXSA9IG1hdGNoU3RhcnRcbiAgfVxuXG4gIC8vIFNjYW5uZWQgdGhyb3VnaCB0aGUgZW5kLCBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICBzdGF0ZS5iYWNrdGlja3NTY2FubmVkID0gdHJ1ZVxuXG4gIGlmICghc2lsZW50KSBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlclxuICBzdGF0ZS5wb3MgKz0gb3BlbmVyTGVuZ3RoXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/backticks.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ link_pairs; }\n/* harmony export */ });\n// For each opening emphasis-like marker find a matching closing one\n//\n\nfunction processDelimiters (delimiters) {\n  const openersBottom = {}\n  const max = delimiters.length\n\n  if (!max) return\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  let headerIdx = 0\n  let lastTokenIdx = -2 // needs any value lower than -1\n  const jumps = []\n\n  for (let closerIdx = 0; closerIdx < max; closerIdx++) {\n    const closer = delimiters[closerIdx]\n\n    jumps.push(0)\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx\n    }\n\n    lastTokenIdx = closer.token\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0\n\n    if (!closer.close) continue\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1]\n    }\n\n    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)]\n\n    let openerIdx = headerIdx - jumps[headerIdx] - 1\n\n    let newMinOpenerIdx = openerIdx\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      const opener = delimiters[openerIdx]\n\n      if (opener.marker !== closer.marker) continue\n\n      if (opener.open && opener.end < 0) {\n        let isOddMatch = false\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open\n            ? jumps[openerIdx - 1] + 1\n            : 0\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump\n          jumps[openerIdx] = lastJump\n\n          closer.open  = false\n          opener.end   = closerIdx\n          opener.close = false\n          newMinOpenerIdx = -1\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2\n          break\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx\n    }\n  }\n}\n\nfunction link_pairs (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  processDelimiters(state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(tokens_meta[curr].delimiters)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsaUJBQWlCO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLDBCQUEwQjtBQUNyQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhbGFuY2VfcGFpcnMubWpzPzJmYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG5cbmZ1bmN0aW9uIHByb2Nlc3NEZWxpbWl0ZXJzIChkZWxpbWl0ZXJzKSB7XG4gIGNvbnN0IG9wZW5lcnNCb3R0b20gPSB7fVxuICBjb25zdCBtYXggPSBkZWxpbWl0ZXJzLmxlbmd0aFxuXG4gIGlmICghbWF4KSByZXR1cm5cblxuICAvLyBoZWFkZXJJZHggaXMgdGhlIGZpcnN0IGRlbGltaXRlciBvZiB0aGUgY3VycmVudCAod2hlcmUgY2xvc2VyIGlzKSBkZWxpbWl0ZXIgcnVuXG4gIGxldCBoZWFkZXJJZHggPSAwXG4gIGxldCBsYXN0VG9rZW5JZHggPSAtMiAvLyBuZWVkcyBhbnkgdmFsdWUgbG93ZXIgdGhhbiAtMVxuICBjb25zdCBqdW1wcyA9IFtdXG5cbiAgZm9yIChsZXQgY2xvc2VySWR4ID0gMDsgY2xvc2VySWR4IDwgbWF4OyBjbG9zZXJJZHgrKykge1xuICAgIGNvbnN0IGNsb3NlciA9IGRlbGltaXRlcnNbY2xvc2VySWR4XVxuXG4gICAganVtcHMucHVzaCgwKVxuXG4gICAgLy8gbWFya2VycyBiZWxvbmcgdG8gc2FtZSBkZWxpbWl0ZXIgcnVuIGlmOlxuICAgIC8vICAtIHRoZXkgaGF2ZSBhZGphY2VudCB0b2tlbnNcbiAgICAvLyAgLSBBTkQgbWFya2VycyBhcmUgdGhlIHNhbWVcbiAgICAvL1xuICAgIGlmIChkZWxpbWl0ZXJzW2hlYWRlcklkeF0ubWFya2VyICE9PSBjbG9zZXIubWFya2VyIHx8IGxhc3RUb2tlbklkeCAhPT0gY2xvc2VyLnRva2VuIC0gMSkge1xuICAgICAgaGVhZGVySWR4ID0gY2xvc2VySWR4XG4gICAgfVxuXG4gICAgbGFzdFRva2VuSWR4ID0gY2xvc2VyLnRva2VuXG5cbiAgICAvLyBMZW5ndGggaXMgb25seSB1c2VkIGZvciBlbXBoYXNpcy1zcGVjaWZpYyBcInJ1bGUgb2YgM1wiLFxuICAgIC8vIGlmIGl0J3Mgbm90IGRlZmluZWQgKGluIHN0cmlrZXRocm91Z2ggb3IgM3JkIHBhcnR5IHBsdWdpbnMpLFxuICAgIC8vIHdlIGNhbiBkZWZhdWx0IGl0IHRvIDAgdG8gZGlzYWJsZSB0aG9zZSBjaGVja3MuXG4gICAgLy9cbiAgICBjbG9zZXIubGVuZ3RoID0gY2xvc2VyLmxlbmd0aCB8fCAwXG5cbiAgICBpZiAoIWNsb3Nlci5jbG9zZSkgY29udGludWVcblxuICAgIC8vIFByZXZpb3VzbHkgY2FsY3VsYXRlZCBsb3dlciBib3VuZHMgKHByZXZpb3VzIGZhaWxzKVxuICAgIC8vIGZvciBlYWNoIG1hcmtlciwgZWFjaCBkZWxpbWl0ZXIgbGVuZ3RoIG1vZHVsbyAzLFxuICAgIC8vIGFuZCBmb3Igd2hldGhlciB0aGlzIGNsb3NlciBjYW4gYmUgYW4gb3BlbmVyO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21tb25tYXJrL2NtYXJrL2NvbW1pdC8zNDI1MGUxMmNjZWJkYzYzNzJiOGI0OWM0NGZhYjU3YzcyNDQzNDYwXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuICAgIGlmICghb3BlbmVyc0JvdHRvbS5oYXNPd25Qcm9wZXJ0eShjbG9zZXIubWFya2VyKSkge1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXSA9IFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xXVxuICAgIH1cblxuICAgIGNvbnN0IG1pbk9wZW5lcklkeCA9IG9wZW5lcnNCb3R0b21bY2xvc2VyLm1hcmtlcl1bKGNsb3Nlci5vcGVuID8gMyA6IDApICsgKGNsb3Nlci5sZW5ndGggJSAzKV1cblxuICAgIGxldCBvcGVuZXJJZHggPSBoZWFkZXJJZHggLSBqdW1wc1toZWFkZXJJZHhdIC0gMVxuXG4gICAgbGV0IG5ld01pbk9wZW5lcklkeCA9IG9wZW5lcklkeFxuXG4gICAgZm9yICg7IG9wZW5lcklkeCA+IG1pbk9wZW5lcklkeDsgb3BlbmVySWR4IC09IGp1bXBzW29wZW5lcklkeF0gKyAxKSB7XG4gICAgICBjb25zdCBvcGVuZXIgPSBkZWxpbWl0ZXJzW29wZW5lcklkeF1cblxuICAgICAgaWYgKG9wZW5lci5tYXJrZXIgIT09IGNsb3Nlci5tYXJrZXIpIGNvbnRpbnVlXG5cbiAgICAgIGlmIChvcGVuZXIub3BlbiAmJiBvcGVuZXIuZW5kIDwgMCkge1xuICAgICAgICBsZXQgaXNPZGRNYXRjaCA9IGZhbHNlXG5cbiAgICAgICAgLy8gZnJvbSBzcGVjOlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIGRlbGltaXRlcnMgY2FuIGJvdGggb3BlbiBhbmQgY2xvc2UgZW1waGFzaXMsIHRoZW4gdGhlXG4gICAgICAgIC8vIHN1bSBvZiB0aGUgbGVuZ3RocyBvZiB0aGUgZGVsaW1pdGVyIHJ1bnMgY29udGFpbmluZyB0aGUgb3BlbmluZyBhbmRcbiAgICAgICAgLy8gY2xvc2luZyBkZWxpbWl0ZXJzIG11c3Qgbm90IGJlIGEgbXVsdGlwbGUgb2YgMyB1bmxlc3MgYm90aCBsZW5ndGhzXG4gICAgICAgIC8vIGFyZSBtdWx0aXBsZXMgb2YgMy5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKG9wZW5lci5jbG9zZSB8fCBjbG9zZXIub3Blbikge1xuICAgICAgICAgIGlmICgob3BlbmVyLmxlbmd0aCArIGNsb3Nlci5sZW5ndGgpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG9wZW5lci5sZW5ndGggJSAzICE9PSAwIHx8IGNsb3Nlci5sZW5ndGggJSAzICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlzT2RkTWF0Y2ggPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc09kZE1hdGNoKSB7XG4gICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGVsaW1pdGVyIGNhbm5vdCBiZSBhbiBvcGVuZXIsIHdlIGNhbiBzYWZlbHkgc2tpcFxuICAgICAgICAgIC8vIHRoZSBlbnRpcmUgc2VxdWVuY2UgaW4gZnV0dXJlIGNoZWNrcy4gVGhpcyBpcyByZXF1aXJlZCB0byBtYWtlXG4gICAgICAgICAgLy8gc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhciBjb21wbGV4aXR5IChzZWUgKl8qXypfKl8qXy4uLiBjYXNlKS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGxhc3RKdW1wID0gb3BlbmVySWR4ID4gMCAmJiAhZGVsaW1pdGVyc1tvcGVuZXJJZHggLSAxXS5vcGVuXG4gICAgICAgICAgICA/IGp1bXBzW29wZW5lcklkeCAtIDFdICsgMVxuICAgICAgICAgICAgOiAwXG5cbiAgICAgICAgICBqdW1wc1tjbG9zZXJJZHhdID0gY2xvc2VySWR4IC0gb3BlbmVySWR4ICsgbGFzdEp1bXBcbiAgICAgICAgICBqdW1wc1tvcGVuZXJJZHhdID0gbGFzdEp1bXBcblxuICAgICAgICAgIGNsb3Nlci5vcGVuICA9IGZhbHNlXG4gICAgICAgICAgb3BlbmVyLmVuZCAgID0gY2xvc2VySWR4XG4gICAgICAgICAgb3BlbmVyLmNsb3NlID0gZmFsc2VcbiAgICAgICAgICBuZXdNaW5PcGVuZXJJZHggPSAtMVxuICAgICAgICAgIC8vIHRyZWF0IG5leHQgdG9rZW4gYXMgc3RhcnQgb2YgcnVuLFxuICAgICAgICAgIC8vIGl0IG9wdGltaXplcyBza2lwcyBpbiAqKjwuLi4+KiphKio8Li4uPioqIHBhdGhvbG9naWNhbCBjYXNlXG4gICAgICAgICAgbGFzdFRva2VuSWR4ID0gLTJcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld01pbk9wZW5lcklkeCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIG1hdGNoIGZvciB0aGlzIGRlbGltaXRlciBydW4gZmFpbGVkLCB3ZSB3YW50IHRvIHNldCBsb3dlciBib3VuZCBmb3JcbiAgICAgIC8vIGZ1dHVyZSBsb29rdXBzLiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2Ugc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhclxuICAgICAgLy8gY29tcGxleGl0eS5cbiAgICAgIC8vXG4gICAgICAvLyBTZWUgZGV0YWlscyBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbW1vbm1hcmsvY21hcmsvaXNzdWVzLzE3OCNpc3N1ZWNvbW1lbnQtMjcwNDE3NDQyXG4gICAgICAvL1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXVsoY2xvc2VyLm9wZW4gPyAzIDogMCkgKyAoKGNsb3Nlci5sZW5ndGggfHwgMCkgJSAzKV0gPSBuZXdNaW5PcGVuZXJJZHhcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlua19wYWlycyAoc3RhdGUpIHtcbiAgY29uc3QgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YVxuICBjb25zdCBtYXggPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGhcblxuICBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZS5kZWxpbWl0ZXJzKVxuXG4gIGZvciAobGV0IGN1cnIgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICBpZiAodG9rZW5zX21ldGFbY3Vycl0gJiYgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycykge1xuICAgICAgcHJvY2Vzc0RlbGltaXRlcnModG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycylcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/emphasis.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/emphasis.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Process *this* and _that_\n//\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nfunction emphasis_tokenize (state, silent) {\n  const start = state.pos\n  const marker = state.src.charCodeAt(start)\n\n  if (silent) { return false }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false }\n\n  const scanned = state.scanDelims(state.pos, marker === 0x2A)\n\n  for (let i = 0; i < scanned.length; i++) {\n    const token = state.push('text', '', 0)\n    token.content = String.fromCharCode(marker)\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token: state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end: -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open: scanned.can_open,\n      close: scanned.can_close\n    })\n  }\n\n  state.pos += scanned.length\n\n  return true\n}\n\nfunction postProcess (state, delimiters) {\n  const max = delimiters.length\n\n  for (let i = max - 1; i >= 0; i--) {\n    const startDelim = delimiters[i]\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue\n    }\n\n    const endDelim = delimiters[startDelim.end]\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    const isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               // check that first two markers match and adjacent\n               delimiters[i - 1].marker === startDelim.marker &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               // check that last two markers are adjacent (we can safely assume they match)\n               delimiters[startDelim.end + 1].token === endDelim.token + 1\n\n    const ch = String.fromCharCode(startDelim.marker)\n\n    const token_o   = state.tokens[startDelim.token]\n    token_o.type    = isStrong ? 'strong_open' : 'em_open'\n    token_o.tag     = isStrong ? 'strong' : 'em'\n    token_o.nesting = 1\n    token_o.markup  = isStrong ? ch + ch : ch\n    token_o.content = ''\n\n    const token_c   = state.tokens[endDelim.token]\n    token_c.type    = isStrong ? 'strong_close' : 'em_close'\n    token_c.tag     = isStrong ? 'strong' : 'em'\n    token_c.nesting = -1\n    token_c.markup  = isStrong ? ch + ch : ch\n    token_c.content = ''\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = ''\n      state.tokens[delimiters[startDelim.end + 1].token].content = ''\n      i--\n    }\n  }\n}\n\n// Walk through delimiter list and replace text tokens with tags\n//\nfunction emphasis_post_process (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  postProcess(state, state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters)\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  tokenize: emphasis_tokenize,\n  postProcess: emphasis_post_process\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEIsNERBQTREOztBQUU1RDs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsUUFBUTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW1waGFzaXMubWpzPzMxNDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xuLy9cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbmZ1bmN0aW9uIGVtcGhhc2lzX3Rva2VuaXplIChzdGF0ZSwgc2lsZW50KSB7XG4gIGNvbnN0IHN0YXJ0ID0gc3RhdGUucG9zXG4gIGNvbnN0IG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBzY2FubmVkID0gc3RhdGUuc2NhbkRlbGltcyhzdGF0ZS5wb3MsIG1hcmtlciA9PT0gMHgyQSlcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjYW5uZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMClcbiAgICB0b2tlbi5jb250ZW50ID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpXG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgLy8gQ2hhciBjb2RlIG9mIHRoZSBzdGFydGluZyBtYXJrZXIgKG51bWJlcikuXG4gICAgICAvL1xuICAgICAgbWFya2VyLFxuXG4gICAgICAvLyBUb3RhbCBsZW5ndGggb2YgdGhlc2Ugc2VyaWVzIG9mIGRlbGltaXRlcnMuXG4gICAgICAvL1xuICAgICAgbGVuZ3RoOiBzY2FubmVkLmxlbmd0aCxcblxuICAgICAgLy8gQSBwb3NpdGlvbiBvZiB0aGUgdG9rZW4gdGhpcyBkZWxpbWl0ZXIgY29ycmVzcG9uZHMgdG8uXG4gICAgICAvL1xuICAgICAgdG9rZW46IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuXG4gICAgICAvLyBJZiB0aGlzIGRlbGltaXRlciBpcyBtYXRjaGVkIGFzIGEgdmFsaWQgb3BlbmVyLCBgZW5kYCB3aWxsIGJlXG4gICAgICAvLyBlcXVhbCB0byBpdHMgcG9zaXRpb24sIG90aGVyd2lzZSBpdCdzIGAtMWAuXG4gICAgICAvL1xuICAgICAgZW5kOiAtMSxcblxuICAgICAgLy8gQm9vbGVhbiBmbGFncyB0aGF0IGRldGVybWluZSBpZiB0aGlzIGRlbGltaXRlciBjb3VsZCBvcGVuIG9yIGNsb3NlXG4gICAgICAvLyBhbiBlbXBoYXNpcy5cbiAgICAgIC8vXG4gICAgICBvcGVuOiBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6IHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSlcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aFxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzIChzdGF0ZSwgZGVsaW1pdGVycykge1xuICBjb25zdCBtYXggPSBkZWxpbWl0ZXJzLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSBtYXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldXG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4NUYvKiBfICovICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDJBLyogKiAqLykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIG9ubHkgb3BlbmluZyBtYXJrZXJzXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdXG5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgZGVsaW1pdGVyIGhhcyB0aGUgc2FtZSBtYXJrZXIgYW5kIGlzIGFkamFjZW50IHRvIHRoaXMgb25lLFxuICAgIC8vIG1lcmdlIHRob3NlIGludG8gb25lIHN0cm9uZyBkZWxpbWl0ZXIuXG4gICAgLy9cbiAgICAvLyBgPGVtPjxlbT53aGF0ZXZlcjwvZW0+PC9lbT5gIC0+IGA8c3Ryb25nPndoYXRldmVyPC9zdHJvbmc+YFxuICAgIC8vXG4gICAgY29uc3QgaXNTdHJvbmcgPSBpID4gMCAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0uZW5kID09PSBzdGFydERlbGltLmVuZCArIDEgJiZcbiAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgZmlyc3QgdHdvIG1hcmtlcnMgbWF0Y2ggYW5kIGFkamFjZW50XG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS5tYXJrZXIgPT09IHN0YXJ0RGVsaW0ubWFya2VyICYmXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW2kgLSAxXS50b2tlbiA9PT0gc3RhcnREZWxpbS50b2tlbiAtIDEgJiZcbiAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgbGFzdCB0d28gbWFya2VycyBhcmUgYWRqYWNlbnQgKHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoZXkgbWF0Y2gpXG4gICAgICAgICAgICAgICBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW4gPT09IGVuZERlbGltLnRva2VuICsgMVxuXG4gICAgY29uc3QgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0RGVsaW0ubWFya2VyKVxuXG4gICAgY29uc3QgdG9rZW5fbyAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dXG4gICAgdG9rZW5fby50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nXG4gICAgdG9rZW5fby50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSdcbiAgICB0b2tlbl9vLm5lc3RpbmcgPSAxXG4gICAgdG9rZW5fby5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2hcbiAgICB0b2tlbl9vLmNvbnRlbnQgPSAnJ1xuXG4gICAgY29uc3QgdG9rZW5fYyAgID0gc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuXVxuICAgIHRva2VuX2MudHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnXG4gICAgdG9rZW5fYy50YWcgICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nJyA6ICdlbSdcbiAgICB0b2tlbl9jLm5lc3RpbmcgPSAtMVxuICAgIHRva2VuX2MubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoXG4gICAgdG9rZW5fYy5jb250ZW50ID0gJydcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSAtIDFdLnRva2VuXS5jb250ZW50ID0gJydcbiAgICAgIHN0YXRlLnRva2Vuc1tkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kICsgMV0udG9rZW5dLmNvbnRlbnQgPSAnJ1xuICAgICAgaS0tXG4gICAgfVxuICB9XG59XG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5mdW5jdGlvbiBlbXBoYXNpc19wb3N0X3Byb2Nlc3MgKHN0YXRlKSB7XG4gIGNvbnN0IHRva2Vuc19tZXRhID0gc3RhdGUudG9rZW5zX21ldGFcbiAgY29uc3QgbWF4ID0gc3RhdGUudG9rZW5zX21ldGEubGVuZ3RoXG5cbiAgcG9zdFByb2Nlc3Moc3RhdGUsIHN0YXRlLmRlbGltaXRlcnMpXG5cbiAgZm9yIChsZXQgY3VyciA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIGlmICh0b2tlbnNfbWV0YVtjdXJyXSAmJiB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKSB7XG4gICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycylcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICB0b2tlbml6ZTogZW1waGFzaXNfdG9rZW5pemUsXG4gIHBvc3RQcm9jZXNzOiBlbXBoYXNpc19wb3N0X3Byb2Nlc3Ncbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/emphasis.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/entity.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/entity.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ entity; }\n/* harmony export */ });\n/* harmony import */ var entities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! entities */ \"(app-pages-browser)/./node_modules/entities/lib/esm/index.js\");\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\n\n\nconst DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i\nconst NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i\n\nfunction entity (state, silent) {\n  const pos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(pos) !== 0x26/* & */) return false\n\n  if (pos + 1 >= max) return false\n\n  const ch = state.src.charCodeAt(pos + 1)\n\n  if (ch === 0x23 /* # */) {\n    const match = state.src.slice(pos).match(DIGITAL_RE)\n    if (match) {\n      if (!silent) {\n        const code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10)\n\n        const token   = state.push('text_special', '', 0)\n        token.content = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isValidEntityCode)(code) ? (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(code) : (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(0xFFFD)\n        token.markup  = match[0]\n        token.info    = 'entity'\n      }\n      state.pos += match[0].length\n      return true\n    }\n  } else {\n    const match = state.src.slice(pos).match(NAMED_RE)\n    if (match) {\n      const decoded = (0,entities__WEBPACK_IMPORTED_MODULE_0__.decodeHTML)(match[0])\n      if (decoded !== match[0]) {\n        if (!silent) {\n          const token   = state.push('text_special', '', 0)\n          token.content = decoded\n          token.markup  = match[0]\n          token.info    = 'entity'\n        }\n        state.pos += match[0].length\n        return true\n      }\n    }\n  }\n\n  return false\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsK0JBQStCLFFBQVEsUUFBUTs7QUFFVjtBQUNpQzs7QUFFdEUscUNBQXFDLElBQUksT0FBTyxJQUFJLEdBQUc7QUFDdkQscUNBQXFDLEtBQUssRUFBRTs7QUFFN0I7QUFDZjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isb0VBQWlCLFNBQVMsZ0VBQWEsU0FBUyxnRUFBYTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQixvREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lbnRpdHkubWpzPzk0YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG5pbXBvcnQgeyBkZWNvZGVIVE1MIH0gZnJvbSAnZW50aXRpZXMnXG5pbXBvcnQgeyBpc1ZhbGlkRW50aXR5Q29kZSwgZnJvbUNvZGVQb2ludCB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmNvbnN0IERJR0lUQUxfUkUgPSAvXiYjKCg/OnhbYS1mMC05XXsxLDZ9fFswLTldezEsN30pKTsvaVxuY29uc3QgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbnRpdHkgKHN0YXRlLCBzaWxlbnQpIHtcbiAgY29uc3QgcG9zID0gc3RhdGUucG9zXG4gIGNvbnN0IG1heCA9IHN0YXRlLnBvc01heFxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKHBvcyArIDEgPj0gbWF4KSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpXG5cbiAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICBjb25zdCBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKERJR0lUQUxfUkUpXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICBjb25zdCBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMClcblxuICAgICAgICBjb25zdCB0b2tlbiAgID0gc3RhdGUucHVzaCgndGV4dF9zcGVjaWFsJywgJycsIDApXG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRClcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hdGNoWzBdXG4gICAgICAgIHRva2VuLmluZm8gICAgPSAnZW50aXR5J1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSlcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVIVE1MKG1hdGNoWzBdKVxuICAgICAgaWYgKGRlY29kZWQgIT09IG1hdGNoWzBdKSB7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gICA9IHN0YXRlLnB1c2goJ3RleHRfc3BlY2lhbCcsICcnLCAwKVxuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSBkZWNvZGVkXG4gICAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hdGNoWzBdXG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdlbnRpdHknXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/entity.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/escape.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/escape.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ escape; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Process escaped chars and hardbreaks\n\n\n\nconst ESCAPED = []\n\nfor (let i = 0; i < 256; i++) { ESCAPED.push(0) }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1 })\n\nfunction escape (state, silent) {\n  let pos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) return false\n  pos++\n\n  // '\\' at the end of the inline block\n  if (pos >= max) return false\n\n  let ch1 = state.src.charCodeAt(pos)\n\n  if (ch1 === 0x0A) {\n    if (!silent) {\n      state.push('hardbreak', 'br', 0)\n    }\n\n    pos++\n    // skip leading whitespaces from next line\n    while (pos < max) {\n      ch1 = state.src.charCodeAt(pos)\n      if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(ch1)) break\n      pos++\n    }\n\n    state.pos = pos\n    return true\n  }\n\n  let escapedStr = state.src[pos]\n\n  if (ch1 >= 0xD800 && ch1 <= 0xDBFF && pos + 1 < max) {\n    const ch2 = state.src.charCodeAt(pos + 1)\n\n    if (ch2 >= 0xDC00 && ch2 <= 0xDFFF) {\n      escapedStr += state.src[pos + 1]\n      pos++\n    }\n  }\n\n  const origStr = '\\\\' + escapedStr\n\n  if (!silent) {\n    const token = state.push('text_special', '', 0)\n\n    if (ch1 < 256 && ESCAPED[ch1] !== 0) {\n      token.content = escapedStr\n    } else {\n      token.content = origStr\n    }\n\n    token.markup = origStr\n    token.info   = 'escape'\n  }\n\n  state.pos = pos + 1\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VzY2FwZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7QUFFNkM7O0FBRTdDOztBQUVBLGdCQUFnQixTQUFTLE9BQU87O0FBRWhDLG9CQUFvQixXQUFXLEVBQUU7QUFDakMscUNBQXFDLCtCQUErQjs7QUFFckQ7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMERBQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLm1qcz9jMTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2Nlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuY29uc3QgRVNDQVBFRCA9IFtdXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApIH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxIH0pXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzY2FwZSAoc3RhdGUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUucG9zXG4gIGNvbnN0IG1heCA9IHN0YXRlLnBvc01heFxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHJldHVybiBmYWxzZVxuICBwb3MrK1xuXG4gIC8vICdcXCcgYXQgdGhlIGVuZCBvZiB0aGUgaW5saW5lIGJsb2NrXG4gIGlmIChwb3MgPj0gbWF4KSByZXR1cm4gZmFsc2VcblxuICBsZXQgY2gxID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuXG4gIGlmIChjaDEgPT09IDB4MEEpIHtcbiAgICBpZiAoIXNpbGVudCkge1xuICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMClcbiAgICB9XG5cbiAgICBwb3MrK1xuICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNoMSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcbiAgICAgIGlmICghaXNTcGFjZShjaDEpKSBicmVha1xuICAgICAgcG9zKytcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgPSBwb3NcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGVzY2FwZWRTdHIgPSBzdGF0ZS5zcmNbcG9zXVxuXG4gIGlmIChjaDEgPj0gMHhEODAwICYmIGNoMSA8PSAweERCRkYgJiYgcG9zICsgMSA8IG1heCkge1xuICAgIGNvbnN0IGNoMiA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpXG5cbiAgICBpZiAoY2gyID49IDB4REMwMCAmJiBjaDIgPD0gMHhERkZGKSB7XG4gICAgICBlc2NhcGVkU3RyICs9IHN0YXRlLnNyY1twb3MgKyAxXVxuICAgICAgcG9zKytcbiAgICB9XG4gIH1cblxuICBjb25zdCBvcmlnU3RyID0gJ1xcXFwnICsgZXNjYXBlZFN0clxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29uc3QgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0ZXh0X3NwZWNpYWwnLCAnJywgMClcblxuICAgIGlmIChjaDEgPCAyNTYgJiYgRVNDQVBFRFtjaDFdICE9PSAwKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gZXNjYXBlZFN0clxuICAgIH0gZWxzZSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gb3JpZ1N0clxuICAgIH1cblxuICAgIHRva2VuLm1hcmt1cCA9IG9yaWdTdHJcbiAgICB0b2tlbi5pbmZvICAgPSAnZXNjYXBlJ1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zICsgMVxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/escape.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/fragments_join.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/fragments_join.mjs ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ fragments_join; }\n/* harmony export */ });\n// Clean up tokens after emphasis and strikethrough postprocessing:\n// merge adjacent text nodes into one and re-calculate all token levels\n//\n// This is necessary because initially emphasis delimiter markers (*, _, ~)\n// are treated as their own separate text tokens. Then emphasis rule either\n// leaves them as text (needed to merge with adjacent text) or turns them\n// into opening/closing tags (which messes up levels inside).\n//\n\nfunction fragments_join (state) {\n  let curr, last\n  let level = 0\n  const tokens = state.tokens\n  const max = state.tokens.length\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels after emphasis/strikethrough turns some text nodes\n    // into opening/closing tags\n    if (tokens[curr].nesting < 0) level-- // closing tag\n    tokens[curr].level = level\n    if (tokens[curr].nesting > 0) level++ // opening tag\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr] }\n\n      last++\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ZyYWdtZW50c19qb2luLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9mcmFnbWVudHNfam9pbi5tanM/OWY1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDbGVhbiB1cCB0b2tlbnMgYWZ0ZXIgZW1waGFzaXMgYW5kIHN0cmlrZXRocm91Z2ggcG9zdHByb2Nlc3Npbmc6XG4vLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgaW5pdGlhbGx5IGVtcGhhc2lzIGRlbGltaXRlciBtYXJrZXJzICgqLCBfLCB+KVxuLy8gYXJlIHRyZWF0ZWQgYXMgdGhlaXIgb3duIHNlcGFyYXRlIHRleHQgdG9rZW5zLiBUaGVuIGVtcGhhc2lzIHJ1bGUgZWl0aGVyXG4vLyBsZWF2ZXMgdGhlbSBhcyB0ZXh0IChuZWVkZWQgdG8gbWVyZ2Ugd2l0aCBhZGphY2VudCB0ZXh0KSBvciB0dXJucyB0aGVtXG4vLyBpbnRvIG9wZW5pbmcvY2xvc2luZyB0YWdzICh3aGljaCBtZXNzZXMgdXAgbGV2ZWxzIGluc2lkZSkuXG4vL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmcmFnbWVudHNfam9pbiAoc3RhdGUpIHtcbiAgbGV0IGN1cnIsIGxhc3RcbiAgbGV0IGxldmVsID0gMFxuICBjb25zdCB0b2tlbnMgPSBzdGF0ZS50b2tlbnNcbiAgY29uc3QgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aFxuXG4gIGZvciAoY3VyciA9IGxhc3QgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICAvLyByZS1jYWxjdWxhdGUgbGV2ZWxzIGFmdGVyIGVtcGhhc2lzL3N0cmlrZXRocm91Z2ggdHVybnMgc29tZSB0ZXh0IG5vZGVzXG4gICAgLy8gaW50byBvcGVuaW5nL2Nsb3NpbmcgdGFnc1xuICAgIGlmICh0b2tlbnNbY3Vycl0ubmVzdGluZyA8IDApIGxldmVsLS0gLy8gY2xvc2luZyB0YWdcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbFxuICAgIGlmICh0b2tlbnNbY3Vycl0ubmVzdGluZyA+IDApIGxldmVsKysgLy8gb3BlbmluZyB0YWdcblxuICAgIGlmICh0b2tlbnNbY3Vycl0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIGN1cnIgKyAxIDwgbWF4ICYmXG4gICAgICAgIHRva2Vuc1tjdXJyICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAvLyBjb2xsYXBzZSB0d28gYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50ID0gdG9rZW5zW2N1cnJdLmNvbnRlbnQgKyB0b2tlbnNbY3VyciArIDFdLmNvbnRlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGN1cnIgIT09IGxhc3QpIHsgdG9rZW5zW2xhc3RdID0gdG9rZW5zW2N1cnJdIH1cblxuICAgICAgbGFzdCsrXG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnIgIT09IGxhc3QpIHtcbiAgICB0b2tlbnMubGVuZ3RoID0gbGFzdFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/fragments_join.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/html_inline.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/html_inline.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ html_inline; }\n/* harmony export */ });\n/* harmony import */ var _common_html_re_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/html_re.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/html_re.mjs\");\n// Process html tags\n\n\n\nfunction isLinkOpen (str) {\n  return /^<a[>\\s]/i.test(str)\n}\nfunction isLinkClose (str) {\n  return /^<\\/a\\s*>/i.test(str)\n}\n\nfunction isLetter (ch) {\n  /* eslint no-bitwise:0 */\n  const lc = ch | 0x20 // to lower case\n  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */)\n}\n\nfunction html_inline (state, silent) {\n  if (!state.md.options.html) { return false }\n\n  // Check start\n  const max = state.posMax\n  const pos = state.pos\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||\n      pos + 2 >= max) {\n    return false\n  }\n\n  // Quick fail on second char\n  const ch = state.src.charCodeAt(pos + 1)\n  if (ch !== 0x21/* ! */ &&\n      ch !== 0x3F/* ? */ &&\n      ch !== 0x2F/* / */ &&\n      !isLetter(ch)) {\n    return false\n  }\n\n  const match = state.src.slice(pos).match(_common_html_re_mjs__WEBPACK_IMPORTED_MODULE_0__.HTML_TAG_RE)\n  if (!match) { return false }\n\n  if (!silent) {\n    const token = state.push('html_inline', '', 0)\n    token.content = match[0]\n\n    if (isLinkOpen(token.content))  state.linkLevel++\n    if (isLinkClose(token.content)) state.linkLevel--\n  }\n  state.pos += match[0].length\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2h0bWxfaW5saW5lLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLDREQUFXO0FBQ3RELGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9odG1sX2lubGluZS5tanM/NmMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG5pbXBvcnQgeyBIVE1MX1RBR19SRSB9IGZyb20gJy4uL2NvbW1vbi9odG1sX3JlLm1qcydcblxuZnVuY3Rpb24gaXNMaW5rT3BlbiAoc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpXG59XG5mdW5jdGlvbiBpc0xpbmtDbG9zZSAoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cilcbn1cblxuZnVuY3Rpb24gaXNMZXR0ZXIgKGNoKSB7XG4gIC8qIGVzbGludCBuby1iaXR3aXNlOjAgKi9cbiAgY29uc3QgbGMgPSBjaCB8IDB4MjAgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGh0bWxfaW5saW5lIChzdGF0ZSwgc2lsZW50KSB7XG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgLy8gQ2hlY2sgc3RhcnRcbiAgY29uc3QgbWF4ID0gc3RhdGUucG9zTWF4XG4gIGNvbnN0IHBvcyA9IHN0YXRlLnBvc1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8gfHxcbiAgICAgIHBvcyArIDIgPj0gbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNvbnN0IGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSlcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goSFRNTF9UQUdfUkUpXG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnN0IHRva2VuID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMClcbiAgICB0b2tlbi5jb250ZW50ID0gbWF0Y2hbMF1cblxuICAgIGlmIChpc0xpbmtPcGVuKHRva2VuLmNvbnRlbnQpKSAgc3RhdGUubGlua0xldmVsKytcbiAgICBpZiAoaXNMaW5rQ2xvc2UodG9rZW4uY29udGVudCkpIHN0YXRlLmxpbmtMZXZlbC0tXG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aFxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/html_inline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/image.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/image.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ image; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Process ![image](<src> \"title\")\n\n\n\nfunction image (state, silent) {\n  let code, content, label, pos, ref, res, title, start\n  let href = ''\n  const oldPos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false }\n\n  const labelStart = state.pos + 2\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false }\n\n  pos = labelEnd + 1\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n    }\n    if (pos >= max) { return false }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str)\n      if (state.md.validateLink(href)) {\n        pos = res.pos\n      } else {\n        href = ''\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str\n      pos = res.pos\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos)\n        if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n      }\n    } else {\n      title = ''\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos\n      return false\n    }\n    pos++\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1\n      pos = state.md.helpers.parseLinkLabel(state, pos)\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++)\n      } else {\n        pos = labelEnd + 1\n      }\n    } else {\n      pos = labelEnd + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd) }\n\n    ref = state.env.references[(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeReference)(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd)\n\n    const tokens = []\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens\n    )\n\n    const token = state.push('image', 'img', 0)\n    const attrs = [['src', href], ['alt', '']]\n    token.attrs = attrs\n    token.children = tokens\n    token.content = content\n\n    if (title) {\n      attrs.push(['title', title])\n    }\n  }\n\n  state.pos = pos\n  state.posMax = max\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2ltYWdlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztBQUVpRTs7QUFFbEQ7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFdBQVcsMERBQU8sMkJBQTJCO0FBQzdDO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSxXQUFXLDBEQUFPLDJCQUEyQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsMERBQU8sMkJBQTJCO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCLCtCQUErQixxRUFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UubWpzP2VhOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbmltcG9ydCB7IG5vcm1hbGl6ZVJlZmVyZW5jZSwgaXNTcGFjZSB9IGZyb20gJy4uL2NvbW1vbi91dGlscy5tanMnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGltYWdlIChzdGF0ZSwgc2lsZW50KSB7XG4gIGxldCBjb2RlLCBjb250ZW50LCBsYWJlbCwgcG9zLCByZWYsIHJlcywgdGl0bGUsIHN0YXJ0XG4gIGxldCBocmVmID0gJydcbiAgY29uc3Qgb2xkUG9zID0gc3RhdGUucG9zXG4gIGNvbnN0IG1heCA9IHN0YXRlLnBvc01heFxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zICsgMSkgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgY29uc3QgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDJcbiAgY29uc3QgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSlcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMVxuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrK1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3NcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpXG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cilcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvc1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKVxuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heClcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHJcbiAgICAgIHBvcyA9IHJlcy5wb3NcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnXG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHBvcysrXG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMVxuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKVxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDFcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpIH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldXG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvc1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZlxuICAgIHRpdGxlID0gcmVmLnRpdGxlXG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZClcblxuICAgIGNvbnN0IHRva2VucyA9IFtdXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zXG4gICAgKVxuXG4gICAgY29uc3QgdG9rZW4gPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKVxuICAgIGNvbnN0IGF0dHJzID0gW1snc3JjJywgaHJlZl0sIFsnYWx0JywgJyddXVxuICAgIHRva2VuLmF0dHJzID0gYXR0cnNcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2Vuc1xuICAgIHRva2VuLmNvbnRlbnQgPSBjb250ZW50XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyd0aXRsZScsIHRpdGxlXSlcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3NcbiAgc3RhdGUucG9zTWF4ID0gbWF4XG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/image.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/link.mjs":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/link.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ link; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Process [link](<to> \"stuff\")\n\n\n\nfunction link (state, silent) {\n  let code, label, res, ref\n  let href = ''\n  let title = ''\n  let start = state.pos\n  let parseReference = true\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false }\n\n  const oldPos = state.pos\n  const max = state.posMax\n  const labelStart = state.pos + 1\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false }\n\n  let pos = labelEnd + 1\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n    }\n    if (pos >= max) { return false }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str)\n      if (state.md.validateLink(href)) {\n        pos = res.pos\n      } else {\n        href = ''\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n      start = pos\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos)\n        if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str\n        pos = res.pos\n\n        // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos)\n          if (!(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(code) && code !== 0x0A) { break }\n        }\n      }\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true\n    }\n    pos++\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1\n      pos = state.md.helpers.parseLinkLabel(state, pos)\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++)\n      } else {\n        pos = labelEnd + 1\n      }\n    } else {\n      pos = labelEnd + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd) }\n\n    ref = state.env.references[(0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeReference)(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart\n    state.posMax = labelEnd\n\n    const token_o = state.push('link_open', 'a', 1)\n    const attrs = [['href', href]]\n    token_o.attrs  = attrs\n    if (title) {\n      attrs.push(['title', title])\n    }\n\n    state.linkLevel++\n    state.md.inline.tokenize(state)\n    state.linkLevel--\n\n    state.push('link_close', 'a', -1)\n  }\n\n  state.pos = pos\n  state.posMax = max\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRWlFOztBQUVsRDtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFdBQVcsMERBQU8sMkJBQTJCO0FBQzdDO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0EsYUFBYSwwREFBTywyQkFBMkI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxlQUFlLDBEQUFPLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQiwrQkFBK0IscUVBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9saW5rLm1qcz8zZGU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFByb2Nlc3MgW2xpbmtdKDx0bz4gXCJzdHVmZlwiKVxuXG5pbXBvcnQgeyBub3JtYWxpemVSZWZlcmVuY2UsIGlzU3BhY2UgfSBmcm9tICcuLi9jb21tb24vdXRpbHMubWpzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5rIChzdGF0ZSwgc2lsZW50KSB7XG4gIGxldCBjb2RlLCBsYWJlbCwgcmVzLCByZWZcbiAgbGV0IGhyZWYgPSAnJ1xuICBsZXQgdGl0bGUgPSAnJ1xuICBsZXQgc3RhcnQgPSBzdGF0ZS5wb3NcbiAgbGV0IHBhcnNlUmVmZXJlbmNlID0gdHJ1ZVxuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGNvbnN0IG9sZFBvcyA9IHN0YXRlLnBvc1xuICBjb25zdCBtYXggPSBzdGF0ZS5wb3NNYXhcbiAgY29uc3QgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDFcbiAgY29uc3QgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MsIHRydWUpXG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlIH1cblxuICBsZXQgcG9zID0gbGFiZWxFbmQgKyAxXG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKytcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KVxuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpXG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJ1xuICAgICAgfVxuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBzdGFydCA9IHBvc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcylcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWsgfVxuICAgICAgfVxuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KVxuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgICB0aXRsZSA9IHJlcy5zdHJcbiAgICAgICAgcG9zID0gcmVzLnBvc1xuXG4gICAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpXG4gICAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWVcbiAgICB9XG4gICAgcG9zKytcbiAgfVxuXG4gIGlmIChwYXJzZVJlZmVyZW5jZSkge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDFcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcylcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxXG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKSB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXVxuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3NcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWZcbiAgICB0aXRsZSA9IHJlZi50aXRsZVxuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIHN0YXRlLnBvcyA9IGxhYmVsU3RhcnRcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZFxuXG4gICAgY29uc3QgdG9rZW5fbyA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSlcbiAgICBjb25zdCBhdHRycyA9IFtbJ2hyZWYnLCBocmVmXV1cbiAgICB0b2tlbl9vLmF0dHJzICA9IGF0dHJzXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBhdHRycy5wdXNoKFsndGl0bGUnLCB0aXRsZV0pXG4gICAgfVxuXG4gICAgc3RhdGUubGlua0xldmVsKytcbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpXG4gICAgc3RhdGUubGlua0xldmVsLS1cblxuICAgIHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKVxuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zXG4gIHN0YXRlLnBvc01heCA9IG1heFxuICByZXR1cm4gdHJ1ZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/link.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/linkify.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/linkify.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ linkify; }\n/* harmony export */ });\n// Process links like https://example.org/\n\n// RFC3986: scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nconst SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i\n\nfunction linkify (state, silent) {\n  if (!state.md.options.linkify) return false\n  if (state.linkLevel > 0) return false\n\n  const pos = state.pos\n  const max = state.posMax\n\n  if (pos + 3 > max) return false\n  if (state.src.charCodeAt(pos) !== 0x3A/* : */) return false\n  if (state.src.charCodeAt(pos + 1) !== 0x2F/* / */) return false\n  if (state.src.charCodeAt(pos + 2) !== 0x2F/* / */) return false\n\n  const match = state.pending.match(SCHEME_RE)\n  if (!match) return false\n\n  const proto = match[1]\n\n  const link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length))\n  if (!link) return false\n\n  let url = link.url\n\n  // invalid link, but still detected by linkify somehow;\n  // need to check to prevent infinite loop below\n  if (url.length <= proto.length) return false\n\n  // disallow '*' at the end of the link (conflicts with emphasis)\n  url = url.replace(/\\*+$/, '')\n\n  const fullUrl = state.md.normalizeLink(url)\n  if (!state.md.validateLink(fullUrl)) return false\n\n  if (!silent) {\n    state.pending = state.pending.slice(0, -proto.length)\n\n    const token_o = state.push('link_open', 'a', 1)\n    token_o.attrs = [['href', fullUrl]]\n    token_o.markup = 'linkify'\n    token_o.info = 'auto'\n\n    const token_t = state.push('text', '', 0)\n    token_t.content = state.md.normalizeLinkText(url)\n\n    const token_c = state.push('link_close', 'a', -1)\n    token_c.markup = 'linkify'\n    token_c.info = 'auto'\n  }\n\n  state.pos += url.length - proto.length\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmtpZnkubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGlua2lmeS5tanM/ODgxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9jZXNzIGxpbmtzIGxpa2UgaHR0cHM6Ly9leGFtcGxlLm9yZy9cblxuLy8gUkZDMzk4Njogc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG5jb25zdCBTQ0hFTUVfUkUgPSAvKD86XnxbXmEtejAtOS4rLV0pKFthLXpdW2EtejAtOS4rLV0qKSQvaVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaW5raWZ5IChzdGF0ZSwgc2lsZW50KSB7XG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5saW5raWZ5KSByZXR1cm4gZmFsc2VcbiAgaWYgKHN0YXRlLmxpbmtMZXZlbCA+IDApIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IHBvcyA9IHN0YXRlLnBvc1xuICBjb25zdCBtYXggPSBzdGF0ZS5wb3NNYXhcblxuICBpZiAocG9zICsgMyA+IG1heCkgcmV0dXJuIGZhbHNlXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNBLyogOiAqLykgcmV0dXJuIGZhbHNlXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgyRi8qIC8gKi8pIHJldHVybiBmYWxzZVxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMikgIT09IDB4MkYvKiAvICovKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBtYXRjaCA9IHN0YXRlLnBlbmRpbmcubWF0Y2goU0NIRU1FX1JFKVxuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBwcm90byA9IG1hdGNoWzFdXG5cbiAgY29uc3QgbGluayA9IHN0YXRlLm1kLmxpbmtpZnkubWF0Y2hBdFN0YXJ0KHN0YXRlLnNyYy5zbGljZShwb3MgLSBwcm90by5sZW5ndGgpKVxuICBpZiAoIWxpbmspIHJldHVybiBmYWxzZVxuXG4gIGxldCB1cmwgPSBsaW5rLnVybFxuXG4gIC8vIGludmFsaWQgbGluaywgYnV0IHN0aWxsIGRldGVjdGVkIGJ5IGxpbmtpZnkgc29tZWhvdztcbiAgLy8gbmVlZCB0byBjaGVjayB0byBwcmV2ZW50IGluZmluaXRlIGxvb3AgYmVsb3dcbiAgaWYgKHVybC5sZW5ndGggPD0gcHJvdG8ubGVuZ3RoKSByZXR1cm4gZmFsc2VcblxuICAvLyBkaXNhbGxvdyAnKicgYXQgdGhlIGVuZCBvZiB0aGUgbGluayAoY29uZmxpY3RzIHdpdGggZW1waGFzaXMpXG4gIHVybCA9IHVybC5yZXBsYWNlKC9cXCorJC8sICcnKVxuXG4gIGNvbnN0IGZ1bGxVcmwgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHVybClcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoZnVsbFVybCkpIHJldHVybiBmYWxzZVxuXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLXByb3RvLmxlbmd0aClcblxuICAgIGNvbnN0IHRva2VuX28gPSBzdGF0ZS5wdXNoKCdsaW5rX29wZW4nLCAnYScsIDEpXG4gICAgdG9rZW5fby5hdHRycyA9IFtbJ2hyZWYnLCBmdWxsVXJsXV1cbiAgICB0b2tlbl9vLm1hcmt1cCA9ICdsaW5raWZ5J1xuICAgIHRva2VuX28uaW5mbyA9ICdhdXRvJ1xuXG4gICAgY29uc3QgdG9rZW5fdCA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMClcbiAgICB0b2tlbl90LmNvbnRlbnQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCh1cmwpXG5cbiAgICBjb25zdCB0b2tlbl9jID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpXG4gICAgdG9rZW5fYy5tYXJrdXAgPSAnbGlua2lmeSdcbiAgICB0b2tlbl9jLmluZm8gPSAnYXV0bydcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSB1cmwubGVuZ3RoIC0gcHJvdG8ubGVuZ3RoXG4gIHJldHVybiB0cnVlXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/linkify.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/newline.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/newline.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ newline; }\n/* harmony export */ });\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Proceess '\\n'\n\n\n\nfunction newline (state, silent) {\n  let pos = state.pos\n\n  if (state.src.charCodeAt(pos) !== 0x0A/* \\n */) { return false }\n\n  const pmax = state.pending.length - 1\n  const max = state.posMax\n\n  // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Find whitespaces tail of pending chars.\n        let ws = pmax - 1\n        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--\n\n        state.pending = state.pending.slice(0, ws)\n        state.push('hardbreak', 'br', 0)\n      } else {\n        state.pending = state.pending.slice(0, -1)\n        state.push('softbreak', 'br', 0)\n      }\n    } else {\n      state.push('softbreak', 'br', 0)\n    }\n  }\n\n  pos++\n\n  // skip heading spaces for next line\n  while (pos < max && (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_0__.isSpace)(state.src.charCodeAt(pos))) { pos++ }\n\n  state.pos = pos\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL25ld2xpbmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRTZDOztBQUU5QjtBQUNmOztBQUVBLG9EQUFvRDs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsMERBQU8sK0JBQStCOztBQUU1RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbmV3bGluZS5tanM/Nzc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQcm9jZWVzcyAnXFxuJ1xuXG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi4vY29tbW9uL3V0aWxzLm1qcydcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbmV3bGluZSAoc3RhdGUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUucG9zXG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlIH1cblxuICBjb25zdCBwbWF4ID0gc3RhdGUucGVuZGluZy5sZW5ndGggLSAxXG4gIGNvbnN0IG1heCA9IHN0YXRlLnBvc01heFxuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIC8vIEZpbmQgd2hpdGVzcGFjZXMgdGFpbCBvZiBwZW5kaW5nIGNoYXJzLlxuICAgICAgICBsZXQgd3MgPSBwbWF4IC0gMVxuICAgICAgICB3aGlsZSAod3MgPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQod3MgLSAxKSA9PT0gMHgyMCkgd3MtLVxuXG4gICAgICAgIHN0YXRlLnBlbmRpbmcgPSBzdGF0ZS5wZW5kaW5nLnNsaWNlKDAsIHdzKVxuICAgICAgICBzdGF0ZS5wdXNoKCdoYXJkYnJlYWsnLCAnYnInLCAwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpXG4gICAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnB1c2goJ3NvZnRicmVhaycsICdicicsIDApXG4gICAgfVxuICB9XG5cbiAgcG9zKytcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrIH1cblxuICBzdGF0ZS5wb3MgPSBwb3NcbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/newline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/state_inline.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/state_inline.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _token_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../token.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/token.mjs\");\n/* harmony import */ var _common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/utils.mjs */ \"(app-pages-browser)/./node_modules/markdown-it/lib/common/utils.mjs\");\n// Inline parser state\n\n\n\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isMdAsciiPunct)(lastChar) || (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isPunctChar)(String.fromCharCode(lastChar))\n  const isNextPunctChar = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isMdAsciiPunct)(nextChar) || (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isPunctChar)(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isWhiteSpace)(lastChar)\n  const isNextWhiteSpace = (0,_common_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.isWhiteSpace)(nextChar)\n\n  const left_flanking =\n    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)\n  const right_flanking =\n    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)\n\n  const can_open  = left_flanking  && (canSplitWord || !right_flanking || isLastPunctChar)\n  const can_close = right_flanking && (canSplitWord || !left_flanking  || isNextPunctChar)\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = _token_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (StateInline);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRWdDO0FBQytDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtEQUFLO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixpRUFBYyxjQUFjLDhEQUFXO0FBQ2pFLDBCQUEwQixpRUFBYyxjQUFjLDhEQUFXOztBQUVqRSwyQkFBMkIsK0RBQVk7QUFDdkMsMkJBQTJCLCtEQUFZOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLDhCQUE4QixrREFBSzs7QUFFbkMsK0RBQWUsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUubWpzPzIxOGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lIHBhcnNlciBzdGF0ZVxuXG5pbXBvcnQgVG9rZW4gZnJvbSAnLi4vdG9rZW4ubWpzJ1xuaW1wb3J0IHsgaXNXaGl0ZVNwYWNlLCBpc1B1bmN0Q2hhciwgaXNNZEFzY2lpUHVuY3QgfSBmcm9tICcuLi9jb21tb24vdXRpbHMubWpzJ1xuXG5mdW5jdGlvbiBTdGF0ZUlubGluZSAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdGhpcy5zcmMgPSBzcmNcbiAgdGhpcy5lbnYgPSBlbnZcbiAgdGhpcy5tZCA9IG1kXG4gIHRoaXMudG9rZW5zID0gb3V0VG9rZW5zXG4gIHRoaXMudG9rZW5zX21ldGEgPSBBcnJheShvdXRUb2tlbnMubGVuZ3RoKVxuXG4gIHRoaXMucG9zID0gMFxuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aFxuICB0aGlzLmxldmVsID0gMFxuICB0aGlzLnBlbmRpbmcgPSAnJ1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDBcblxuICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuICB0aGlzLmNhY2hlID0ge31cblxuICAvLyBMaXN0IG9mIGVtcGhhc2lzLWxpa2UgZGVsaW1pdGVycyBmb3IgY3VycmVudCB0YWdcbiAgdGhpcy5kZWxpbWl0ZXJzID0gW11cblxuICAvLyBTdGFjayBvZiBkZWxpbWl0ZXIgbGlzdHMgZm9yIHVwcGVyIGxldmVsIHRhZ3NcbiAgdGhpcy5fcHJldl9kZWxpbWl0ZXJzID0gW11cblxuICAvLyBiYWNrdGljayBsZW5ndGggPT4gbGFzdCBzZWVuIHBvc2l0aW9uXG4gIHRoaXMuYmFja3RpY2tzID0ge31cbiAgdGhpcy5iYWNrdGlja3NTY2FubmVkID0gZmFsc2VcblxuICAvLyBDb3VudGVyIHVzZWQgdG8gZGlzYWJsZSBpbmxpbmUgbGlua2lmeS1pdCBleGVjdXRpb25cbiAgLy8gaW5zaWRlIDxhPiBhbmQgbWFya2Rvd24gbGlua3NcbiAgdGhpcy5saW5rTGV2ZWwgPSAwXG59XG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgdG9rZW4gPSBuZXcgVG9rZW4oJ3RleHQnLCAnJywgMClcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZ1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pXG4gIHRoaXMucGVuZGluZyA9ICcnXG4gIHJldHVybiB0b2tlblxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy8gSWYgcGVuZGluZyB0ZXh0IGV4aXN0cyAtIGZsdXNoIGl0IGFzIHRleHQgdG9rZW5cbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh0eXBlLCB0YWcsIG5lc3RpbmcpIHtcbiAgaWYgKHRoaXMucGVuZGluZykge1xuICAgIHRoaXMucHVzaFBlbmRpbmcoKVxuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKVxuICBsZXQgdG9rZW5fbWV0YSA9IG51bGxcblxuICBpZiAobmVzdGluZyA8IDApIHtcbiAgICAvLyBjbG9zaW5nIHRhZ1xuICAgIHRoaXMubGV2ZWwtLVxuICAgIHRoaXMuZGVsaW1pdGVycyA9IHRoaXMuX3ByZXZfZGVsaW1pdGVycy5wb3AoKVxuICB9XG5cbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLmxldmVsXG5cbiAgaWYgKG5lc3RpbmcgPiAwKSB7XG4gICAgLy8gb3BlbmluZyB0YWdcbiAgICB0aGlzLmxldmVsKytcbiAgICB0aGlzLl9wcmV2X2RlbGltaXRlcnMucHVzaCh0aGlzLmRlbGltaXRlcnMpXG4gICAgdGhpcy5kZWxpbWl0ZXJzID0gW11cbiAgICB0b2tlbl9tZXRhID0geyBkZWxpbWl0ZXJzOiB0aGlzLmRlbGltaXRlcnMgfVxuICB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsXG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pXG4gIHRoaXMudG9rZW5zX21ldGEucHVzaCh0b2tlbl9tZXRhKVxuICByZXR1cm4gdG9rZW5cbn1cblxuLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGVtcGhhc2lzLWxpa2UgbWFya2VycywgYW5kIGRldGVybWluZSB3aGV0aGVyXG4vLyBpdCBjYW4gc3RhcnQgYW4gZW1waGFzaXMgc2VxdWVuY2Ugb3IgZW5kIGFuIGVtcGhhc2lzIHNlcXVlbmNlLlxuLy9cbi8vICAtIHN0YXJ0IC0gcG9zaXRpb24gdG8gc2NhbiBmcm9tIChpdCBzaG91bGQgcG9pbnQgYXQgYSB2YWxpZCBtYXJrZXIpO1xuLy8gIC0gY2FuU3BsaXRXb3JkIC0gZGV0ZXJtaW5lIGlmIHRoZXNlIG1hcmtlcnMgY2FuIGJlIGZvdW5kIGluc2lkZSBhIHdvcmRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuc2NhbkRlbGltcyA9IGZ1bmN0aW9uIChzdGFydCwgY2FuU3BsaXRXb3JkKSB7XG4gIGNvbnN0IG1heCA9IHRoaXMucG9zTWF4XG4gIGNvbnN0IG1hcmtlciA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQpXG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBjb25zdCBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjBcblxuICBsZXQgcG9zID0gc3RhcnRcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKyB9XG5cbiAgY29uc3QgY291bnQgPSBwb3MgLSBzdGFydFxuXG4gIC8vIHRyZWF0IGVuZCBvZiB0aGUgbGluZSBhcyBhIHdoaXRlc3BhY2VcbiAgY29uc3QgbmV4dENoYXIgPSBwb3MgPCBtYXggPyB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgOiAweDIwXG5cbiAgY29uc3QgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKVxuICBjb25zdCBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpXG5cbiAgY29uc3QgaXNMYXN0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShsYXN0Q2hhcilcbiAgY29uc3QgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcilcblxuICBjb25zdCBsZWZ0X2ZsYW5raW5nID1cbiAgICAhaXNOZXh0V2hpdGVTcGFjZSAmJiAoIWlzTmV4dFB1bmN0Q2hhciB8fCBpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcilcbiAgY29uc3QgcmlnaHRfZmxhbmtpbmcgPVxuICAgICFpc0xhc3RXaGl0ZVNwYWNlICYmICghaXNMYXN0UHVuY3RDaGFyIHx8IGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKVxuXG4gIGNvbnN0IGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmIChjYW5TcGxpdFdvcmQgfHwgIXJpZ2h0X2ZsYW5raW5nIHx8IGlzTGFzdFB1bmN0Q2hhcilcbiAgY29uc3QgY2FuX2Nsb3NlID0gcmlnaHRfZmxhbmtpbmcgJiYgKGNhblNwbGl0V29yZCB8fCAhbGVmdF9mbGFua2luZyAgfHwgaXNOZXh0UHVuY3RDaGFyKVxuXG4gIHJldHVybiB7IGNhbl9vcGVuLCBjYW5fY2xvc2UsIGxlbmd0aDogY291bnQgfVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUlubGluZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlblxuXG5leHBvcnQgZGVmYXVsdCBTdGF0ZUlubGluZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/state_inline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/strikethrough.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/strikethrough.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// ~~strike through~~\n//\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nfunction strikethrough_tokenize (state, silent) {\n  const start = state.pos\n  const marker = state.src.charCodeAt(start)\n\n  if (silent) { return false }\n\n  if (marker !== 0x7E/* ~ */) { return false }\n\n  const scanned = state.scanDelims(state.pos, true)\n  let len = scanned.length\n  const ch = String.fromCharCode(marker)\n\n  if (len < 2) { return false }\n\n  let token\n\n  if (len % 2) {\n    token         = state.push('text', '', 0)\n    token.content = ch\n    len--\n  }\n\n  for (let i = 0; i < len; i += 2) {\n    token         = state.push('text', '', 0)\n    token.content = ch + ch\n\n    state.delimiters.push({\n      marker,\n      length: 0,     // disable \"rule of 3\" length checks meant for emphasis\n      token: state.tokens.length - 1,\n      end: -1,\n      open: scanned.can_open,\n      close: scanned.can_close\n    })\n  }\n\n  state.pos += scanned.length\n\n  return true\n}\n\nfunction postProcess (state, delimiters) {\n  let token\n  const loneMarkers = []\n  const max = delimiters.length\n\n  for (let i = 0; i < max; i++) {\n    const startDelim = delimiters[i]\n\n    if (startDelim.marker !== 0x7E/* ~ */) {\n      continue\n    }\n\n    if (startDelim.end === -1) {\n      continue\n    }\n\n    const endDelim = delimiters[startDelim.end]\n\n    token         = state.tokens[startDelim.token]\n    token.type    = 's_open'\n    token.tag     = 's'\n    token.nesting = 1\n    token.markup  = '~~'\n    token.content = ''\n\n    token         = state.tokens[endDelim.token]\n    token.type    = 's_close'\n    token.tag     = 's'\n    token.nesting = -1\n    token.markup  = '~~'\n    token.content = ''\n\n    if (state.tokens[endDelim.token - 1].type === 'text' &&\n        state.tokens[endDelim.token - 1].content === '~') {\n      loneMarkers.push(endDelim.token - 1)\n    }\n  }\n\n  // If a marker sequence has an odd number of characters, it's splitted\n  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the\n  // start of the sequence.\n  //\n  // So, we have to move all those markers after subsequent s_close tags.\n  //\n  while (loneMarkers.length) {\n    const i = loneMarkers.pop()\n    let j = i + 1\n\n    while (j < state.tokens.length && state.tokens[j].type === 's_close') {\n      j++\n    }\n\n    j--\n\n    if (i !== j) {\n      token = state.tokens[j]\n      state.tokens[j] = state.tokens[i]\n      state.tokens[i] = token\n    }\n  }\n}\n\n// Walk through delimiter list and replace text tokens with tags\n//\nfunction strikethrough_postProcess (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  postProcess(state, state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters)\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  tokenize: strikethrough_tokenize,\n  postProcess: strikethrough_postProcess\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gubWpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQixnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5tanM/NWVjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5mdW5jdGlvbiBzdHJpa2V0aHJvdWdoX3Rva2VuaXplIChzdGF0ZSwgc2lsZW50KSB7XG4gIGNvbnN0IHN0YXJ0ID0gc3RhdGUucG9zXG4gIGNvbnN0IG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXJ0KVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLykgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGNvbnN0IHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgdHJ1ZSlcbiAgbGV0IGxlbiA9IHNjYW5uZWQubGVuZ3RoXG4gIGNvbnN0IGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpXG5cbiAgaWYgKGxlbiA8IDIpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBsZXQgdG9rZW5cblxuICBpZiAobGVuICUgMikge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApXG4gICAgdG9rZW4uY29udGVudCA9IGNoXG4gICAgbGVuLS1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgndGV4dCcsICcnLCAwKVxuICAgIHRva2VuLmNvbnRlbnQgPSBjaCArIGNoXG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyLFxuICAgICAgbGVuZ3RoOiAwLCAgICAgLy8gZGlzYWJsZSBcInJ1bGUgb2YgM1wiIGxlbmd0aCBjaGVja3MgbWVhbnQgZm9yIGVtcGhhc2lzXG4gICAgICB0b2tlbjogc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBlbmQ6IC0xLFxuICAgICAgb3Blbjogc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pXG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGhcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyAoc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgbGV0IHRva2VuXG4gIGNvbnN0IGxvbmVNYXJrZXJzID0gW11cbiAgY29uc3QgbWF4ID0gZGVsaW1pdGVycy5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgY29uc3Qgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV1cblxuICAgIGlmIChzdGFydERlbGltLm1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdXG5cbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUudG9rZW5zW3N0YXJ0RGVsaW0udG9rZW5dXG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nXG4gICAgdG9rZW4udGFnICAgICA9ICdzJ1xuICAgIHRva2VuLm5lc3RpbmcgPSAxXG4gICAgdG9rZW4ubWFya3VwICA9ICd+fidcbiAgICB0b2tlbi5jb250ZW50ID0gJydcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW5dXG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJ1xuICAgIHRva2VuLnRhZyAgICAgPSAncydcbiAgICB0b2tlbi5uZXN0aW5nID0gLTFcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+J1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJ1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgICAgICBzdGF0ZS50b2tlbnNbZW5kRGVsaW0udG9rZW4gLSAxXS5jb250ZW50ID09PSAnficpIHtcbiAgICAgIGxvbmVNYXJrZXJzLnB1c2goZW5kRGVsaW0udG9rZW4gLSAxKVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGEgbWFya2VyIHNlcXVlbmNlIGhhcyBhbiBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGl0J3Mgc3BsaXR0ZWRcbiAgLy8gbGlrZSB0aGlzOiBgfn5+fn5gIC0+IGB+YCArIGB+fmAgKyBgfn5gLCBsZWF2aW5nIG9uZSBtYXJrZXIgYXQgdGhlXG4gIC8vIHN0YXJ0IG9mIHRoZSBzZXF1ZW5jZS5cbiAgLy9cbiAgLy8gU28sIHdlIGhhdmUgdG8gbW92ZSBhbGwgdGhvc2UgbWFya2VycyBhZnRlciBzdWJzZXF1ZW50IHNfY2xvc2UgdGFncy5cbiAgLy9cbiAgd2hpbGUgKGxvbmVNYXJrZXJzLmxlbmd0aCkge1xuICAgIGNvbnN0IGkgPSBsb25lTWFya2Vycy5wb3AoKVxuICAgIGxldCBqID0gaSArIDFcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKytcbiAgICB9XG5cbiAgICBqLS1cblxuICAgIGlmIChpICE9PSBqKSB7XG4gICAgICB0b2tlbiA9IHN0YXRlLnRva2Vuc1tqXVxuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldXG4gICAgICBzdGF0ZS50b2tlbnNbaV0gPSB0b2tlblxuICAgIH1cbiAgfVxufVxuXG4vLyBXYWxrIHRocm91Z2ggZGVsaW1pdGVyIGxpc3QgYW5kIHJlcGxhY2UgdGV4dCB0b2tlbnMgd2l0aCB0YWdzXG4vL1xuZnVuY3Rpb24gc3RyaWtldGhyb3VnaF9wb3N0UHJvY2VzcyAoc3RhdGUpIHtcbiAgY29uc3QgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YVxuICBjb25zdCBtYXggPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGhcblxuICBwb3N0UHJvY2VzcyhzdGF0ZSwgc3RhdGUuZGVsaW1pdGVycylcblxuICBmb3IgKGxldCBjdXJyID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgIHBvc3RQcm9jZXNzKHN0YXRlLCB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHRva2VuaXplOiBzdHJpa2V0aHJvdWdoX3Rva2VuaXplLFxuICBwb3N0UHJvY2Vzczogc3RyaWtldGhyb3VnaF9wb3N0UHJvY2Vzc1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/strikethrough.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/text.mjs":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ text; }\n/* harmony export */ });\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar (ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\nfunction text (state, silent) {\n  let pos = state.pos\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++\n  }\n\n  if (pos === state.pos) { return false }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos) }\n\n  state.pos = pos\n\n  return true\n}\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParserInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n}; */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixvREFBb0Qsb0NBQW9DLE1BQU07O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0IsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjs7QUFFQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dC5tanM/OTUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTa2lwIHRleHQgY2hhcmFjdGVycyBmb3IgdGV4dCB0b2tlbiwgcGxhY2UgdGhvc2UgdG8gcGVuZGluZyBidWZmZXJcbi8vIGFuZCBpbmNyZW1lbnQgY3VycmVudCBwb3NcblxuLy8gUnVsZSB0byBza2lwIHB1cmUgdGV4dFxuLy8gJ3t9JCVAfis9OicgcmVzZXJ2ZWQgZm9yIGV4dGVudGlvbnNcblxuLy8gISwgXCIsICMsICQsICUsICYsICcsICgsICksICosICssICwsIC0sIC4sIC8sIDosIDssIDwsID0sID4sID8sIEAsIFssIFxcLCBdLCBeLCBfLCBgLCB7LCB8LCB9LCBvciB+XG5cbi8vICEhISEgRG9uJ3QgY29uZnVzZSB3aXRoIFwiTWFya2Rvd24gQVNDSUkgUHVuY3R1YXRpb25cIiBjaGFyc1xuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JDaGFyIChjaCkge1xuICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAweDBBLyogXFxuICovOlxuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHg0MC8qIEAgKi86XG4gICAgY2FzZSAweDVCLyogWyAqLzpcbiAgICBjYXNlIDB4NUMvKiBcXCAqLzpcbiAgICBjYXNlIDB4NUQvKiBdICovOlxuICAgIGNhc2UgMHg1RS8qIF4gKi86XG4gICAgY2FzZSAweDVGLyogXyAqLzpcbiAgICBjYXNlIDB4NjAvKiBgICovOlxuICAgIGNhc2UgMHg3Qi8qIHsgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGV4dCAoc3RhdGUsIHNpbGVudCkge1xuICBsZXQgcG9zID0gc3RhdGUucG9zXG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLnBvc01heCAmJiAhaXNUZXJtaW5hdG9yQ2hhcihzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpKSkge1xuICAgIHBvcysrXG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShzdGF0ZS5wb3MsIHBvcykgfVxuXG4gIHN0YXRlLnBvcyA9IHBvc1xuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIEFsdGVybmF0aXZlIGltcGxlbWVudGF0aW9uLCBmb3IgbWVtb3J5LlxuLy9cbi8vIEl0IGNvc3RzIDEwJSBvZiBwZXJmb3JtYW5jZSwgYnV0IGFsbG93cyBleHRlbmQgdGVybWluYXRvcnMgbGlzdCwgaWYgcGxhY2UgaXRcbi8vIHRvIGBQYXJzZXJJbmxpbmVgIHByb3BlcnR5LiBQcm9iYWJseSwgd2lsbCBzd2l0Y2ggdG8gaXQgc29tZXRpbWUsIHN1Y2hcbi8vIGZsZXhpYmlsaXR5IHJlcXVpcmVkLlxuXG4vKlxudmFyIFRFUk1JTkFUT1JfUkUgPSAvW1xcbiEjJCUmKitcXC06PD0+QFtcXFxcXFxdXl9ge31+XS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBpZHggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5zZWFyY2goVEVSTUlOQVRPUl9SRSk7XG5cbiAgLy8gZmlyc3QgY2hhciBpcyB0ZXJtaW5hdG9yIC0+IGVtcHR5IHRleHRcbiAgaWYgKGlkeCA9PT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBubyB0ZXJtaW5hdG9yIC0+IHRleHQgdGlsbCBlbmQgb2Ygc3RyaW5nXG4gIGlmIChpZHggPCAwKSB7XG4gICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2UocG9zKTsgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnNyYy5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIGlkeCk7IH1cblxuICBzdGF0ZS5wb3MgKz0gaWR4O1xuXG4gIHJldHVybiB0cnVlO1xufTsgKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/rules_inline/text.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-it/lib/token.mjs":
/*!************************************************!*\
  !*** ./node_modules/markdown-it/lib/token.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Token class\n\n/**\n * class Token\n **/\n\n/**\n * new Token(type, tag, nesting)\n *\n * Create new token and fill passed properties.\n **/\nfunction Token (type, tag, nesting) {\n  /**\n   * Token#type -> String\n   *\n   * Type of the token (string, e.g. \"paragraph_open\")\n   **/\n  this.type     = type\n\n  /**\n   * Token#tag -> String\n   *\n   * html tag name, e.g. \"p\"\n   **/\n  this.tag      = tag\n\n  /**\n   * Token#attrs -> Array\n   *\n   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`\n   **/\n  this.attrs    = null\n\n  /**\n   * Token#map -> Array\n   *\n   * Source map info. Format: `[ line_begin, line_end ]`\n   **/\n  this.map      = null\n\n  /**\n   * Token#nesting -> Number\n   *\n   * Level change (number in {-1, 0, 1} set), where:\n   *\n   * -  `1` means the tag is opening\n   * -  `0` means the tag is self-closing\n   * - `-1` means the tag is closing\n   **/\n  this.nesting  = nesting\n\n  /**\n   * Token#level -> Number\n   *\n   * nesting level, the same as `state.level`\n   **/\n  this.level    = 0\n\n  /**\n   * Token#children -> Array\n   *\n   * An array of child nodes (inline and img tokens)\n   **/\n  this.children = null\n\n  /**\n   * Token#content -> String\n   *\n   * In a case of self-closing tag (code, html, fence, etc.),\n   * it has contents of this tag.\n   **/\n  this.content  = ''\n\n  /**\n   * Token#markup -> String\n   *\n   * '*' or '_' for emphasis, fence string for fence, etc.\n   **/\n  this.markup   = ''\n\n  /**\n   * Token#info -> String\n   *\n   * Additional information:\n   *\n   * - Info string for \"fence\" tokens\n   * - The value \"auto\" for autolink \"link_open\" and \"link_close\" tokens\n   * - The string value of the item marker for ordered-list \"list_item_open\" tokens\n   **/\n  this.info     = ''\n\n  /**\n   * Token#meta -> Object\n   *\n   * A place for plugins to store an arbitrary data\n   **/\n  this.meta     = null\n\n  /**\n   * Token#block -> Boolean\n   *\n   * True for block-level tokens, false for inline tokens.\n   * Used in renderer to calculate line breaks\n   **/\n  this.block    = false\n\n  /**\n   * Token#hidden -> Boolean\n   *\n   * If it's true, ignore this element when rendering. Used for tight lists\n   * to hide paragraphs.\n   **/\n  this.hidden   = false\n}\n\n/**\n * Token.attrIndex(name) -> Number\n *\n * Search attribute index by name.\n **/\nToken.prototype.attrIndex = function attrIndex (name) {\n  if (!this.attrs) { return -1 }\n\n  const attrs = this.attrs\n\n  for (let i = 0, len = attrs.length; i < len; i++) {\n    if (attrs[i][0] === name) { return i }\n  }\n  return -1\n}\n\n/**\n * Token.attrPush(attrData)\n *\n * Add `[ name, value ]` attribute to list. Init attrs if necessary\n **/\nToken.prototype.attrPush = function attrPush (attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData)\n  } else {\n    this.attrs = [attrData]\n  }\n}\n\n/**\n * Token.attrSet(name, value)\n *\n * Set `name` attribute to `value`. Override old value if exists.\n **/\nToken.prototype.attrSet = function attrSet (name, value) {\n  const idx = this.attrIndex(name)\n  const attrData = [name, value]\n\n  if (idx < 0) {\n    this.attrPush(attrData)\n  } else {\n    this.attrs[idx] = attrData\n  }\n}\n\n/**\n * Token.attrGet(name)\n *\n * Get the value of attribute `name`, or null if it does not exist.\n **/\nToken.prototype.attrGet = function attrGet (name) {\n  const idx = this.attrIndex(name)\n  let value = null\n  if (idx >= 0) {\n    value = this.attrs[idx][1]\n  }\n  return value\n}\n\n/**\n * Token.attrJoin(name, value)\n *\n * Join value to existing attribute via space. Or create new attribute if not\n * exists. Useful to operate with token classes.\n **/\nToken.prototype.attrJoin = function attrJoin (name, value) {\n  const idx = this.attrIndex(name)\n\n  if (idx < 0) {\n    this.attrPush([name, value])\n  } else {\n    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Token);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvdG9rZW4ubWpzIiwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBLHNDQUFzQyxTQUFTO0FBQy9DLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLCtEQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5tanM/ZTcwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUb2tlbiBjbGFzc1xuXG4vKipcbiAqIGNsYXNzIFRva2VuXG4gKiovXG5cbi8qKlxuICogbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZylcbiAqXG4gKiBDcmVhdGUgbmV3IHRva2VuIGFuZCBmaWxsIHBhc3NlZCBwcm9wZXJ0aWVzLlxuICoqL1xuZnVuY3Rpb24gVG9rZW4gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGVcblxuICAvKipcbiAgICogVG9rZW4jdGFnIC0+IFN0cmluZ1xuICAgKlxuICAgKiBodG1sIHRhZyBuYW1lLCBlLmcuIFwicFwiXG4gICAqKi9cbiAgdGhpcy50YWcgICAgICA9IHRhZ1xuXG4gIC8qKlxuICAgKiBUb2tlbiNhdHRycyAtPiBBcnJheVxuICAgKlxuICAgKiBIdG1sIGF0dHJpYnV0ZXMuIEZvcm1hdDogYFsgWyBuYW1lMSwgdmFsdWUxIF0sIFsgbmFtZTIsIHZhbHVlMiBdIF1gXG4gICAqKi9cbiAgdGhpcy5hdHRycyAgICA9IG51bGxcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsXG5cbiAgLyoqXG4gICAqIFRva2VuI25lc3RpbmcgLT4gTnVtYmVyXG4gICAqXG4gICAqIExldmVsIGNoYW5nZSAobnVtYmVyIGluIHstMSwgMCwgMX0gc2V0KSwgd2hlcmU6XG4gICAqXG4gICAqIC0gIGAxYCBtZWFucyB0aGUgdGFnIGlzIG9wZW5pbmdcbiAgICogLSAgYDBgIG1lYW5zIHRoZSB0YWcgaXMgc2VsZi1jbG9zaW5nXG4gICAqIC0gYC0xYCBtZWFucyB0aGUgdGFnIGlzIGNsb3NpbmdcbiAgICoqL1xuICB0aGlzLm5lc3RpbmcgID0gbmVzdGluZ1xuXG4gIC8qKlxuICAgKiBUb2tlbiNsZXZlbCAtPiBOdW1iZXJcbiAgICpcbiAgICogbmVzdGluZyBsZXZlbCwgdGhlIHNhbWUgYXMgYHN0YXRlLmxldmVsYFxuICAgKiovXG4gIHRoaXMubGV2ZWwgICAgPSAwXG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGxcblxuICAvKipcbiAgICogVG9rZW4jY29udGVudCAtPiBTdHJpbmdcbiAgICpcbiAgICogSW4gYSBjYXNlIG9mIHNlbGYtY2xvc2luZyB0YWcgKGNvZGUsIGh0bWwsIGZlbmNlLCBldGMuKSxcbiAgICogaXQgaGFzIGNvbnRlbnRzIG9mIHRoaXMgdGFnLlxuICAgKiovXG4gIHRoaXMuY29udGVudCAgPSAnJ1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtYXJrdXAgLT4gU3RyaW5nXG4gICAqXG4gICAqICcqJyBvciAnXycgZm9yIGVtcGhhc2lzLCBmZW5jZSBzdHJpbmcgZm9yIGZlbmNlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5tYXJrdXAgICA9ICcnXG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb246XG4gICAqXG4gICAqIC0gSW5mbyBzdHJpbmcgZm9yIFwiZmVuY2VcIiB0b2tlbnNcbiAgICogLSBUaGUgdmFsdWUgXCJhdXRvXCIgZm9yIGF1dG9saW5rIFwibGlua19vcGVuXCIgYW5kIFwibGlua19jbG9zZVwiIHRva2Vuc1xuICAgKiAtIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGl0ZW0gbWFya2VyIGZvciBvcmRlcmVkLWxpc3QgXCJsaXN0X2l0ZW1fb3BlblwiIHRva2Vuc1xuICAgKiovXG4gIHRoaXMuaW5mbyAgICAgPSAnJ1xuXG4gIC8qKlxuICAgKiBUb2tlbiNtZXRhIC0+IE9iamVjdFxuICAgKlxuICAgKiBBIHBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIGFuIGFyYml0cmFyeSBkYXRhXG4gICAqKi9cbiAgdGhpcy5tZXRhICAgICA9IG51bGxcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBUb2tlbiNoaWRkZW4gLT4gQm9vbGVhblxuICAgKlxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXG4gICAqIHRvIGhpZGUgcGFyYWdyYXBocy5cbiAgICoqL1xuICB0aGlzLmhpZGRlbiAgID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBUb2tlbi5hdHRySW5kZXgobmFtZSkgLT4gTnVtYmVyXG4gKlxuICogU2VhcmNoIGF0dHJpYnV0ZSBpbmRleCBieSBuYW1lLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleCAobmFtZSkge1xuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xIH1cblxuICBjb25zdCBhdHRycyA9IHRoaXMuYXR0cnNcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoIChhdHRyRGF0YSkge1xuICBpZiAodGhpcy5hdHRycykge1xuICAgIHRoaXMuYXR0cnMucHVzaChhdHRyRGF0YSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gW2F0dHJEYXRhXVxuICB9XG59XG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0IChuYW1lLCB2YWx1ZSkge1xuICBjb25zdCBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKVxuICBjb25zdCBhdHRyRGF0YSA9IFtuYW1lLCB2YWx1ZV1cblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goYXR0ckRhdGEpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGFcbiAgfVxufVxuXG4vKipcbiAqIFRva2VuLmF0dHJHZXQobmFtZSlcbiAqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBgbmFtZWAsIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckdldCA9IGZ1bmN0aW9uIGF0dHJHZXQgKG5hbWUpIHtcbiAgY29uc3QgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSlcbiAgbGV0IHZhbHVlID0gbnVsbFxuICBpZiAoaWR4ID49IDApIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXR0cnNbaWR4XVsxXVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIFRva2VuLmF0dHJKb2luKG5hbWUsIHZhbHVlKVxuICpcbiAqIEpvaW4gdmFsdWUgdG8gZXhpc3RpbmcgYXR0cmlidXRlIHZpYSBzcGFjZS4gT3IgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgaWYgbm90XG4gKiBleGlzdHMuIFVzZWZ1bCB0byBvcGVyYXRlIHdpdGggdG9rZW4gY2xhc3Nlcy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luIChuYW1lLCB2YWx1ZSkge1xuICBjb25zdCBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKVxuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChbbmFtZSwgdmFsdWVdKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnNbaWR4XVsxXSA9IHRoaXMuYXR0cnNbaWR4XVsxXSArICcgJyArIHZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9rZW5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-it/lib/token.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdurl/index.mjs":
/*!**************************************!*\
  !*** ./node_modules/mdurl/index.mjs ***!
  \**************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* reexport safe */ _lib_decode_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   encode: function() { return /* reexport safe */ _lib_encode_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   format: function() { return /* reexport safe */ _lib_format_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   parse: function() { return /* reexport safe */ _lib_parse_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _lib_decode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/decode.mjs */ \"(app-pages-browser)/./node_modules/mdurl/lib/decode.mjs\");\n/* harmony import */ var _lib_encode_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/encode.mjs */ \"(app-pages-browser)/./node_modules/mdurl/lib/encode.mjs\");\n/* harmony import */ var _lib_format_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/format.mjs */ \"(app-pages-browser)/./node_modules/mdurl/lib/format.mjs\");\n/* harmony import */ var _lib_parse_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/parse.mjs */ \"(app-pages-browser)/./node_modules/mdurl/lib/parse.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBcUM7QUFDQTtBQUNBO0FBQ0Y7O0FBT2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5tanM/YjBiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVjb2RlIGZyb20gJy4vbGliL2RlY29kZS5tanMnXG5pbXBvcnQgZW5jb2RlIGZyb20gJy4vbGliL2VuY29kZS5tanMnXG5pbXBvcnQgZm9ybWF0IGZyb20gJy4vbGliL2Zvcm1hdC5tanMnXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9saWIvcGFyc2UubWpzJ1xuXG5leHBvcnQge1xuICBkZWNvZGUsXG4gIGVuY29kZSxcbiAgZm9ybWF0LFxuICBwYXJzZVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdurl/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdurl/lib/decode.mjs":
/*!*******************************************!*\
  !*** ./node_modules/mdurl/lib/decode.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* eslint-disable no-bitwise */\n\nconst decodeCache = {}\n\nfunction getDecodeCache (exclude) {\n  let cache = decodeCache[exclude]\n  if (cache) { return cache }\n\n  cache = decodeCache[exclude] = []\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i)\n    cache.push(ch)\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    const ch = exclude.charCodeAt(i)\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2)\n  }\n\n  return cache\n}\n\n// Decode percent-encoded string.\n//\nfunction decode (string, exclude) {\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars\n  }\n\n  const cache = getDecodeCache(exclude)\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n    let result = ''\n\n    for (let i = 0, l = seq.length; i < l; i += 3) {\n      const b1 = parseInt(seq.slice(i + 1, i + 3), 16)\n\n      if (b1 < 0x80) {\n        result += cache[b1]\n        continue\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)\n\n        if ((b2 & 0xC0) === 0x80) {\n          const chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F)\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd'\n          } else {\n            result += String.fromCharCode(chr)\n          }\n\n          i += 3\n          continue\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16)\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          const chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F)\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd'\n          } else {\n            result += String.fromCharCode(chr)\n          }\n\n          i += 6\n          continue\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16)\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16)\n        const b4 = parseInt(seq.slice(i + 10, i + 12), 16)\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          let chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F)\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd'\n          } else {\n            chr -= 0x10000\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF))\n          }\n\n          i += 9\n          continue\n        }\n      }\n\n      result += '\\ufffd'\n    }\n\n    return result\n  })\n}\n\ndecode.defaultChars = ';/?:@&=+$,#'\ndecode.componentChars = ''\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (decode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZHVybC9saWIvZGVjb2RlLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQyxFQUFFO0FBQ3RDOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUEsK0RBQWUsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWR1cmwvbGliL2RlY29kZS5tanM/MmFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNvbnN0IGRlY29kZUNhY2hlID0ge31cblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUgKGV4Y2x1ZGUpIHtcbiAgbGV0IGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV1cbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZSB9XG5cbiAgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXSA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNvbnN0IGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxuICAgIGNhY2hlLnB1c2goY2gpXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKVxuICAgIGNhY2hlW2NoXSA9ICclJyArICgnMCcgKyBjaC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpXG4gIH1cblxuICByZXR1cm4gY2FjaGVcbn1cblxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXG4vL1xuZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcsIGV4Y2x1ZGUpIHtcbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzXG4gIH1cblxuICBjb25zdCBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpXG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8oJVthLWYwLTldezJ9KSsvZ2ksIGZ1bmN0aW9uIChzZXEpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgY29uc3QgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpXG5cbiAgICAgIGlmIChiMSA8IDB4ODApIHtcbiAgICAgICAgcmVzdWx0ICs9IGNhY2hlW2IxXVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgY29uc3QgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpXG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgY29uc3QgY2hyID0gKChiMSA8PCA2KSAmIDB4N0MwKSB8IChiMiAmIDB4M0YpXG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZCdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gM1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGNvbnN0IGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KVxuICAgICAgICBjb25zdCBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNilcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjb25zdCBjaHIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRilcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDZcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEY4KSA9PT0gMHhGMCAmJiAoaSArIDkgPCBsKSkge1xuICAgICAgICAvLyAxMTExMTB4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBjb25zdCBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNilcbiAgICAgICAgY29uc3QgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpXG4gICAgICAgIGNvbnN0IGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpXG5cbiAgICAgICAgaWYgKChiMiAmIDB4QzApID09PSAweDgwICYmIChiMyAmIDB4QzApID09PSAweDgwICYmIChiNCAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgbGV0IGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKVxuXG4gICAgICAgICAgaWYgKGNociA8IDB4MTAwMDAgfHwgY2hyID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkXFx1ZmZmZCdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyIC09IDB4MTAwMDBcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gOVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJ1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxuZGVjb2RlLmRlZmF1bHRDaGFycyA9ICc7Lz86QCY9KyQsIydcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnXG5cbmV4cG9ydCBkZWZhdWx0IGRlY29kZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdurl/lib/decode.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdurl/lib/encode.mjs":
/*!*******************************************!*\
  !*** ./node_modules/mdurl/lib/encode.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst encodeCache = {}\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache (exclude) {\n  let cache = encodeCache[exclude]\n  if (cache) { return cache }\n\n  cache = encodeCache[exclude] = []\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i)\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch)\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2))\n    }\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i]\n  }\n\n  return cache\n}\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode (string, exclude, keepEscaped) {\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude\n    exclude = encode.defaultChars\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true\n  }\n\n  const cache = getEncodeCache(exclude)\n  let result = ''\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const code = string.charCodeAt(i)\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3)\n        i += 2\n        continue\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code]\n      continue\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        const nextCode = string.charCodeAt(i + 1)\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1])\n          i++\n          continue\n        }\n      }\n      result += '%EF%BF%BD'\n      continue\n    }\n\n    result += encodeURIComponent(string[i])\n  }\n\n  return result\n}\n\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\"\nencode.componentChars = \"-_.!~*'()\"\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (encode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZHVybC9saWIvZW5jb2RlLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1Qzs7QUFFQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7O0FBRUEsK0RBQWUsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWR1cmwvbGliL2VuY29kZS5tanM/ODIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBlbmNvZGVDYWNoZSA9IHt9XG5cbi8vIENyZWF0ZSBhIGxvb2t1cCBhcnJheSB3aGVyZSBhbnl0aGluZyBidXQgY2hhcmFjdGVycyBpbiBgY2hhcnNgIHN0cmluZ1xuLy8gYW5kIGFscGhhbnVtZXJpYyBjaGFycyBpcyBwZXJjZW50LWVuY29kZWQuXG4vL1xuZnVuY3Rpb24gZ2V0RW5jb2RlQ2FjaGUgKGV4Y2x1ZGUpIHtcbiAgbGV0IGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV1cbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZSB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNvbnN0IGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxuXG4gICAgaWYgKC9eWzAtOWEtel0kL2kudGVzdChjaCkpIHtcbiAgICAgIC8vIGFsd2F5cyBhbGxvdyB1bmVuY29kZWQgYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgIGNhY2hlLnB1c2goY2gpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSlcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXVxuICB9XG5cbiAgcmV0dXJuIGNhY2hlXG59XG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUgKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkID0gZXhjbHVkZVxuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzXG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZVxuICB9XG5cbiAgY29uc3QgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKVxuICBsZXQgcmVzdWx0ID0gJydcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XG4gICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKVxuICAgICAgICBpICs9IDJcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKVxuICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSlcbiAgICAgICAgICBpKytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyVFRiVCRiVCRCdcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgPSBcIjsvPzpAJj0rJCwtXy4hfionKCkjXCJcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCJcblxuZXhwb3J0IGRlZmF1bHQgZW5jb2RlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdurl/lib/encode.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdurl/lib/format.mjs":
/*!*******************************************!*\
  !*** ./node_modules/mdurl/lib/format.mjs ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ format; }\n/* harmony export */ });\nfunction format (url) {\n  let result = ''\n\n  result += url.protocol || ''\n  result += url.slashes ? '//' : ''\n  result += url.auth ? url.auth + '@' : ''\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']'\n  } else {\n    result += url.hostname || ''\n  }\n\n  result += url.port ? ':' + url.port : ''\n  result += url.pathname || ''\n  result += url.search || ''\n  result += url.hash || ''\n\n  return result\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZHVybC9saWIvZm9ybWF0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWR1cmwvbGliL2Zvcm1hdC5tanM/NGFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQgKHVybCkge1xuICBsZXQgcmVzdWx0ID0gJydcblxuICByZXN1bHQgKz0gdXJsLnByb3RvY29sIHx8ICcnXG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJ1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnXG5cbiAgaWYgKHVybC5ob3N0bmFtZSAmJiB1cmwuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIC8vIGlwdjYgYWRkcmVzc1xuICAgIHJlc3VsdCArPSAnWycgKyB1cmwuaG9zdG5hbWUgKyAnXSdcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnXG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnXG4gIHJlc3VsdCArPSB1cmwucGF0aG5hbWUgfHwgJydcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJydcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnXG5cbiAgcmV0dXJuIHJlc3VsdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdurl/lib/format.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdurl/lib/parse.mjs":
/*!******************************************!*\
  !*** ./node_modules/mdurl/lib/parse.mjs ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\nfunction Url () {\n  this.protocol = null\n  this.slashes = null\n  this.auth = null\n  this.port = null\n  this.hostname = null\n  this.hash = null\n  this.search = null\n  this.pathname = null\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i\nconst portPattern = /:[0-9]*$/\n\n// Special case for a simple path URL\n/* eslint-disable-next-line no-useless-escape */\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t']\n\n// RFC 2396: characters not allowed for various reasons.\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims)\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nconst autoEscape = ['\\''].concat(unwise)\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape)\nconst hostEndingChars = ['/', '?', '#']\nconst hostnameMaxLen = 255\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n}\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n}\n\nfunction urlParse (url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url\n\n  const u = new Url()\n  u.parse(url, slashesDenoteHost)\n  return u\n}\n\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes\n  let rest = url\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim()\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest)\n    if (simplePath) {\n      this.pathname = simplePath[1]\n      if (simplePath[2]) {\n        this.search = simplePath[2]\n      }\n      return this\n    }\n  }\n\n  let proto = protocolPattern.exec(rest)\n  if (proto) {\n    proto = proto[0]\n    lowerProto = proto.toLowerCase()\n    this.protocol = proto\n    rest = rest.substr(proto.length)\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  /* eslint-disable-next-line no-useless-escape */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//'\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2)\n      this.slashes = true\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i])\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    let auth, atSign\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@')\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd)\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign)\n      rest = rest.slice(atSign + 1)\n      this.auth = auth\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i])\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd-- }\n    const host = rest.slice(0, hostEnd)\n    rest = rest.slice(hostEnd)\n\n    // pull out port.\n    this.parseHost(host)\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || ''\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']'\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./)\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i]\n        if (!part) { continue }\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = ''\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x'\n            } else {\n              newpart += part[j]\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i)\n            const notHost = hostparts.slice(i + 1)\n            const bit = part.match(hostnamePartStart)\n            if (bit) {\n              validParts.push(bit[1])\n              notHost.unshift(bit[2])\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest\n            }\n            this.hostname = validParts.join('.')\n            break\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = ''\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2)\n    }\n  }\n\n  // chop off from the tail first.\n  const hash = rest.indexOf('#')\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash)\n    rest = rest.slice(0, hash)\n  }\n  const qm = rest.indexOf('?')\n  if (qm !== -1) {\n    this.search = rest.substr(qm)\n    rest = rest.slice(0, qm)\n  }\n  if (rest) { this.pathname = rest }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = ''\n  }\n\n  return this\n}\n\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host)\n  if (port) {\n    port = port[0]\n    if (port !== ':') {\n      this.port = port.substr(1)\n    }\n    host = host.substr(0, host.length - port.length)\n  }\n  if (host) { this.hostname = host }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (urlParse);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZHVybC9saWIvcGFyc2UubWpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixLQUFLOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xELDRDQUE0QyxLQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQSwrREFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZHVybC9saWIvcGFyc2UubWpzPzZhZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuZnVuY3Rpb24gVXJsICgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGxcbiAgdGhpcy5zbGFzaGVzID0gbnVsbFxuICB0aGlzLmF1dGggPSBudWxsXG4gIHRoaXMucG9ydCA9IG51bGxcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGxcbiAgdGhpcy5oYXNoID0gbnVsbFxuICB0aGlzLnNlYXJjaCA9IG51bGxcbiAgdGhpcy5wYXRobmFtZSA9IG51bGxcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbmNvbnN0IHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2lcbmNvbnN0IHBvcnRQYXR0ZXJuID0gLzpbMC05XSokL1xuXG4vLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbmNvbnN0IHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kL1xuXG4vLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbmNvbnN0IGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddXG5cbi8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG5jb25zdCB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcylcblxuLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuY29uc3QgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSlcbi8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4vLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4vLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbi8vIHRoZW0uXG5jb25zdCBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKVxuY29uc3QgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddXG5jb25zdCBob3N0bmFtZU1heExlbiA9IDI1NVxuY29uc3QgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kL1xuY29uc3QgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC9cbi8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuY29uc3QgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgamF2YXNjcmlwdDogdHJ1ZSxcbiAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxufVxuLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gIGh0dHA6IHRydWUsXG4gIGh0dHBzOiB0cnVlLFxuICBmdHA6IHRydWUsXG4gIGdvcGhlcjogdHJ1ZSxcbiAgZmlsZTogdHJ1ZSxcbiAgJ2h0dHA6JzogdHJ1ZSxcbiAgJ2h0dHBzOic6IHRydWUsXG4gICdmdHA6JzogdHJ1ZSxcbiAgJ2dvcGhlcjonOiB0cnVlLFxuICAnZmlsZTonOiB0cnVlXG59XG5cbmZ1bmN0aW9uIHVybFBhcnNlICh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsXG5cbiAgY29uc3QgdSA9IG5ldyBVcmwoKVxuICB1LnBhcnNlKHVybCwgc2xhc2hlc0Rlbm90ZUhvc3QpXG4gIHJldHVybiB1XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBsZXQgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzXG4gIGxldCByZXN0ID0gdXJsXG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKClcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgY29uc3Qgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdClcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV1cbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cblxuICBsZXQgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KVxuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdXG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKClcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9cbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKVxuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nXG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKVxuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgbGV0IGhvc3RFbmQgPSAtMVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKVxuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWNcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICBsZXQgYXV0aCwgYXRTaWduXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZClcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pXG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKVxuICAgICAgdGhpcy5hdXRoID0gYXV0aFxuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSlcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICBob3N0RW5kID0gaGVjXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aFxuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLSB9XG4gICAgY29uc3QgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZClcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdChob3N0KVxuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnXG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIGNvbnN0IGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJ1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIGNvbnN0IGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pXG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFydCA9IGhvc3RwYXJ0c1tpXVxuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWUgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICBsZXQgbmV3cGFydCA9ICcnXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKVxuICAgICAgICAgICAgY29uc3Qgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSlcbiAgICAgICAgICAgIGNvbnN0IGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpXG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pXG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJydcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKVxuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIGNvbnN0IGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKVxuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaClcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKVxuICB9XG4gIGNvbnN0IHFtID0gcmVzdC5pbmRleE9mKCc/JylcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pXG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3QgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcnXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIGxldCBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KVxuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdXG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSlcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpXG4gIH1cbiAgaWYgKGhvc3QpIHsgdGhpcy5ob3N0bmFtZSA9IGhvc3QgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB1cmxQYXJzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdurl/lib/parse.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/categories/Cc/regex.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cc/regex.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[\\0-\\x1F\\x7F-\\x9F]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4Lm1qcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXgubWpzP2U0NTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL1tcXDAtXFx4MUZcXHg3Ri1cXHg5Rl0vIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/categories/Cc/regex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/categories/Cf/regex.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cf/regex.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB]|\\uD804[\\uDCBD\\uDCCD]|\\uD80D[\\uDC30-\\uDC3F]|\\uD82F[\\uDCA0-\\uDCA3]|\\uD834[\\uDD73-\\uDD7A]|\\uDB40[\\uDC01\\uDC20-\\uDC7F]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4Lm1qcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXgubWpzP2Q1MmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTA4OTBcXHUwODkxXFx1MDhFMlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXXxcXHVEODBEW1xcdURDMzAtXFx1REMzRl18XFx1RDgyRltcXHVEQ0EwLVxcdURDQTNdfFxcdUQ4MzRbXFx1REQ3My1cXHVERDdBXXxcXHVEQjQwW1xcdURDMDFcXHVEQzIwLVxcdURDN0ZdLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/categories/Cf/regex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/categories/P/regex.mjs":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/P/regex.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061D-\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1B7D\\u1B7E\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52-\\u2E5D\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD803[\\uDEAD\\uDF55-\\uDF59\\uDF86-\\uDF89]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC8\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDC4B-\\uDC4F\\uDC5A\\uDC5B\\uDC5D\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDE60-\\uDE6C\\uDEB9\\uDF3C-\\uDF3E]|\\uD806[\\uDC3B\\uDD44-\\uDD46\\uDDE2\\uDE3F-\\uDE46\\uDE9A-\\uDE9C\\uDE9E-\\uDEA2\\uDF00-\\uDF09]|\\uD807[\\uDC41-\\uDC45\\uDC70\\uDC71\\uDEF7\\uDEF8\\uDF43-\\uDF4F\\uDFFF]|\\uD809[\\uDC70-\\uDC74]|\\uD80B[\\uDFF1\\uDFF2]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD81B[\\uDE97-\\uDE9A\\uDFE2]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]|\\uD83A[\\uDD5E\\uDD5F]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgubWpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxlQUFlLFdBQVcsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Lm1qcz83ZjU1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9bIS0jJS1cXCosLVxcLzo7XFw/QFxcWy1cXF1fXFx7XFx9XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFELVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDNzdcXHUwQzg0XFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCN0RcXHUxQjdFXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0RlxcdTJFNTItXFx1MkU1RFxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwM1tcXHVERUFEXFx1REY1NS1cXHVERjU5XFx1REY4Ni1cXHVERjg5XXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzhcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QVxcdURDNUJcXHVEQzVEXFx1RENDNlxcdUREQzEtXFx1REREN1xcdURFNDEtXFx1REU0M1xcdURFNjAtXFx1REU2Q1xcdURFQjlcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDZbXFx1REMzQlxcdURENDQtXFx1REQ0NlxcdURERTJcXHVERTNGLVxcdURFNDZcXHVERTlBLVxcdURFOUNcXHVERTlFLVxcdURFQTJcXHVERjAwLVxcdURGMDldfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFcXHVERUY3XFx1REVGOFxcdURGNDMtXFx1REY0RlxcdURGRkZdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODBCW1xcdURGRjFcXHVERkYyXXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MUJbXFx1REU5Ny1cXHVERTlBXFx1REZFMl18XFx1RDgyRlxcdURDOUZ8XFx1RDgzNltcXHVERTg3LVxcdURFOEJdfFxcdUQ4M0FbXFx1REQ1RVxcdURENUZdLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/categories/P/regex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/categories/S/regex.mjs":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/S/regex.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[\\$\\+<->\\^`\\|~\\xA2-\\xA6\\xA8\\xA9\\xAC\\xAE-\\xB1\\xB4\\xB8\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u03F6\\u0482\\u058D-\\u058F\\u0606-\\u0608\\u060B\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u07FE\\u07FF\\u0888\\u09F2\\u09F3\\u09FA\\u09FB\\u0AF1\\u0B70\\u0BF3-\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0E3F\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u17DB\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u20A0-\\u20C0\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F\\u218A\\u218B\\u2190-\\u2307\\u230C-\\u2328\\u232B-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u2767\\u2794-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2B73\\u2B76-\\u2B95\\u2B97-\\u2BFF\\u2CE5-\\u2CEA\\u2E50\\u2E51\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFF\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u309B\\u309C\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u31EF\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA828-\\uA82B\\uA836-\\uA839\\uAA77-\\uAA79\\uAB5B\\uAB6A\\uAB6B\\uFB29\\uFBB2-\\uFBC2\\uFD40-\\uFD4F\\uFDCF\\uFDFC-\\uFDFF\\uFE62\\uFE64-\\uFE66\\uFE69\\uFF04\\uFF0B\\uFF1C-\\uFF1E\\uFF3E\\uFF40\\uFF5C\\uFF5E\\uFFE0-\\uFFE6\\uFFE8-\\uFFEE\\uFFFC\\uFFFD]|\\uD800[\\uDD37-\\uDD3F\\uDD79-\\uDD89\\uDD8C-\\uDD8E\\uDD90-\\uDD9C\\uDDA0\\uDDD0-\\uDDFC]|\\uD802[\\uDC77\\uDC78\\uDEC8]|\\uD805\\uDF3F|\\uD807[\\uDFD5-\\uDFF1]|\\uD81A[\\uDF3C-\\uDF3F\\uDF45]|\\uD82F\\uDC9C|\\uD833[\\uDF50-\\uDFC3]|\\uD834[\\uDC00-\\uDCF5\\uDD00-\\uDD26\\uDD29-\\uDD64\\uDD6A-\\uDD6C\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDDEA\\uDE00-\\uDE41\\uDE45\\uDF00-\\uDF56]|\\uD835[\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85\\uDE86]|\\uD838[\\uDD4F\\uDEFF]|\\uD83B[\\uDCAC\\uDCB0\\uDD2E\\uDEF0\\uDEF1]|\\uD83C[\\uDC00-\\uDC2B\\uDC30-\\uDC93\\uDCA0-\\uDCAE\\uDCB1-\\uDCBF\\uDCC1-\\uDCCF\\uDCD1-\\uDCF5\\uDD0D-\\uDDAD\\uDDE6-\\uDE02\\uDE10-\\uDE3B\\uDE40-\\uDE48\\uDE50\\uDE51\\uDE60-\\uDE65\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDED7\\uDEDC-\\uDEEC\\uDEF0-\\uDEFC\\uDF00-\\uDF76\\uDF7B-\\uDFD9\\uDFE0-\\uDFEB\\uDFF0]|\\uD83E[\\uDC00-\\uDC0B\\uDC10-\\uDC47\\uDC50-\\uDC59\\uDC60-\\uDC87\\uDC90-\\uDCAD\\uDCB0\\uDCB1\\uDD00-\\uDE53\\uDE60-\\uDE6D\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC5\\uDECE-\\uDEDB\\uDEE0-\\uDEE8\\uDEF0-\\uDEF8\\uDF00-\\uDF92\\uDF94-\\uDFCA]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1MvcmVnZXgubWpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9TL3JlZ2V4Lm1qcz9kMmI1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9bXFwkXFwrPC0+XFxeYFxcfH5cXHhBMi1cXHhBNlxceEE4XFx4QTlcXHhBQ1xceEFFLVxceEIxXFx4QjRcXHhCOFxceEQ3XFx4RjdcXHUwMkMyLVxcdTAyQzVcXHUwMkQyLVxcdTAyREZcXHUwMkU1LVxcdTAyRUJcXHUwMkVEXFx1MDJFRi1cXHUwMkZGXFx1MDM3NVxcdTAzODRcXHUwMzg1XFx1MDNGNlxcdTA0ODJcXHUwNThELVxcdTA1OEZcXHUwNjA2LVxcdTA2MDhcXHUwNjBCXFx1MDYwRVxcdTA2MEZcXHUwNkRFXFx1MDZFOVxcdTA2RkRcXHUwNkZFXFx1MDdGNlxcdTA3RkVcXHUwN0ZGXFx1MDg4OFxcdTA5RjJcXHUwOUYzXFx1MDlGQVxcdTA5RkJcXHUwQUYxXFx1MEI3MFxcdTBCRjMtXFx1MEJGQVxcdTBDN0ZcXHUwRDRGXFx1MEQ3OVxcdTBFM0ZcXHUwRjAxLVxcdTBGMDNcXHUwRjEzXFx1MEYxNS1cXHUwRjE3XFx1MEYxQS1cXHUwRjFGXFx1MEYzNFxcdTBGMzZcXHUwRjM4XFx1MEZCRS1cXHUwRkM1XFx1MEZDNy1cXHUwRkNDXFx1MEZDRVxcdTBGQ0ZcXHUwRkQ1LVxcdTBGRDhcXHUxMDlFXFx1MTA5RlxcdTEzOTAtXFx1MTM5OVxcdTE2NkRcXHUxN0RCXFx1MTk0MFxcdTE5REUtXFx1MTlGRlxcdTFCNjEtXFx1MUI2QVxcdTFCNzQtXFx1MUI3Q1xcdTFGQkRcXHUxRkJGLVxcdTFGQzFcXHUxRkNELVxcdTFGQ0ZcXHUxRkRELVxcdTFGREZcXHUxRkVELVxcdTFGRUZcXHUxRkZEXFx1MUZGRVxcdTIwNDRcXHUyMDUyXFx1MjA3QS1cXHUyMDdDXFx1MjA4QS1cXHUyMDhDXFx1MjBBMC1cXHUyMEMwXFx1MjEwMFxcdTIxMDFcXHUyMTAzLVxcdTIxMDZcXHUyMTA4XFx1MjEwOVxcdTIxMTRcXHUyMTE2LVxcdTIxMThcXHUyMTFFLVxcdTIxMjNcXHUyMTI1XFx1MjEyN1xcdTIxMjlcXHUyMTJFXFx1MjEzQVxcdTIxM0JcXHUyMTQwLVxcdTIxNDRcXHUyMTRBLVxcdTIxNERcXHUyMTRGXFx1MjE4QVxcdTIxOEJcXHUyMTkwLVxcdTIzMDdcXHUyMzBDLVxcdTIzMjhcXHUyMzJCLVxcdTI0MjZcXHUyNDQwLVxcdTI0NEFcXHUyNDlDLVxcdTI0RTlcXHUyNTAwLVxcdTI3NjdcXHUyNzk0LVxcdTI3QzRcXHUyN0M3LVxcdTI3RTVcXHUyN0YwLVxcdTI5ODJcXHUyOTk5LVxcdTI5RDdcXHUyOURDLVxcdTI5RkJcXHUyOUZFLVxcdTJCNzNcXHUyQjc2LVxcdTJCOTVcXHUyQjk3LVxcdTJCRkZcXHUyQ0U1LVxcdTJDRUFcXHUyRTUwXFx1MkU1MVxcdTJFODAtXFx1MkU5OVxcdTJFOUItXFx1MkVGM1xcdTJGMDAtXFx1MkZENVxcdTJGRjAtXFx1MkZGRlxcdTMwMDRcXHUzMDEyXFx1MzAxM1xcdTMwMjBcXHUzMDM2XFx1MzAzN1xcdTMwM0VcXHUzMDNGXFx1MzA5QlxcdTMwOUNcXHUzMTkwXFx1MzE5MVxcdTMxOTYtXFx1MzE5RlxcdTMxQzAtXFx1MzFFM1xcdTMxRUZcXHUzMjAwLVxcdTMyMUVcXHUzMjJBLVxcdTMyNDdcXHUzMjUwXFx1MzI2MC1cXHUzMjdGXFx1MzI4QS1cXHUzMkIwXFx1MzJDMC1cXHUzM0ZGXFx1NERDMC1cXHU0REZGXFx1QTQ5MC1cXHVBNEM2XFx1QTcwMC1cXHVBNzE2XFx1QTcyMFxcdUE3MjFcXHVBNzg5XFx1QTc4QVxcdUE4MjgtXFx1QTgyQlxcdUE4MzYtXFx1QTgzOVxcdUFBNzctXFx1QUE3OVxcdUFCNUJcXHVBQjZBXFx1QUI2QlxcdUZCMjlcXHVGQkIyLVxcdUZCQzJcXHVGRDQwLVxcdUZENEZcXHVGRENGXFx1RkRGQy1cXHVGREZGXFx1RkU2MlxcdUZFNjQtXFx1RkU2NlxcdUZFNjlcXHVGRjA0XFx1RkYwQlxcdUZGMUMtXFx1RkYxRVxcdUZGM0VcXHVGRjQwXFx1RkY1Q1xcdUZGNUVcXHVGRkUwLVxcdUZGRTZcXHVGRkU4LVxcdUZGRUVcXHVGRkZDXFx1RkZGRF18XFx1RDgwMFtcXHVERDM3LVxcdUREM0ZcXHVERDc5LVxcdUREODlcXHVERDhDLVxcdUREOEVcXHVERDkwLVxcdUREOUNcXHVEREEwXFx1REREMC1cXHVEREZDXXxcXHVEODAyW1xcdURDNzdcXHVEQzc4XFx1REVDOF18XFx1RDgwNVxcdURGM0Z8XFx1RDgwN1tcXHVERkQ1LVxcdURGRjFdfFxcdUQ4MUFbXFx1REYzQy1cXHVERjNGXFx1REY0NV18XFx1RDgyRlxcdURDOUN8XFx1RDgzM1tcXHVERjUwLVxcdURGQzNdfFxcdUQ4MzRbXFx1REMwMC1cXHVEQ0Y1XFx1REQwMC1cXHVERDI2XFx1REQyOS1cXHVERDY0XFx1REQ2QS1cXHVERDZDXFx1REQ4M1xcdUREODRcXHVERDhDLVxcdUREQTlcXHVEREFFLVxcdURERUFcXHVERTAwLVxcdURFNDFcXHVERTQ1XFx1REYwMC1cXHVERjU2XXxcXHVEODM1W1xcdURFQzFcXHVERURCXFx1REVGQlxcdURGMTVcXHVERjM1XFx1REY0RlxcdURGNkZcXHVERjg5XFx1REZBOVxcdURGQzNdfFxcdUQ4MzZbXFx1REMwMC1cXHVEREZGXFx1REUzNy1cXHVERTNBXFx1REU2RC1cXHVERTc0XFx1REU3Ni1cXHVERTgzXFx1REU4NVxcdURFODZdfFxcdUQ4MzhbXFx1REQ0RlxcdURFRkZdfFxcdUQ4M0JbXFx1RENBQ1xcdURDQjBcXHVERDJFXFx1REVGMFxcdURFRjFdfFxcdUQ4M0NbXFx1REMwMC1cXHVEQzJCXFx1REMzMC1cXHVEQzkzXFx1RENBMC1cXHVEQ0FFXFx1RENCMS1cXHVEQ0JGXFx1RENDMS1cXHVEQ0NGXFx1RENEMS1cXHVEQ0Y1XFx1REQwRC1cXHVEREFEXFx1RERFNi1cXHVERTAyXFx1REUxMC1cXHVERTNCXFx1REU0MC1cXHVERTQ4XFx1REU1MFxcdURFNTFcXHVERTYwLVxcdURFNjVcXHVERjAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERUQ3XFx1REVEQy1cXHVERUVDXFx1REVGMC1cXHVERUZDXFx1REYwMC1cXHVERjc2XFx1REY3Qi1cXHVERkQ5XFx1REZFMC1cXHVERkVCXFx1REZGMF18XFx1RDgzRVtcXHVEQzAwLVxcdURDMEJcXHVEQzEwLVxcdURDNDdcXHVEQzUwLVxcdURDNTlcXHVEQzYwLVxcdURDODdcXHVEQzkwLVxcdURDQURcXHVEQ0IwXFx1RENCMVxcdUREMDAtXFx1REU1M1xcdURFNjAtXFx1REU2RFxcdURFNzAtXFx1REU3Q1xcdURFODAtXFx1REU4OFxcdURFOTAtXFx1REVCRFxcdURFQkYtXFx1REVDNVxcdURFQ0UtXFx1REVEQlxcdURFRTAtXFx1REVFOFxcdURFRjAtXFx1REVGOFxcdURGMDAtXFx1REY5MlxcdURGOTQtXFx1REZDQV0vIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/categories/S/regex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/categories/Z/regex.mjs":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Z/regex.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[ \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXgubWpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9aL3JlZ2V4Lm1qcz85MjIyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS8iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/categories/Z/regex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/index.mjs":
/*!*****************************************!*\
  !*** ./node_modules/uc.micro/index.mjs ***!
  \*****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: function() { return /* reexport safe */ _properties_Any_regex_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   Cc: function() { return /* reexport safe */ _categories_Cc_regex_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   Cf: function() { return /* reexport safe */ _categories_Cf_regex_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   P: function() { return /* reexport safe */ _categories_P_regex_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   S: function() { return /* reexport safe */ _categories_S_regex_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   Z: function() { return /* reexport safe */ _categories_Z_regex_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _properties_Any_regex_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./properties/Any/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/properties/Any/regex.mjs\");\n/* harmony import */ var _categories_Cc_regex_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./categories/Cc/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/categories/Cc/regex.mjs\");\n/* harmony import */ var _categories_Cf_regex_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./categories/Cf/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/categories/Cf/regex.mjs\");\n/* harmony import */ var _categories_P_regex_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./categories/P/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/categories/P/regex.mjs\");\n/* harmony import */ var _categories_S_regex_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./categories/S/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/categories/S/regex.mjs\");\n/* harmony import */ var _categories_Z_regex_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./categories/Z/regex.mjs */ \"(app-pages-browser)/./node_modules/uc.micro/categories/Z/regex.mjs\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0Q7QUFDQTtBQUNEO0FBQ0E7QUFDQTs7QUFFWCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdWMubWljcm8vaW5kZXgubWpzPzZjY2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEFueSBmcm9tICcuL3Byb3BlcnRpZXMvQW55L3JlZ2V4Lm1qcyc7XG5pbXBvcnQgQ2MgIGZyb20gJy4vY2F0ZWdvcmllcy9DYy9yZWdleC5tanMnO1xuaW1wb3J0IENmICBmcm9tICcuL2NhdGVnb3JpZXMvQ2YvcmVnZXgubWpzJztcbmltcG9ydCBQICAgZnJvbSAnLi9jYXRlZ29yaWVzL1AvcmVnZXgubWpzJztcbmltcG9ydCBTICAgZnJvbSAnLi9jYXRlZ29yaWVzL1MvcmVnZXgubWpzJztcbmltcG9ydCBaICAgZnJvbSAnLi9jYXRlZ29yaWVzL1ovcmVnZXgubWpzJztcblxuZXhwb3J0IHsgQW55LCBDYywgQ2YsIFAsIFMsIFogfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uc.micro/properties/Any/regex.mjs":
/*!********************************************************!*\
  !*** ./node_modules/uc.micro/properties/Any/regex.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5tanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5tanM/NWNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvW1xcMC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdLyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uc.micro/properties/Any/regex.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Faleksandar%2FDesktop%2FRaboten%2Fmd%20to%20docx%2Fapp%2Fpage.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);