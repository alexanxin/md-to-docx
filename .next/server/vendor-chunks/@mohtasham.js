"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mohtasham";
exports.ids = ["vendor-chunks/@mohtasham"];
exports.modules = {

/***/ "(ssr)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   collectTables: () => (/* binding */ collectTables),\n/* harmony export */   computeImageDimensions: () => (/* binding */ computeImageDimensions),\n/* harmony export */   createLinkParagraph: () => (/* binding */ createLinkParagraph),\n/* harmony export */   processBlockquote: () => (/* binding */ processBlockquote),\n/* harmony export */   processCodeBlock: () => (/* binding */ processCodeBlock),\n/* harmony export */   processComment: () => (/* binding */ processComment),\n/* harmony export */   processFormattedText: () => (/* binding */ processFormattedText),\n/* harmony export */   processHeading: () => (/* binding */ processHeading),\n/* harmony export */   processImage: () => (/* binding */ processImage),\n/* harmony export */   processInlineCode: () => (/* binding */ processInlineCode),\n/* harmony export */   processLink: () => (/* binding */ processLink),\n/* harmony export */   processLinkParagraph: () => (/* binding */ processLinkParagraph),\n/* harmony export */   processListItem: () => (/* binding */ processListItem),\n/* harmony export */   processParagraph: () => (/* binding */ processParagraph),\n/* harmony export */   processTable: () => (/* binding */ processTable)\n/* harmony export */ });\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docx */ \"(ssr)/./node_modules/docx/dist/index.mjs\");\n\n// Helper function to sanitize text for use in bookmark IDs\nfunction sanitizeForBookmarkId(text) {\n    // Remove non-alphanumeric characters (except underscores), replace spaces with underscores\n    // Ensure it starts with a letter or underscore\n    let sanitized = text.replace(/[^a-zA-Z0-9_\\s]/g, \"\").replace(/\\s+/g, \"_\");\n    if (!/^[a-zA-Z_]/.test(sanitized)) {\n        sanitized = \"_\" + sanitized;\n    }\n    // Truncate if necessary (Word has limits, though usually generous)\n    return sanitized.substring(0, 40);\n}\n/**\n * Processes a heading line and returns appropriate paragraph formatting and a bookmark ID\n * @param line - The heading line to process\n * @param config - The heading configuration\n * @param style - The style configuration\n * @param documentType - The document type\n * @returns An object containing the processed paragraph and its bookmark ID\n */\nfunction processHeading(line, config, style, documentType) {\n    const headingText = line.replace(new RegExp(`^#{${config.level}} `), \"\");\n    const headingLevel = config.level;\n    // Generate a unique bookmark ID using the clean text (without markdown)\n    const cleanTextForBookmark = headingText\n        .replace(/\\*\\*/g, \"\")\n        .replace(/\\*/g, \"\");\n    const bookmarkId = `_Toc_${sanitizeForBookmarkId(cleanTextForBookmark)}_${Date.now()}`;\n    // Get the appropriate font size based on heading level and custom style\n    let headingSize = style.titleSize;\n    // Use specific heading size if provided, otherwise calculate based on level\n    if (headingLevel === 1 && style.heading1Size) {\n        headingSize = style.heading1Size;\n    }\n    else if (headingLevel === 2 && style.heading2Size) {\n        headingSize = style.heading2Size;\n    }\n    else if (headingLevel === 3 && style.heading3Size) {\n        headingSize = style.heading3Size;\n    }\n    else if (headingLevel === 4 && style.heading4Size) {\n        headingSize = style.heading4Size;\n    }\n    else if (headingLevel === 5 && style.heading5Size) {\n        headingSize = style.heading5Size;\n    }\n    else if (headingLevel > 1) {\n        // Fallback calculation if specific size not provided\n        headingSize = style.titleSize - (headingLevel - 1) * 4;\n    }\n    // Determine alignment based on heading level\n    let alignment;\n    // Check for level-specific alignment first\n    if (headingLevel === 1 && style.heading1Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading1Alignment];\n    }\n    else if (headingLevel === 2 && style.heading2Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading2Alignment];\n    }\n    else if (headingLevel === 3 && style.heading3Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading3Alignment];\n    }\n    else if (headingLevel === 4 && style.heading4Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading4Alignment];\n    }\n    else if (headingLevel === 5 && style.heading5Alignment) {\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.heading5Alignment];\n    }\n    else if (style.headingAlignment) {\n        // Fallback to general heading alignment if no level-specific alignment\n        alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.headingAlignment];\n    }\n    // Process the heading text to handle markdown formatting (bold/italic)\n    const processedTextRuns = processFormattedTextForHeading(headingText, headingSize, style);\n    // Create the paragraph with bookmark\n    const paragraph = new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Bookmark({\n                id: bookmarkId,\n                children: processedTextRuns,\n            }),\n        ],\n        heading: headingLevel,\n        spacing: {\n            before: config.level === 1 ? style.headingSpacing * 2 : style.headingSpacing,\n            after: style.headingSpacing / 2,\n        },\n        alignment: alignment,\n        style: `Heading${headingLevel}`, // This is crucial for TOC recognition\n        bidirectional: style.direction === \"RTL\",\n    });\n    return { paragraph, bookmarkId };\n}\n/**\n * Processes formatted text specifically for headings (bold/italic) and returns an array of TextRun objects\n * @param text - The text to process\n * @param fontSize - The font size to apply\n * @returns An array of TextRun objects\n */\nfunction processFormattedTextForHeading(text, fontSize, style) {\n    const textRuns = [];\n    let currentText = \"\";\n    let isBold = false;\n    let isItalic = false;\n    // Track unclosed markers to reset at end if needed\n    let boldStart = -1;\n    let italicStart = -1;\n    for (let j = 0; j < text.length; j++) {\n        // Handle escaped characters\n        if (text[j] === \"\\\\\" && j + 1 < text.length) {\n            const nextChar = text[j + 1];\n            if (nextChar === \"*\" || nextChar === \"\\\\\") {\n                currentText += nextChar;\n                j++; // Skip the escaped character\n                continue;\n            }\n            // If not a recognized escape sequence, treat normally\n            currentText += text[j];\n            continue;\n        }\n        // Handle bold with ** markers\n        if (j + 1 < text.length && text[j] === \"*\" && text[j + 1] === \"*\") {\n            // Flush current text before toggling bold\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: fontSize,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle bold state\n            if (!isBold) {\n                boldStart = j;\n            }\n            else {\n                boldStart = -1;\n            }\n            isBold = !isBold;\n            j++; // Skip the second *\n            continue;\n        }\n        // Handle italic with single * marker (but not if it's part of **)\n        if (text[j] === \"*\" &&\n            (j === 0 || text[j - 1] !== \"*\") &&\n            (j === text.length - 1 || text[j + 1] !== \"*\")) {\n            // Flush current text before toggling italic\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: fontSize,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle italic state\n            if (!isItalic) {\n                italicStart = j;\n            }\n            else {\n                italicStart = -1;\n            }\n            isItalic = !isItalic;\n            continue;\n        }\n        // Add to current text\n        currentText += text[j];\n    }\n    // Handle any remaining text\n    if (currentText) {\n        // If we have unclosed markers, treat them as literal text\n        if (isBold && boldStart >= 0) {\n            // Insert the ** back into the text and turn off bold\n            const beforeBold = currentText;\n            currentText = \"**\" + beforeBold;\n            isBold = false;\n        }\n        if (isItalic && italicStart >= 0) {\n            // Insert the * back into the text and turn off italic\n            const beforeItalic = currentText;\n            currentText = \"*\" + beforeItalic;\n            isItalic = false;\n        }\n        // Only add non-empty text runs\n        if (currentText.trim()) {\n            textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: currentText,\n                bold: isBold,\n                italics: isItalic,\n                color: \"000000\",\n                size: fontSize,\n                rightToLeft: style?.direction === \"RTL\",\n            }));\n        }\n    }\n    // If no text runs were created, return a single empty run to avoid empty paragraphs\n    if (textRuns.length === 0) {\n        textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\",\n            color: \"000000\",\n            size: fontSize,\n            bold: true, // Headings are bold by default\n        }));\n    }\n    return textRuns;\n}\n/**\n * Processes a table and returns table formatting\n * @param tableData - The table data\n * @param documentType - The document type\n * @returns The processed table\n */\nfunction processTable(tableData, documentType) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Table({\n        width: { size: 100, type: docx__WEBPACK_IMPORTED_MODULE_0__.WidthType.PERCENTAGE },\n        rows: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TableRow({\n                tableHeader: true,\n                children: tableData.headers.map((header) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableCell({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                            style: \"Strong\",\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: header,\n                                    bold: true,\n                                    color: \"000000\",\n                                }),\n                            ],\n                        }),\n                    ],\n                    shading: {\n                        fill: documentType === \"report\" ? \"DDDDDD\" : \"F2F2F2\",\n                    },\n                })),\n            }),\n            ...tableData.rows.map((row) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableRow({\n                children: row.map((cell) => new docx__WEBPACK_IMPORTED_MODULE_0__.TableCell({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: cell,\n                                    color: \"000000\",\n                                    rightToLeft: false,\n                                }),\n                            ],\n                        }),\n                    ],\n                })),\n            })),\n        ],\n        layout: docx__WEBPACK_IMPORTED_MODULE_0__.TableLayoutType.FIXED,\n        margins: {\n            top: 100,\n            bottom: 100,\n            left: 100,\n            right: 100,\n        },\n    });\n}\n/**\n * Processes a list item and returns appropriate paragraph formatting\n * @param config - The list item configuration\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processListItem(config, style) {\n    let textContent = config.text;\n    // Process the main text with formatting\n    const children = processFormattedText(textContent, style);\n    // If there's bold text on the next line, add it with a line break\n    if (config.boldText) {\n        children.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\\n\",\n            size: style.listItemSize || 24,\n        }), new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: config.boldText,\n            bold: true,\n            color: \"000000\",\n            size: style.listItemSize || 24,\n        }));\n    }\n    // Use different formatting for numbered vs bullet lists\n    if (config.isNumbered) {\n        // Use numbering for numbered lists with unique reference per sequence\n        const numberingReference = `numbered-list-${config.sequenceId || 1}`;\n        return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n            children,\n            numbering: {\n                reference: numberingReference,\n                level: 0,\n            },\n            spacing: {\n                before: style.paragraphSpacing / 2,\n                after: style.paragraphSpacing / 2,\n            },\n            bidirectional: style.direction === \"RTL\",\n        });\n    }\n    else {\n        // Use bullet formatting for bullet lists\n        return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n            children,\n            bullet: {\n                level: 0,\n            },\n            spacing: {\n                before: style.paragraphSpacing / 2,\n                after: style.paragraphSpacing / 2,\n            },\n            bidirectional: style.direction === \"RTL\",\n        });\n    }\n}\n/**\n * Processes a blockquote and returns appropriate paragraph formatting\n * @param text - The blockquote text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processBlockquote(text, style) {\n    // Determine alignment for blockquote - only if explicitly set\n    let alignment = undefined;\n    if (style.blockquoteAlignment) {\n        switch (style.blockquoteAlignment) {\n            case \"LEFT\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT;\n                break;\n            case \"CENTER\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER;\n                break;\n            case \"RIGHT\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.RIGHT;\n                break;\n            case \"JUSTIFIED\":\n                alignment = docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.JUSTIFIED;\n                break;\n            default:\n                // Don't set alignment if not explicitly defined\n                alignment = undefined;\n        }\n    }\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: text,\n                italics: true,\n                color: \"000000\",\n                size: style.blockquoteSize || 24, // Use custom blockquote size if provided\n                rightToLeft: style.direction === \"RTL\",\n            }),\n        ],\n        indent: {\n            left: 720, // 0.5 inch indent\n        },\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n        border: {\n            left: {\n                style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE,\n                size: 3,\n                color: \"AAAAAA\",\n            },\n        },\n        alignment: alignment,\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n/**\n * Processes a comment and returns appropriate paragraph formatting\n * @param text - The comment text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processComment(text, style) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: \"Comment: \" + text,\n                italics: true,\n                color: \"666666\",\n            }),\n        ],\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n    });\n}\n/**\n * Processes formatted text (bold/italic/inline-code/links) and returns an array of TextRun or ExternalHyperlink objects\n * @param line - The line to process\n * @param style - The style configuration\n * @returns An array of TextRun or ExternalHyperlink objects\n */\nfunction processFormattedText(line, style) {\n    const textRuns = [];\n    let currentText = \"\";\n    let isBold = false;\n    let isItalic = false;\n    let isInlineCode = false;\n    // Track unclosed markers to reset at end if needed\n    let boldStart = -1;\n    let italicStart = -1;\n    for (let j = 0; j < line.length; j++) {\n        // Handle escaped characters\n        if (line[j] === \"\\\\\" && j + 1 < line.length) {\n            const nextChar = line[j + 1];\n            if (nextChar === \"*\" || nextChar === \"`\" || nextChar === \"\\\\\" || nextChar === \"[\" || nextChar === \"]\") {\n                currentText += nextChar;\n                j++; // Skip the escaped character\n                continue;\n            }\n            // If not a recognized escape sequence, treat normally\n            currentText += line[j];\n            continue;\n        }\n        // Handle inline links [text](url) - only when not in inline code\n        if (!isInlineCode && line[j] === \"[\") {\n            // Look for closing ] and then (url)\n            let closeBracket = -1;\n            let openParen = -1;\n            let closeParen = -1;\n            // Find closing bracket\n            for (let k = j + 1; k < line.length; k++) {\n                if (line[k] === \"\\\\\" && k + 1 < line.length) {\n                    k++; // Skip escaped character\n                    continue;\n                }\n                if (line[k] === \"]\") {\n                    closeBracket = k;\n                    break;\n                }\n            }\n            // If we found closing bracket, look for (url)\n            if (closeBracket > j && closeBracket + 1 < line.length && line[closeBracket + 1] === \"(\") {\n                openParen = closeBracket + 1;\n                // Find closing paren\n                for (let k = openParen + 1; k < line.length; k++) {\n                    if (line[k] === \")\") {\n                        closeParen = k;\n                        break;\n                    }\n                }\n            }\n            // If we found a complete link pattern\n            if (closeBracket > j && openParen > closeBracket && closeParen > openParen) {\n                // Flush current text first\n                if (currentText) {\n                    textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: currentText,\n                        bold: isBold,\n                        italics: isItalic,\n                        color: \"000000\",\n                        size: style?.paragraphSize || 24,\n                        rightToLeft: style?.direction === \"RTL\",\n                    }));\n                    currentText = \"\";\n                }\n                // Extract link text and URL\n                const linkText = line.substring(j + 1, closeBracket);\n                const linkUrl = line.substring(openParen + 1, closeParen);\n                // Create hyperlink\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                            text: linkText,\n                            color: \"0000FF\",\n                            underline: { type: \"single\" },\n                            bold: isBold,\n                            italics: isItalic,\n                            size: style?.paragraphSize || 24,\n                            rightToLeft: style?.direction === \"RTL\",\n                        }),\n                    ],\n                    link: linkUrl,\n                }));\n                // Skip to after the link\n                j = closeParen;\n                continue;\n            }\n        }\n        // Handle inline code with backtick\n        if (line[j] === \"`\" && !isInlineCode) {\n            // Starting inline code - flush current text first\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            isInlineCode = true;\n            continue;\n        }\n        if (line[j] === \"`\" && isInlineCode) {\n            // Ending inline code\n            if (currentText) {\n                textRuns.push(processInlineCode(currentText, style));\n                currentText = \"\";\n            }\n            isInlineCode = false;\n            continue;\n        }\n        // If we're inside inline code, just accumulate text (no formatting)\n        if (isInlineCode) {\n            currentText += line[j];\n            continue;\n        }\n        // Handle bold with ** markers\n        if (j + 1 < line.length && line[j] === \"*\" && line[j + 1] === \"*\") {\n            // Flush current text before toggling bold\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                    rightToLeft: style?.direction === \"RTL\",\n                }));\n                currentText = \"\";\n            }\n            // Toggle bold state\n            if (!isBold) {\n                boldStart = j;\n            }\n            else {\n                boldStart = -1;\n            }\n            isBold = !isBold;\n            j++; // Skip the second *\n            continue;\n        }\n        // Handle italic with single * marker (but not if it's part of **)\n        if (line[j] === \"*\" &&\n            (j === 0 || line[j - 1] !== \"*\") &&\n            (j === line.length - 1 || line[j + 1] !== \"*\")) {\n            // Flush current text before toggling italic\n            if (currentText) {\n                textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                    text: currentText,\n                    bold: isBold,\n                    italics: isItalic,\n                    color: \"000000\",\n                    size: style?.paragraphSize || 24,\n                }));\n                currentText = \"\";\n            }\n            // Toggle italic state\n            if (!isItalic) {\n                italicStart = j;\n            }\n            else {\n                italicStart = -1;\n            }\n            isItalic = !isItalic;\n            continue;\n        }\n        // Add to current text\n        currentText += line[j];\n    }\n    // Handle any remaining text\n    if (currentText) {\n        // If we have unclosed markers, treat them as literal text\n        if (isBold && boldStart >= 0) {\n            // Insert the ** back into the text and turn off bold\n            const beforeBold = currentText;\n            currentText = \"**\" + beforeBold;\n            isBold = false;\n        }\n        if (isItalic && italicStart >= 0) {\n            // Insert the * back into the text and turn off italic\n            const beforeItalic = currentText;\n            currentText = \"*\" + beforeItalic;\n            isItalic = false;\n        }\n        if (isInlineCode) {\n            // Unclosed inline code - treat as literal text\n            currentText = \"`\" + currentText;\n        }\n        // Only add non-empty text runs\n        if (currentText.trim()) {\n            textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: currentText,\n                bold: isBold,\n                italics: isItalic,\n                color: \"000000\",\n                size: style?.paragraphSize || 24,\n                rightToLeft: style?.direction === \"RTL\",\n            }));\n        }\n    }\n    // If no text runs were created, return a single empty run to avoid empty paragraphs\n    if (textRuns.length === 0) {\n        textRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\",\n            color: \"000000\",\n            size: style?.paragraphSize || 24,\n        }));\n    }\n    return textRuns;\n}\n/**\n * Collects tables from markdown lines\n * @param lines - The markdown lines\n * @returns An array of table data\n */\nfunction collectTables(lines) {\n    const tables = [];\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        if (line.trim().startsWith(\"|\")) {\n            // Check for separator row with proper regex\n            if (i + 1 < lines.length &&\n                /^\\s*\\|(?:\\s*:?-+:?\\s*\\|)+\\s*$/.test(lines[i + 1])) {\n                // Preserve empty cells by slicing off leading/trailing pipe and splitting\n                const headers = line\n                    .trim()\n                    .replace(/^\\|/, \"\")\n                    .replace(/\\|$/, \"\")\n                    .split(\"|\")\n                    .map((h) => h.trim());\n                const rows = [];\n                let j = i + 2;\n                while (j < lines.length && lines[j].trim().startsWith(\"|\")) {\n                    const row = lines[j]\n                        .trim()\n                        .replace(/^\\|/, \"\")\n                        .replace(/\\|$/, \"\")\n                        .split(\"|\")\n                        .map((cell) => cell.trim());\n                    rows.push(row);\n                    j++;\n                }\n                tables.push({ headers, rows });\n            }\n        }\n    }\n    return tables;\n}\n/**\n * Processes inline code and returns a TextRun object\n * @param code - The inline code text\n * @param style - The style configuration\n * @returns A TextRun object\n */\nfunction processInlineCode(code, style) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n        text: code,\n        font: \"Courier New\",\n        size: style?.paragraphSize ? style.paragraphSize - 2 : 20,\n        color: \"444444\",\n        shading: {\n            fill: \"F5F5F5\",\n        },\n        rightToLeft: style?.direction === \"RTL\",\n    });\n}\n/**\n * Processes a code block and returns appropriate paragraph formatting\n * @param code - The code block text\n * @param language - The programming language (optional)\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processCodeBlock(code, language, style) {\n    // Split the code into lines and process each line\n    const lines = code.split(\"\\n\");\n    // Create text runs for each line\n    const codeRuns = [];\n    // Add language indicator if present\n    if (language) {\n        codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: language,\n            font: \"Courier New\",\n            size: style.codeBlockSize || 18,\n            color: \"666666\",\n            bold: true,\n            rightToLeft: style.direction === \"RTL\",\n        }), new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: \"\\n\",\n            font: \"Courier New\",\n            size: style.codeBlockSize || 18,\n            break: 1,\n            rightToLeft: style.direction === \"RTL\",\n        }));\n    }\n    // Process each line\n    lines.forEach((line, index) => {\n        // Preserve leading spaces by converting them to non-breaking spaces\n        const leadingSpaces = line.match(/^\\s*/)?.[0].length || 0;\n        const leadingNbsp = \"\\u00A0\".repeat(leadingSpaces);\n        const processedLine = leadingNbsp + line.slice(leadingSpaces);\n        // Add the line\n        codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n            text: processedLine,\n            font: \"Courier New\",\n            size: style.codeBlockSize || 20,\n            color: \"444444\",\n            rightToLeft: style.direction === \"RTL\",\n        }));\n        // Add line break if not the last line\n        if (index < lines.length - 1) {\n            codeRuns.push(new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: \"\\n\",\n                font: \"Courier New\",\n                size: style.codeBlockSize || 20,\n                break: 1,\n                rightToLeft: style.direction === \"RTL\",\n            }));\n        }\n    });\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: codeRuns,\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n            // Preserve line spacing exactly\n            line: 360,\n            lineRule: \"exact\",\n        },\n        shading: {\n            fill: \"F5F5F5\",\n        },\n        border: {\n            top: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            bottom: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            left: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n            right: { style: docx__WEBPACK_IMPORTED_MODULE_0__.BorderStyle.SINGLE, size: 1, color: \"DDDDDD\" },\n        },\n        // Preserve indentation\n        indent: {\n            left: 360, // 0.25 inch indent for the entire code block\n        },\n    });\n}\n/**\n * Processes a link and returns appropriate text run\n */\nfunction processLink(text, url) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n        text: text,\n        color: \"0000FF\",\n        underline: { type: \"single\" },\n    });\n}\n/**\n * Processes a link and returns a paragraph with hyperlink\n * @param text - The link text\n * @param url - The link URL\n * @param style - The style configuration\n * @returns The processed paragraph with hyperlink\n */\nfunction processLinkParagraph(text, url, style) {\n    const hyperlink = new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                text: text,\n                color: \"0000FF\",\n                underline: { type: \"single\" },\n                rightToLeft: style.direction === \"RTL\",\n            }),\n        ],\n        link: url,\n    });\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [hyperlink],\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n        },\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n/**\n * Computes output image dimensions preserving aspect ratio.\n * - If both hints provided, uses them directly.\n * - If one hint provided and intrinsic aspect known, computes the other.\n * - Falls back to intrinsic width capped to 400, or default width 200.\n */\nfunction computeImageDimensions(widthHint, heightHint, intrinsicWidth, intrinsicHeight) {\n    let outWidth;\n    let outHeight;\n    const aspect = intrinsicWidth && intrinsicHeight\n        ? intrinsicWidth / intrinsicHeight\n        : undefined;\n    if (widthHint && heightHint) {\n        outWidth = widthHint;\n        outHeight = heightHint;\n    }\n    else if (widthHint && aspect) {\n        outWidth = widthHint;\n        outHeight = Math.max(1, Math.round(widthHint / aspect));\n    }\n    else if (heightHint && aspect) {\n        outHeight = heightHint;\n        outWidth = Math.max(1, Math.round(heightHint * aspect));\n    }\n    else if (intrinsicWidth) {\n        outWidth = Math.min(intrinsicWidth, 400);\n        if (aspect)\n            outHeight = Math.max(1, Math.round(outWidth / aspect));\n    }\n    else {\n        outWidth = 200;\n    }\n    return { width: outWidth, height: outHeight };\n}\n/**\n * Creates a simple link paragraph\n * @param text - The link text\n * @param url - The URL to link to\n * @returns A paragraph with a hyperlink\n */\nfunction createLinkParagraph(text, url) {\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.ExternalHyperlink({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: text,\n                        color: \"0000FF\",\n                        underline: { type: \"single\" },\n                    }),\n                ],\n                link: url,\n            }),\n        ],\n    });\n}\n/**\n * Processes an image and returns appropriate paragraph\n * @param altText - The alt text\n * @param imageUrl - The image URL\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nasync function processImage(altText, imageUrl, style) {\n    try {\n        // Support data URLs without fetch and extract raw data/content-type\n        let data;\n        let contentType = \"\";\n        if (/^data:/i.test(imageUrl)) {\n            // data:[<mediatype>][;base64],<data>\n            const match = imageUrl.match(/^data:([^;,]*)(;base64)?,(.*)$/i);\n            if (!match) {\n                throw new Error(\"Invalid data URL for image\");\n            }\n            contentType = match[1] || \"\";\n            const isBase64 = !!match[2];\n            const dataPart = match[3];\n            const binary = isBase64\n                ? typeof Buffer !== \"undefined\"\n                    ? Buffer.from(dataPart, \"base64\")\n                    : Uint8Array.from(atob(dataPart), (c) => c.charCodeAt(0))\n                : typeof Buffer !== \"undefined\"\n                    ? Buffer.from(decodeURIComponent(dataPart))\n                    : new TextEncoder().encode(decodeURIComponent(dataPart));\n            data = binary;\n        }\n        else {\n            const response = await fetch(imageUrl);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);\n            }\n            const arrayBuffer = await response.arrayBuffer();\n            // Use Buffer in Node environments, Uint8Array in browsers\n            data =\n                typeof Buffer !== \"undefined\"\n                    ? Buffer.from(arrayBuffer)\n                    : new Uint8Array(arrayBuffer);\n            // Infer image type from content-type header or URL extension\n            contentType = response.headers.get(\"content-type\") || \"\";\n        }\n        let imageType = \"png\";\n        if (/jpeg|jpg/i.test(contentType) || /\\.(jpe?g)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"jpg\";\n        }\n        else if (/png/i.test(contentType) || /\\.(png)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"png\";\n        }\n        else if (/gif/i.test(contentType) || /\\.(gif)(\\?|$)/i.test(imageUrl)) {\n            imageType = \"gif\";\n        }\n        // Parse optional width/height hints from URL fragment\n        let widthHint;\n        let heightHint;\n        const hashIndex = imageUrl.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            const fragment = imageUrl.substring(hashIndex + 1);\n            // Pattern #<width>x<height>\n            const wxh = fragment.match(/^(\\d+)x(\\d+)$/);\n            if (wxh) {\n                widthHint = parseInt(wxh[1], 10);\n                heightHint = parseInt(wxh[2], 10);\n            }\n            else {\n                // Pattern #w=123&h=45 or #width=..&height=..\n                const params = new URLSearchParams(fragment.replace(/&amp;/g, \"&\"));\n                const w = params.get(\"w\") || params.get(\"width\");\n                const h = params.get(\"h\") || params.get(\"height\");\n                if (w && /^\\d+$/.test(w))\n                    widthHint = parseInt(w, 10);\n                if (h && /^\\d+$/.test(h))\n                    heightHint = parseInt(h, 10);\n            }\n        }\n        // Extract intrinsic dimensions and compute output to preserve aspect ratio\n        function readUint16BE(buf, offset) {\n            return (buf[offset] << 8) | buf[offset + 1];\n        }\n        function readUint32BE(buf, offset) {\n            return (((buf[offset] << 24) |\n                (buf[offset + 1] << 16) |\n                (buf[offset + 2] << 8) |\n                buf[offset + 3]) >>>\n                0);\n        }\n        let intrinsicWidth;\n        let intrinsicHeight;\n        const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);\n        if (imageType === \"png\" && bytes.length >= 24) {\n            const isPng = bytes[0] === 0x89 &&\n                bytes[1] === 0x50 &&\n                bytes[2] === 0x4e &&\n                bytes[3] === 0x47;\n            if (isPng) {\n                intrinsicWidth = readUint32BE(bytes, 16);\n                intrinsicHeight = readUint32BE(bytes, 20);\n            }\n        }\n        else if (imageType === \"jpg\") {\n            let offset = 2; // skip SOI\n            while (offset + 9 < bytes.length) {\n                if (bytes[offset] !== 0xff)\n                    break;\n                const marker = bytes[offset + 1];\n                const length = readUint16BE(bytes, offset + 2);\n                if (marker === 0xc0 || marker === 0xc2) {\n                    intrinsicHeight = readUint16BE(bytes, offset + 5);\n                    intrinsicWidth = readUint16BE(bytes, offset + 7);\n                    break;\n                }\n                offset += 2 + length;\n            }\n        }\n        else if (imageType === \"gif\" && bytes.length >= 10) {\n            intrinsicWidth = bytes[6] | (bytes[7] << 8);\n            intrinsicHeight = bytes[8] | (bytes[9] << 8);\n        }\n        let outWidth;\n        let outHeight;\n        const aspect = intrinsicWidth && intrinsicHeight\n            ? intrinsicWidth / intrinsicHeight\n            : undefined;\n        if (widthHint && heightHint) {\n            outWidth = widthHint;\n            outHeight = heightHint;\n        }\n        else if (widthHint && aspect) {\n            outWidth = widthHint;\n            outHeight = Math.max(1, Math.round(widthHint / aspect));\n        }\n        else if (heightHint && aspect) {\n            outHeight = heightHint;\n            outWidth = Math.max(1, Math.round(heightHint * aspect));\n        }\n        else if (intrinsicWidth) {\n            outWidth = Math.min(intrinsicWidth, 400);\n            if (aspect)\n                outHeight = Math.max(1, Math.round(outWidth / aspect));\n        }\n        else {\n            outWidth = 200;\n        }\n        // Create a paragraph with just the image, no hyperlink\n        return [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.ImageRun({\n                        data,\n                        transformation: outHeight\n                            ? { width: outWidth, height: outHeight }\n                            : { width: outWidth, height: 1 },\n                        type: imageType,\n                    }),\n                ],\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                spacing: {\n                    before: style.paragraphSpacing,\n                    after: style.paragraphSpacing,\n                },\n            }),\n        ];\n    }\n    catch (error) {\n        console.error(\"Error in processImage:\", error);\n        console.error(\"Error stack:\", error instanceof Error ? error.stack : \"No stack available\");\n        return [\n            new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                children: [\n                    new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                        text: `[Image could not be displayed: ${altText}]`,\n                        italics: true,\n                        color: \"FF0000\",\n                    }),\n                ],\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n            }),\n        ];\n    }\n}\n/**\n * Processes a paragraph and returns appropriate paragraph formatting\n * @param text - The paragraph text\n * @param style - The style configuration\n * @returns The processed paragraph\n */\nfunction processParagraph(text, style) {\n    // Use processFormattedText to handle all inline formatting\n    const textRuns = processFormattedText(text, style);\n    // Default alignment uses direct enum value\n    const alignment = style.paragraphAlignment\n        ? style.paragraphAlignment === \"CENTER\"\n            ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER\n            : style.paragraphAlignment === \"RIGHT\"\n                ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.RIGHT\n                : style.paragraphAlignment === \"JUSTIFIED\"\n                    ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.JUSTIFIED\n                    : docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT\n        : docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT;\n    // Only apply indent for justified text\n    const indent = style.paragraphAlignment === \"JUSTIFIED\"\n        ? { left: 0, right: 0 }\n        : undefined;\n    return new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n        children: textRuns,\n        spacing: {\n            before: style.paragraphSpacing,\n            after: style.paragraphSpacing,\n            line: style.lineSpacing * 240,\n        },\n        alignment,\n        indent,\n        bidirectional: style.direction === \"RTL\",\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vaHRhc2hhbS9tZC10by1kb2N4L2Rpc3QvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNLO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvREFBb0QsRUFBRSxlQUFlO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDLEdBQUcsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQWE7QUFDakM7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBYTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJDQUFTO0FBQ25DO0FBQ0EsZ0JBQWdCLDBDQUFRO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7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LGVBQWUsMkNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZC10by1kb2N4Ly4vbm9kZV9tb2R1bGVzL0Btb2h0YXNoYW0vbWQtdG8tZG9jeC9kaXN0L2hlbHBlcnMuanM/MzcyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJhZ3JhcGgsIFRleHRSdW4sIFRhYmxlLCBUYWJsZVJvdywgVGFibGVDZWxsLCBBbGlnbm1lbnRUeXBlLCBCb3JkZXJTdHlsZSwgVGFibGVMYXlvdXRUeXBlLCBXaWR0aFR5cGUsIEV4dGVybmFsSHlwZXJsaW5rLCBJbWFnZVJ1biwgQm9va21hcmssIH0gZnJvbSBcImRvY3hcIjtcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzYW5pdGl6ZSB0ZXh0IGZvciB1c2UgaW4gYm9va21hcmsgSURzXG5mdW5jdGlvbiBzYW5pdGl6ZUZvckJvb2ttYXJrSWQodGV4dCkge1xuICAgIC8vIFJlbW92ZSBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgKGV4Y2VwdCB1bmRlcnNjb3JlcyksIHJlcGxhY2Ugc3BhY2VzIHdpdGggdW5kZXJzY29yZXNcbiAgICAvLyBFbnN1cmUgaXQgc3RhcnRzIHdpdGggYSBsZXR0ZXIgb3IgdW5kZXJzY29yZVxuICAgIGxldCBzYW5pdGl6ZWQgPSB0ZXh0LnJlcGxhY2UoL1teYS16QS1aMC05X1xcc10vZywgXCJcIikucmVwbGFjZSgvXFxzKy9nLCBcIl9cIik7XG4gICAgaWYgKCEvXlthLXpBLVpfXS8udGVzdChzYW5pdGl6ZWQpKSB7XG4gICAgICAgIHNhbml0aXplZCA9IFwiX1wiICsgc2FuaXRpemVkO1xuICAgIH1cbiAgICAvLyBUcnVuY2F0ZSBpZiBuZWNlc3NhcnkgKFdvcmQgaGFzIGxpbWl0cywgdGhvdWdoIHVzdWFsbHkgZ2VuZXJvdXMpXG4gICAgcmV0dXJuIHNhbml0aXplZC5zdWJzdHJpbmcoMCwgNDApO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBoZWFkaW5nIGxpbmUgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmcgYW5kIGEgYm9va21hcmsgSURcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGhlYWRpbmcgbGluZSB0byBwcm9jZXNzXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGhlYWRpbmcgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBkb2N1bWVudFR5cGUgLSBUaGUgZG9jdW1lbnQgdHlwZVxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGggYW5kIGl0cyBib29rbWFyayBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0hlYWRpbmcobGluZSwgY29uZmlnLCBzdHlsZSwgZG9jdW1lbnRUeXBlKSB7XG4gICAgY29uc3QgaGVhZGluZ1RleHQgPSBsaW5lLnJlcGxhY2UobmV3IFJlZ0V4cChgXiN7JHtjb25maWcubGV2ZWx9fSBgKSwgXCJcIik7XG4gICAgY29uc3QgaGVhZGluZ0xldmVsID0gY29uZmlnLmxldmVsO1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGJvb2ttYXJrIElEIHVzaW5nIHRoZSBjbGVhbiB0ZXh0ICh3aXRob3V0IG1hcmtkb3duKVxuICAgIGNvbnN0IGNsZWFuVGV4dEZvckJvb2ttYXJrID0gaGVhZGluZ1RleHRcbiAgICAgICAgLnJlcGxhY2UoL1xcKlxcKi9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiXCIpO1xuICAgIGNvbnN0IGJvb2ttYXJrSWQgPSBgX1RvY18ke3Nhbml0aXplRm9yQm9va21hcmtJZChjbGVhblRleHRGb3JCb29rbWFyayl9XyR7RGF0ZS5ub3coKX1gO1xuICAgIC8vIEdldCB0aGUgYXBwcm9wcmlhdGUgZm9udCBzaXplIGJhc2VkIG9uIGhlYWRpbmcgbGV2ZWwgYW5kIGN1c3RvbSBzdHlsZVxuICAgIGxldCBoZWFkaW5nU2l6ZSA9IHN0eWxlLnRpdGxlU2l6ZTtcbiAgICAvLyBVc2Ugc3BlY2lmaWMgaGVhZGluZyBzaXplIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY2FsY3VsYXRlIGJhc2VkIG9uIGxldmVsXG4gICAgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMSAmJiBzdHlsZS5oZWFkaW5nMVNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nMVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMiAmJiBzdHlsZS5oZWFkaW5nMlNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nMlNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMyAmJiBzdHlsZS5oZWFkaW5nM1NpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nM1NpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gNCAmJiBzdHlsZS5oZWFkaW5nNFNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nNFNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gNSAmJiBzdHlsZS5oZWFkaW5nNVNpemUpIHtcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS5oZWFkaW5nNVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA+IDEpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgY2FsY3VsYXRpb24gaWYgc3BlY2lmaWMgc2l6ZSBub3QgcHJvdmlkZWRcbiAgICAgICAgaGVhZGluZ1NpemUgPSBzdHlsZS50aXRsZVNpemUgLSAoaGVhZGluZ0xldmVsIC0gMSkgKiA0O1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgYWxpZ25tZW50IGJhc2VkIG9uIGhlYWRpbmcgbGV2ZWxcbiAgICBsZXQgYWxpZ25tZW50O1xuICAgIC8vIENoZWNrIGZvciBsZXZlbC1zcGVjaWZpYyBhbGlnbm1lbnQgZmlyc3RcbiAgICBpZiAoaGVhZGluZ0xldmVsID09PSAxICYmIHN0eWxlLmhlYWRpbmcxQWxpZ25tZW50KSB7XG4gICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGVbc3R5bGUuaGVhZGluZzFBbGlnbm1lbnRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWFkaW5nTGV2ZWwgPT09IDIgJiYgc3R5bGUuaGVhZGluZzJBbGlnbm1lbnQpIHtcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nMkFsaWdubWVudF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGhlYWRpbmdMZXZlbCA9PT0gMyAmJiBzdHlsZS5oZWFkaW5nM0FsaWdubWVudCkge1xuICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlW3N0eWxlLmhlYWRpbmczQWxpZ25tZW50XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGVhZGluZ0xldmVsID09PSA0ICYmIHN0eWxlLmhlYWRpbmc0QWxpZ25tZW50KSB7XG4gICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGVbc3R5bGUuaGVhZGluZzRBbGlnbm1lbnRdO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWFkaW5nTGV2ZWwgPT09IDUgJiYgc3R5bGUuaGVhZGluZzVBbGlnbm1lbnQpIHtcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nNUFsaWdubWVudF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0eWxlLmhlYWRpbmdBbGlnbm1lbnQpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZ2VuZXJhbCBoZWFkaW5nIGFsaWdubWVudCBpZiBubyBsZXZlbC1zcGVjaWZpYyBhbGlnbm1lbnRcbiAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZVtzdHlsZS5oZWFkaW5nQWxpZ25tZW50XTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyB0aGUgaGVhZGluZyB0ZXh0IHRvIGhhbmRsZSBtYXJrZG93biBmb3JtYXR0aW5nIChib2xkL2l0YWxpYylcbiAgICBjb25zdCBwcm9jZXNzZWRUZXh0UnVucyA9IHByb2Nlc3NGb3JtYXR0ZWRUZXh0Rm9ySGVhZGluZyhoZWFkaW5nVGV4dCwgaGVhZGluZ1NpemUsIHN0eWxlKTtcbiAgICAvLyBDcmVhdGUgdGhlIHBhcmFncmFwaCB3aXRoIGJvb2ttYXJrXG4gICAgY29uc3QgcGFyYWdyYXBoID0gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgQm9va21hcmsoe1xuICAgICAgICAgICAgICAgIGlkOiBib29rbWFya0lkLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBwcm9jZXNzZWRUZXh0UnVucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nTGV2ZWwsXG4gICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgIGJlZm9yZTogY29uZmlnLmxldmVsID09PSAxID8gc3R5bGUuaGVhZGluZ1NwYWNpbmcgKiAyIDogc3R5bGUuaGVhZGluZ1NwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUuaGVhZGluZ1NwYWNpbmcgLyAyLFxuICAgICAgICB9LFxuICAgICAgICBhbGlnbm1lbnQ6IGFsaWdubWVudCxcbiAgICAgICAgc3R5bGU6IGBIZWFkaW5nJHtoZWFkaW5nTGV2ZWx9YCwgLy8gVGhpcyBpcyBjcnVjaWFsIGZvciBUT0MgcmVjb2duaXRpb25cbiAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgIH0pO1xuICAgIHJldHVybiB7IHBhcmFncmFwaCwgYm9va21hcmtJZCB9O1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgZm9ybWF0dGVkIHRleHQgc3BlY2lmaWNhbGx5IGZvciBoZWFkaW5ncyAoYm9sZC9pdGFsaWMpIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFRleHRSdW4gb2JqZWN0c1xuICogQHBhcmFtIHRleHQgLSBUaGUgdGV4dCB0byBwcm9jZXNzXG4gKiBAcGFyYW0gZm9udFNpemUgLSBUaGUgZm9udCBzaXplIHRvIGFwcGx5XG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBUZXh0UnVuIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0Zvcm1hdHRlZFRleHRGb3JIZWFkaW5nKHRleHQsIGZvbnRTaXplLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHRSdW5zID0gW107XG4gICAgbGV0IGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICBsZXQgaXNCb2xkID0gZmFsc2U7XG4gICAgbGV0IGlzSXRhbGljID0gZmFsc2U7XG4gICAgLy8gVHJhY2sgdW5jbG9zZWQgbWFya2VycyB0byByZXNldCBhdCBlbmQgaWYgbmVlZGVkXG4gICAgbGV0IGJvbGRTdGFydCA9IC0xO1xuICAgIGxldCBpdGFsaWNTdGFydCA9IC0xO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBIYW5kbGUgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICh0ZXh0W2pdID09PSBcIlxcXFxcIiAmJiBqICsgMSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRleHRbaiArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHRDaGFyID09PSBcIipcIiB8fCBuZXh0Q2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dCArPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgICBqKys7IC8vIFNraXAgdGhlIGVzY2FwZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBub3QgYSByZWNvZ25pemVkIGVzY2FwZSBzZXF1ZW5jZSwgdHJlYXQgbm9ybWFsbHlcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IHRleHRbal07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYm9sZCB3aXRoICoqIG1hcmtlcnNcbiAgICAgICAgaWYgKGogKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dFtqXSA9PT0gXCIqXCIgJiYgdGV4dFtqICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAvLyBGbHVzaCBjdXJyZW50IHRleHQgYmVmb3JlIHRvZ2dsaW5nIGJvbGRcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGJvbGQgc3RhdGVcbiAgICAgICAgICAgIGlmICghaXNCb2xkKSB7XG4gICAgICAgICAgICAgICAgYm9sZFN0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvbGRTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNCb2xkID0gIWlzQm9sZDtcbiAgICAgICAgICAgIGorKzsgLy8gU2tpcCB0aGUgc2Vjb25kICpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpdGFsaWMgd2l0aCBzaW5nbGUgKiBtYXJrZXIgKGJ1dCBub3QgaWYgaXQncyBwYXJ0IG9mICoqKVxuICAgICAgICBpZiAodGV4dFtqXSA9PT0gXCIqXCIgJiZcbiAgICAgICAgICAgIChqID09PSAwIHx8IHRleHRbaiAtIDFdICE9PSBcIipcIikgJiZcbiAgICAgICAgICAgIChqID09PSB0ZXh0Lmxlbmd0aCAtIDEgfHwgdGV4dFtqICsgMV0gIT09IFwiKlwiKSkge1xuICAgICAgICAgICAgLy8gRmx1c2ggY3VycmVudCB0ZXh0IGJlZm9yZSB0b2dnbGluZyBpdGFsaWNcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGl0YWxpYyBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc0l0YWxpYykge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0l0YWxpYyA9ICFpc0l0YWxpYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IHRleHRcbiAgICAgICAgY3VycmVudFRleHQgKz0gdGV4dFtqXTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFueSByZW1haW5pbmcgdGV4dFxuICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHVuY2xvc2VkIG1hcmtlcnMsIHRyZWF0IHRoZW0gYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgIGlmIChpc0JvbGQgJiYgYm9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgKiogYmFjayBpbnRvIHRoZSB0ZXh0IGFuZCB0dXJuIG9mZiBib2xkXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVCb2xkID0gY3VycmVudFRleHQ7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiKipcIiArIGJlZm9yZUJvbGQ7XG4gICAgICAgICAgICBpc0JvbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGFsaWMgJiYgaXRhbGljU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSAqIGJhY2sgaW50byB0aGUgdGV4dCBhbmQgdHVybiBvZmYgaXRhbGljXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVJdGFsaWMgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCIqXCIgKyBiZWZvcmVJdGFsaWM7XG4gICAgICAgICAgICBpc0l0YWxpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgYWRkIG5vbi1lbXB0eSB0ZXh0IHJ1bnNcbiAgICAgICAgaWYgKGN1cnJlbnRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgdGV4dFJ1bnMucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgIGl0YWxpY3M6IGlzSXRhbGljLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBzdHlsZT8uZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIG5vIHRleHQgcnVucyB3ZXJlIGNyZWF0ZWQsIHJldHVybiBhIHNpbmdsZSBlbXB0eSBydW4gdG8gYXZvaWQgZW1wdHkgcGFyYWdyYXBoc1xuICAgIGlmICh0ZXh0UnVucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGV4dFJ1bnMucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICBzaXplOiBmb250U2l6ZSxcbiAgICAgICAgICAgIGJvbGQ6IHRydWUsIC8vIEhlYWRpbmdzIGFyZSBib2xkIGJ5IGRlZmF1bHRcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dFJ1bnM7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIHRhYmxlIGFuZCByZXR1cm5zIHRhYmxlIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0YWJsZURhdGEgLSBUaGUgdGFibGUgZGF0YVxuICogQHBhcmFtIGRvY3VtZW50VHlwZSAtIFRoZSBkb2N1bWVudCB0eXBlXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHRhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVGFibGUodGFibGVEYXRhLCBkb2N1bWVudFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlKHtcbiAgICAgICAgd2lkdGg6IHsgc2l6ZTogMTAwLCB0eXBlOiBXaWR0aFR5cGUuUEVSQ0VOVEFHRSB9LFxuICAgICAgICByb3dzOiBbXG4gICAgICAgICAgICBuZXcgVGFibGVSb3coe1xuICAgICAgICAgICAgICAgIHRhYmxlSGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB0YWJsZURhdGEuaGVhZGVycy5tYXAoKGhlYWRlcikgPT4gbmV3IFRhYmxlQ2VsbCh7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcIlN0cm9uZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBkb2N1bWVudFR5cGUgPT09IFwicmVwb3J0XCIgPyBcIkRERERERFwiIDogXCJGMkYyRjJcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC4uLnRhYmxlRGF0YS5yb3dzLm1hcCgocm93KSA9PiBuZXcgVGFibGVSb3coe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiByb3cubWFwKChjZWxsKSA9PiBuZXcgVGFibGVDZWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgXSxcbiAgICAgICAgbGF5b3V0OiBUYWJsZUxheW91dFR5cGUuRklYRUQsXG4gICAgICAgIG1hcmdpbnM6IHtcbiAgICAgICAgICAgIHRvcDogMTAwLFxuICAgICAgICAgICAgYm90dG9tOiAxMDAsXG4gICAgICAgICAgICBsZWZ0OiAxMDAsXG4gICAgICAgICAgICByaWdodDogMTAwLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsaXN0IGl0ZW0gYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgbGlzdCBpdGVtIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xpc3RJdGVtKGNvbmZpZywgc3R5bGUpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSBjb25maWcudGV4dDtcbiAgICAvLyBQcm9jZXNzIHRoZSBtYWluIHRleHQgd2l0aCBmb3JtYXR0aW5nXG4gICAgY29uc3QgY2hpbGRyZW4gPSBwcm9jZXNzRm9ybWF0dGVkVGV4dCh0ZXh0Q29udGVudCwgc3R5bGUpO1xuICAgIC8vIElmIHRoZXJlJ3MgYm9sZCB0ZXh0IG9uIHRoZSBuZXh0IGxpbmUsIGFkZCBpdCB3aXRoIGEgbGluZSBicmVha1xuICAgIGlmIChjb25maWcuYm9sZFRleHQpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICB0ZXh0OiBcIlxcblwiLFxuICAgICAgICAgICAgc2l6ZTogc3R5bGUubGlzdEl0ZW1TaXplIHx8IDI0LFxuICAgICAgICB9KSwgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgdGV4dDogY29uZmlnLmJvbGRUZXh0LFxuICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgc2l6ZTogc3R5bGUubGlzdEl0ZW1TaXplIHx8IDI0LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFVzZSBkaWZmZXJlbnQgZm9ybWF0dGluZyBmb3IgbnVtYmVyZWQgdnMgYnVsbGV0IGxpc3RzXG4gICAgaWYgKGNvbmZpZy5pc051bWJlcmVkKSB7XG4gICAgICAgIC8vIFVzZSBudW1iZXJpbmcgZm9yIG51bWJlcmVkIGxpc3RzIHdpdGggdW5pcXVlIHJlZmVyZW5jZSBwZXIgc2VxdWVuY2VcbiAgICAgICAgY29uc3QgbnVtYmVyaW5nUmVmZXJlbmNlID0gYG51bWJlcmVkLWxpc3QtJHtjb25maWcuc2VxdWVuY2VJZCB8fCAxfWA7XG4gICAgICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgbnVtYmVyaW5nOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBudW1iZXJpbmdSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogc3R5bGUucGFyYWdyYXBoU3BhY2luZyAvIDIsXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcgLyAyLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVc2UgYnVsbGV0IGZvcm1hdHRpbmcgZm9yIGJ1bGxldCBsaXN0c1xuICAgICAgICByZXR1cm4gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGJ1bGxldDoge1xuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcgLyAyLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nIC8gMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgYmxvY2txdW90ZSBhbmQgcmV0dXJucyBhcHByb3ByaWF0ZSBwYXJhZ3JhcGggZm9ybWF0dGluZ1xuICogQHBhcmFtIHRleHQgLSBUaGUgYmxvY2txdW90ZSB0ZXh0XG4gKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgVGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NCbG9ja3F1b3RlKHRleHQsIHN0eWxlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGFsaWdubWVudCBmb3IgYmxvY2txdW90ZSAtIG9ubHkgaWYgZXhwbGljaXRseSBzZXRcbiAgICBsZXQgYWxpZ25tZW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChzdHlsZS5ibG9ja3F1b3RlQWxpZ25tZW50KSB7XG4gICAgICAgIHN3aXRjaCAoc3R5bGUuYmxvY2txdW90ZUFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSBcIkxFRlRcIjpcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLkxFRlQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQ0VOVEVSXCI6XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50ID0gQWxpZ25tZW50VHlwZS5DRU5URVI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUklHSFRcIjpcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSBBbGlnbm1lbnRUeXBlLlJJR0hUO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkpVU1RJRklFRFwiOlxuICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IEFsaWdubWVudFR5cGUuSlVTVElGSUVEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzZXQgYWxpZ25tZW50IGlmIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgaXRhbGljczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS5ibG9ja3F1b3RlU2l6ZSB8fCAyNCwgLy8gVXNlIGN1c3RvbSBibG9ja3F1b3RlIHNpemUgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgbGVmdDogNzIwLCAvLyAwLjUgaW5jaCBpbmRlbnRcbiAgICAgICAgfSxcbiAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgbGVmdDoge1xuICAgICAgICAgICAgICAgIHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsXG4gICAgICAgICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJBQUFBQUFcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFsaWdubWVudDogYWxpZ25tZW50LFxuICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgfSk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIGNvbW1lbnQgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIGNvbW1lbnQgdGV4dFxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIFRoZSBwcm9jZXNzZWQgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzQ29tbWVudCh0ZXh0LCBzdHlsZSkge1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIkNvbW1lbnQ6IFwiICsgdGV4dCxcbiAgICAgICAgICAgICAgICBpdGFsaWNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIjY2NjY2NlwiLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgIGJlZm9yZTogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgIGFmdGVyOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgZm9ybWF0dGVkIHRleHQgKGJvbGQvaXRhbGljL2lubGluZS1jb2RlL2xpbmtzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBUZXh0UnVuIG9yIEV4dGVybmFsSHlwZXJsaW5rIG9iamVjdHNcbiAqIEBwYXJhbSBsaW5lIC0gVGhlIGxpbmUgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFRleHRSdW4gb3IgRXh0ZXJuYWxIeXBlcmxpbmsgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0Zvcm1hdHRlZFRleHQobGluZSwgc3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UnVucyA9IFtdO1xuICAgIGxldCBjdXJyZW50VGV4dCA9IFwiXCI7XG4gICAgbGV0IGlzQm9sZCA9IGZhbHNlO1xuICAgIGxldCBpc0l0YWxpYyA9IGZhbHNlO1xuICAgIGxldCBpc0lubGluZUNvZGUgPSBmYWxzZTtcbiAgICAvLyBUcmFjayB1bmNsb3NlZCBtYXJrZXJzIHRvIHJlc2V0IGF0IGVuZCBpZiBuZWVkZWRcbiAgICBsZXQgYm9sZFN0YXJ0ID0gLTE7XG4gICAgbGV0IGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiXFxcXFwiICYmIGogKyAxIDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gbGluZVtqICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dENoYXIgPT09IFwiKlwiIHx8IG5leHRDaGFyID09PSBcImBcIiB8fCBuZXh0Q2hhciA9PT0gXCJcXFxcXCIgfHwgbmV4dENoYXIgPT09IFwiW1wiIHx8IG5leHRDaGFyID09PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ICs9IG5leHRDaGFyO1xuICAgICAgICAgICAgICAgIGorKzsgLy8gU2tpcCB0aGUgZXNjYXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vdCBhIHJlY29nbml6ZWQgZXNjYXBlIHNlcXVlbmNlLCB0cmVhdCBub3JtYWxseVxuICAgICAgICAgICAgY3VycmVudFRleHQgKz0gbGluZVtqXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBpbmxpbmUgbGlua3MgW3RleHRdKHVybCkgLSBvbmx5IHdoZW4gbm90IGluIGlubGluZSBjb2RlXG4gICAgICAgIGlmICghaXNJbmxpbmVDb2RlICYmIGxpbmVbal0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBjbG9zaW5nIF0gYW5kIHRoZW4gKHVybClcbiAgICAgICAgICAgIGxldCBjbG9zZUJyYWNrZXQgPSAtMTtcbiAgICAgICAgICAgIGxldCBvcGVuUGFyZW4gPSAtMTtcbiAgICAgICAgICAgIGxldCBjbG9zZVBhcmVuID0gLTE7XG4gICAgICAgICAgICAvLyBGaW5kIGNsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgZm9yIChsZXQgayA9IGogKyAxOyBrIDwgbGluZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lW2tdID09PSBcIlxcXFxcIiAmJiBrICsgMSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKzsgLy8gU2tpcCBlc2NhcGVkIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVba10gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlQnJhY2tldCA9IGs7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGNsb3NpbmcgYnJhY2tldCwgbG9vayBmb3IgKHVybClcbiAgICAgICAgICAgIGlmIChjbG9zZUJyYWNrZXQgPiBqICYmIGNsb3NlQnJhY2tldCArIDEgPCBsaW5lLmxlbmd0aCAmJiBsaW5lW2Nsb3NlQnJhY2tldCArIDFdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIG9wZW5QYXJlbiA9IGNsb3NlQnJhY2tldCArIDE7XG4gICAgICAgICAgICAgICAgLy8gRmluZCBjbG9zaW5nIHBhcmVuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IG9wZW5QYXJlbiArIDE7IGsgPCBsaW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lW2tdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VQYXJlbiA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgY29tcGxldGUgbGluayBwYXR0ZXJuXG4gICAgICAgICAgICBpZiAoY2xvc2VCcmFja2V0ID4gaiAmJiBvcGVuUGFyZW4gPiBjbG9zZUJyYWNrZXQgJiYgY2xvc2VQYXJlbiA+IG9wZW5QYXJlbikge1xuICAgICAgICAgICAgICAgIC8vIEZsdXNoIGN1cnJlbnQgdGV4dCBmaXJzdFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGN1cnJlbnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlPy5wYXJhZ3JhcGhTaXplIHx8IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGxpbmsgdGV4dCBhbmQgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgbGlua1RleHQgPSBsaW5lLnN1YnN0cmluZyhqICsgMSwgY2xvc2VCcmFja2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rVXJsID0gbGluZS5zdWJzdHJpbmcob3BlblBhcmVuICsgMSwgY2xvc2VQYXJlbik7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGh5cGVybGlua1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gobmV3IEV4dGVybmFsSHlwZXJsaW5rKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsaW5rVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwRkZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiBpc0l0YWxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBsaW5rOiBsaW5rVXJsLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRvIGFmdGVyIHRoZSBsaW5rXG4gICAgICAgICAgICAgICAgaiA9IGNsb3NlUGFyZW47XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlubGluZSBjb2RlIHdpdGggYmFja3RpY2tcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiYFwiICYmICFpc0lubGluZUNvZGUpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGlubGluZSBjb2RlIC0gZmx1c2ggY3VycmVudCB0ZXh0IGZpcnN0XG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzSW5saW5lQ29kZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVtqXSA9PT0gXCJgXCIgJiYgaXNJbmxpbmVDb2RlKSB7XG4gICAgICAgICAgICAvLyBFbmRpbmcgaW5saW5lIGNvZGVcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAgICAgICAgIHRleHRSdW5zLnB1c2gocHJvY2Vzc0lubGluZUNvZGUoY3VycmVudFRleHQsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNJbmxpbmVDb2RlID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgaW5saW5lIGNvZGUsIGp1c3QgYWNjdW11bGF0ZSB0ZXh0IChubyBmb3JtYXR0aW5nKVxuICAgICAgICBpZiAoaXNJbmxpbmVDb2RlKSB7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCArPSBsaW5lW2pdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGJvbGQgd2l0aCAqKiBtYXJrZXJzXG4gICAgICAgIGlmIChqICsgMSA8IGxpbmUubGVuZ3RoICYmIGxpbmVbal0gPT09IFwiKlwiICYmIGxpbmVbaiArIDFdID09PSBcIipcIikge1xuICAgICAgICAgICAgLy8gRmx1c2ggY3VycmVudCB0ZXh0IGJlZm9yZSB0b2dnbGluZyBib2xkXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvZ2dsZSBib2xkIHN0YXRlXG4gICAgICAgICAgICBpZiAoIWlzQm9sZCkge1xuICAgICAgICAgICAgICAgIGJvbGRTdGFydCA9IGo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2xkU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzQm9sZCA9ICFpc0JvbGQ7XG4gICAgICAgICAgICBqKys7IC8vIFNraXAgdGhlIHNlY29uZCAqXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaXRhbGljIHdpdGggc2luZ2xlICogbWFya2VyIChidXQgbm90IGlmIGl0J3MgcGFydCBvZiAqKilcbiAgICAgICAgaWYgKGxpbmVbal0gPT09IFwiKlwiICYmXG4gICAgICAgICAgICAoaiA9PT0gMCB8fCBsaW5lW2ogLSAxXSAhPT0gXCIqXCIpICYmXG4gICAgICAgICAgICAoaiA9PT0gbGluZS5sZW5ndGggLSAxIHx8IGxpbmVbaiArIDFdICE9PSBcIipcIikpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIGN1cnJlbnQgdGV4dCBiZWZvcmUgdG9nZ2xpbmcgaXRhbGljXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY3VycmVudFRleHQsXG4gICAgICAgICAgICAgICAgICAgIGJvbGQ6IGlzQm9sZCxcbiAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSB8fCAyNCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGl0YWxpYyBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc0l0YWxpYykge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0YWxpY1N0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0l0YWxpYyA9ICFpc0l0YWxpYztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBjdXJyZW50IHRleHRcbiAgICAgICAgY3VycmVudFRleHQgKz0gbGluZVtqXTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFueSByZW1haW5pbmcgdGV4dFxuICAgIGlmIChjdXJyZW50VGV4dCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHVuY2xvc2VkIG1hcmtlcnMsIHRyZWF0IHRoZW0gYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgIGlmIChpc0JvbGQgJiYgYm9sZFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgKiogYmFjayBpbnRvIHRoZSB0ZXh0IGFuZCB0dXJuIG9mZiBib2xkXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVCb2xkID0gY3VycmVudFRleHQ7XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiKipcIiArIGJlZm9yZUJvbGQ7XG4gICAgICAgICAgICBpc0JvbGQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGFsaWMgJiYgaXRhbGljU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSAqIGJhY2sgaW50byB0aGUgdGV4dCBhbmQgdHVybiBvZmYgaXRhbGljXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVJdGFsaWMgPSBjdXJyZW50VGV4dDtcbiAgICAgICAgICAgIGN1cnJlbnRUZXh0ID0gXCIqXCIgKyBiZWZvcmVJdGFsaWM7XG4gICAgICAgICAgICBpc0l0YWxpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0lubGluZUNvZGUpIHtcbiAgICAgICAgICAgIC8vIFVuY2xvc2VkIGlubGluZSBjb2RlIC0gdHJlYXQgYXMgbGl0ZXJhbCB0ZXh0XG4gICAgICAgICAgICBjdXJyZW50VGV4dCA9IFwiYFwiICsgY3VycmVudFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhZGQgbm9uLWVtcHR5IHRleHQgcnVuc1xuICAgICAgICBpZiAoY3VycmVudFRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBjdXJyZW50VGV4dCxcbiAgICAgICAgICAgICAgICBib2xkOiBpc0JvbGQsXG4gICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgc2l6ZTogc3R5bGU/LnBhcmFncmFwaFNpemUgfHwgMjQsXG4gICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlPy5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgbm8gdGV4dCBydW5zIHdlcmUgY3JlYXRlZCwgcmV0dXJuIGEgc2luZ2xlIGVtcHR5IHJ1biB0byBhdm9pZCBlbXB0eSBwYXJhZ3JhcGhzXG4gICAgaWYgKHRleHRSdW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0ZXh0UnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgIHNpemU6IHN0eWxlPy5wYXJhZ3JhcGhTaXplIHx8IDI0LFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0UnVucztcbn1cbi8qKlxuICogQ29sbGVjdHMgdGFibGVzIGZyb20gbWFya2Rvd24gbGluZXNcbiAqIEBwYXJhbSBsaW5lcyAtIFRoZSBtYXJrZG93biBsaW5lc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGFibGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdFRhYmxlcyhsaW5lcykge1xuICAgIGNvbnN0IHRhYmxlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aChcInxcIikpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBzZXBhcmF0b3Igcm93IHdpdGggcHJvcGVyIHJlZ2V4XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBsaW5lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAvXlxccypcXHwoPzpcXHMqOj8tKzo/XFxzKlxcfCkrXFxzKiQvLnRlc3QobGluZXNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGVtcHR5IGNlbGxzIGJ5IHNsaWNpbmcgb2ZmIGxlYWRpbmcvdHJhaWxpbmcgcGlwZSBhbmQgc3BsaXR0aW5nXG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcfC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHwkLywgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwifFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChoKSA9PiBoLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSArIDI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsaW5lcy5sZW5ndGggJiYgbGluZXNbal0udHJpbSgpLnN0YXJ0c1dpdGgoXCJ8XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGxpbmVzW2pdXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcfC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx8JC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoXCJ8XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjZWxsKSA9PiBjZWxsLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlcy5wdXNoKHsgaGVhZGVycywgcm93cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGVzO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgaW5saW5lIGNvZGUgYW5kIHJldHVybnMgYSBUZXh0UnVuIG9iamVjdFxuICogQHBhcmFtIGNvZGUgLSBUaGUgaW5saW5lIGNvZGUgdGV4dFxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIEEgVGV4dFJ1biBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NJbmxpbmVDb2RlKGNvZGUsIHN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgdGV4dDogY29kZSxcbiAgICAgICAgZm9udDogXCJDb3VyaWVyIE5ld1wiLFxuICAgICAgICBzaXplOiBzdHlsZT8ucGFyYWdyYXBoU2l6ZSA/IHN0eWxlLnBhcmFncmFwaFNpemUgLSAyIDogMjAsXG4gICAgICAgIGNvbG9yOiBcIjQ0NDQ0NFwiLFxuICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICBmaWxsOiBcIkY1RjVGNVwiLFxuICAgICAgICB9LFxuICAgICAgICByaWdodFRvTGVmdDogc3R5bGU/LmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICB9KTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgY29kZSBibG9jayBhbmQgcmV0dXJucyBhcHByb3ByaWF0ZSBwYXJhZ3JhcGggZm9ybWF0dGluZ1xuICogQHBhcmFtIGNvZGUgLSBUaGUgY29kZSBibG9jayB0ZXh0XG4gKiBAcGFyYW0gbGFuZ3VhZ2UgLSBUaGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgKG9wdGlvbmFsKVxuICogQHBhcmFtIHN0eWxlIC0gVGhlIHN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIFRoZSBwcm9jZXNzZWQgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzQ29kZUJsb2NrKGNvZGUsIGxhbmd1YWdlLCBzdHlsZSkge1xuICAgIC8vIFNwbGl0IHRoZSBjb2RlIGludG8gbGluZXMgYW5kIHByb2Nlc3MgZWFjaCBsaW5lXG4gICAgY29uc3QgbGluZXMgPSBjb2RlLnNwbGl0KFwiXFxuXCIpO1xuICAgIC8vIENyZWF0ZSB0ZXh0IHJ1bnMgZm9yIGVhY2ggbGluZVxuICAgIGNvbnN0IGNvZGVSdW5zID0gW107XG4gICAgLy8gQWRkIGxhbmd1YWdlIGluZGljYXRvciBpZiBwcmVzZW50XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgIGNvZGVSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgdGV4dDogbGFuZ3VhZ2UsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDE4LFxuICAgICAgICAgICAgY29sb3I6IFwiNjY2NjY2XCIsXG4gICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgfSksIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDE4LFxuICAgICAgICAgICAgYnJlYWs6IDEsXG4gICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgZWFjaCBsaW5lXG4gICAgbGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gUHJlc2VydmUgbGVhZGluZyBzcGFjZXMgYnkgY29udmVydGluZyB0aGVtIHRvIG5vbi1icmVha2luZyBzcGFjZXNcbiAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlcyA9IGxpbmUubWF0Y2goL15cXHMqLyk/LlswXS5sZW5ndGggfHwgMDtcbiAgICAgICAgY29uc3QgbGVhZGluZ05ic3AgPSBcIlxcdTAwQTBcIi5yZXBlYXQobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZExpbmUgPSBsZWFkaW5nTmJzcCArIGxpbmUuc2xpY2UobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgIC8vIEFkZCB0aGUgbGluZVxuICAgICAgICBjb2RlUnVucy5wdXNoKG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgIHRleHQ6IHByb2Nlc3NlZExpbmUsXG4gICAgICAgICAgICBmb250OiBcIkNvdXJpZXIgTmV3XCIsXG4gICAgICAgICAgICBzaXplOiBzdHlsZS5jb2RlQmxvY2tTaXplIHx8IDIwLFxuICAgICAgICAgICAgY29sb3I6IFwiNDQ0NDQ0XCIsXG4gICAgICAgICAgICByaWdodFRvTGVmdDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEFkZCBsaW5lIGJyZWFrIGlmIG5vdCB0aGUgbGFzdCBsaW5lXG4gICAgICAgIGlmIChpbmRleCA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvZGVSdW5zLnB1c2gobmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXFxuXCIsXG4gICAgICAgICAgICAgICAgZm9udDogXCJDb3VyaWVyIE5ld1wiLFxuICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLmNvZGVCbG9ja1NpemUgfHwgMjAsXG4gICAgICAgICAgICAgICAgYnJlYWs6IDEsXG4gICAgICAgICAgICAgICAgcmlnaHRUb0xlZnQ6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IGNvZGVSdW5zLFxuICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxpbmUgc3BhY2luZyBleGFjdGx5XG4gICAgICAgICAgICBsaW5lOiAzNjAsXG4gICAgICAgICAgICBsaW5lUnVsZTogXCJleGFjdFwiLFxuICAgICAgICB9LFxuICAgICAgICBzaGFkaW5nOiB7XG4gICAgICAgICAgICBmaWxsOiBcIkY1RjVGNVwiLFxuICAgICAgICB9LFxuICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgIHRvcDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCJERERERERcIiB9LFxuICAgICAgICAgICAgYm90dG9tOiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIkRERERERFwiIH0sXG4gICAgICAgICAgICBsZWZ0OiB7IHN0eWxlOiBCb3JkZXJTdHlsZS5TSU5HTEUsIHNpemU6IDEsIGNvbG9yOiBcIkRERERERFwiIH0sXG4gICAgICAgICAgICByaWdodDogeyBzdHlsZTogQm9yZGVyU3R5bGUuU0lOR0xFLCBzaXplOiAxLCBjb2xvcjogXCJERERERERcIiB9LFxuICAgICAgICB9LFxuICAgICAgICAvLyBQcmVzZXJ2ZSBpbmRlbnRhdGlvblxuICAgICAgICBpbmRlbnQ6IHtcbiAgICAgICAgICAgIGxlZnQ6IDM2MCwgLy8gMC4yNSBpbmNoIGluZGVudCBmb3IgdGhlIGVudGlyZSBjb2RlIGJsb2NrXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIGxpbmsgYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgdGV4dCBydW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NMaW5rKHRleHQsIHVybCkge1xuICAgIHJldHVybiBuZXcgVGV4dFJ1bih7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGNvbG9yOiBcIjAwMDBGRlwiLFxuICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBsaW5rIGFuZCByZXR1cm5zIGEgcGFyYWdyYXBoIHdpdGggaHlwZXJsaW5rXG4gKiBAcGFyYW0gdGV4dCAtIFRoZSBsaW5rIHRleHRcbiAqIEBwYXJhbSB1cmwgLSBUaGUgbGluayBVUkxcbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaCB3aXRoIGh5cGVybGlua1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0xpbmtQYXJhZ3JhcGgodGV4dCwgdXJsLCBzdHlsZSkge1xuICAgIGNvbnN0IGh5cGVybGluayA9IG5ldyBFeHRlcm5hbEh5cGVybGluayh7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwRkZcIixcbiAgICAgICAgICAgICAgICB1bmRlcmxpbmU6IHsgdHlwZTogXCJzaW5nbGVcIiB9LFxuICAgICAgICAgICAgICAgIHJpZ2h0VG9MZWZ0OiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICAgICAgbGluazogdXJsLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtoeXBlcmxpbmtdLFxuICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgfSxcbiAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb21wdXRlcyBvdXRwdXQgaW1hZ2UgZGltZW5zaW9ucyBwcmVzZXJ2aW5nIGFzcGVjdCByYXRpby5cbiAqIC0gSWYgYm90aCBoaW50cyBwcm92aWRlZCwgdXNlcyB0aGVtIGRpcmVjdGx5LlxuICogLSBJZiBvbmUgaGludCBwcm92aWRlZCBhbmQgaW50cmluc2ljIGFzcGVjdCBrbm93biwgY29tcHV0ZXMgdGhlIG90aGVyLlxuICogLSBGYWxscyBiYWNrIHRvIGludHJpbnNpYyB3aWR0aCBjYXBwZWQgdG8gNDAwLCBvciBkZWZhdWx0IHdpZHRoIDIwMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZURpbWVuc2lvbnMod2lkdGhIaW50LCBoZWlnaHRIaW50LCBpbnRyaW5zaWNXaWR0aCwgaW50cmluc2ljSGVpZ2h0KSB7XG4gICAgbGV0IG91dFdpZHRoO1xuICAgIGxldCBvdXRIZWlnaHQ7XG4gICAgY29uc3QgYXNwZWN0ID0gaW50cmluc2ljV2lkdGggJiYgaW50cmluc2ljSGVpZ2h0XG4gICAgICAgID8gaW50cmluc2ljV2lkdGggLyBpbnRyaW5zaWNIZWlnaHRcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHdpZHRoSGludCAmJiBoZWlnaHRIaW50KSB7XG4gICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgIH1cbiAgICBlbHNlIGlmICh3aWR0aEhpbnQgJiYgYXNwZWN0KSB7XG4gICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHdpZHRoSGludCAvIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChoZWlnaHRIaW50ICYmIGFzcGVjdCkge1xuICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaGVpZ2h0SGludCAqIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbnRyaW5zaWNXaWR0aCkge1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGgubWluKGludHJpbnNpY1dpZHRoLCA0MDApO1xuICAgICAgICBpZiAoYXNwZWN0KVxuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChvdXRXaWR0aCAvIGFzcGVjdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0V2lkdGggPSAyMDA7XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoOiBvdXRXaWR0aCwgaGVpZ2h0OiBvdXRIZWlnaHQgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNpbXBsZSBsaW5rIHBhcmFncmFwaFxuICogQHBhcmFtIHRleHQgLSBUaGUgbGluayB0ZXh0XG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBsaW5rIHRvXG4gKiBAcmV0dXJucyBBIHBhcmFncmFwaCB3aXRoIGEgaHlwZXJsaW5rXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaW5rUGFyYWdyYXBoKHRleHQsIHVybCkge1xuICAgIHJldHVybiBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEh5cGVybGluayh7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDBGRlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJsaW5lOiB7IHR5cGU6IFwic2luZ2xlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBsaW5rOiB1cmwsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcbn1cbi8qKlxuICogUHJvY2Vzc2VzIGFuIGltYWdlIGFuZCByZXR1cm5zIGFwcHJvcHJpYXRlIHBhcmFncmFwaFxuICogQHBhcmFtIGFsdFRleHQgLSBUaGUgYWx0IHRleHRcbiAqIEBwYXJhbSBpbWFnZVVybCAtIFRoZSBpbWFnZSBVUkxcbiAqIEBwYXJhbSBzdHlsZSAtIFRoZSBzdHlsZSBjb25maWd1cmF0aW9uXG4gKiBAcmV0dXJucyBUaGUgcHJvY2Vzc2VkIHBhcmFncmFwaFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ltYWdlKGFsdFRleHQsIGltYWdlVXJsLCBzdHlsZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZGF0YSBVUkxzIHdpdGhvdXQgZmV0Y2ggYW5kIGV4dHJhY3QgcmF3IGRhdGEvY29udGVudC10eXBlXG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBcIlwiO1xuICAgICAgICBpZiAoL15kYXRhOi9pLnRlc3QoaW1hZ2VVcmwpKSB7XG4gICAgICAgICAgICAvLyBkYXRhOls8bWVkaWF0eXBlPl1bO2Jhc2U2NF0sPGRhdGE+XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGltYWdlVXJsLm1hdGNoKC9eZGF0YTooW147LF0qKSg7YmFzZTY0KT8sKC4qKSQvaSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3IgaW1hZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IG1hdGNoWzFdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBpc0Jhc2U2NCA9ICEhbWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCBkYXRhUGFydCA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gaXNCYXNlNjRcbiAgICAgICAgICAgICAgICA/IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAgPyBCdWZmZXIuZnJvbShkYXRhUGFydCwgXCJiYXNlNjRcIilcbiAgICAgICAgICAgICAgICAgICAgOiBVaW50OEFycmF5LmZyb20oYXRvYihkYXRhUGFydCksIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgID8gQnVmZmVyLmZyb20oZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFQYXJ0KSlcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGVjb2RlVVJJQ29tcG9uZW50KGRhdGFQYXJ0KSk7XG4gICAgICAgICAgICBkYXRhID0gYmluYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZVVybCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAvLyBVc2UgQnVmZmVyIGluIE5vZGUgZW52aXJvbm1lbnRzLCBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICAgICAgICBkYXRhID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgLy8gSW5mZXIgaW1hZ2UgdHlwZSBmcm9tIGNvbnRlbnQtdHlwZSBoZWFkZXIgb3IgVVJMIGV4dGVuc2lvblxuICAgICAgICAgICAgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbWFnZVR5cGUgPSBcInBuZ1wiO1xuICAgICAgICBpZiAoL2pwZWd8anBnL2kudGVzdChjb250ZW50VHlwZSkgfHwgL1xcLihqcGU/ZykoXFw/fCQpL2kudGVzdChpbWFnZVVybCkpIHtcbiAgICAgICAgICAgIGltYWdlVHlwZSA9IFwianBnXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL3BuZy9pLnRlc3QoY29udGVudFR5cGUpIHx8IC9cXC4ocG5nKShcXD98JCkvaS50ZXN0KGltYWdlVXJsKSkge1xuICAgICAgICAgICAgaW1hZ2VUeXBlID0gXCJwbmdcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvZ2lmL2kudGVzdChjb250ZW50VHlwZSkgfHwgL1xcLihnaWYpKFxcP3wkKS9pLnRlc3QoaW1hZ2VVcmwpKSB7XG4gICAgICAgICAgICBpbWFnZVR5cGUgPSBcImdpZlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIG9wdGlvbmFsIHdpZHRoL2hlaWdodCBoaW50cyBmcm9tIFVSTCBmcmFnbWVudFxuICAgICAgICBsZXQgd2lkdGhIaW50O1xuICAgICAgICBsZXQgaGVpZ2h0SGludDtcbiAgICAgICAgY29uc3QgaGFzaEluZGV4ID0gaW1hZ2VVcmwuaW5kZXhPZihcIiNcIik7XG4gICAgICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpbWFnZVVybC5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG4gICAgICAgICAgICAvLyBQYXR0ZXJuICM8d2lkdGg+eDxoZWlnaHQ+XG4gICAgICAgICAgICBjb25zdCB3eGggPSBmcmFnbWVudC5tYXRjaCgvXihcXGQrKXgoXFxkKykkLyk7XG4gICAgICAgICAgICBpZiAod3hoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGhIaW50ID0gcGFyc2VJbnQod3hoWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0SGludCA9IHBhcnNlSW50KHd4aFsyXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGF0dGVybiAjdz0xMjMmaD00NSBvciAjd2lkdGg9Li4maGVpZ2h0PS4uXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhmcmFnbWVudC5yZXBsYWNlKC8mYW1wOy9nLCBcIiZcIikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBwYXJhbXMuZ2V0KFwid1wiKSB8fCBwYXJhbXMuZ2V0KFwid2lkdGhcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IHBhcmFtcy5nZXQoXCJoXCIpIHx8IHBhcmFtcy5nZXQoXCJoZWlnaHRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHcgJiYgL15cXGQrJC8udGVzdCh3KSlcbiAgICAgICAgICAgICAgICAgICAgd2lkdGhIaW50ID0gcGFyc2VJbnQodywgMTApO1xuICAgICAgICAgICAgICAgIGlmIChoICYmIC9eXFxkKyQvLnRlc3QoaCkpXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodEhpbnQgPSBwYXJzZUludChoLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXh0cmFjdCBpbnRyaW5zaWMgZGltZW5zaW9ucyBhbmQgY29tcHV0ZSBvdXRwdXQgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRVaW50MTZCRShidWYsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIChidWZbb2Zmc2V0XSA8PCA4KSB8IGJ1ZltvZmZzZXQgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkVWludDMyQkUoYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKChidWZbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM10pID4+PlxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRyaW5zaWNXaWR0aDtcbiAgICAgICAgbGV0IGludHJpbnNpY0hlaWdodDtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRhdGEgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKGltYWdlVHlwZSA9PT0gXCJwbmdcIiAmJiBieXRlcy5sZW5ndGggPj0gMjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUG5nID0gYnl0ZXNbMF0gPT09IDB4ODkgJiZcbiAgICAgICAgICAgICAgICBieXRlc1sxXSA9PT0gMHg1MCAmJlxuICAgICAgICAgICAgICAgIGJ5dGVzWzJdID09PSAweDRlICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNbM10gPT09IDB4NDc7XG4gICAgICAgICAgICBpZiAoaXNQbmcpIHtcbiAgICAgICAgICAgICAgICBpbnRyaW5zaWNXaWR0aCA9IHJlYWRVaW50MzJCRShieXRlcywgMTYpO1xuICAgICAgICAgICAgICAgIGludHJpbnNpY0hlaWdodCA9IHJlYWRVaW50MzJCRShieXRlcywgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltYWdlVHlwZSA9PT0gXCJqcGdcIikge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDI7IC8vIHNraXAgU09JXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0ICsgOSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1tvZmZzZXRdICE9PSAweGZmKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBieXRlc1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkVWludDE2QkUoYnl0ZXMsIG9mZnNldCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDB4YzAgfHwgbWFya2VyID09PSAweGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpY0hlaWdodCA9IHJlYWRVaW50MTZCRShieXRlcywgb2Zmc2V0ICsgNSk7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpY1dpZHRoID0gcmVhZFVpbnQxNkJFKGJ5dGVzLCBvZmZzZXQgKyA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyICsgbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltYWdlVHlwZSA9PT0gXCJnaWZcIiAmJiBieXRlcy5sZW5ndGggPj0gMTApIHtcbiAgICAgICAgICAgIGludHJpbnNpY1dpZHRoID0gYnl0ZXNbNl0gfCAoYnl0ZXNbN10gPDwgOCk7XG4gICAgICAgICAgICBpbnRyaW5zaWNIZWlnaHQgPSBieXRlc1s4XSB8IChieXRlc1s5XSA8PCA4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0V2lkdGg7XG4gICAgICAgIGxldCBvdXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGFzcGVjdCA9IGludHJpbnNpY1dpZHRoICYmIGludHJpbnNpY0hlaWdodFxuICAgICAgICAgICAgPyBpbnRyaW5zaWNXaWR0aCAvIGludHJpbnNpY0hlaWdodFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh3aWR0aEhpbnQgJiYgaGVpZ2h0SGludCkge1xuICAgICAgICAgICAgb3V0V2lkdGggPSB3aWR0aEhpbnQ7XG4gICAgICAgICAgICBvdXRIZWlnaHQgPSBoZWlnaHRIaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpZHRoSGludCAmJiBhc3BlY3QpIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gd2lkdGhIaW50O1xuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZCh3aWR0aEhpbnQgLyBhc3BlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoZWlnaHRIaW50ICYmIGFzcGVjdCkge1xuICAgICAgICAgICAgb3V0SGVpZ2h0ID0gaGVpZ2h0SGludDtcbiAgICAgICAgICAgIG91dFdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChoZWlnaHRIaW50ICogYXNwZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW50cmluc2ljV2lkdGgpIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gTWF0aC5taW4oaW50cmluc2ljV2lkdGgsIDQwMCk7XG4gICAgICAgICAgICBpZiAoYXNwZWN0KVxuICAgICAgICAgICAgICAgIG91dEhlaWdodCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQob3V0V2lkdGggLyBhc3BlY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFdpZHRoID0gMjAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHBhcmFncmFwaCB3aXRoIGp1c3QgdGhlIGltYWdlLCBubyBoeXBlcmxpbmtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQYXJhZ3JhcGgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbWFnZVJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb246IG91dEhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyB3aWR0aDogb3V0V2lkdGgsIGhlaWdodDogb3V0SGVpZ2h0IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHsgd2lkdGg6IG91dFdpZHRoLCBoZWlnaHQ6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGltYWdlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogc3R5bGUucGFyYWdyYXBoU3BhY2luZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gcHJvY2Vzc0ltYWdlOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzdGFjazpcIiwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogXCJObyBzdGFjayBhdmFpbGFibGVcIik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgVGV4dFJ1bih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBgW0ltYWdlIGNvdWxkIG5vdCBiZSBkaXNwbGF5ZWQ6ICR7YWx0VGV4dH1dYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0YWxpY3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJGRjAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfVxufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSBwYXJhZ3JhcGggYW5kIHJldHVybnMgYXBwcm9wcmlhdGUgcGFyYWdyYXBoIGZvcm1hdHRpbmdcbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIHBhcmFncmFwaCB0ZXh0XG4gKiBAcGFyYW0gc3R5bGUgLSBUaGUgc3R5bGUgY29uZmlndXJhdGlvblxuICogQHJldHVybnMgVGhlIHByb2Nlc3NlZCBwYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NQYXJhZ3JhcGgodGV4dCwgc3R5bGUpIHtcbiAgICAvLyBVc2UgcHJvY2Vzc0Zvcm1hdHRlZFRleHQgdG8gaGFuZGxlIGFsbCBpbmxpbmUgZm9ybWF0dGluZ1xuICAgIGNvbnN0IHRleHRSdW5zID0gcHJvY2Vzc0Zvcm1hdHRlZFRleHQodGV4dCwgc3R5bGUpO1xuICAgIC8vIERlZmF1bHQgYWxpZ25tZW50IHVzZXMgZGlyZWN0IGVudW0gdmFsdWVcbiAgICBjb25zdCBhbGlnbm1lbnQgPSBzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnRcbiAgICAgICAgPyBzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnQgPT09IFwiQ0VOVEVSXCJcbiAgICAgICAgICAgID8gQWxpZ25tZW50VHlwZS5DRU5URVJcbiAgICAgICAgICAgIDogc3R5bGUucGFyYWdyYXBoQWxpZ25tZW50ID09PSBcIlJJR0hUXCJcbiAgICAgICAgICAgICAgICA/IEFsaWdubWVudFR5cGUuUklHSFRcbiAgICAgICAgICAgICAgICA6IHN0eWxlLnBhcmFncmFwaEFsaWdubWVudCA9PT0gXCJKVVNUSUZJRURcIlxuICAgICAgICAgICAgICAgICAgICA/IEFsaWdubWVudFR5cGUuSlVTVElGSUVEXG4gICAgICAgICAgICAgICAgICAgIDogQWxpZ25tZW50VHlwZS5MRUZUXG4gICAgICAgIDogQWxpZ25tZW50VHlwZS5MRUZUO1xuICAgIC8vIE9ubHkgYXBwbHkgaW5kZW50IGZvciBqdXN0aWZpZWQgdGV4dFxuICAgIGNvbnN0IGluZGVudCA9IHN0eWxlLnBhcmFncmFwaEFsaWdubWVudCA9PT0gXCJKVVNUSUZJRURcIlxuICAgICAgICA/IHsgbGVmdDogMCwgcmlnaHQ6IDAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IFBhcmFncmFwaCh7XG4gICAgICAgIGNoaWxkcmVuOiB0ZXh0UnVucyxcbiAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgYmVmb3JlOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgYWZ0ZXI6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICBsaW5lOiBzdHlsZS5saW5lU3BhY2luZyAqIDI0MCxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICB9KTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@mohtasham/md-to-docx/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MarkdownConversionError: () => (/* binding */ MarkdownConversionError),\n/* harmony export */   convertMarkdownToDocx: () => (/* binding */ convertMarkdownToDocx),\n/* harmony export */   downloadDocx: () => (/* binding */ downloadDocx),\n/* harmony export */   parseToDocxOptions: () => (/* binding */ parseToDocxOptions)\n/* harmony export */ });\n/* harmony import */ var docx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docx */ \"(ssr)/./node_modules/docx/dist/index.mjs\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"(ssr)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.js */ \"(ssr)/./node_modules/@mohtasham/md-to-docx/dist/types.js\");\n/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/@mohtasham/md-to-docx/dist/helpers.js\");\n\n\n\n\nconst defaultStyle = {\n    titleSize: 32,\n    headingSpacing: 240,\n    paragraphSpacing: 240,\n    lineSpacing: 1.15,\n    paragraphAlignment: \"LEFT\",\n    direction: \"LTR\",\n};\nconst defaultOptions = {\n    documentType: \"document\",\n    style: defaultStyle,\n};\n/**\n * Custom error class for markdown conversion errors\n * @extends Error\n * @param message - The error message\n * @param context - The context of the error\n */\nclass MarkdownConversionError extends Error {\n    constructor(message, context) {\n        super(message);\n        this.context = context;\n        this.name = \"MarkdownConversionError\";\n    }\n}\n/**\n * Validates markdown input and options\n * @throws {MarkdownConversionError} If input is invalid\n */\nfunction validateInput(markdown, options) {\n    if (!markdown || typeof markdown !== \"string\") {\n        throw new MarkdownConversionError(\"Invalid markdown input: Markdown must be a non-empty string\");\n    }\n    if (options.style) {\n        const { titleSize, headingSpacing, paragraphSpacing, lineSpacing } = options.style;\n        if (titleSize && (titleSize < 8 || titleSize > 72)) {\n            throw new MarkdownConversionError(\"Invalid title size: Must be between 8 and 72 points\", { titleSize });\n        }\n        if (headingSpacing && (headingSpacing < 0 || headingSpacing > 720)) {\n            throw new MarkdownConversionError(\"Invalid heading spacing: Must be between 0 and 720 twips\", { headingSpacing });\n        }\n        if (paragraphSpacing && (paragraphSpacing < 0 || paragraphSpacing > 720)) {\n            throw new MarkdownConversionError(\"Invalid paragraph spacing: Must be between 0 and 720 twips\", { paragraphSpacing });\n        }\n        if (lineSpacing && (lineSpacing < 1 || lineSpacing > 3)) {\n            throw new MarkdownConversionError(\"Invalid line spacing: Must be between 1 and 3\", { lineSpacing });\n        }\n    }\n}\n/**\n * Convert Markdown to Docx file\n * @param markdown - The Markdown string to convert\n * @param options - The options for the conversion\n * @returns A Promise that resolves to a Blob containing the Docx file\n * @throws {MarkdownConversionError} If conversion fails\n */\nasync function convertMarkdownToDocx(markdown, options = defaultOptions) {\n    try {\n        const docxOptions = await parseToDocxOptions(markdown, options);\n        // Create the document with appropriate settings\n        const doc = new docx__WEBPACK_IMPORTED_MODULE_0__.Document(docxOptions);\n        return await docx__WEBPACK_IMPORTED_MODULE_0__.Packer.toBlob(doc);\n    }\n    catch (error) {\n        if (error instanceof MarkdownConversionError) {\n            throw error;\n        }\n        throw new MarkdownConversionError(`Failed to convert markdown to docx: ${error instanceof Error ? error.message : \"Unknown error\"}`, { originalError: error });\n    }\n}\n/**\n * Convert Markdown to Docx options\n * @param markdown - The Markdown string to convert\n * @param options - The options for the conversion\n * @returns A Promise that resolves to a Blob containing the Docx file\n * @throws {MarkdownConversionError} If conversion fails\n */\nasync function parseToDocxOptions(markdown, options = defaultOptions) {\n    try {\n        // Validate inputs early\n        validateInput(markdown, options);\n        const { style = defaultStyle, documentType = \"document\" } = options;\n        const docChildren = [];\n        const headings = [];\n        const lines = markdown.split(\"\\n\");\n        let inList = false;\n        let listItems = [];\n        let currentListNumber = 1;\n        let isCurrentListNumbered = false;\n        let numberedListSequenceId = 0;\n        let inCodeBlock = false;\n        let codeBlockContent = \"\";\n        let codeBlockLanguage;\n        let tableIndex = 0;\n        const tables = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.collectTables)(lines);\n        for (let i = 0; i < lines.length; i++) {\n            try {\n                const line = lines[i];\n                const trimmedLine = line.trim();\n                // Skip empty lines\n                if (!trimmedLine) {\n                    if (inCodeBlock) {\n                        codeBlockContent += \"\\n\";\n                    }\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({}));\n                    continue;\n                }\n                // Handle Page Break\n                if (trimmedLine === \"\\\\pagebreak\") {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({ children: [new docx__WEBPACK_IMPORTED_MODULE_0__.PageBreak()] }));\n                    continue;\n                }\n                // Handle Markdown Separators (e.g., ---)\n                if (/^\\s*---\\s*$/.test(trimmedLine)) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    // Skip the separator line\n                    continue;\n                }\n                // Handle TOC Placeholder\n                if (trimmedLine === \"[TOC]\") {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    // Create a paragraph and add a unique property to identify it later\n                    const tocPlaceholder = new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({});\n                    tocPlaceholder.__isTocPlaceholder = true; // Add temporary marker property\n                    docChildren.push(tocPlaceholder);\n                    continue;\n                }\n                // Handle code blocks\n                if (trimmedLine.startsWith(\"```\")) {\n                    if (!inCodeBlock) {\n                        // Start of code block\n                        inCodeBlock = true;\n                        codeBlockLanguage = trimmedLine.slice(3).trim() || undefined;\n                        codeBlockContent = \"\";\n                    }\n                    else {\n                        // End of code block\n                        inCodeBlock = false;\n                        docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processCodeBlock)(codeBlockContent.trim(), codeBlockLanguage, style));\n                        codeBlockContent = \"\";\n                        codeBlockLanguage = undefined;\n                    }\n                    continue;\n                }\n                if (inCodeBlock) {\n                    codeBlockContent += (codeBlockContent ? \"\\n\" : \"\") + line;\n                    continue;\n                }\n                // Process headings\n                if (trimmedLine.startsWith(\"#\")) {\n                    const match = trimmedLine.match(/^#+/);\n                    if (match) {\n                        const level = match[0].length;\n                        if (level >= 1 && level <= 5) {\n                            if (inList) {\n                                docChildren.push(...listItems);\n                                listItems = [];\n                                inList = false;\n                            }\n                            const headingText = trimmedLine.substring(level).trim();\n                            const config = {\n                                ..._types_js__WEBPACK_IMPORTED_MODULE_2__.headingConfigs[level],\n                                alignment: _types_js__WEBPACK_IMPORTED_MODULE_2__.headingConfigs[level].alignment || style.headingAlignment,\n                            };\n                            const { paragraph: headingParagraph, bookmarkId } = (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processHeading)(trimmedLine, config, style, documentType);\n                            headings.push({ text: headingText, level, bookmarkId });\n                            docChildren.push(headingParagraph);\n                            continue;\n                        }\n                        // Graceful degradation for unsupported heading levels\n                        console.warn(`Warning: Heading level ${level} is not supported. Converting to regular paragraph.`);\n                    }\n                }\n                // Handle tables\n                if (trimmedLine.startsWith(\"|\") && trimmedLine.endsWith(\"|\")) {\n                    // Support standard and aligned separator rows (with optional leading/trailing colons)\n                    const separatorRegex = /^\\s*\\|(?:\\s*:?-+:?\\s*\\|)+\\s*$/;\n                    if (i + 1 < lines.length &&\n                        (separatorRegex.test(lines[i + 1]) ||\n                            (i + 2 < lines.length && separatorRegex.test(lines[i + 2])))) {\n                        if (inList) {\n                            docChildren.push(...listItems);\n                            listItems = [];\n                            inList = false;\n                        }\n                        if (tableIndex < tables.length) {\n                            try {\n                                docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processTable)(tables[tableIndex], documentType));\n                                const tableRowCount = 2 + tables[tableIndex].rows.length;\n                                i += tableRowCount - 1;\n                                tableIndex++;\n                                continue;\n                            }\n                            catch (error) {\n                                console.warn(`Warning: Failed to process table at line ${i + 1}. Converting to regular text.`);\n                                // Fallback to regular text\n                                docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                                    children: [\n                                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                            text: trimmedLine.replace(/\\|/g, \"\").trim(),\n                                            color: \"000000\",\n                                        }),\n                                    ],\n                                    bidirectional: style.direction === \"RTL\",\n                                }));\n                                continue;\n                            }\n                        }\n                    }\n                }\n                // Handle lists\n                if (trimmedLine.startsWith(\"- \") || trimmedLine.startsWith(\"* \")) {\n                    // Reset if switching from numbered to bullet list\n                    if (isCurrentListNumbered) {\n                        currentListNumber = 1;\n                        isCurrentListNumbered = false;\n                    }\n                    inList = true;\n                    const listText = trimmedLine.replace(/^[-*]\\s+/, \"\").trim();\n                    // Check if there's a bold section on the next line\n                    let boldText = \"\";\n                    if (i + 1 < lines.length &&\n                        lines[i + 1].trim().startsWith(\"**\") &&\n                        lines[i + 1].trim().endsWith(\"**\")) {\n                        boldText = lines[i + 1].trim().slice(2, -2); // Remove ** markers\n                        i++;\n                    }\n                    listItems.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processListItem)({ text: listText, boldText }, style));\n                    continue;\n                }\n                // Handle numbered lists\n                if (/^\\s*\\d+\\.\\s/.test(trimmedLine)) {\n                    // Check if we need to start a new numbered list sequence\n                    if (!isCurrentListNumbered || !inList) {\n                        // Starting a new numbered list sequence\n                        numberedListSequenceId++;\n                        currentListNumber = 1;\n                        isCurrentListNumbered = true;\n                    }\n                    inList = true;\n                    const listText = trimmedLine.replace(/^\\s*\\d+\\.\\s/, \"\").trim();\n                    // Check if there's a bold section on the next line\n                    let boldText = \"\";\n                    if (i + 1 < lines.length &&\n                        lines[i + 1].trim().startsWith(\"**\") &&\n                        lines[i + 1].trim().endsWith(\"**\")) {\n                        boldText = lines[i + 1].trim().slice(2, -2); // Remove ** markers\n                        i++;\n                    }\n                    listItems.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processListItem)({\n                        text: listText,\n                        boldText,\n                        isNumbered: true,\n                        listNumber: currentListNumber,\n                        sequenceId: numberedListSequenceId,\n                    }, style));\n                    currentListNumber++;\n                    continue;\n                }\n                // Handle blockquotes\n                if (trimmedLine.startsWith(\"> \")) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    const quoteText = trimmedLine.replace(/^>\\s*/, \"\").trim();\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processBlockquote)(quoteText, style));\n                    continue;\n                }\n                // Handle comments\n                if (trimmedLine.startsWith(\"COMMENT:\")) {\n                    if (inList) {\n                        docChildren.push(...listItems);\n                        listItems = [];\n                        inList = false;\n                    }\n                    const commentText = trimmedLine.replace(/^COMMENT:\\s*/, \"\").trim();\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processComment)(commentText, style));\n                    continue;\n                }\n                // Handle images\n                const imageMatch = trimmedLine.match(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/);\n                if (imageMatch) {\n                    const [_, altText, imageUrl] = imageMatch;\n                    // Process images synchronously to ensure they're fully loaded\n                    try {\n                        const imageParagraphs = await (0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processImage)(altText, imageUrl, style);\n                        docChildren.push(...imageParagraphs);\n                    }\n                    catch (error) {\n                        console.error(`Error in image processing: ${error instanceof Error ? error.message : String(error)}`);\n                        docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: `[Image could not be loaded: ${altText}]`,\n                                    italics: true,\n                                    color: \"FF0000\",\n                                }),\n                            ],\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                            bidirectional: style.direction === \"RTL\",\n                        }));\n                    }\n                    continue;\n                }\n                // Handle standalone links (entire line is a single link) - inline links are handled in processParagraph\n                const linkMatch = trimmedLine.match(/^\\[([^\\]]+)\\]\\(([^)]+)\\)$/);\n                if (linkMatch) {\n                    const [_, text, url] = linkMatch;\n                    docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processLinkParagraph)(text, url, style));\n                    continue;\n                }\n                // Regular paragraph text with special formatting (use trimmedLine for processing)\n                if (!inList) {\n                    try {\n                        docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processParagraph)(trimmedLine, style));\n                    }\n                    catch (error) {\n                        // Fallback to plain text if formatting fails\n                        console.warn(`Warning: Failed to process text formatting at line ${i + 1}: ${error instanceof Error ? error.message : String(error)}. Using plain text.`);\n                        docChildren.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: trimmedLine,\n                                    color: \"000000\",\n                                    size: style.paragraphSize || 24,\n                                }),\n                            ],\n                            spacing: {\n                                before: style.paragraphSpacing,\n                                after: style.paragraphSpacing,\n                                line: style.lineSpacing * 240,\n                            },\n                            alignment: style.paragraphAlignment\n                                ? docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType[style.paragraphAlignment]\n                                : undefined,\n                        }));\n                    }\n                    continue;\n                }\n                // Removed the fallback 'isContinuation' list item processing as it was causing type errors\n                // and needs a more robust implementation if required.\n            }\n            catch (error) {\n                // Log error and continue with next line\n                console.warn(`Warning: Failed to process line ${i + 1}: ${error instanceof Error ? error.message : \"Unknown error\"}. Skipping line.`);\n                continue;\n            }\n        }\n        // Handle any remaining code block\n        if (inCodeBlock && codeBlockContent) {\n            docChildren.push((0,_helpers_js__WEBPACK_IMPORTED_MODULE_3__.processCodeBlock)(codeBlockContent.trim(), codeBlockLanguage, style));\n        }\n        // Add any remaining list items\n        if (inList && listItems.length > 0) {\n            docChildren.push(...listItems);\n        }\n        // Generate TOC content\n        const tocContent = [];\n        if (headings.length > 0) {\n            // Optional: Add a title for the TOC\n            tocContent.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                text: \"Table of Contents\",\n                heading: \"Heading1\", // Or a specific TOC title style\n                alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                spacing: { after: 240 },\n                bidirectional: style.direction === \"RTL\",\n            }));\n            headings.forEach((heading) => {\n                // Determine font size based on heading level\n                let fontSize;\n                let isBold = false;\n                let isItalic = false;\n                // Apply level-specific styles if provided\n                switch (heading.level) {\n                    case 1:\n                        fontSize = style.tocHeading1FontSize || style.tocFontSize;\n                        isBold =\n                            style.tocHeading1Bold !== undefined\n                                ? style.tocHeading1Bold\n                                : true;\n                        isItalic = style.tocHeading1Italic || false;\n                        break;\n                    case 2:\n                        fontSize = style.tocHeading2FontSize || style.tocFontSize;\n                        isBold =\n                            style.tocHeading2Bold !== undefined\n                                ? style.tocHeading2Bold\n                                : false;\n                        isItalic = style.tocHeading2Italic || false;\n                        break;\n                    case 3:\n                        fontSize = style.tocHeading3FontSize || style.tocFontSize;\n                        isBold = style.tocHeading3Bold || false;\n                        isItalic = style.tocHeading3Italic || false;\n                        break;\n                    case 4:\n                        fontSize = style.tocHeading4FontSize || style.tocFontSize;\n                        isBold = style.tocHeading4Bold || false;\n                        isItalic = style.tocHeading4Italic || false;\n                        break;\n                    case 5:\n                        fontSize = style.tocHeading5FontSize || style.tocFontSize;\n                        isBold = style.tocHeading5Bold || false;\n                        isItalic = style.tocHeading5Italic || false;\n                        break;\n                    default:\n                        fontSize = style.tocFontSize;\n                }\n                // Use default calculation if no specific size provided\n                if (!fontSize) {\n                    fontSize = style.paragraphSize\n                        ? style.paragraphSize - (heading.level - 1) * 2\n                        : 24 - (heading.level - 1) * 2;\n                }\n                tocContent.push(new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                    children: [\n                        new docx__WEBPACK_IMPORTED_MODULE_0__.InternalHyperlink({\n                            anchor: heading.bookmarkId,\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                    text: heading.text,\n                                    size: fontSize,\n                                    bold: isBold,\n                                    italics: isItalic,\n                                }),\n                            ],\n                        }),\n                    ],\n                    // Indentation based on heading level\n                    indent: { left: (heading.level - 1) * 400 },\n                    spacing: { after: 120 }, // Spacing between TOC items\n                    bidirectional: style.direction === \"RTL\",\n                }));\n            });\n        }\n        // Replace placeholder with TOC content\n        const finalDocChildren = [];\n        let tocInserted = false;\n        docChildren.forEach((child) => {\n            // Check for the marker property instead of inspecting content\n            if (child.__isTocPlaceholder === true) {\n                if (tocContent.length > 0 && !tocInserted) {\n                    finalDocChildren.push(...tocContent);\n                    tocInserted = true; // Ensure TOC is inserted only once\n                }\n                else {\n                    // If no headings were found or TOC already inserted, remove placeholder\n                    console.warn(\"TOC placeholder found, but no headings collected or TOC already inserted.\");\n                }\n            }\n            else {\n                finalDocChildren.push(child);\n            }\n        });\n        // Create numbering configurations for all numbered list sequences\n        const numberingConfigs = [];\n        for (let i = 1; i <= numberedListSequenceId; i++) {\n            numberingConfigs.push({\n                reference: `numbered-list-${i}`,\n                levels: [\n                    {\n                        level: 0,\n                        format: docx__WEBPACK_IMPORTED_MODULE_0__.LevelFormat.DECIMAL,\n                        text: \"%1.\",\n                        alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.LEFT,\n                        style: {\n                            paragraph: {\n                                indent: { left: 720, hanging: 260 },\n                            },\n                        },\n                    },\n                ],\n            });\n        }\n        // Create the document with appropriate settings\n        const docxOptions = {\n            numbering: {\n                config: numberingConfigs,\n            },\n            sections: [\n                {\n                    properties: {\n                        page: {\n                            margin: {\n                                top: 1440,\n                                right: 1080,\n                                bottom: 1440,\n                                left: 1080,\n                            },\n                            size: {\n                                orientation: docx__WEBPACK_IMPORTED_MODULE_0__.PageOrientation.PORTRAIT,\n                            },\n                        },\n                    },\n                    footers: {\n                        default: new docx__WEBPACK_IMPORTED_MODULE_0__.Footer({\n                            children: [\n                                new docx__WEBPACK_IMPORTED_MODULE_0__.Paragraph({\n                                    alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                                    children: [\n                                        new docx__WEBPACK_IMPORTED_MODULE_0__.TextRun({\n                                            children: [docx__WEBPACK_IMPORTED_MODULE_0__.PageNumber.CURRENT],\n                                        }),\n                                    ],\n                                }),\n                            ],\n                        }),\n                    },\n                    children: finalDocChildren,\n                },\n            ],\n            styles: {\n                paragraphStyles: [\n                    {\n                        id: \"Title\",\n                        name: \"Title\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                after: 240,\n                                line: style.lineSpacing * 240,\n                            },\n                            alignment: docx__WEBPACK_IMPORTED_MODULE_0__.AlignmentType.CENTER,\n                        },\n                    },\n                    {\n                        id: \"Heading1\",\n                        name: \"Heading 1\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 360,\n                                after: 240,\n                            },\n                            outlineLevel: 1,\n                        },\n                    },\n                    {\n                        id: \"Heading2\",\n                        name: \"Heading 2\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 4,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 320,\n                                after: 160,\n                            },\n                            outlineLevel: 2,\n                        },\n                    },\n                    {\n                        id: \"Heading3\",\n                        name: \"Heading 3\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 8,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 280,\n                                after: 120,\n                            },\n                            outlineLevel: 3,\n                        },\n                    },\n                    {\n                        id: \"Heading4\",\n                        name: \"Heading 4\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 12,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 240,\n                                after: 120,\n                            },\n                            outlineLevel: 4,\n                        },\n                    },\n                    {\n                        id: \"Heading5\",\n                        name: \"Heading 5\",\n                        basedOn: \"Normal\",\n                        next: \"Normal\",\n                        quickFormat: true,\n                        run: {\n                            size: style.titleSize - 16,\n                            bold: true,\n                            color: \"000000\",\n                        },\n                        paragraph: {\n                            spacing: {\n                                before: 220,\n                                after: 100,\n                            },\n                            outlineLevel: 5,\n                        },\n                    },\n                    {\n                        id: \"Strong\",\n                        name: \"Strong\",\n                        run: {\n                            bold: true,\n                        },\n                    },\n                ],\n            },\n        };\n        return docxOptions;\n    }\n    catch (error) {\n        if (error instanceof MarkdownConversionError) {\n            throw error;\n        }\n        throw new MarkdownConversionError(`Failed to convert markdown to docx: ${error instanceof Error ? error.message : \"Unknown error\"}`, { originalError: error });\n    }\n}\n/**\n * Downloads a DOCX file in the browser environment\n * @param blob - The Blob containing the DOCX file data\n * @param filename - The name to save the file as (defaults to \"document.docx\")\n * @throws {Error} If the function is called outside browser environment\n * @throws {Error} If invalid blob or filename is provided\n * @throws {Error} If file save fails\n */\nfunction downloadDocx(blob, filename = \"document.docx\") {\n    if (typeof window === \"undefined\") {\n        throw new Error(\"This function can only be used in browser environments\");\n    }\n    if (!(blob instanceof Blob)) {\n        throw new Error(\"Invalid blob provided\");\n    }\n    if (!filename || typeof filename !== \"string\") {\n        throw new Error(\"Invalid filename provided\");\n    }\n    try {\n        file_saver__WEBPACK_IMPORTED_MODULE_1__(blob, filename);\n    }\n    catch (error) {\n        console.error(\"Failed to save file:\", error);\n        throw new Error(`Failed to save file: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vaHRhc2hhbS9tZC10by1kb2N4L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEo7QUFDNUg7QUFDWTtBQUM0SjtBQUN4TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQTJEO0FBQzNFO0FBQ0EsdUdBQXVHLFdBQVc7QUFDbEg7QUFDQTtBQUNBLDRHQUE0RyxnQkFBZ0I7QUFDNUg7QUFDQTtBQUNBLDhHQUE4RyxrQkFBa0I7QUFDaEk7QUFDQTtBQUNBLGlHQUFpRyxhQUFhO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBDQUFRO0FBQ2hDLHFCQUFxQix3Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHlEQUF5RCxLQUFLLHNCQUFzQjtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQWtEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBYTtBQUNwQyx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5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Q0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHlEQUF5RCxLQUFLLHNCQUFzQjtBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlEQUF5RDtBQUN6RztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWQtdG8tZG9jeC8uL25vZGVfbW9kdWxlcy9AbW9odGFzaGFtL21kLXRvLWRvY3gvZGlzdC9pbmRleC5qcz80OWI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERvY3VtZW50LCBQYXJhZ3JhcGgsIFRleHRSdW4sIEFsaWdubWVudFR5cGUsIFBhZ2VPcmllbnRhdGlvbiwgUGFja2VyLCBQYWdlQnJlYWssIEludGVybmFsSHlwZXJsaW5rLCBGb290ZXIsIFBhZ2VOdW1iZXIsIExldmVsRm9ybWF0LCB9IGZyb20gXCJkb2N4XCI7XG5pbXBvcnQgc2F2ZUFzIGZyb20gXCJmaWxlLXNhdmVyXCI7XG5pbXBvcnQgeyBoZWFkaW5nQ29uZmlncyB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5pbXBvcnQgeyBwcm9jZXNzSGVhZGluZywgcHJvY2Vzc1RhYmxlLCBwcm9jZXNzTGlzdEl0ZW0sIHByb2Nlc3NCbG9ja3F1b3RlLCBwcm9jZXNzQ29tbWVudCwgY29sbGVjdFRhYmxlcywgcHJvY2Vzc0NvZGVCbG9jaywgcHJvY2Vzc0xpbmtQYXJhZ3JhcGgsIHByb2Nlc3NJbWFnZSwgcHJvY2Vzc1BhcmFncmFwaCwgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG5jb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gICAgdGl0bGVTaXplOiAzMixcbiAgICBoZWFkaW5nU3BhY2luZzogMjQwLFxuICAgIHBhcmFncmFwaFNwYWNpbmc6IDI0MCxcbiAgICBsaW5lU3BhY2luZzogMS4xNSxcbiAgICBwYXJhZ3JhcGhBbGlnbm1lbnQ6IFwiTEVGVFwiLFxuICAgIGRpcmVjdGlvbjogXCJMVFJcIixcbn07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBkb2N1bWVudFR5cGU6IFwiZG9jdW1lbnRcIixcbiAgICBzdHlsZTogZGVmYXVsdFN0eWxlLFxufTtcbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIGZvciBtYXJrZG93biBjb252ZXJzaW9uIGVycm9yc1xuICogQGV4dGVuZHMgRXJyb3JcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgb2YgdGhlIGVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBNYXJrZG93bkNvbnZlcnNpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk1hcmtkb3duQ29udmVyc2lvbkVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBWYWxpZGF0ZXMgbWFya2Rvd24gaW5wdXQgYW5kIG9wdGlvbnNcbiAqIEB0aHJvd3Mge01hcmtkb3duQ29udmVyc2lvbkVycm9yfSBJZiBpbnB1dCBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQobWFya2Rvd24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIW1hcmtkb3duIHx8IHR5cGVvZiBtYXJrZG93biAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgTWFya2Rvd25Db252ZXJzaW9uRXJyb3IoXCJJbnZhbGlkIG1hcmtkb3duIGlucHV0OiBNYXJrZG93biBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgICAgY29uc3QgeyB0aXRsZVNpemUsIGhlYWRpbmdTcGFjaW5nLCBwYXJhZ3JhcGhTcGFjaW5nLCBsaW5lU3BhY2luZyB9ID0gb3B0aW9ucy5zdHlsZTtcbiAgICAgICAgaWYgKHRpdGxlU2l6ZSAmJiAodGl0bGVTaXplIDwgOCB8fCB0aXRsZVNpemUgPiA3MikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihcIkludmFsaWQgdGl0bGUgc2l6ZTogTXVzdCBiZSBiZXR3ZWVuIDggYW5kIDcyIHBvaW50c1wiLCB7IHRpdGxlU2l6ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGluZ1NwYWNpbmcgJiYgKGhlYWRpbmdTcGFjaW5nIDwgMCB8fCBoZWFkaW5nU3BhY2luZyA+IDcyMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihcIkludmFsaWQgaGVhZGluZyBzcGFjaW5nOiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgNzIwIHR3aXBzXCIsIHsgaGVhZGluZ1NwYWNpbmcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFncmFwaFNwYWNpbmcgJiYgKHBhcmFncmFwaFNwYWNpbmcgPCAwIHx8IHBhcmFncmFwaFNwYWNpbmcgPiA3MjApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWFya2Rvd25Db252ZXJzaW9uRXJyb3IoXCJJbnZhbGlkIHBhcmFncmFwaCBzcGFjaW5nOiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgNzIwIHR3aXBzXCIsIHsgcGFyYWdyYXBoU3BhY2luZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVNwYWNpbmcgJiYgKGxpbmVTcGFjaW5nIDwgMSB8fCBsaW5lU3BhY2luZyA+IDMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWFya2Rvd25Db252ZXJzaW9uRXJyb3IoXCJJbnZhbGlkIGxpbmUgc3BhY2luZzogTXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDNcIiwgeyBsaW5lU3BhY2luZyB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ29udmVydCBNYXJrZG93biB0byBEb2N4IGZpbGVcbiAqIEBwYXJhbSBtYXJrZG93biAtIFRoZSBNYXJrZG93biBzdHJpbmcgdG8gY29udmVydFxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGNvbnZlcnNpb25cbiAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmxvYiBjb250YWluaW5nIHRoZSBEb2N4IGZpbGVcbiAqIEB0aHJvd3Mge01hcmtkb3duQ29udmVyc2lvbkVycm9yfSBJZiBjb252ZXJzaW9uIGZhaWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0TWFya2Rvd25Ub0RvY3gobWFya2Rvd24sIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRvY3hPcHRpb25zID0gYXdhaXQgcGFyc2VUb0RvY3hPcHRpb25zKG1hcmtkb3duLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBkb2N1bWVudCB3aXRoIGFwcHJvcHJpYXRlIHNldHRpbmdzXG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudChkb2N4T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBhd2FpdCBQYWNrZXIudG9CbG9iKGRvYyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNYXJrZG93bkNvbnZlcnNpb25FcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE1hcmtkb3duQ29udmVyc2lvbkVycm9yKGBGYWlsZWQgdG8gY29udmVydCBtYXJrZG93biB0byBkb2N4OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9YCwgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9KTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnQgTWFya2Rvd24gdG8gRG9jeCBvcHRpb25zXG4gKiBAcGFyYW0gbWFya2Rvd24gLSBUaGUgTWFya2Rvd24gc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBjb252ZXJzaW9uXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJsb2IgY29udGFpbmluZyB0aGUgRG9jeCBmaWxlXG4gKiBAdGhyb3dzIHtNYXJrZG93bkNvbnZlcnNpb25FcnJvcn0gSWYgY29udmVyc2lvbiBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VUb0RvY3hPcHRpb25zKG1hcmtkb3duLCBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dHMgZWFybHlcbiAgICAgICAgdmFsaWRhdGVJbnB1dChtYXJrZG93biwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgPSBkZWZhdWx0U3R5bGUsIGRvY3VtZW50VHlwZSA9IFwiZG9jdW1lbnRcIiB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZG9jQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZGluZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBtYXJrZG93bi5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgbGV0IGluTGlzdCA9IGZhbHNlO1xuICAgICAgICBsZXQgbGlzdEl0ZW1zID0gW107XG4gICAgICAgIGxldCBjdXJyZW50TGlzdE51bWJlciA9IDE7XG4gICAgICAgIGxldCBpc0N1cnJlbnRMaXN0TnVtYmVyZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IG51bWJlcmVkTGlzdFNlcXVlbmNlSWQgPSAwO1xuICAgICAgICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvZGVCbG9ja0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICBsZXQgY29kZUJsb2NrTGFuZ3VhZ2U7XG4gICAgICAgIGxldCB0YWJsZUluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdGFibGVzID0gY29sbGVjdFRhYmxlcyhsaW5lcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lc1xuICAgICAgICAgICAgICAgIGlmICghdHJpbW1lZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tDb250ZW50ICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0TnVtYmVyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ3VycmVudExpc3ROdW1iZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7fSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIFBhZ2UgQnJlYWtcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUgPT09IFwiXFxcXHBhZ2VicmVha1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdE51bWJlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRMaXN0TnVtYmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKG5ldyBQYXJhZ3JhcGgoeyBjaGlsZHJlbjogW25ldyBQYWdlQnJlYWsoKV0gfSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIE1hcmtkb3duIFNlcGFyYXRvcnMgKGUuZy4sIC0tLSlcbiAgICAgICAgICAgICAgICBpZiAoL15cXHMqLS0tXFxzKiQvLnRlc3QodHJpbW1lZExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdE51bWJlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRMaXN0TnVtYmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBzZXBhcmF0b3IgbGluZVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIFRPQyBQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZSA9PT0gXCJbVE9DXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcGFyYWdyYXBoIGFuZCBhZGQgYSB1bmlxdWUgcHJvcGVydHkgdG8gaWRlbnRpZnkgaXQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9jUGxhY2Vob2xkZXIgPSBuZXcgUGFyYWdyYXBoKHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9jUGxhY2Vob2xkZXIuX19pc1RvY1BsYWNlaG9sZGVyID0gdHJ1ZTsgLy8gQWRkIHRlbXBvcmFyeSBtYXJrZXIgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCh0b2NQbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aChcImBgYFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBvZiBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNvZGVCbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tMYW5ndWFnZSA9IHRyaW1tZWRMaW5lLnNsaWNlKDMpLnRyaW0oKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBvZiBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaChwcm9jZXNzQ29kZUJsb2NrKGNvZGVCbG9ja0NvbnRlbnQudHJpbSgpLCBjb2RlQmxvY2tMYW5ndWFnZSwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUJsb2NrTGFuZ3VhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbkNvZGVCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tDb250ZW50ICs9IChjb2RlQmxvY2tDb250ZW50ID8gXCJcXG5cIiA6IFwiXCIpICsgbGluZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgaGVhZGluZ3NcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkTGluZS5tYXRjaCgvXiMrLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gMSAmJiBsZXZlbCA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKC4uLmxpc3RJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGluZ1RleHQgPSB0cmltbWVkTGluZS5zdWJzdHJpbmcobGV2ZWwpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmhlYWRpbmdDb25maWdzW2xldmVsXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBoZWFkaW5nQ29uZmlnc1tsZXZlbF0uYWxpZ25tZW50IHx8IHN0eWxlLmhlYWRpbmdBbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhcmFncmFwaDogaGVhZGluZ1BhcmFncmFwaCwgYm9va21hcmtJZCB9ID0gcHJvY2Vzc0hlYWRpbmcodHJpbW1lZExpbmUsIGNvbmZpZywgc3R5bGUsIGRvY3VtZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZ3MucHVzaCh7IHRleHQ6IGhlYWRpbmdUZXh0LCBsZXZlbCwgYm9va21hcmtJZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKGhlYWRpbmdQYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3JhY2VmdWwgZGVncmFkYXRpb24gZm9yIHVuc3VwcG9ydGVkIGhlYWRpbmcgbGV2ZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IEhlYWRpbmcgbGV2ZWwgJHtsZXZlbH0gaXMgbm90IHN1cHBvcnRlZC4gQ29udmVydGluZyB0byByZWd1bGFyIHBhcmFncmFwaC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGFibGVzXG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoXCJ8XCIpICYmIHRyaW1tZWRMaW5lLmVuZHNXaXRoKFwifFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IHN0YW5kYXJkIGFuZCBhbGlnbmVkIHNlcGFyYXRvciByb3dzICh3aXRoIG9wdGlvbmFsIGxlYWRpbmcvdHJhaWxpbmcgY29sb25zKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JSZWdleCA9IC9eXFxzKlxcfCg/Olxccyo6Py0rOj9cXHMqXFx8KStcXHMqJC87XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvclJlZ2V4LnRlc3QobGluZXNbaSArIDFdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpICsgMiA8IGxpbmVzLmxlbmd0aCAmJiBzZXBhcmF0b3JSZWdleC50ZXN0KGxpbmVzW2kgKyAyXSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZUluZGV4IDwgdGFibGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc1RhYmxlKHRhYmxlc1t0YWJsZUluZGV4XSwgZG9jdW1lbnRUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlUm93Q291bnQgPSAyICsgdGFibGVzW3RhYmxlSW5kZXhdLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IHRhYmxlUm93Q291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBGYWlsZWQgdG8gcHJvY2VzcyB0YWJsZSBhdCBsaW5lICR7aSArIDF9LiBDb252ZXJ0aW5nIHRvIHJlZ3VsYXIgdGV4dC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcmVndWxhciB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJpbW1lZExpbmUucmVwbGFjZSgvXFx8L2csIFwiXCIpLnRyaW0oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlkaXJlY3Rpb25hbDogc3R5bGUuZGlyZWN0aW9uID09PSBcIlJUTFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbGlzdHNcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aChcIi0gXCIpIHx8IHRyaW1tZWRMaW5lLnN0YXJ0c1dpdGgoXCIqIFwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpZiBzd2l0Y2hpbmcgZnJvbSBudW1iZXJlZCB0byBidWxsZXQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50TGlzdE51bWJlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGlzdE51bWJlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0N1cnJlbnRMaXN0TnVtYmVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VGV4dCA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL15bLSpdXFxzKy8sIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIGJvbGQgc2VjdGlvbiBvbiB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGxldCBib2xkVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaSArIDFdLnRyaW0oKS5zdGFydHNXaXRoKFwiKipcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2kgKyAxXS50cmltKCkuZW5kc1dpdGgoXCIqKlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZFRleHQgPSBsaW5lc1tpICsgMV0udHJpbSgpLnNsaWNlKDIsIC0yKTsgLy8gUmVtb3ZlICoqIG1hcmtlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbXMucHVzaChwcm9jZXNzTGlzdEl0ZW0oeyB0ZXh0OiBsaXN0VGV4dCwgYm9sZFRleHQgfSwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBudW1iZXJlZCBsaXN0c1xuICAgICAgICAgICAgICAgIGlmICgvXlxccypcXGQrXFwuXFxzLy50ZXN0KHRyaW1tZWRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHN0YXJ0IGEgbmV3IG51bWJlcmVkIGxpc3Qgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0N1cnJlbnRMaXN0TnVtYmVyZWQgfHwgIWluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBuZXcgbnVtYmVyZWQgbGlzdCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyZWRMaXN0U2VxdWVuY2VJZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpc3ROdW1iZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDdXJyZW50TGlzdE51bWJlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VGV4dCA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL15cXHMqXFxkK1xcLlxccy8sIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIGJvbGQgc2VjdGlvbiBvbiB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGxldCBib2xkVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaSArIDFdLnRyaW0oKS5zdGFydHNXaXRoKFwiKipcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2kgKyAxXS50cmltKCkuZW5kc1dpdGgoXCIqKlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9sZFRleHQgPSBsaW5lc1tpICsgMV0udHJpbSgpLnNsaWNlKDIsIC0yKTsgLy8gUmVtb3ZlICoqIG1hcmtlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsaXN0SXRlbXMucHVzaChwcm9jZXNzTGlzdEl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbGlzdFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2xkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTnVtYmVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0TnVtYmVyOiBjdXJyZW50TGlzdE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlSWQ6IG51bWJlcmVkTGlzdFNlcXVlbmNlSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMaXN0TnVtYmVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYmxvY2txdW90ZXNcbiAgICAgICAgICAgICAgICBpZiAodHJpbW1lZExpbmUuc3RhcnRzV2l0aChcIj4gXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2goLi4ubGlzdEl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5MaXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcXVvdGVUZXh0ID0gdHJpbW1lZExpbmUucmVwbGFjZSgvXj5cXHMqLywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKHByb2Nlc3NCbG9ja3F1b3RlKHF1b3RlVGV4dCwgc3R5bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb21tZW50c1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkTGluZS5zdGFydHNXaXRoKFwiQ09NTUVOVDpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jQ2hpbGRyZW4ucHVzaCguLi5saXN0SXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL15DT01NRU5UOlxccyovLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc0NvbW1lbnQoY29tbWVudFRleHQsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaW1hZ2VzXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VNYXRjaCA9IHRyaW1tZWRMaW5lLm1hdGNoKC8hXFxbKFteXFxdXSopXFxdXFwoKFteKV0rKVxcKS8pO1xuICAgICAgICAgICAgICAgIGlmIChpbWFnZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtfLCBhbHRUZXh0LCBpbWFnZVVybF0gPSBpbWFnZU1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGltYWdlcyBzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGV5J3JlIGZ1bGx5IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VQYXJhZ3JhcGhzID0gYXdhaXQgcHJvY2Vzc0ltYWdlKGFsdFRleHQsIGltYWdlVXJsLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKC4uLmltYWdlUGFyYWdyYXBocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBpbWFnZSBwcm9jZXNzaW5nOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYFtJbWFnZSBjb3VsZCBub3QgYmUgbG9hZGVkOiAke2FsdFRleHR9XWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGFsaWNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiRkYwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiBBbGlnbm1lbnRUeXBlLkNFTlRFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzdGFuZGFsb25lIGxpbmtzIChlbnRpcmUgbGluZSBpcyBhIHNpbmdsZSBsaW5rKSAtIGlubGluZSBsaW5rcyBhcmUgaGFuZGxlZCBpbiBwcm9jZXNzUGFyYWdyYXBoXG4gICAgICAgICAgICAgICAgY29uc3QgbGlua01hdGNoID0gdHJpbW1lZExpbmUubWF0Y2goL15cXFsoW15cXF1dKylcXF1cXCgoW14pXSspXFwpJC8pO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW18sIHRleHQsIHVybF0gPSBsaW5rTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc0xpbmtQYXJhZ3JhcGgodGV4dCwgdXJsLCBzdHlsZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBwYXJhZ3JhcGggdGV4dCB3aXRoIHNwZWNpYWwgZm9ybWF0dGluZyAodXNlIHRyaW1tZWRMaW5lIGZvciBwcm9jZXNzaW5nKVxuICAgICAgICAgICAgICAgIGlmICghaW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKHByb2Nlc3NQYXJhZ3JhcGgodHJpbW1lZExpbmUsIHN0eWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBwbGFpbiB0ZXh0IGlmIGZvcm1hdHRpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogRmFpbGVkIHRvIHByb2Nlc3MgdGV4dCBmb3JtYXR0aW5nIGF0IGxpbmUgJHtpICsgMX06ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpfS4gVXNpbmcgcGxhaW4gdGV4dC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gobmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRleHRSdW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdHJpbW1lZExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnBhcmFncmFwaFNpemUgfHwgMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IHN0eWxlLnBhcmFncmFwaFNwYWNpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiBzdHlsZS5wYXJhZ3JhcGhTcGFjaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBzdHlsZS5saW5lU3BhY2luZyAqIDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogc3R5bGUucGFyYWdyYXBoQWxpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gQWxpZ25tZW50VHlwZVtzdHlsZS5wYXJhZ3JhcGhBbGlnbm1lbnRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVkIHRoZSBmYWxsYmFjayAnaXNDb250aW51YXRpb24nIGxpc3QgaXRlbSBwcm9jZXNzaW5nIGFzIGl0IHdhcyBjYXVzaW5nIHR5cGUgZXJyb3JzXG4gICAgICAgICAgICAgICAgLy8gYW5kIG5lZWRzIGEgbW9yZSByb2J1c3QgaW1wbGVtZW50YXRpb24gaWYgcmVxdWlyZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYW5kIGNvbnRpbnVlIHdpdGggbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiBGYWlsZWQgdG8gcHJvY2VzcyBsaW5lICR7aSArIDF9OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJ9LiBTa2lwcGluZyBsaW5lLmApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbnkgcmVtYWluaW5nIGNvZGUgYmxvY2tcbiAgICAgICAgaWYgKGluQ29kZUJsb2NrICYmIGNvZGVCbG9ja0NvbnRlbnQpIHtcbiAgICAgICAgICAgIGRvY0NoaWxkcmVuLnB1c2gocHJvY2Vzc0NvZGVCbG9jayhjb2RlQmxvY2tDb250ZW50LnRyaW0oKSwgY29kZUJsb2NrTGFuZ3VhZ2UsIHN0eWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGFueSByZW1haW5pbmcgbGlzdCBpdGVtc1xuICAgICAgICBpZiAoaW5MaXN0ICYmIGxpc3RJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkb2NDaGlsZHJlbi5wdXNoKC4uLmxpc3RJdGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgVE9DIGNvbnRlbnRcbiAgICAgICAgY29uc3QgdG9jQ29udGVudCA9IFtdO1xuICAgICAgICBpZiAoaGVhZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gT3B0aW9uYWw6IEFkZCBhIHRpdGxlIGZvciB0aGUgVE9DXG4gICAgICAgICAgICB0b2NDb250ZW50LnB1c2gobmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJUYWJsZSBvZiBDb250ZW50c1wiLFxuICAgICAgICAgICAgICAgIGhlYWRpbmc6IFwiSGVhZGluZzFcIiwgLy8gT3IgYSBzcGVjaWZpYyBUT0MgdGl0bGUgc3R5bGVcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IHsgYWZ0ZXI6IDI0MCB9LFxuICAgICAgICAgICAgICAgIGJpZGlyZWN0aW9uYWw6IHN0eWxlLmRpcmVjdGlvbiA9PT0gXCJSVExcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGhlYWRpbmdzLmZvckVhY2goKGhlYWRpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgZm9udCBzaXplIGJhc2VkIG9uIGhlYWRpbmcgbGV2ZWxcbiAgICAgICAgICAgICAgICBsZXQgZm9udFNpemU7XG4gICAgICAgICAgICAgICAgbGV0IGlzQm9sZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBpc0l0YWxpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGxldmVsLXNwZWNpZmljIHN0eWxlcyBpZiBwcm92aWRlZFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGVhZGluZy5sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnRvY0hlYWRpbmcxRm9udFNpemUgfHwgc3R5bGUudG9jRm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JvbGQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnRvY0hlYWRpbmcxQm9sZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3R5bGUudG9jSGVhZGluZzFCb2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSXRhbGljID0gc3R5bGUudG9jSGVhZGluZzFJdGFsaWMgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemUgPSBzdHlsZS50b2NIZWFkaW5nMkZvbnRTaXplIHx8IHN0eWxlLnRvY0ZvbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNCb2xkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS50b2NIZWFkaW5nMkJvbGQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxlLnRvY0hlYWRpbmcyQm9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJdGFsaWMgPSBzdHlsZS50b2NIZWFkaW5nMkl0YWxpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLnRvY0hlYWRpbmczRm9udFNpemUgfHwgc3R5bGUudG9jRm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JvbGQgPSBzdHlsZS50b2NIZWFkaW5nM0JvbGQgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0l0YWxpYyA9IHN0eWxlLnRvY0hlYWRpbmczSXRhbGljIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplID0gc3R5bGUudG9jSGVhZGluZzRGb250U2l6ZSB8fCBzdHlsZS50b2NGb250U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQm9sZCA9IHN0eWxlLnRvY0hlYWRpbmc0Qm9sZCB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSXRhbGljID0gc3R5bGUudG9jSGVhZGluZzRJdGFsaWMgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemUgPSBzdHlsZS50b2NIZWFkaW5nNUZvbnRTaXplIHx8IHN0eWxlLnRvY0ZvbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNCb2xkID0gc3R5bGUudG9jSGVhZGluZzVCb2xkIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNJdGFsaWMgPSBzdHlsZS50b2NIZWFkaW5nNUl0YWxpYyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemUgPSBzdHlsZS50b2NGb250U2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgY2FsY3VsYXRpb24gaWYgbm8gc3BlY2lmaWMgc2l6ZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGlmICghZm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5wYXJhZ3JhcGhTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxlLnBhcmFncmFwaFNpemUgLSAoaGVhZGluZy5sZXZlbCAtIDEpICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiAyNCAtIChoZWFkaW5nLmxldmVsIC0gMSkgKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2NDb250ZW50LnB1c2gobmV3IFBhcmFncmFwaCh7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgSW50ZXJuYWxIeXBlcmxpbmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvcjogaGVhZGluZy5ib29rbWFya0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRpbmcudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZvbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogaXNCb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRhbGljczogaXNJdGFsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kZW50YXRpb24gYmFzZWQgb24gaGVhZGluZyBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHsgbGVmdDogKGhlYWRpbmcubGV2ZWwgLSAxKSAqIDQwMCB9LFxuICAgICAgICAgICAgICAgICAgICBzcGFjaW5nOiB7IGFmdGVyOiAxMjAgfSwgLy8gU3BhY2luZyBiZXR3ZWVuIFRPQyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICBiaWRpcmVjdGlvbmFsOiBzdHlsZS5kaXJlY3Rpb24gPT09IFwiUlRMXCIsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVwbGFjZSBwbGFjZWhvbGRlciB3aXRoIFRPQyBjb250ZW50XG4gICAgICAgIGNvbnN0IGZpbmFsRG9jQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbGV0IHRvY0luc2VydGVkID0gZmFsc2U7XG4gICAgICAgIGRvY0NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgdGhlIG1hcmtlciBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGluc3BlY3RpbmcgY29udGVudFxuICAgICAgICAgICAgaWYgKGNoaWxkLl9faXNUb2NQbGFjZWhvbGRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0b2NDb250ZW50Lmxlbmd0aCA+IDAgJiYgIXRvY0luc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRG9jQ2hpbGRyZW4ucHVzaCguLi50b2NDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG9jSW5zZXJ0ZWQgPSB0cnVlOyAvLyBFbnN1cmUgVE9DIGlzIGluc2VydGVkIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gaGVhZGluZ3Mgd2VyZSBmb3VuZCBvciBUT0MgYWxyZWFkeSBpbnNlcnRlZCwgcmVtb3ZlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRPQyBwbGFjZWhvbGRlciBmb3VuZCwgYnV0IG5vIGhlYWRpbmdzIGNvbGxlY3RlZCBvciBUT0MgYWxyZWFkeSBpbnNlcnRlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluYWxEb2NDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBudW1iZXJpbmcgY29uZmlndXJhdGlvbnMgZm9yIGFsbCBudW1iZXJlZCBsaXN0IHNlcXVlbmNlc1xuICAgICAgICBjb25zdCBudW1iZXJpbmdDb25maWdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlcmVkTGlzdFNlcXVlbmNlSWQ7IGkrKykge1xuICAgICAgICAgICAgbnVtYmVyaW5nQ29uZmlncy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2U6IGBudW1iZXJlZC1saXN0LSR7aX1gLFxuICAgICAgICAgICAgICAgIGxldmVsczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogTGV2ZWxGb3JtYXQuREVDSU1BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IFwiJTEuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuTEVGVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogeyBsZWZ0OiA3MjAsIGhhbmdpbmc6IDI2MCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdGhlIGRvY3VtZW50IHdpdGggYXBwcm9wcmlhdGUgc2V0dGluZ3NcbiAgICAgICAgY29uc3QgZG9jeE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBudW1iZXJpbmc6IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IG51bWJlcmluZ0NvbmZpZ3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAxNDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMTA4MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAxNDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAxMDgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogUGFnZU9yaWVudGF0aW9uLlBPUlRSQUlULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmb290ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBuZXcgRm9vdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWdubWVudDogQWxpZ25tZW50VHlwZS5DRU5URVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0UnVuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtQYWdlTnVtYmVyLkNVUlJFTlRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogZmluYWxEb2NDaGlsZHJlbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN0eWxlczoge1xuICAgICAgICAgICAgICAgIHBhcmFncmFwaFN0eWxlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJUaXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUaXRsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWRPbjogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWlja0Zvcm1hdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnRpdGxlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogc3R5bGUubGluZVNwYWNpbmcgKiAyNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IEFsaWdubWVudFR5cGUuQ0VOVEVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiSGVhZGluZzFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSGVhZGluZyAxXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlZE9uOiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrRm9ybWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUudGl0bGVTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbGQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiMDAwMDAwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2luZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmU6IDM2MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXI6IDI0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVMZXZlbDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIkhlYWRpbmcyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkhlYWRpbmcgMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWRPbjogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQ6IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWlja0Zvcm1hdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnRpdGxlU2l6ZSAtIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9sZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIwMDAwMDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhZ3JhcGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFjaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZTogMzIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogMTYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZUxldmVsOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiSGVhZGluZzNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSGVhZGluZyAzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlZE9uOiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dDogXCJOb3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1aWNrRm9ybWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUudGl0bGVTaXplIC0gOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiAyODAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lTGV2ZWw6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJIZWFkaW5nNFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJIZWFkaW5nIDRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkT246IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVpY2tGb3JtYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS50aXRsZVNpemUgLSAxMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiAyNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiAxMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lTGV2ZWw6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJIZWFkaW5nNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJIZWFkaW5nIDVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkT246IFwiTm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBcIk5vcm1hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVpY2tGb3JtYXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdHlsZS50aXRsZVNpemUgLSAxNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIjAwMDAwMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiAyMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lTGV2ZWw6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJTdHJvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU3Ryb25nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2xkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRvY3hPcHRpb25zO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTWFya2Rvd25Db252ZXJzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBNYXJrZG93bkNvbnZlcnNpb25FcnJvcihgRmFpbGVkIHRvIGNvbnZlcnQgbWFya2Rvd24gdG8gZG9jeDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWAsIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBEb3dubG9hZHMgYSBET0NYIGZpbGUgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqIEBwYXJhbSBibG9iIC0gVGhlIEJsb2IgY29udGFpbmluZyB0aGUgRE9DWCBmaWxlIGRhdGFcbiAqIEBwYXJhbSBmaWxlbmFtZSAtIFRoZSBuYW1lIHRvIHNhdmUgdGhlIGZpbGUgYXMgKGRlZmF1bHRzIHRvIFwiZG9jdW1lbnQuZG9jeFwiKVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb3V0c2lkZSBicm93c2VyIGVudmlyb25tZW50XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgaW52YWxpZCBibG9iIG9yIGZpbGVuYW1lIGlzIHByb3ZpZGVkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZmlsZSBzYXZlIGZhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZERvY3goYmxvYiwgZmlsZW5hbWUgPSBcImRvY3VtZW50LmRvY3hcIikge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgdXNlZCBpbiBicm93c2VyIGVudmlyb25tZW50c1wiKTtcbiAgICB9XG4gICAgaWYgKCEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmxvYiBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFmaWxlbmFtZSB8fCB0eXBlb2YgZmlsZW5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmaWxlbmFtZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc2F2ZUFzKGJsb2IsIGZpbGVuYW1lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBmaWxlOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNhdmUgZmlsZTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwifWApO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mohtasham/md-to-docx/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@mohtasham/md-to-docx/dist/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mohtasham/md-to-docx/dist/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultStyle: () => (/* binding */ defaultStyle),\n/* harmony export */   headingConfigs: () => (/* binding */ headingConfigs)\n/* harmony export */ });\nconst defaultStyle = {\n    titleSize: 32,\n    headingSpacing: 240,\n    paragraphSpacing: 240,\n    lineSpacing: 1.15,\n    direction: \"LTR\",\n    // Default font sizes\n    heading1Size: 32,\n    heading2Size: 28,\n    heading3Size: 24,\n    heading4Size: 20,\n    heading5Size: 18,\n    paragraphSize: 24,\n    listItemSize: 24,\n    codeBlockSize: 20,\n    blockquoteSize: 24,\n    // Default alignments\n    paragraphAlignment: \"LEFT\",\n    heading1Alignment: \"LEFT\",\n    heading2Alignment: \"LEFT\",\n    heading3Alignment: \"LEFT\",\n    heading4Alignment: \"LEFT\",\n    heading5Alignment: \"LEFT\",\n    blockquoteAlignment: \"LEFT\",\n    headingAlignment: \"LEFT\",\n};\nconst headingConfigs = {\n    1: { level: 1, size: 0, style: \"Title\" },\n    2: { level: 2, size: 0, style: \"Heading2\" },\n    3: { level: 3, size: 0 },\n    4: { level: 4, size: 0 },\n    5: { level: 5, size: 0 },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vaHRhc2hhbS9tZC10by1kb2N4L2Rpc3QvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLG1DQUFtQztBQUM1QyxTQUFTLHNDQUFzQztBQUMvQyxTQUFTLG1CQUFtQjtBQUM1QixTQUFTLG1CQUFtQjtBQUM1QixTQUFTLG1CQUFtQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL21kLXRvLWRvY3gvLi9ub2RlX21vZHVsZXMvQG1vaHRhc2hhbS9tZC10by1kb2N4L2Rpc3QvdHlwZXMuanM/ZWY3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZGVmYXVsdFN0eWxlID0ge1xuICAgIHRpdGxlU2l6ZTogMzIsXG4gICAgaGVhZGluZ1NwYWNpbmc6IDI0MCxcbiAgICBwYXJhZ3JhcGhTcGFjaW5nOiAyNDAsXG4gICAgbGluZVNwYWNpbmc6IDEuMTUsXG4gICAgZGlyZWN0aW9uOiBcIkxUUlwiLFxuICAgIC8vIERlZmF1bHQgZm9udCBzaXplc1xuICAgIGhlYWRpbmcxU2l6ZTogMzIsXG4gICAgaGVhZGluZzJTaXplOiAyOCxcbiAgICBoZWFkaW5nM1NpemU6IDI0LFxuICAgIGhlYWRpbmc0U2l6ZTogMjAsXG4gICAgaGVhZGluZzVTaXplOiAxOCxcbiAgICBwYXJhZ3JhcGhTaXplOiAyNCxcbiAgICBsaXN0SXRlbVNpemU6IDI0LFxuICAgIGNvZGVCbG9ja1NpemU6IDIwLFxuICAgIGJsb2NrcXVvdGVTaXplOiAyNCxcbiAgICAvLyBEZWZhdWx0IGFsaWdubWVudHNcbiAgICBwYXJhZ3JhcGhBbGlnbm1lbnQ6IFwiTEVGVFwiLFxuICAgIGhlYWRpbmcxQWxpZ25tZW50OiBcIkxFRlRcIixcbiAgICBoZWFkaW5nMkFsaWdubWVudDogXCJMRUZUXCIsXG4gICAgaGVhZGluZzNBbGlnbm1lbnQ6IFwiTEVGVFwiLFxuICAgIGhlYWRpbmc0QWxpZ25tZW50OiBcIkxFRlRcIixcbiAgICBoZWFkaW5nNUFsaWdubWVudDogXCJMRUZUXCIsXG4gICAgYmxvY2txdW90ZUFsaWdubWVudDogXCJMRUZUXCIsXG4gICAgaGVhZGluZ0FsaWdubWVudDogXCJMRUZUXCIsXG59O1xuZXhwb3J0IGNvbnN0IGhlYWRpbmdDb25maWdzID0ge1xuICAgIDE6IHsgbGV2ZWw6IDEsIHNpemU6IDAsIHN0eWxlOiBcIlRpdGxlXCIgfSxcbiAgICAyOiB7IGxldmVsOiAyLCBzaXplOiAwLCBzdHlsZTogXCJIZWFkaW5nMlwiIH0sXG4gICAgMzogeyBsZXZlbDogMywgc2l6ZTogMCB9LFxuICAgIDQ6IHsgbGV2ZWw6IDQsIHNpemU6IDAgfSxcbiAgICA1OiB7IGxldmVsOiA1LCBzaXplOiAwIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mohtasham/md-to-docx/dist/types.js\n");

/***/ })

};
;